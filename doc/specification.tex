\documentclass[11pt]{article}
\makeindex
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage{listings}    % for C syntax highlighting
\usepackage{color}
\usepackage{tipa}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% set listings colors
\lstset{ %
  backgroundcolor=\color{white},  % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  breaklines=true,                % sets automatic line breaking
  captionpos=b,                   % sets the caption-position to bottom
  commentstyle=\color{dkgreen},   % comment style
  deletekeywords={...},           % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},         % if you want to add LaTeX within your code
  keywordstyle=\color{blue},      % keyword style
  language=C,                % the language of the code
  morekeywords={entity,local},           % if you want to add more keywords to the set
  numbers=left,                   % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                  % how far the line-numbers are from the code
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,               % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,         % underline spaces within strings only
  showtabs=false,                 % show tabs within strings adding particular underscores
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mauve},      % string literal style
  tabsize=2,                      % sets default tabsize to 2 spaces
  title=\lstname                  % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm

\textwidth 16.59cm
\textheight 21.94cm 
\parskip 7.2pt                         % spacing between paragraphs
\renewcommand{\baselinestretch}{1.5} 	% 1.5 spacing between lines
\parindent 0pt		                    % leading space for paragraphs
\title{The GMQCC Quake C Programming Language}
\author{Dale Weiler, Wolfgang Bullimer}

% subscript and superscript in text mode require
% strange uses of math expression scripting, which
% is unusable, these macros implement it using math
% expressions, and reimplement ^ and _ to work in
% text mode :-)
\makeatletter
\newcommand\textsubscript[1]{\@textsubscript{\selectfont#1}}
\def\@textsubscript#1{{\m@th\ensuremath{_{\mbox{\fontsize\sf@size\z@#1}}}}}
\newcommand\textbothscript[2]{%
  \@textbothscript{\selectfont#1}{\selectfont#2}}
\def\@textbothscript#1#2{%
  {\m@th\ensuremath{%
    ^{\mbox{\fontsize\sf@size\z@#1}}%
    _{\mbox{\fontsize\sf@size\z@#2}}}}}
\def\@super{^}\def\@sub{_}

\catcode`^\active\catcode`_\active
\def\@super@sub#1_#2{\textbothscript{#1}{#2}}
\def\@sub@super#1^#2{\textbothscript{#2}{#1}}
\def\@@super#1{\@ifnextchar_{\@super@sub{#1}}{\textsuperscript{#1}}}
\def\@@sub#1{\@ifnextchar^{\@sub@super{#1}}{\textsubscript{#1}}}
\def^{\let\@next\relax\ifmmode\@super\else\let\@next\@@super\fi\@next}
\def_{\let\@next\relax\ifmmode\@sub\else\let\@next\@@sub\fi\@next}
\makeatother

% set standard paper sizes
\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}
 
\begin{document}
\maketitle
\pagebreak
\tableofcontents
\pagebreak
\section{Introduction}
With the introduction of improvements of existing runtime environments, new features may be added to this specification.  Subclauses in the language warn implementors and programmers of usages which, though valid in themselfs, may conflict with future additions.

This specification is divided into three major subjects:
\begin{enumerate}
	\item preliminary elements
	\item the characteristics of environments that translate and execute QuakeC programs
	\item the languages syntax, constraints, and semantics
\end{enumerate}

Examples are provided to illustrate possible forms of the constructions described, to better facilitate the reader.

\section{Scope}
This specification only specifies the form and establishes the interpretation of programs written in the GMQCC QuakeC programming language variant. It specifies:
\begin{enumerate}
	\item The representation of Quake C programs;
	\item The syntax and constraints of the Quake C language;
	\item The semantic rules for interpreting Quake C programs;
	\item The representation of input data to be processed by Quake C programs;
	\item The restrictions and limits imposed by a conforming implementation of Quake C.
\end{enumerate}
This specification does not specify
\begin{enumerate}
	\item The process in which Quake C programs are transformed for use by a data-processing system;
	\item The process in which Quake C programs are invoked for use by a data-processing system;
	\item The process in which input data is transformed for use by a Quake C program;
	\item The process in which output data is transformed after being produces by a Quake C program;
	\item The size of complexity involved with a Quake C program and its  data that will exceed the capacity of any specific data-processing system or the capacity of a particular processor;
	\item The minimal requirements of a data-processing system which is capable of supporting a conforming implementation.
\end{enumerate}
These details are decided upon by the environment designer (usually the engine developer).  The details are as such subjected to implementation-defined behavior.

\section{Terms and definitions}
\subsection*{argument}
The expression in a comma-separated list bounded by parentheses in a function call expression, or a sequence of preprocessing tokens in a comma-separated list bounded by parentheses in a function-like macro invocation.
\subsection*{behavior}
The external appearance or action of an expression, statement, etc
\subsection*{implementation-defined behavior}
Unspecified behavior where each implementation decides how the choice is made.
\subsection*{unspecified behavior}
Use of an unspecified value, or other behavior where this specification provides two or more possibilities and imposes no further requirements on which is chosen in any instance (e.g. Thus any ambiguity is considered unspecified behavior).
\subsection*{constraint}
A restriction, either syntactically or semantically, by which the exposition of various language elements is to be interpreted.
\subsection*{implementation}
Particular set of software, running in a particular translation environment under particular control options, that performs translations of programs for, and supports execution of functions in, a particular execution environment.
\subsection*{object}
A region of data storage in the execution environment, the contents of which are capable of representing values.
\subsection*{parameter}
An object declared as part of a function declaration that acquires a value on entry to the function, or an identifier from the comma-separated list bounded by parentheses immediately following the macro name in a function-like macro definition.
\subsection*{value}
The precise meaning of the contents of an object when interpreted as having a specific type.
\subsection*{implementation-defined value}
An unspecified value where each implementation decides how the choice is made.
\subsection*{unspecified value}
A valid value of the relevant type where this specification imposes no requirements on which value is chosen in any instance.

\section{Conformance}
In this specification, "shall" is to be interpreted as a requirement on an implementation or on a program; conversely, "shall not" is to be interpreted as a prohibition on the implementation or on a program.

A conforming program is one that is acceptable to a conforming implementation.

An implementation shall be accompanied by a document that defines all implementation-defined characteristic and extensions.

\section{Enviroment}
\subsection{Conceptual models}
\subsubsection{Translation environment}
\paragraph{Program structure}
A Quake C program need not all be translated at the same time.  The text of the program is kept in units called source files. All source files become concatenated, less any source lines skipped by any of the conditional inclusion preprocessing directives.  The final concatenation becomes the program structure.

\paragraph{Translation phases}
\begin{enumerate}
	\item Physical source file characters are mapped to the source character set (introducing new-line characters for end-of-line indicators) if necessary.  Trigraph and Digraph sequences are replaced by corresponding single-character internal representations.
	\item The source file is decomposed into preprocessing tokens and sequences of white-space characters (including comments).
	\item Preprocessing directives are executed and macro invocations expanded recursively.
	\item Each escape sequence in character constants and string literals is converted to a member of the execution character set.
	\item Adjacent character string literal tokens are concatenated.
	\item White-space characters separating tokens are no longer sufficient. The resulting tokens are syntactically and semantically analyzed and translated.
\end{enumerate}

\paragraph{Diagnostics}
A conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a program structure contains a violation of any syntax rule or constraint, even if the behavior is explicitly specifies as being undefined or implementation-defined.  diagnostic messages need not be produces in other circumstances.
\begin{small}
EXAMPLE
\end{small}
\begin{lstlisting}[language=C]
	string i;
	float  i;
\end{lstlisting}
The following example should produce a diagnostic for the program structure.

\section{Language}
\subsection{Notation}
In the syntax notation used in this clause, syntactic categories (non-terminals) are indicated by italic type, and literal words and character set members (terminals) by bold type.  A colon (:) following a non-terminal introduces its definition.  Alternative definitions are listed on corresponding separate lines, except when prefaced by words "one of".  An optional symbol is indicated by a subscript "opt", so that\\
\{ expression _{opt} \}\\
indicates an optional expression closed in braces. When syntactic categories are refereed to in the main text, they are not italicized and words are separated by spaces instead of hyphens.

\subsection{Concepts}
\subsubsection{Scopes of identifiers}
An identifier can denote an object; a function; a tag or member of an entity, or enumeration; a typedef name; a label name; a macro name; or a macro parameter.  The same identifier can denote different entities at different points in the program.  A member of an enumeration is called an enumeration constant.  Macro names and macro parameters are not considered further here, because prior to the semantic phase of program translation any occurrences of macro names in the source file are replaced by the preprocessing token sequences that constitute their macro definitions.

For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its scope.  Different entities designated by the same identifier either have different scopes, or are in different name spaces.  There are four kinds of scopes: function, global, block and function prototype. (A function prototype is a declaration of a function that declares the types of its parameters.)

A label name is the only kind of identifier that has function scope.  It can be used (in a goto statement) anywhere in the function in which it appears, and is declared implicitly by it's syntactic appearance (prefixed by a : and a statement).

Every other identifier has scoped determined by the placement of its declaration (in a declarator or type specifier).  If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has global scope, which terminates at the end of the program structure.  If the declarator or type specifier that declares the identifier appears inside a block or within the list of parameter declarations in a function definition, the identifier has block scope, which terminates at the end of the associated block. If the declarator or type specifier that declares the identifier appears within the list of parameter declarations in a function prototype (not part of a function definition), the identifier has function prototype scope, which terminates at the end of the function declarator.  If an identifier designates two different entities in the same name space, the scopes might overlap.  If so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope).  Within the inner scope, the identifier designates the entity declared in the inner scope; the entity declared in the outer scope is hidden (and is not visible) within the inner scope.

Unless explicitly stated otherwise, where this specification uses the term "identifier" to refer to some entity (as opposed to the syntactic construct), it refers to the entity in the relevant name space whose declaration is visible at the point the identifier occurs.

Unless explicitly stated otherwise, where this specification uses the term "entity", is not to be ambiguous with the entity type, but considered a semantic construct.

Two identifiers have the same scope if and only if their scopes terminate at the same point.

Enumeration tags have scope that begins just after the appearance of the tag in a type specifier that declares the tag.  Each enumeration constant has scope that begins just after the appearance of its defining enumerator in an enumeration list.  Any other identifier has scope that begins just after the completion of its declarator.

\subsubsection{Name spaces of identifiers}
If more than one declaration of a particular identifier is visible at any point in the program structure, the syntactic context disambiguates uses that refer to different entities.  Thus, there are separate name spaces for various categories of identifiers, as follows:
\begin{enumerate}
	\item label names (disambiguated by the syntax of the label declaration and use);
	\item the tags of enumerations
	\item all other identifiers, called ordinary identifiers (declared in ordinary declarators or as enumeration constants).
\end{enumerate}

\subsubsection{Types}
The meaning of a value stored in an object or returned by a function is determined by the type of the expression used to access it.  (An identifier declared to be an object is the simplest such expression; the type is specified in the declaration of the identifier.)  Types are partitioned into object types(types that fully describe object) and function types(types that describe functions).

An object declares as type bool is large enough to store the values 0 and 1.

An object declared as type char is large enough to store any member of the basic execution character set.  If a member of the basic execution character set is stored in a char object, its value is guaranteed to be nonnegative.  If any other character is stored in a char, the resulting value is implemented-defined.

An object declared as type string is large enough to store any length string-literal composed of any length chars, and as such follows the same rules as an object declared as type char.

The void type comprises an empty set of values; it is an incomplete type that cannot be completed.

The float and vector type .. TODO

An enumeration comprises a set of named integer constant values.  Each enumeration constitutes a different enumerated type.

\subsubsection{Compatible type and composite type}
Two types have compatibility if their types are the same.

All declarations that refer to the same object or function shall have compatibility; otherwise, the behavior is undefined.

A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:
\begin{enumerate}
	\item If one type is a function type with a paramater type list (function prototype), the composite type is a function prototype with the parameter type list.
	\item If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.
\end{enumerate}

\subsection{Conversions}
\subsubsection{Other operands}
\paragraph{Lvalues, arrays, and function designators}
An lvalue is an expression with an object type or an incomplete type other than void; if an lvalue does not designate an object when it is evaluated, the behavior is undefined.  When an object is said to have a particular type, the type is specified by the lvalue used to designated said object.  A modifiable lvalue is an lvalue that does not have an array type, does not have a const-qualified type and does not have an incomplete type.

A function designator is an expression that has function type. A function designator with type "function returning type" is converted to an expression that has type "pointer to function returning type".

\paragraph{void}
The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, and implicit or explicit conversions (except to void) shall not be applied to any such expression.  If an expression of a type not void is evaluated as a void expression, its value or designator shall be discarded. (A void expression is evaluated only for its side effects.)

\subsection{Lexical elements}
\subsubsection{Keywords}
\begin{tabular} { l l l l l }
	for & do & while & if & else \\
	local & return & const & switch & case \\
	default & struct & union & break & continue \\
	typedef & goto & namespace \\
\end{tabular}

\subsubsection{Identifiers}
\paragraph*{identifier}
\begin{tabular} { l }
	identifier-nondigit \\
	identifier identifier-nondigit \\
	identifier-digit \\
\end{tabular}

\paragraph*{identifier-nondigit}
\begin{tabular} { l }
	nondigit \\
	other implementation-defined characters \\
\end{tabular}

\paragraph*{nondigit}
\begin{tabular}{ c c c c c c c c c c c c c c c c c c c c }
	\_ & a & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p & q & r & s \\
	t & u & v & w & y & z & A & B & C & D & E & F & G & H & I & J & K & L & M & N \\
	O & P & Q & R & S & T & U & V & W & X & Y & Z \\
\end{tabular}

\paragraph*{digit}
\begin{tabular}{c c c c c c c c c c c }
	0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\end{tabular}

\paragraph*{hex-quad}
\begin{tabular} { l }
	hexadecimal-digit hexadecimal-digit \\
\end{tabular}

\subsubsection{Constants}
\label{sec:constants}
\paragraph*{constant}
\begin{tabular} { l }
	integer-constant \\
	floating-constant \\
	enumeration-constant \\
	character-constant \\
	vector-constant \\
\end{tabular}

\paragraph*{integer-constant}
\begin{tabular} { l }
	decimal-constant \\
	octal-constant \\
	hexadecimal-constant \\
\end{tabular}

\paragraph*{decimal-constant}
\begin{tabular} { l }
	nonzero-digit \\
	decimal-constant digit \\
\end{tabular}

\paragraph*{octal-constant}
\begin{tabular} { l }
	0 \\
	octal-constant octal-digit
\end{tabular}

\paragraph*{hexadecimal-constant}
\begin{tabular} { l }
	hexadecimal-prefix hexadecimal-digit \\
	hexadecimal-constant hexadecimal-digit \\
\end{tabular}

\paragraph*{hexadecimal-prefix}
\begin{tabular} { c c }
	0x & 0X \\
\end{tabular}

\paragraph*{nonzero-digit}
\begin{tabular} { c c c c c c c c c }
	1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\end{tabular}

\paragraph*{octal-digit}
\begin{tabular}{ c c c c c c c c c }
	0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\end{tabular}

\paragraph*{hexadecimal-digit}
\begin{tabular}{ c c c c c c c c c c c c c c c c }
	0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F \\
\end{tabular}

\paragraph*{floating-constant}
\begin{tabular} { l }
	decimal-floating-constant \\
	hexadecimal-floating-constant \\
\end{tabular}

\subsubsection{String Literals}
\paragraph*{string-literal}
\begin{tabular} { l }
	" s-char-sequence _{opt} " \\
	\_(" s-char-sequence _{opt} ") \\
\end{tabular}

\subsubsection*{s-char-sequence}
\begin{tabular} { l }
	s-char \\
	s-char-sequence s-char \\
\end{tabular}

\subsubsection*{s-char}
\begin{tabular} { l }
	any member of the source character set except double-quote, backslash, or new-line characters \\
	escape-sequence \\
\end{tabular}

\subsubsection{Header names}
\paragraph*{header-name}
\begin{tabular} { l }
	< h-char-sequence > \\
	" q-char-sequence " \\
\end{tabular}

\subsubsection*{h-char-sequence}
\begin{tabular} { l }
	h-char \\
	h-char-sequence h-char \\
\end{tabular}

\subsubsection*{h-char}
\begin{tabular} { l }
	any member of the source character set except the new-line and > character \\
\end{tabular}

\subsubsection*{q-char-sequence}
\begin{tabular} { l }
	q-char \\
	q-char-sequence q-char \\
\end{tabular}

\subsubsection*{q-char}
\begin{tabular} { l }
	any member of the source character set except the new-line and " character \\
\end{tabular}

\pagebreak

\subsubsection{Comments}
Except within a character constant, a string literal, or a comment, the characters /* introduce a comment. The contents of such a comment are examined only to find the characters */ that terminate it. (Thus /* .. */ comments do not nest.)

Expect within a character constant, a string literal, or a comment, the character // introduces a comment that includes all characters up to, but not including, the next new-line character.  The contents of such a comment are examined only to find the terminating new-line character.

\begin{small}
EXAMPLE
\end{small}
\begin{lstlisting}[language=C]
"a//b"             // four-character string literal
#include "//e"     // undefined behavior
// */              // comment, not syntax error
a = b/**//c;       // same as a = b / c;
/*//*/ foo();      // same as foo();
\end{lstlisting}

\subsection{Expressions}
An expression is a sequence of operators and operands that specifies computation of a value, or that designates an object or function, or that generates side effects, or that performs a combination thereof.

Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression.  Furthermore, the prior value shall be read only to determine the value to be stored.

The grouping of operators and operands is indicated by the syntax.  Except as specified later (for the function-call(), \&\&, \textpipe\textpipe, ?:, and comma operators), the order of evaluation of subexpressions and the order in which side effects take place are both unspecified.

Some operators (the unary \~\space, and the binary operators \textless\textless, \textgreater\textgreater, \&, \^\space, and \textpipe, collectively describe as bitwise operators) are required to have operands that have integer type.

An object shall have its stored value accessed only by an lvalue expression that has one of the following types:
\begin{enumerate}
	\item A type compatible with the effective type of the object,
	\item A qualified version of a type compatible with the effective type of the object,
\end{enumerate}

\subsubsection{Primary expressions}
\paragraph*{Syntax}
\begin{tabular}{ l }
	identifier \\
	constant \\
	string-literal \\
	( expression )
\end{tabular}
\paragraph*{Semantics}
An identifier is a primary expression, provided it has been declares as a designating object (in which case it is an lvalue) or a function (in which case it is a function designator).

A constant is a primary expression, with type as detailed in \ref{sec:constants}.

\subsection{Constant Expressions}
\subsubsection{Description}
A constant expression can be evaluated during translation rather than runtime, and accordingly can be used in any place that a constant may be.
\subsubsection{Constraints}
Constant expressions shall not contain assignment, increment, decrement, function-call, or comma operators, except when they're contained within a subexpression that is not evaluated.

Each constant expression shall evaluate to a constant that is in the range of representable values for it's designated type.
\subsubsection{Semantics}
An expression that evaluates to a constant is required in several contexts.  If a floating expression is evaluated in the translation environment, the arithmetic precision and range shall be at least as great as if they expression were being evaluated in the execution environment.

An integer constant expression shall have integral type, and shall only have operands that are integer constants, enumeration constants, character constants, and floating constants that are the immediate operands of casts.

The semantic rules for the evaluation of a constant expression are the same as for nonconstant expressions.

An implementation may accept other forms of constant expressions
\subsection{Declarations}
\subsubsection{Constraints}
All declarations shall declare at least a declarator (other than the parameters of a function), a tag, or members of an enumeration.

All declarations in the same scope that refer to the same object or function shall specify compatible types.
\subsubsection{Semantics}
A declaration specifies the interpretation and attributes of a set of identifiers.  A definition of an identifier is a declaration for that identifier that:
\begin{enumerate}
	\item for an object, causes storage to be reversed for that object;
	\item for a function, includes the function body;
	\item for an enumeration constant or typedef name, is the (only) declaration of the identifier.
\end{enumerate}


\subsection{Statement and blocks}
A statement specifies a specific action to be preformed.  Execpt as indicated, statements are executed in sequence.

\end{document}
