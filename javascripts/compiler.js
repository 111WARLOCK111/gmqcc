// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.
// TODO: " u s e   s t r i c t ";

try {
  this['Module'] = Module;
} catch(e) {
  this['Module'] = Module = {};
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  Module['print'] = function(x) {
    process['stdout'].write(x + '\n');
  };
  Module['printErr'] = function(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function(filename) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename).toString();
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename).toString();
    }
    return ret;
  };

  Module['load'] = function(f) {
    globalEval(read(f));
  };

  if (!Module['arguments']) {
    Module['arguments'] = process['argv'].slice(2);
  }
}

if (ENVIRONMENT_IS_SHELL) {
  Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  // Polyfill over SpiderMonkey/V8 differences
  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function(f) { snarf(f) };
  }

  if (!Module['arguments']) {
    if (typeof scriptArgs != 'undefined') {
      Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER) {
  if (!Module['print']) {
    Module['print'] = function(x) {
      console.log(x);
    };
  }

  if (!Module['printErr']) {
    Module['printErr'] = function(x) {
      console.log(x);
    };
  }
}

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (!Module['arguments']) {
    if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WORKER) {
  // We can do very little here...
  var TRY_USE_DUMP = false;
  if (!Module['print']) {
    Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  Module['load'] = importScripts;
}

if (!ENVIRONMENT_IS_WORKER && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_SHELL) {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
if (!Module['preRun']) Module['preRun'] = [];
if (!Module['postRun']) Module['postRun'] = [];

  
// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      var logg = log2(quantum);
      return '((((' +target + ')+' + (quantum-1) + ')>>' + logg + ')<<' + logg + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (/^\[\d+\ x\ (.*)\]/.test(type)) return true; // [15 x ?] blocks. Like structs
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  bitshift64: function (low, high, op, bits) {
    var ander = Math.pow(2, bits)-1;
    if (bits < 32) {
      switch (op) {
        case 'shl':
          return [low << bits, (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits))];
        case 'ashr':
          return [(((low >>> bits ) | ((high&ander) << (32 - bits))) >> 0) >>> 0, (high >> bits) >>> 0];
        case 'lshr':
          return [((low >>> bits) | ((high&ander) << (32 - bits))) >>> 0, high >>> bits];
      }
    } else if (bits == 32) {
      switch (op) {
        case 'shl':
          return [0, low];
        case 'ashr':
          return [high, (high|0) < 0 ? ander : 0];
        case 'lshr':
          return [high, 0];
      }
    } else { // bits > 32
      switch (op) {
        case 'shl':
          return [0, low << (bits - 32)];
        case 'ashr':
          return [(high >> (bits - 32)) >>> 0, (high|0) < 0 ? ander : 0];
        case 'lshr':
          return [high >>>  (bits - 32) , 0];
      }
    }
    abort('unknown bitshift64 op: ' + [value, op, bits]);
  },
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type, quantumSize) {
    if (Runtime.QUANTUM_SIZE == 1) return 1;
    var size = {
      '%i1': 1,
      '%i8': 1,
      '%i16': 2,
      '%i32': 4,
      '%i64': 8,
      "%float": 4,
      "%double": 8
    }['%'+type]; // add '%' since float and double confuse Closure compiler as keys, and also spidermonkey as a compiler will remove 's from '_i8' etc
    if (!size) {
      if (type.charAt(type.length-1) == '*') {
        size = Runtime.QUANTUM_SIZE; // A pointer
      } else if (type[0] == 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 == 0);
        size = bits/8;
      }
    }
    return size;
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    type.flatIndexes = type.fields.map(function(field) {
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = size;
      } else if (Runtime.isStructType(field)) {
        size = Types.types[field].flatSize;
        alignSize = Types.types[field].alignSize;
      } else {
        throw 'Unclear type in struct: ' + field + ', in ' + type.name_ + ' :: ' + dump(Types.types[type.name_]);
      }
      alignSize = type.packed ? 1 : Math.min(alignSize, Runtime.QUANTUM_SIZE);
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  addFunction: function (func) {
    var ret = FUNCTION_TABLE.length;
    FUNCTION_TABLE.push(func);
    FUNCTION_TABLE.push(0);
    return ret;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func) {
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function() {
        FUNCTION_TABLE[func].apply(null, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xff;
      if (needed) {
        buffer.push(code);
        needed--;
      }
      if (buffer.length == 0) {
        if (code < 128) return String.fromCharCode(code);
        buffer.push(code);
        if (code > 191 && code < 224) {
          needed = 1;
        } else {
          needed = 2;
        }
        return '';
      }
      if (needed > 0) return '';
      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var ret;
      if (c1 > 191 && c1 < 224) {
        ret = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      } else {
        ret = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function stackAlloc(size) { var ret = STACKTOP;STACKTOP += size;STACKTOP = ((((STACKTOP)+3)>>2)<<2);assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"); return ret; },
  staticAlloc: function staticAlloc(size) { var ret = STATICTOP;STATICTOP += size;STATICTOP = ((((STATICTOP)+3)>>2)<<2); if (STATICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function alignMemory(size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 4))*(quantum ? quantum : 4); return ret; },
  makeBigInt: function makeBigInt(low,high,unsigned) { var ret = (unsigned ? (((low)>>>0)+(((high)>>>0)*4294967296)) : (((low)>>>0)+(((high)|0)*4294967296))); return ret; },
  QUANTUM_SIZE: 4,
  __dummy__: 0
}



var CorrectionsMonitor = {
  MAX_ALLOWED: 0, // XXX
  corrections: 0,
  sigs: {},

  note: function(type, succeed, sig) {
    if (!succeed) {
      this.corrections++;
      if (this.corrections >= this.MAX_ALLOWED) abort('\n\nToo many corrections!');
    }
  },

  print: function() {
  }
};





//========================================
// Runtime essentials
//========================================

var __THREW__ = false; // Used in checking for thrown exceptions.

var ABORT = false;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD;
var tempI64, tempI64b;

function abort(text) {
  Module.print(text + ':\n' + (new Error).stack);
  ABORT = true;
  throw "Assertion: " + text;
}

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Adding
//
//         __attribute__((used))
//
//       to the function definition will prevent that.
//
// Note: Closure optimizations will minify function names, making
//       functions no longer callable. If you run closure (on by default
//       in -O2 and above), you should export the functions you will call
//       by calling emcc with something like
//
//         -s EXPORTED_FUNCTIONS='["_func1","_func2"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length+1);
      writeStringToMemory(value, ret);
      return ret;
    } else if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  try {
    var func = eval('_' + ident);
  } catch(e) {
    try {
      func = globalScope['Module']['_' + ident]; // closure exported function
    } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}
Module["ccall"] = ccall;

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  // TODO: optimize this, eval the whole function once instead of going through ccall each time
  return function() {
    return ccall(ident, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,Math.min(Math.floor((value)/4294967296), 4294967295)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': (tempDoubleF64[0]=value,HEAP32[((ptr)>>2)]=tempDoubleI32[0],HEAP32[(((ptr)+(4))>>2)]=tempDoubleI32[1]); break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return (tempDoubleI32[0]=HEAP32[((ptr)>>2)],tempDoubleI32[1]=HEAP32[(((ptr)+(4))>>2)],tempDoubleF64[0]);
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));

  if (zeroinit) {
      _memset(ret, 0, size);
      return ret;
  }
  
  var i = 0, type;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);
    i += Runtime.getNativeTypeSize(type);
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  var utf8 = new Runtime.UTF8Processor();
  var nullTerminated = typeof(length) == "undefined";
  var ret = "";
  var i = 0;
  var t;
  while (1) {
    t = HEAPU8[((ptr)+(i))];
    if (nullTerminated && t == 0) break;
    ret += utf8.processCChar(t);
    i += 1;
    if (!nullTerminated && i == length) break;
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

function Array_stringify(array) {
  var ret = "";
  for (var i = 0; i < array.length; i++) {
    ret += String.fromCharCode(array[i]);
  }
  return ret;
}
Module['Array_stringify'] = Array_stringify;

// Memory management

var FUNCTION_TABLE; // XXX: In theory the indexes here can be equal to pointers to stacked or malloced memory. Such comparisons should
                    //      be false, but can turn out true. We should probably set the top bit to prevent such issues.

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return ((x+4095)>>12)<<12;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STACK_ROOT, STACKTOP, STACK_MAX;
var STATICTOP;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Adjust TOTAL_MEMORY (currently ' + TOTAL_MEMORY + ') or compile with ALLOW_MEMORY_GROWTH');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 10485760;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
  assert(!!Int32Array && !!Float64Array && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
         'Cannot fallback to non-typed array case: Code is too specialized');

  var buffer = new ArrayBuffer(TOTAL_MEMORY);
  HEAP8 = new Int8Array(buffer);
  HEAP16 = new Int16Array(buffer);
  HEAP32 = new Int32Array(buffer);
  HEAPU8 = new Uint8Array(buffer);
  HEAPU16 = new Uint16Array(buffer);
  HEAPU32 = new Uint32Array(buffer);
  HEAPF32 = new Float32Array(buffer);
  HEAPF64 = new Float64Array(buffer);

  // Endianness check (note: assumes compiler arch was little-endian)
  HEAP32[0] = 255;
  assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

STACK_ROOT = STACKTOP = Runtime.alignMemory(1);
STACK_MAX = STACK_ROOT + TOTAL_STACK;

var tempDoublePtr = Runtime.alignMemory(STACK_MAX, 8);
var tempDoubleI8  = HEAP8.subarray(tempDoublePtr);
var tempDoubleI32 = HEAP32.subarray(tempDoublePtr >> 2);
var tempDoubleF32 = HEAPF32.subarray(tempDoublePtr >> 2);
var tempDoubleF64 = HEAPF64.subarray(tempDoublePtr >> 3);
function copyTempFloat(ptr) { // functions, because inlining this code is increases code size too much
  tempDoubleI8[0] = HEAP8[ptr];
  tempDoubleI8[1] = HEAP8[ptr+1];
  tempDoubleI8[2] = HEAP8[ptr+2];
  tempDoubleI8[3] = HEAP8[ptr+3];
}
function copyTempDouble(ptr) {
  tempDoubleI8[0] = HEAP8[ptr];
  tempDoubleI8[1] = HEAP8[ptr+1];
  tempDoubleI8[2] = HEAP8[ptr+2];
  tempDoubleI8[3] = HEAP8[ptr+3];
  tempDoubleI8[4] = HEAP8[ptr+4];
  tempDoubleI8[5] = HEAP8[ptr+5];
  tempDoubleI8[6] = HEAP8[ptr+6];
  tempDoubleI8[7] = HEAP8[ptr+7];
}
STACK_MAX = tempDoublePtr + 8;

STATICTOP = alignMemoryPage(STACK_MAX);

assert(STATICTOP < TOTAL_MEMORY); // Stack must fit in TOTAL_MEMORY; allocations from here on may enlarge TOTAL_MEMORY

var nullString = allocate(intArrayFromString('(null)'), 'i8', ALLOC_STATIC);

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    var func = callback.func;
    if (typeof func === 'number') {
      func = FUNCTION_TABLE[func];
    }
    func(callback.arg === undefined ? null : callback.arg);
  }
}

var __ATINIT__ = []; // functions called during startup
var __ATMAIN__ = []; // functions called when main() is to be run
var __ATEXIT__ = []; // functions called during shutdown

function initRuntime() {
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);

  // Print summary of correction activity
  CorrectionsMonitor.print();
}

function String_len(ptr) {
  var i = ptr;
  while (HEAP8[(i++)]) {}; // Note: should be |!= 0|, technically. But this helps catch bugs with undefineds
  return i - ptr - 1;
}
Module['String_len'] = String_len;

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[((buffer)+(i))]=chr
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer)+(i))]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

var STRING_TABLE = [];

function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
  // TODO: clean up previous line
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyTracking = {};
var calledRun = false;
var runDependencyWatcher = null;
function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 6000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    } 
    if (!calledRun) run();
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

// === Body ===




// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.

function _ast_expression_init($self, $codegen) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$self;
  $2=$codegen;
  var $3=$2;
  var $4=$1;
  var $5=$4;
  var $6=(($5+20)|0);
  HEAP32[(($6)>>2)]=$3;
  var $7=$1;
  var $8=$7;
  var $9=(($8+24)|0);
  HEAP32[(($9)>>2)]=0;
  var $10=$1;
  var $11=$10;
  var $12=(($11+28)|0);
  HEAP32[(($12)>>2)]=0;
  var $13=$1;
  var $14=$13;
  var $15=(($14+48)|0);
  HEAP32[(($15)>>2)]=0;
  var $16=$1;
  var $17=$16;
  var $18=(($17+52)|0);
  HEAP32[(($18)>>2)]=0;
  var $19=$1;
  var $20=$19;
  var $21=(($20+44)|0);
  HEAP8[($21)]=0;
  var $22=$1;
  var $23=$22;
  var $24=(($23+32)|0);
  HEAP32[(($24)>>2)]=0;
  var $25=$1;
  var $26=$25;
  var $27=(($26+36)|0);
  HEAP32[(($27)>>2)]=0;
  var $28=$1;
  var $29=$28;
  var $30=(($29+40)|0);
  HEAP32[(($30)>>2)]=0;
  ;
  return;
}


function _ast_expression_common_params_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+36)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+40)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+40)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+40)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+40)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+40)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 93, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+32)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+36)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+32)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 93, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+32)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+36)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+32)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_expression_common_params_add["X"]=1;

function _ast_value_copy($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $fromex;
      var $selfex;
      var $cp;
      var $v;
      $2=$self;
      var $3=$2;
      var $4=(($3)|0);
      var $5=(($4)|0);
      var $6=(($5)|0);
      var $7=$2;
      var $8=(($7+56)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+24)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($6)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($6+4)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=_ast_value_new($15, $17, $9, $13);
      $cp=$18;
      var $19=$2;
      var $20=(($19)|0);
      var $21=(($20+28)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $25=$2;
      var $26=(($25)|0);
      var $27=(($26)|0);
      var $28=(($27)|0);
      var $29=$2;
      var $30=(($29)|0);
      var $31=(($30+28)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=(($28)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($28+4)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=_ast_type_copy($34, $36, $32);
      var $38=$cp;
      var $39=(($38)|0);
      var $40=(($39+28)|0);
      HEAP32[(($40)>>2)]=$37;
      var $41=$cp;
      var $42=(($41)|0);
      var $43=(($42+28)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($44)|0)!=0;
      if ($45) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $47=$cp;
      _ast_value_delete($47);
      $1=0;
      __label__ = 14; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $50=$2;
      var $51=(($50)|0);
      $fromex=$51;
      var $52=$cp;
      var $53=(($52)|0);
      $selfex=$53;
      var $54=$fromex;
      var $55=(($54+44)|0);
      var $56=HEAP8[($55)];
      var $57=(($56) & 1);
      var $58=$selfex;
      var $59=(($58+44)|0);
      var $60=(($57)&1);
      HEAP8[($59)]=$60;
      $i=0;
      __label__ = 7; break;
    case 7: 
      var $62=$i;
      var $63=$fromex;
      var $64=(($63+36)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($62)>>>0) < (($65)>>>0);
      if ($66) { __label__ = 8; break; } else { __label__ = 13; break; }
    case 8: 
      var $68=$i;
      var $69=$fromex;
      var $70=(($69+32)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=(($71+($68<<2))|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=_ast_value_copy($73);
      $v=$74;
      var $75=$v;
      var $76=(($75)|0)!=0;
      if ($76) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $78=$selfex;
      var $79=$v;
      var $80=_ast_expression_common_params_add($78, $79);
      if ($80) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $82=$cp;
      _ast_value_delete($82);
      $1=0;
      __label__ = 14; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $85=$i;
      var $86=((($85)+(1))|0);
      $i=$86;
      __label__ = 7; break;
    case 13: 
      var $88=$cp;
      $1=$88;
      __label__ = 14; break;
    case 14: 
      var $90=$1;
      ;
      return $90;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_value_copy["X"]=1;

function _ast_value_new($ctx_0, $ctx_1, $name, $t) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $self;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$name;
      $3=$t;
      var $6=_util_memory_a(84, 303, ((STRING_TABLE.__str)|0));
      var $7=$6;
      $self=$7;
      var $8=$self;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $12=$self;
      var $13=$12;
      var $14=(($ctx)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($ctx+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _ast_node_init($13, $15, $17, 2);
      var $18=$self;
      var $19=$18;
      var $20=$19;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=(30);
      var $22=$self;
      var $23=$22;
      _ast_expression_init($23, (6));
      var $24=$self;
      var $25=(($24)|0);
      var $26=(($25)|0);
      var $27=(($26+16)|0);
      HEAP8[($27)]=1;
      var $28=$2;
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $31=$2;
      var $32=_util_strdup($31);
      var $35 = $32;__label__ = 7; break;
    case 6: 
      var $35 = 0;__label__ = 7; break;
    case 7: 
      var $35;
      var $36=$self;
      var $37=(($36+56)|0);
      HEAP32[(($37)>>2)]=$35;
      var $38=$3;
      var $39=$self;
      var $40=(($39)|0);
      var $41=(($40+24)|0);
      HEAP32[(($41)>>2)]=$38;
      var $42=$self;
      var $43=(($42)|0);
      var $44=(($43+28)|0);
      HEAP32[(($44)>>2)]=0;
      var $45=$self;
      var $46=(($45+60)|0);
      HEAP8[($46)]=0;
      var $47=$self;
      var $48=(($47+76)|0);
      HEAP32[(($48)>>2)]=0;
      var $49=$self;
      var $50=(($49+64)|0);
      var $51=$50;
      HEAP32[(($51)>>2)]=0; HEAP32[((($51)+(4))>>2)]=0; HEAP32[((($51)+(8))>>2)]=0;
      var $52=$self;
      var $53=(($52+80)|0);
      HEAP32[(($53)>>2)]=0;
      var $54=$self;
      $1=$54;
      __label__ = 8; break;
    case 8: 
      var $56=$1;
      STACKTOP = __stackBase__;
      return $56;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_value_new["X"]=1;

function _ast_type_copy($ctx_0, $ctx_1, $ex) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $i;
      var $fromex;
      var $selfex;
      var $self;
      var $v;
      var $3=(($ctx)|0);
      HEAP32[(($3)>>2)]=$ctx_0;
      var $4=(($ctx+4)|0);
      HEAP32[(($4)>>2)]=$ctx_1;
      $2=$ex;
      var $5=$2;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 19; break;
    case 4: 
      var $9=_util_memory_a(92, 163, ((STRING_TABLE.__str)|0));
      var $10=$9;
      $self=$10;
      var $11=$self;
      var $12=(($11)|0)!=0;
      if ($12) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 19; break;
    case 6: 
      var $15=$self;
      var $16=$15;
      var $17=(($ctx)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($ctx+4)|0);
      var $20=HEAP32[(($19)>>2)];
      _ast_node_init($16, $18, $20, 1);
      var $21=$self;
      var $22=$21;
      var $23=$22;
      var $24=(($23+8)|0);
      HEAP32[(($24)>>2)]=(22);
      var $25=$self;
      _ast_expression_init($25, 0);
      var $26=$2;
      var $27=$26;
      $fromex=$27;
      var $28=$self;
      var $29=$28;
      $selfex=$29;
      var $30=$selfex;
      var $31=(($30+20)|0);
      HEAP32[(($31)>>2)]=0;
      var $32=$fromex;
      var $33=(($32+24)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$selfex;
      var $36=(($35+24)|0);
      HEAP32[(($36)>>2)]=$34;
      var $37=$fromex;
      var $38=(($37+28)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($39)|0)!=0;
      if ($40) { __label__ = 7; break; } else { __label__ = 10; break; }
    case 7: 
      var $42=$fromex;
      var $43=(($42+28)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($ctx)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($ctx+4)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=_ast_type_copy($46, $48, $44);
      var $50=$selfex;
      var $51=(($50+28)|0);
      HEAP32[(($51)>>2)]=$49;
      var $52=$selfex;
      var $53=(($52+28)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=(($54)|0)!=0;
      if ($55) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $57=$self;
      _ast_expression_delete_full($57);
      $1=0;
      __label__ = 19; break;
    case 9: 
      __label__ = 11; break;
    case 10: 
      var $60=$selfex;
      var $61=(($60+28)|0);
      HEAP32[(($61)>>2)]=0;
      __label__ = 11; break;
    case 11: 
      var $63=$fromex;
      var $64=(($63+44)|0);
      var $65=HEAP8[($64)];
      var $66=(($65) & 1);
      var $67=$selfex;
      var $68=(($67+44)|0);
      var $69=(($66)&1);
      HEAP8[($68)]=$69;
      $i=0;
      __label__ = 12; break;
    case 12: 
      var $71=$i;
      var $72=$fromex;
      var $73=(($72+36)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=(($71)>>>0) < (($74)>>>0);
      if ($75) { __label__ = 13; break; } else { __label__ = 18; break; }
    case 13: 
      var $77=$i;
      var $78=$fromex;
      var $79=(($78+32)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=(($80+($77<<2))|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=_ast_value_copy($82);
      $v=$83;
      var $84=$v;
      var $85=(($84)|0)!=0;
      if ($85) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      var $87=$selfex;
      var $88=$v;
      var $89=_ast_expression_common_params_add($87, $88);
      if ($89) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $91=$self;
      _ast_expression_delete_full($91);
      $1=0;
      __label__ = 19; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $94=$i;
      var $95=((($94)+(1))|0);
      $i=$95;
      __label__ = 12; break;
    case 18: 
      var $97=$self;
      $1=$97;
      __label__ = 19; break;
    case 19: 
      var $99=$1;
      STACKTOP = __stackBase__;
      return $99;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_type_copy["X"]=1;

function _ast_value_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      var $2=$1;
      var $3=(($2+56)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7+56)|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 323, ((STRING_TABLE.__str)|0));
      __label__ = 4; break;
    case 4: 
      var $11=$1;
      var $12=(($11+60)|0);
      var $13=HEAP8[($12)];
      var $14=(($13) & 1);
      if ($14) { __label__ = 5; break; } else { __label__ = 10; break; }
    case 5: 
      var $16=$1;
      var $17=(($16)|0);
      var $18=(($17+24)|0);
      var $19=HEAP32[(($18)>>2)];
      if ((($19)|0) == 1) {
        __label__ = 6; break;
      }
      else if ((($19)|0) == 6) {
        __label__ = 7; break;
      }
      else {
      __label__ = 8; break;
      }
      
    case 6: 
      var $21=$1;
      var $22=(($21+64)|0);
      var $23=$22;
      var $24=HEAP32[(($23)>>2)];
      _util_memory_d($24, 328, ((STRING_TABLE.__str)|0));
      __label__ = 9; break;
    case 7: 
      var $26=$1;
      var $27=(($26+64)|0);
      var $28=$27;
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+20)|0);
      HEAP32[(($30)>>2)]=0;
      __label__ = 9; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $34=$1;
      var $35=$34;
      _ast_expression_delete($35);
      var $36=$1;
      var $37=$36;
      _util_memory_d($37, 342, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_type_adopt_impl($self, $other) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $fromex;
      var $selfex;
      var $v;
      $2=$self;
      $3=$other;
      var $4=$3;
      var $5=$4;
      var $6=(($5+24)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=$8;
      var $10=(($9+24)|0);
      HEAP32[(($10)>>2)]=$7;
      var $11=$3;
      var $12=$11;
      var $13=(($12+28)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $17=$2;
      var $18=$17;
      var $19=(($18)|0);
      var $20=$3;
      var $21=$20;
      var $22=(($21+28)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($19)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($19+4)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=_ast_type_copy($25, $27, $23);
      var $29=$2;
      var $30=$29;
      var $31=(($30+28)|0);
      HEAP32[(($31)>>2)]=$28;
      var $32=$2;
      var $33=$32;
      var $34=(($33+28)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)!=0;
      if ($36) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      $1=0;
      __label__ = 14; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $40=$3;
      var $41=$40;
      $fromex=$41;
      var $42=$2;
      var $43=$42;
      $selfex=$43;
      var $44=$fromex;
      var $45=(($44+44)|0);
      var $46=HEAP8[($45)];
      var $47=(($46) & 1);
      var $48=$selfex;
      var $49=(($48+44)|0);
      var $50=(($47)&1);
      HEAP8[($49)]=$50;
      $i=0;
      __label__ = 7; break;
    case 7: 
      var $52=$i;
      var $53=$fromex;
      var $54=(($53+36)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=(($52)>>>0) < (($55)>>>0);
      if ($56) { __label__ = 8; break; } else { __label__ = 13; break; }
    case 8: 
      var $58=$i;
      var $59=$fromex;
      var $60=(($59+32)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($61+($58<<2))|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=_ast_value_copy($63);
      $v=$64;
      var $65=$v;
      var $66=(($65)|0)!=0;
      if ($66) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $68=$selfex;
      var $69=$v;
      var $70=_ast_expression_common_params_add($68, $69);
      if ($70) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 14; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $74=$i;
      var $75=((($74)+(1))|0);
      $i=$75;
      __label__ = 7; break;
    case 13: 
      $1=1;
      __label__ = 14; break;
    case 14: 
      var $78=$1;
      ;
      return $78;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_type_adopt_impl["X"]=1;

function _ast_node_init($self, $ctx_0, $ctx_1, $nodetype) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  var $ctx=__stackBase__;
  var $2;
  $1=$self;
  var $3=(($ctx)|0);
  HEAP32[(($3)>>2)]=$ctx_0;
  var $4=(($ctx+4)|0);
  HEAP32[(($4)>>2)]=$ctx_1;
  $2=$nodetype;
  var $5=$1;
  var $6=$5;
  var $7=(($6)|0);
  var $8=$7;
  var $9=$ctx;
  assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($8)>>2)]=HEAP32[(($9)>>2)];HEAP32[((($8)+(4))>>2)]=HEAP32[((($9)+(4))>>2)];
  var $10=$1;
  var $11=$10;
  var $12=(($11+8)|0);
  HEAP32[(($12)>>2)]=8;
  var $13=$1;
  var $14=$13;
  var $15=(($14+16)|0);
  HEAP8[($15)]=0;
  var $16=$2;
  var $17=$1;
  var $18=$17;
  var $19=(($18+12)|0);
  HEAP32[(($19)>>2)]=$16;
  STACKTOP = __stackBase__;
  return;
}


function _ast_expression_delete_full($self) {
  ;
  var __label__;

  var $1;
  $1=$self;
  var $2=$1;
  _ast_expression_delete($2);
  var $3=$1;
  var $4=$3;
  _util_memory_d($4, 90, ((STRING_TABLE.__str)|0));
  ;
  return;
}


function _ast_compare_type($a, $b) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$a;
      $3=$b;
      var $4=$2;
      var $5=$4;
      var $6=(($5+24)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$3;
      var $9=$8;
      var $10=(($9+24)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($7)|0)!=(($11)|0);
      if ($12) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 21; break;
    case 4: 
      var $15=$2;
      var $16=$15;
      var $17=(($16+28)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=(($20)&1);
      var $22=$3;
      var $23=$22;
      var $24=(($23+28)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)!=0;
      var $27=$26 ^ 1;
      var $28=(($27)&1);
      var $29=(($21)|0)!=(($28)|0);
      if ($29) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 21; break;
    case 6: 
      var $32=$2;
      var $33=$32;
      var $34=(($33+36)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$3;
      var $37=$36;
      var $38=(($37+36)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($35)|0)!=(($39)|0);
      if ($40) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      $1=0;
      __label__ = 21; break;
    case 8: 
      var $43=$2;
      var $44=$43;
      var $45=(($44+44)|0);
      var $46=HEAP8[($45)];
      var $47=(($46) & 1);
      var $48=(($47)&1);
      var $49=$3;
      var $50=$49;
      var $51=(($50+44)|0);
      var $52=HEAP8[($51)];
      var $53=(($52) & 1);
      var $54=(($53)&1);
      var $55=(($48)|0)!=(($54)|0);
      if ($55) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      $1=0;
      __label__ = 21; break;
    case 10: 
      var $58=$2;
      var $59=$58;
      var $60=(($59+36)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($61)|0)!=0;
      if ($62) { __label__ = 11; break; } else { __label__ = 18; break; }
    case 11: 
      $i=0;
      __label__ = 12; break;
    case 12: 
      var $65=$i;
      var $66=$2;
      var $67=$66;
      var $68=(($67+36)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=(($65)>>>0) < (($69)>>>0);
      if ($70) { __label__ = 13; break; } else { __label__ = 17; break; }
    case 13: 
      var $72=$i;
      var $73=$2;
      var $74=$73;
      var $75=(($74+32)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($76+($72<<2))|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$78;
      var $80=$i;
      var $81=$3;
      var $82=$81;
      var $83=(($82+32)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=(($84+($80<<2))|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=$86;
      var $88=_ast_compare_type($79, $87);
      if ($88) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      $1=0;
      __label__ = 21; break;
    case 15: 
      __label__ = 16; break;
    case 16: 
      var $92=$i;
      var $93=((($92)+(1))|0);
      $i=$93;
      __label__ = 12; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $96=$2;
      var $97=$96;
      var $98=(($97+28)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=(($99)|0)!=0;
      if ($100) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $102=$2;
      var $103=$102;
      var $104=(($103+28)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=$3;
      var $107=$106;
      var $108=(($107+28)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=_ast_compare_type($105, $109);
      $1=$110;
      __label__ = 21; break;
    case 20: 
      $1=1;
      __label__ = 21; break;
    case 21: 
      var $113=$1;
      ;
      return $113;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_compare_type["X"]=1;

function _ast_type_to_string($e, $buf, $bufsize) {
  ;
  var __label__;

  var $1;
  var $2;
  var $3;
  var $pos;
  $1=$e;
  $2=$buf;
  $3=$bufsize;
  var $4=$1;
  var $5=$2;
  var $6=$3;
  var $7=((($6)-(1))|0);
  var $8=_ast_type_to_string_impl($4, $5, $7, 0);
  $pos=$8;
  var $9=$pos;
  var $10=$2;
  var $11=(($10+$9)|0);
  HEAP8[($11)]=0;
  ;
  return;
}


function _ast_type_to_string_impl($e, $buf, $bufsize, $pos) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $typestr;
      var $typelen;
      var $i;
      $2=$e;
      $3=$buf;
      $4=$bufsize;
      $5=$pos;
      var $6=$2;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 6; break; } else { __label__ = 3; break; }
    case 3: 
      var $9=$5;
      var $10=((($9)+(6))|0);
      var $11=$4;
      var $12=(($10)>>>0) >= (($11)>>>0);
      if ($12) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      __label__ = 32; break;
    case 5: 
      var $15=$3;
      var $16=$5;
      var $17=(($15+$16)|0);
      var $18=_strcpy($17, ((STRING_TABLE.__str109)|0));
      var $19=$5;
      var $20=((($19)+(6))|0);
      $1=$20;
      __label__ = 33; break;
    case 6: 
      var $22=$5;
      var $23=((($22)+(1))|0);
      var $24=$4;
      var $25=(($23)>>>0) >= (($24)>>>0);
      if ($25) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      __label__ = 32; break;
    case 8: 
      var $28=$2;
      var $29=$28;
      var $30=(($29+24)|0);
      var $31=HEAP32[(($30)>>2)];
      if ((($31)|0) == 9) {
        __label__ = 9; break;
      }
      else if ((($31)|0) == 5) {
        __label__ = 10; break;
      }
      else if ((($31)|0) == 7) {
        __label__ = 11; break;
      }
      else if ((($31)|0) == 6) {
        __label__ = 16; break;
      }
      else {
      __label__ = 29; break;
      }
      
    case 9: 
      var $33=$3;
      var $34=$5;
      var $35=(($33+$34)|0);
      var $36=_strcpy($35, ((STRING_TABLE.__str110)|0));
      var $37=$5;
      var $38=((($37)+(9))|0);
      $1=$38;
      __label__ = 33; break;
    case 10: 
      var $40=$5;
      var $41=((($40)+(1))|0);
      $5=$41;
      var $42=$3;
      var $43=(($42+$40)|0);
      HEAP8[($43)]=46;
      var $44=$2;
      var $45=$44;
      var $46=(($45+28)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$3;
      var $49=$4;
      var $50=$5;
      var $51=_ast_type_to_string_impl($47, $48, $49, $50);
      $1=$51;
      __label__ = 33; break;
    case 11: 
      var $53=$5;
      var $54=((($53)+(3))|0);
      var $55=$4;
      var $56=(($54)>>>0) >= (($55)>>>0);
      if ($56) { __label__ = 12; break; } else { __label__ = 13; break; }
    case 12: 
      __label__ = 32; break;
    case 13: 
      var $59=$5;
      var $60=((($59)+(1))|0);
      $5=$60;
      var $61=$3;
      var $62=(($61+$59)|0);
      HEAP8[($62)]=42;
      var $63=$5;
      var $64=((($63)+(1))|0);
      $5=$64;
      var $65=$3;
      var $66=(($65+$63)|0);
      HEAP8[($66)]=40;
      var $67=$2;
      var $68=$67;
      var $69=(($68+28)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=$3;
      var $72=$4;
      var $73=$5;
      var $74=_ast_type_to_string_impl($70, $71, $72, $73);
      $5=$74;
      var $75=$5;
      var $76=((($75)+(1))|0);
      var $77=$4;
      var $78=(($76)>>>0) >= (($77)>>>0);
      if ($78) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      __label__ = 32; break;
    case 15: 
      var $81=$5;
      var $82=((($81)+(1))|0);
      $5=$82;
      var $83=$3;
      var $84=(($83+$81)|0);
      HEAP8[($84)]=41;
      var $85=$5;
      $1=$85;
      __label__ = 33; break;
    case 16: 
      var $87=$2;
      var $88=$87;
      var $89=(($88+28)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=$3;
      var $92=$4;
      var $93=$5;
      var $94=_ast_type_to_string_impl($90, $91, $92, $93);
      $5=$94;
      var $95=$5;
      var $96=((($95)+(2))|0);
      var $97=$4;
      var $98=(($96)>>>0) >= (($97)>>>0);
      if ($98) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      __label__ = 32; break;
    case 18: 
      var $101=$2;
      var $102=$101;
      var $103=(($102+36)|0);
      var $104=HEAP32[(($103)>>2)];
      var $105=(($104)|0)==0;
      if ($105) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $107=$5;
      var $108=((($107)+(1))|0);
      $5=$108;
      var $109=$3;
      var $110=(($109+$107)|0);
      HEAP8[($110)]=40;
      var $111=$5;
      var $112=((($111)+(1))|0);
      $5=$112;
      var $113=$3;
      var $114=(($113+$111)|0);
      HEAP8[($114)]=41;
      var $115=$5;
      $1=$115;
      __label__ = 33; break;
    case 20: 
      var $117=$5;
      var $118=((($117)+(1))|0);
      $5=$118;
      var $119=$3;
      var $120=(($119+$117)|0);
      HEAP8[($120)]=40;
      var $121=$2;
      var $122=$121;
      var $123=(($122+32)|0);
      var $124=HEAP32[(($123)>>2)];
      var $125=(($124)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=$126;
      var $128=$3;
      var $129=$4;
      var $130=$5;
      var $131=_ast_type_to_string_impl($127, $128, $129, $130);
      $5=$131;
      $i=1;
      __label__ = 21; break;
    case 21: 
      var $133=$i;
      var $134=$2;
      var $135=$134;
      var $136=(($135+36)|0);
      var $137=HEAP32[(($136)>>2)];
      var $138=(($133)>>>0) < (($137)>>>0);
      if ($138) { __label__ = 22; break; } else { __label__ = 26; break; }
    case 22: 
      var $140=$5;
      var $141=((($140)+(2))|0);
      var $142=$4;
      var $143=(($141)>>>0) >= (($142)>>>0);
      if ($143) { __label__ = 23; break; } else { __label__ = 24; break; }
    case 23: 
      __label__ = 32; break;
    case 24: 
      var $146=$5;
      var $147=((($146)+(1))|0);
      $5=$147;
      var $148=$3;
      var $149=(($148+$146)|0);
      HEAP8[($149)]=44;
      var $150=$5;
      var $151=((($150)+(1))|0);
      $5=$151;
      var $152=$3;
      var $153=(($152+$150)|0);
      HEAP8[($153)]=32;
      var $154=$i;
      var $155=$2;
      var $156=$155;
      var $157=(($156+32)|0);
      var $158=HEAP32[(($157)>>2)];
      var $159=(($158+($154<<2))|0);
      var $160=HEAP32[(($159)>>2)];
      var $161=$160;
      var $162=$3;
      var $163=$4;
      var $164=$5;
      var $165=_ast_type_to_string_impl($161, $162, $163, $164);
      $5=$165;
      __label__ = 25; break;
    case 25: 
      var $167=$i;
      var $168=((($167)+(1))|0);
      $i=$168;
      __label__ = 21; break;
    case 26: 
      var $170=$5;
      var $171=((($170)+(1))|0);
      var $172=$4;
      var $173=(($171)>>>0) >= (($172)>>>0);
      if ($173) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      __label__ = 32; break;
    case 28: 
      var $176=$5;
      var $177=((($176)+(1))|0);
      $5=$177;
      var $178=$3;
      var $179=(($178+$176)|0);
      HEAP8[($179)]=41;
      var $180=$5;
      $1=$180;
      __label__ = 33; break;
    case 29: 
      var $182=$2;
      var $183=$182;
      var $184=(($183+24)|0);
      var $185=HEAP32[(($184)>>2)];
      var $186=((_type_name+($185<<2))|0);
      var $187=HEAP32[(($186)>>2)];
      $typestr=$187;
      var $188=$typestr;
      var $189=_strlen($188);
      $typelen=$189;
      var $190=$5;
      var $191=$typelen;
      var $192=((($190)+($191))|0);
      var $193=$4;
      var $194=(($192)>>>0) >= (($193)>>>0);
      if ($194) { __label__ = 30; break; } else { __label__ = 31; break; }
    case 30: 
      __label__ = 32; break;
    case 31: 
      var $197=$3;
      var $198=$5;
      var $199=(($197+$198)|0);
      var $200=$typestr;
      var $201=_strcpy($199, $200);
      var $202=$5;
      var $203=$typelen;
      var $204=((($202)+($203))|0);
      $1=$204;
      __label__ = 33; break;
    case 32: 
      var $206=$4;
      var $207=((($206)-(3))|0);
      var $208=$3;
      var $209=(($208+$207)|0);
      HEAP8[($209)]=46;
      var $210=$4;
      var $211=((($210)-(2))|0);
      var $212=$3;
      var $213=(($212+$211)|0);
      HEAP8[($213)]=46;
      var $214=$4;
      var $215=((($214)-(1))|0);
      var $216=$3;
      var $217=(($216+$215)|0);
      HEAP8[($217)]=46;
      var $218=$4;
      $1=$218;
      __label__ = 33; break;
    case 33: 
      var $220=$1;
      ;
      return $220;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_type_to_string_impl["X"]=1;

function _ast_value_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$2;
      var $8=(($7+80)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $12=$2;
      var $13=$12;
      var $14=(($13)|0);
      var $15=$2;
      var $16=(($15+56)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($14)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($14+4)|0);
      var $21=HEAP32[(($20)>>2)];
      _asterror($19, $21, ((STRING_TABLE.__str4)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$17,tempInt));
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $23=$2;
      var $24=(($23+80)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=$5;
      HEAP32[(($26)>>2)]=$25;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $28=$1;
      STACKTOP = __stackBase__;
      return $28;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_expression_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=$2;
      var $4=(($3+28)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=$8;
      var $10=(($9+28)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=$11;
      var $13=$12;
      var $14=(($13+8)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$1;
      var $17=$16;
      var $18=(($17+28)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$19;
      FUNCTION_TABLE[$15]($20);
      __label__ = 4; break;
    case 4: 
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $23=$i;
      var $24=$1;
      var $25=$24;
      var $26=(($25+36)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($23)>>>0) < (($27)>>>0);
      if ($28) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $30=$i;
      var $31=$1;
      var $32=$31;
      var $33=(($32+32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($34+($30<<2))|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=$36;
      var $38=$37;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$i;
      var $42=$1;
      var $43=$42;
      var $44=(($43+32)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($45+($41<<2))|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      FUNCTION_TABLE[$40]($48);
      __label__ = 7; break;
    case 7: 
      var $50=$i;
      var $51=((($50)+(1))|0);
      $i=$51;
      __label__ = 5; break;
    case 8: 
      var $53=$1;
      var $54=$53;
      var $55=(($54+32)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56)|0)!=0;
      if ($57) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $59=$1;
      var $60=$59;
      var $61=(($60+32)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=$62;
      _util_memory_d($63, 84, ((STRING_TABLE.__str)|0));
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      var $66=$65;
      var $67=(($66+32)|0);
      HEAP32[(($67)>>2)]=0;
      var $68=$1;
      var $69=$68;
      var $70=(($69+36)|0);
      HEAP32[(($70)>>2)]=0;
      var $71=$1;
      var $72=$71;
      var $73=(($72+40)|0);
      HEAP32[(($73)>>2)]=0;
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_expression_delete["X"]=1;

function _ast_value_set_name($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$name;
      var $3=$1;
      var $4=(($3+56)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=(($8+56)|0);
      var $10=HEAP32[(($9)>>2)];
      _util_memory_d($10, 353, ((STRING_TABLE.__str)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$2;
      var $13=_util_strdup($12);
      var $14=$1;
      var $15=(($14+56)|0);
      HEAP32[(($15)>>2)]=$13;
      var $16=$1;
      var $17=(($16+56)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=$20 ^ 1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_binary_new($ctx_0, $ctx_1, $op, $left, $right) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $4;
      var $self;
      var $5=(($ctx)|0);
      HEAP32[(($5)>>2)]=$ctx_0;
      var $6=(($ctx+4)|0);
      HEAP32[(($6)>>2)]=$ctx_1;
      $2=$op;
      $3=$left;
      $4=$right;
      var $7=_util_memory_a(68, 361, ((STRING_TABLE.__str)|0));
      var $8=$7;
      $self=$8;
      var $9=$self;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 22; break;
    case 4: 
      var $13=$self;
      var $14=$13;
      var $15=(($ctx)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($ctx+4)|0);
      var $18=HEAP32[(($17)>>2)];
      _ast_node_init($14, $16, $18, 5);
      var $19=$self;
      var $20=$19;
      var $21=$20;
      var $22=(($21+8)|0);
      HEAP32[(($22)>>2)]=(44);
      var $23=$self;
      var $24=$23;
      _ast_expression_init($24, (36));
      var $25=$2;
      var $26=$self;
      var $27=(($26+56)|0);
      HEAP32[(($27)>>2)]=$25;
      var $28=$3;
      var $29=$self;
      var $30=(($29+60)|0);
      HEAP32[(($30)>>2)]=$28;
      var $31=$4;
      var $32=$self;
      var $33=(($32+64)|0);
      HEAP32[(($33)>>2)]=$31;
      var $34=$2;
      var $35=(($34)|0) >= 10;
      if ($35) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 5: 
      var $37=$2;
      var $38=(($37)|0) <= 23;
      if ($38) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $40=$self;
      var $41=(($40)|0);
      var $42=(($41+24)|0);
      HEAP32[(($42)>>2)]=2;
      __label__ = 21; break;
    case 7: 
      var $44=$2;
      var $45=(($44)|0)==62;
      if ($45) { __label__ = 11; break; } else { __label__ = 8; break; }
    case 8: 
      var $47=$2;
      var $48=(($47)|0)==63;
      if ($48) { __label__ = 11; break; } else { __label__ = 9; break; }
    case 9: 
      var $50=$2;
      var $51=(($50)|0)==64;
      if ($51) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $53=$2;
      var $54=(($53)|0)==65;
      if ($54) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $56=$self;
      var $57=(($56)|0);
      var $58=(($57+24)|0);
      HEAP32[(($58)>>2)]=2;
      __label__ = 20; break;
    case 12: 
      var $60=$2;
      var $61=(($60)|0)==4;
      if ($61) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      var $63=$2;
      var $64=(($63)|0)==3;
      if ($64) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      var $66=$self;
      var $67=(($66)|0);
      var $68=(($67+24)|0);
      HEAP32[(($68)>>2)]=3;
      __label__ = 19; break;
    case 15: 
      var $70=$2;
      var $71=(($70)|0)==2;
      if ($71) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      var $73=$self;
      var $74=(($73)|0);
      var $75=(($74+24)|0);
      HEAP32[(($75)>>2)]=2;
      __label__ = 18; break;
    case 17: 
      var $77=$3;
      var $78=$77;
      var $79=(($78+24)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=$self;
      var $82=(($81)|0);
      var $83=(($82+24)|0);
      HEAP32[(($83)>>2)]=$80;
      __label__ = 18; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $88=$self;
      $1=$88;
      __label__ = 22; break;
    case 22: 
      var $90=$1;
      STACKTOP = __stackBase__;
      return $90;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binary_new["X"]=1;

function _ast_binary_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+60)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+60)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $26=$1;
      var $27=(($26+64)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28;
      var $30=$29;
      var $31=(($30+16)|0);
      var $32=HEAP8[($31)];
      var $33=(($32) & 1);
      if ($33) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $35=$1;
      var $36=(($35+64)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=$38;
      var $40=(($39+8)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$1;
      var $43=(($42+64)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=$44;
      FUNCTION_TABLE[$41]($45);
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=$48;
      _ast_expression_delete($49);
      var $50=$1;
      var $51=$50;
      _util_memory_d($51, 388, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binary_delete["X"]=1;

function _ast_binary_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $left=__stackBase__;
      var $right=(__stackBase__)+(4);
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str15)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 13; break;
    case 4: 
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $24=$2;
      var $25=(($24)|0);
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$5;
      HEAP32[(($28)>>2)]=$27;
      $1=1;
      __label__ = 13; break;
    case 6: 
      var $30=$2;
      var $31=(($30+60)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$32;
      var $34=(($33+20)|0);
      var $35=HEAP32[(($34)>>2)];
      $cgen=$35;
      var $36=$cgen;
      var $37=$2;
      var $38=(($37+60)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$3;
      var $41=FUNCTION_TABLE[$36]($39, $40, 0, $left);
      if ($41) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 13; break;
    case 8: 
      var $44=$2;
      var $45=(($44+64)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$46;
      var $48=(($47+20)|0);
      var $49=HEAP32[(($48)>>2)];
      $cgen=$49;
      var $50=$cgen;
      var $51=$2;
      var $52=(($51+64)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=$3;
      var $55=FUNCTION_TABLE[$50]($53, $54, 0, $right);
      if ($55) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 13; break;
    case 10: 
      var $58=$3;
      var $59=(($58+36)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=$3;
      var $62=_ast_function_label($61, ((STRING_TABLE.__str16)|0));
      var $63=$2;
      var $64=(($63+56)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=HEAP32[(($left)>>2)];
      var $67=HEAP32[(($right)>>2)];
      var $68=_ir_block_create_binop($60, $62, $65, $66, $67);
      var $69=$5;
      HEAP32[(($69)>>2)]=$68;
      var $70=$5;
      var $71=HEAP32[(($70)>>2)];
      var $72=(($71)|0)!=0;
      if ($72) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 13; break;
    case 12: 
      var $75=$5;
      var $76=HEAP32[(($75)>>2)];
      var $77=$2;
      var $78=(($77)|0);
      var $79=(($78+52)|0);
      HEAP32[(($79)>>2)]=$76;
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $81=$1;
      STACKTOP = __stackBase__;
      return $81;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binary_codegen["X"]=1;

function _ast_binstore_new($ctx_0, $ctx_1, $storop, $op, $left, $right) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $4;
      var $5;
      var $self;
      var $6=(($ctx)|0);
      HEAP32[(($6)>>2)]=$ctx_0;
      var $7=(($ctx+4)|0);
      HEAP32[(($7)>>2)]=$ctx_1;
      $2=$storop;
      $3=$op;
      $4=$left;
      $5=$right;
      var $8=_util_memory_a(72, 394, ((STRING_TABLE.__str)|0));
      var $9=$8;
      $self=$9;
      var $10=$self;
      var $11=(($10)|0)!=0;
      if ($11) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 10; break;
    case 4: 
      var $14=$self;
      var $15=$14;
      var $16=(($ctx)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($ctx+4)|0);
      var $19=HEAP32[(($18)>>2)];
      _ast_node_init($15, $17, $19, 7);
      var $20=$self;
      var $21=$20;
      var $22=$21;
      var $23=(($22+8)|0);
      HEAP32[(($23)>>2)]=(40);
      var $24=$self;
      var $25=$24;
      _ast_expression_init($25, (16));
      var $26=$2;
      var $27=$self;
      var $28=(($27+56)|0);
      HEAP32[(($28)>>2)]=$26;
      var $29=$3;
      var $30=$self;
      var $31=(($30+60)|0);
      HEAP32[(($31)>>2)]=$29;
      var $32=$4;
      var $33=$self;
      var $34=(($33+64)|0);
      HEAP32[(($34)>>2)]=$32;
      var $35=$5;
      var $36=$self;
      var $37=(($36+68)|0);
      HEAP32[(($37)>>2)]=$35;
      var $38=$4;
      var $39=$38;
      var $40=(($39+24)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$self;
      var $43=(($42)|0);
      var $44=(($43+24)|0);
      HEAP32[(($44)>>2)]=$41;
      var $45=$4;
      var $46=$45;
      var $47=(($46+28)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48)|0)!=0;
      if ($49) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $51=$4;
      var $52=(($ctx)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($ctx+4)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=_ast_type_copy($53, $55, $51);
      var $57=$self;
      var $58=(($57)|0);
      var $59=(($58+28)|0);
      HEAP32[(($59)>>2)]=$56;
      var $60=$self;
      var $61=(($60)|0);
      var $62=(($61+28)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63)|0)!=0;
      if ($64) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $66=$self;
      var $67=$66;
      var $68=$67;
      var $69=(($68+8)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=$self;
      var $72=$71;
      FUNCTION_TABLE[$70]($72);
      $1=0;
      __label__ = 10; break;
    case 7: 
      __label__ = 9; break;
    case 8: 
      var $75=$self;
      var $76=(($75)|0);
      var $77=(($76+28)|0);
      HEAP32[(($77)>>2)]=0;
      __label__ = 9; break;
    case 9: 
      var $79=$self;
      $1=$79;
      __label__ = 10; break;
    case 10: 
      var $81=$1;
      STACKTOP = __stackBase__;
      return $81;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binstore_new["X"]=1;

function _ast_binstore_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+64)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+64)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+64)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $26=$1;
      var $27=(($26+68)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28;
      var $30=$29;
      var $31=(($30+16)|0);
      var $32=HEAP8[($31)];
      var $33=(($32) & 1);
      if ($33) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $35=$1;
      var $36=(($35+68)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=$38;
      var $40=(($39+8)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$1;
      var $43=(($42+68)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=$44;
      FUNCTION_TABLE[$41]($45);
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=$48;
      _ast_expression_delete($49);
      var $50=$1;
      var $51=$50;
      _util_memory_d($51, 421, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binstore_delete["X"]=1;

function _ast_binstore_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $leftl=__stackBase__;
      var $leftr=(__stackBase__)+(4);
      var $right=(__stackBase__)+(8);
      var $bin;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+48)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $16=$2;
      var $17=(($16)|0);
      var $18=(($17+48)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$5;
      HEAP32[(($20)>>2)]=$19;
      $1=1;
      __label__ = 20; break;
    case 5: 
      var $22=$4;
      var $23=(($22) & 1);
      if ($23) { __label__ = 8; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$2;
      var $26=(($25)|0);
      var $27=(($26+52)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $31=$2;
      var $32=(($31)|0);
      var $33=(($32+52)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$5;
      HEAP32[(($35)>>2)]=$34;
      $1=1;
      __label__ = 20; break;
    case 8: 
      var $37=$2;
      var $38=(($37+64)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=(($40+20)|0);
      var $42=HEAP32[(($41)>>2)];
      $cgen=$42;
      var $43=$cgen;
      var $44=$2;
      var $45=(($44+64)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$3;
      var $48=FUNCTION_TABLE[$43]($46, $47, 0, $leftr);
      if ($48) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 20; break;
    case 10: 
      var $51=$2;
      var $52=(($51+68)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=$53;
      var $55=(($54+20)|0);
      var $56=HEAP32[(($55)>>2)];
      $cgen=$56;
      var $57=$cgen;
      var $58=$2;
      var $59=(($58+68)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=$3;
      var $62=FUNCTION_TABLE[$57]($60, $61, 0, $right);
      if ($62) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 20; break;
    case 12: 
      var $65=$3;
      var $66=(($65+36)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$3;
      var $69=_ast_function_label($68, ((STRING_TABLE.__str17)|0));
      var $70=$2;
      var $71=(($70+60)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=HEAP32[(($leftr)>>2)];
      var $74=HEAP32[(($right)>>2)];
      var $75=_ir_block_create_binop($67, $69, $72, $73, $74);
      $bin=$75;
      var $76=$bin;
      var $77=$2;
      var $78=(($77)|0);
      var $79=(($78+52)|0);
      HEAP32[(($79)>>2)]=$76;
      var $80=$2;
      var $81=(($80+64)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=$82;
      var $84=(($83+20)|0);
      var $85=HEAP32[(($84)>>2)];
      $cgen=$85;
      var $86=$cgen;
      var $87=$2;
      var $88=(($87+64)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$3;
      var $91=FUNCTION_TABLE[$86]($89, $90, 1, $leftl);
      if ($91) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      $1=0;
      __label__ = 20; break;
    case 14: 
      var $94=HEAP32[(($leftl)>>2)];
      var $95=$2;
      var $96=(($95)|0);
      var $97=(($96+48)|0);
      HEAP32[(($97)>>2)]=$94;
      var $98=$3;
      var $99=(($98+36)|0);
      var $100=HEAP32[(($99)>>2)];
      var $101=$2;
      var $102=(($101+56)|0);
      var $103=HEAP32[(($102)>>2)];
      var $104=HEAP32[(($leftl)>>2)];
      var $105=$bin;
      var $106=_ir_block_create_store_op($100, $103, $104, $105);
      if ($106) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 20; break;
    case 16: 
      var $109=$bin;
      var $110=$2;
      var $111=(($110)|0);
      var $112=(($111+52)|0);
      HEAP32[(($112)>>2)]=$109;
      var $113=$4;
      var $114=(($113) & 1);
      if ($114) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      var $116=HEAP32[(($leftl)>>2)];
      var $120 = $116;__label__ = 19; break;
    case 18: 
      var $118=$bin;
      var $120 = $118;__label__ = 19; break;
    case 19: 
      var $120;
      var $121=$5;
      HEAP32[(($121)>>2)]=$120;
      $1=1;
      __label__ = 20; break;
    case 20: 
      var $123=$1;
      STACKTOP = __stackBase__;
      return $123;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_binstore_codegen["X"]=1;

function _ast_unary_new($ctx_0, $ctx_1, $op, $expr) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $self;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$op;
      $3=$expr;
      var $6=_util_memory_a(64, 427, ((STRING_TABLE.__str)|0));
      var $7=$6;
      $self=$7;
      var $8=$self;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 9; break;
    case 4: 
      var $12=$self;
      var $13=$12;
      var $14=(($ctx)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($ctx+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _ast_node_init($13, $15, $17, 13);
      var $18=$self;
      var $19=$18;
      var $20=$19;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=(12);
      var $22=$self;
      var $23=$22;
      _ast_expression_init($23, (24));
      var $24=$2;
      var $25=$self;
      var $26=(($25+56)|0);
      HEAP32[(($26)>>2)]=$24;
      var $27=$3;
      var $28=$self;
      var $29=(($28+60)|0);
      HEAP32[(($29)>>2)]=$27;
      var $30=$2;
      var $31=(($30)|0) >= 44;
      if ($31) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 5: 
      var $33=$2;
      var $34=(($33)|0) <= 48;
      if ($34) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $36=$self;
      var $37=(($36)|0);
      var $38=(($37+24)|0);
      HEAP32[(($38)>>2)]=2;
      __label__ = 8; break;
    case 7: 
      var $40=$2;
      var $41=((_asm_instr+($40)*(12))|0);
      var $42=(($41)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($ctx)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($ctx+4)|0);
      var $47=HEAP32[(($46)>>2)];
      _asterror($45, $47, ((STRING_TABLE.__str1)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$43,tempInt));
      __label__ = 8; break;
    case 8: 
      var $49=$self;
      $1=$49;
      __label__ = 9; break;
    case 9: 
      var $51=$1;
      STACKTOP = __stackBase__;
      return $51;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_unary_new["X"]=1;

function _ast_unary_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+60)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+60)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $25=$1;
      var $26=$25;
      _ast_expression_delete($26);
      var $27=$1;
      var $28=$27;
      _util_memory_d($28, 445, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_unary_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $operand=__stackBase__;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str15)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $24=$2;
      var $25=(($24)|0);
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$5;
      HEAP32[(($28)>>2)]=$27;
      $1=1;
      __label__ = 11; break;
    case 6: 
      var $30=$2;
      var $31=(($30+60)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$32;
      var $34=(($33+20)|0);
      var $35=HEAP32[(($34)>>2)];
      $cgen=$35;
      var $36=$cgen;
      var $37=$2;
      var $38=(($37+60)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$3;
      var $41=FUNCTION_TABLE[$36]($39, $40, 0, $operand);
      if ($41) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 11; break;
    case 8: 
      var $44=$3;
      var $45=(($44+36)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$3;
      var $48=_ast_function_label($47, ((STRING_TABLE.__str18)|0));
      var $49=$2;
      var $50=(($49+56)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=HEAP32[(($operand)>>2)];
      var $53=_ir_block_create_unary($46, $48, $51, $52);
      var $54=$5;
      HEAP32[(($54)>>2)]=$53;
      var $55=$5;
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56)|0)!=0;
      if ($57) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $60=$5;
      var $61=HEAP32[(($60)>>2)];
      var $62=$2;
      var $63=(($62)|0);
      var $64=(($63+52)|0);
      HEAP32[(($64)>>2)]=$61;
      $1=1;
      __label__ = 11; break;
    case 11: 
      var $66=$1;
      STACKTOP = __stackBase__;
      return $66;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_unary_codegen["X"]=1;

function _asterror($ctx_0, $ctx_1, $msg) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $ap=(__stackBase__)+(8);
  var $2=(($ctx)|0);
  HEAP32[(($2)>>2)]=$ctx_0;
  var $3=(($ctx+4)|0);
  HEAP32[(($3)>>2)]=$ctx_1;
  $1=$msg;
  var $4=$ap;
  HEAP32[(($4)>>2)]=arguments[_asterror.length];
  var $5=$1;
  var $6=HEAP32[(($ap)>>2)];
  var $7=(($ctx)|0);
  var $8=HEAP32[(($7)>>2)];
  var $9=(($ctx+4)|0);
  var $10=HEAP32[(($9)>>2)];
  _cvprintmsg($8, $10, 2, ((STRING_TABLE.__str108)|0), $5, $6);
  var $11=$ap;
  ;
  STACKTOP = __stackBase__;
  return;
}


function _ast_return_new($ctx_0, $ctx_1, $expr) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $self;
      var $3=(($ctx)|0);
      HEAP32[(($3)>>2)]=$ctx_0;
      var $4=(($ctx+4)|0);
      HEAP32[(($4)>>2)]=$ctx_1;
      $2=$expr;
      var $5=_util_memory_a(60, 450, ((STRING_TABLE.__str)|0));
      var $6=$5;
      $self=$6;
      var $7=$self;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $11=$self;
      var $12=$11;
      var $13=(($ctx)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($ctx+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _ast_node_init($12, $14, $16, 14);
      var $17=$self;
      var $18=$17;
      var $19=$18;
      var $20=(($19+8)|0);
      HEAP32[(($20)>>2)]=(10);
      var $21=$self;
      var $22=$21;
      _ast_expression_init($22, (2));
      var $23=$2;
      var $24=$self;
      var $25=(($24+56)|0);
      HEAP32[(($25)>>2)]=$23;
      var $26=$self;
      $1=$26;
      __label__ = 5; break;
    case 5: 
      var $28=$1;
      STACKTOP = __stackBase__;
      return $28;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_return_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      var $2=$1;
      var $3=(($2+56)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 8; break; }
    case 3: 
      __label__ = 4; break;
    case 4: 
      var $8=$1;
      var $9=(($8+56)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=$10;
      var $12=$11;
      var $13=(($12+16)|0);
      var $14=HEAP8[($13)];
      var $15=(($14) & 1);
      if ($15) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $17=$1;
      var $18=(($17+56)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$19;
      var $21=$20;
      var $22=(($21+8)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$1;
      var $25=(($24+56)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$26;
      FUNCTION_TABLE[$23]($27);
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      var $31=$1;
      var $32=$31;
      _ast_expression_delete($32);
      var $33=$1;
      var $34=$33;
      _util_memory_d($34, 463, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_return_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $operand=__stackBase__;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str19)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 4: 
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $24=$2;
      var $25=$24;
      var $26=(($25)|0);
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($26+4)|0);
      var $30=HEAP32[(($29)>>2)];
      _asterror($28, $30, ((STRING_TABLE.__str20)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 6: 
      var $32=$2;
      var $33=(($32)|0);
      var $34=(($33+52)|0);
      HEAP32[(($34)>>2)]=1;
      var $35=$2;
      var $36=(($35+56)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)|0)!=0;
      if ($38) { __label__ = 7; break; } else { __label__ = 12; break; }
    case 7: 
      var $40=$2;
      var $41=(($40+56)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$42;
      var $44=(($43+20)|0);
      var $45=HEAP32[(($44)>>2)];
      $cgen=$45;
      var $46=$cgen;
      var $47=$2;
      var $48=(($47+56)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=$3;
      var $51=FUNCTION_TABLE[$46]($49, $50, 0, $operand);
      if ($51) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 16; break;
    case 9: 
      var $54=$3;
      var $55=(($54+36)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=HEAP32[(($operand)>>2)];
      var $58=_ir_block_create_return($56, $57);
      if ($58) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 16; break;
    case 11: 
      __label__ = 15; break;
    case 12: 
      var $62=$3;
      var $63=(($62+36)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=_ir_block_create_return($64, 0);
      if ($65) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      $1=0;
      __label__ = 16; break;
    case 14: 
      __label__ = 15; break;
    case 15: 
      $1=1;
      __label__ = 16; break;
    case 16: 
      var $70=$1;
      STACKTOP = __stackBase__;
      return $70;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_return_codegen["X"]=1;

function _ast_entfield_new($ctx_0, $ctx_1, $entity, $field) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $outtype;
      var $self;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$entity;
      $3=$field;
      var $6=_util_memory_a(64, 470, ((STRING_TABLE.__str)|0));
      var $7=$6;
      $self=$7;
      var $8=$self;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $12=$self;
      var $13=$12;
      var $14=(($ctx)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($ctx+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _ast_node_init($13, $15, $17, 8);
      var $18=$self;
      var $19=$18;
      var $20=$19;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=(46);
      var $22=$3;
      var $23=$22;
      var $24=(($23+24)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)!=5;
      if ($26) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $28=$self;
      var $29=$28;
      _util_memory_d($29, 473, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 11; break;
    case 6: 
      var $31=$3;
      var $32=$31;
      var $33=(($32+28)|0);
      var $34=HEAP32[(($33)>>2)];
      $outtype=$34;
      var $35=$outtype;
      var $36=(($35)|0)!=0;
      if ($36) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $38=$self;
      var $39=$38;
      _util_memory_d($39, 479, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 11; break;
    case 8: 
      var $41=$self;
      var $42=$41;
      _ast_expression_init($42, (20));
      var $43=$2;
      var $44=$self;
      var $45=(($44+56)|0);
      HEAP32[(($45)>>2)]=$43;
      var $46=$3;
      var $47=$self;
      var $48=(($47+60)|0);
      HEAP32[(($48)>>2)]=$46;
      var $49=$self;
      var $50=$49;
      var $51=$outtype;
      var $52=_ast_type_adopt_impl($50, $51);
      if ($52) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $54=$self;
      _ast_entfield_delete($54);
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $56=$self;
      $1=$56;
      __label__ = 11; break;
    case 11: 
      var $58=$1;
      STACKTOP = __stackBase__;
      return $58;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_entfield_new["X"]=1;

function _ast_entfield_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+56)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+56)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+56)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $26=$1;
      var $27=(($26+60)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28;
      var $30=$29;
      var $31=(($30+16)|0);
      var $32=HEAP8[($31)];
      var $33=(($32) & 1);
      if ($33) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $35=$1;
      var $36=(($35+60)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=$38;
      var $40=(($39+8)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$1;
      var $43=(($42+60)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=$44;
      FUNCTION_TABLE[$41]($45);
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=$48;
      _ast_expression_delete($49);
      var $50=$1;
      var $51=$50;
      _util_memory_d($51, 502, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_entfield_delete["X"]=1;

function _ast_entfield_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $ent=__stackBase__;
      var $field=(__stackBase__)+(4);
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+48)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $16=$2;
      var $17=(($16)|0);
      var $18=(($17+48)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$5;
      HEAP32[(($20)>>2)]=$19;
      $1=1;
      __label__ = 21; break;
    case 5: 
      var $22=$4;
      var $23=(($22) & 1);
      if ($23) { __label__ = 8; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$2;
      var $26=(($25)|0);
      var $27=(($26+52)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $31=$2;
      var $32=(($31)|0);
      var $33=(($32+52)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$5;
      HEAP32[(($35)>>2)]=$34;
      $1=1;
      __label__ = 21; break;
    case 8: 
      var $37=$2;
      var $38=(($37+56)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=(($40+20)|0);
      var $42=HEAP32[(($41)>>2)];
      $cgen=$42;
      var $43=$cgen;
      var $44=$2;
      var $45=(($44+56)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$3;
      var $48=FUNCTION_TABLE[$43]($46, $47, 0, $ent);
      if ($48) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 21; break;
    case 10: 
      var $51=$2;
      var $52=(($51+60)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=$53;
      var $55=(($54+20)|0);
      var $56=HEAP32[(($55)>>2)];
      $cgen=$56;
      var $57=$cgen;
      var $58=$2;
      var $59=(($58+60)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=$3;
      var $62=FUNCTION_TABLE[$57]($60, $61, 0, $field);
      if ($62) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 21; break;
    case 12: 
      var $65=$4;
      var $66=(($65) & 1);
      if ($66) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $68=$3;
      var $69=(($68+36)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=$3;
      var $72=_ast_function_label($71, ((STRING_TABLE.__str21)|0));
      var $73=HEAP32[(($ent)>>2)];
      var $74=HEAP32[(($field)>>2)];
      var $75=_ir_block_create_fieldaddress($70, $72, $73, $74);
      var $76=$5;
      HEAP32[(($76)>>2)]=$75;
      __label__ = 15; break;
    case 14: 
      var $78=$3;
      var $79=(($78+36)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=$3;
      var $82=_ast_function_label($81, ((STRING_TABLE.__str22)|0));
      var $83=HEAP32[(($ent)>>2)];
      var $84=HEAP32[(($field)>>2)];
      var $85=$2;
      var $86=(($85)|0);
      var $87=(($86+24)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=_ir_block_create_load_from_ent($80, $82, $83, $84, $88);
      var $90=$5;
      HEAP32[(($90)>>2)]=$89;
      __label__ = 15; break;
    case 15: 
      var $92=$5;
      var $93=HEAP32[(($92)>>2)];
      var $94=(($93)|0)!=0;
      if ($94) { __label__ = 17; break; } else { __label__ = 16; break; }
    case 16: 
      var $96=$2;
      var $97=$96;
      var $98=(($97)|0);
      var $99=$4;
      var $100=(($99) & 1);
      var $101=$100 ? (((STRING_TABLE.__str24)|0)) : (((STRING_TABLE.__str25)|0));
      var $102=$2;
      var $103=(($102)|0);
      var $104=(($103+24)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=((_type_name+($105<<2))|0);
      var $107=HEAP32[(($106)>>2)];
      var $108=(($98)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=(($98+4)|0);
      var $111=HEAP32[(($110)>>2)];
      _asterror($109, $111, ((STRING_TABLE.__str23)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$101,HEAP32[(((tempInt)+(4))>>2)]=$107,tempInt));
      $1=0;
      __label__ = 21; break;
    case 17: 
      var $113=$4;
      var $114=(($113) & 1);
      if ($114) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      var $116=$5;
      var $117=HEAP32[(($116)>>2)];
      var $118=$2;
      var $119=(($118)|0);
      var $120=(($119+48)|0);
      HEAP32[(($120)>>2)]=$117;
      __label__ = 20; break;
    case 19: 
      var $122=$5;
      var $123=HEAP32[(($122)>>2)];
      var $124=$2;
      var $125=(($124)|0);
      var $126=(($125+52)|0);
      HEAP32[(($126)>>2)]=$123;
      __label__ = 20; break;
    case 20: 
      $1=1;
      __label__ = 21; break;
    case 21: 
      var $129=$1;
      STACKTOP = __stackBase__;
      return $129;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_entfield_codegen["X"]=1;

function _ast_member_new($ctx_0, $ctx_1, $owner, $field) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $self;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$owner;
      $3=$field;
      var $6=_util_memory_a(64, 507, ((STRING_TABLE.__str)|0));
      var $7=$6;
      $self=$7;
      var $8=$self;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 13; break;
    case 4: 
      var $12=$self;
      var $13=$12;
      var $14=(($ctx)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($ctx+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _ast_node_init($13, $15, $17, 15);
      var $18=$self;
      var $19=$18;
      var $20=$19;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=(38);
      var $22=$3;
      var $23=(($22)>>>0) >= 3;
      if ($23) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $25=$self;
      var $26=$25;
      _util_memory_d($26, 509, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 13; break;
    case 6: 
      var $28=$2;
      var $29=$28;
      var $30=(($29+24)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($31)|0)!=3;
      if ($32) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $34=$2;
      var $35=$34;
      var $36=(($35+24)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)|0)!=5;
      if ($38) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $40=$2;
      var $41=$40;
      var $42=(($41+24)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((_type_name+($43<<2))|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($ctx)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($ctx+4)|0);
      var $49=HEAP32[(($48)>>2)];
      _asterror($47, $49, ((STRING_TABLE.__str2)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$45,tempInt));
      var $50=$self;
      var $51=$50;
      _util_memory_d($51, 516, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 13; break;
    case 9: 
      var $53=$self;
      var $54=$53;
      _ast_expression_init($54, (14));
      var $55=$self;
      var $56=(($55)|0);
      var $57=(($56)|0);
      var $58=(($57+16)|0);
      HEAP8[($58)]=1;
      var $59=$2;
      var $60=$59;
      var $61=(($60+24)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)==3;
      if ($63) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $65=$self;
      var $66=(($65)|0);
      var $67=(($66+24)|0);
      HEAP32[(($67)>>2)]=2;
      var $68=$self;
      var $69=(($68)|0);
      var $70=(($69+28)|0);
      HEAP32[(($70)>>2)]=0;
      __label__ = 12; break;
    case 11: 
      var $72=$self;
      var $73=(($72)|0);
      var $74=(($73+24)|0);
      HEAP32[(($74)>>2)]=5;
      var $75=(($ctx)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($ctx+4)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=_ast_shallow_type($76, $78, 2);
      var $80=$self;
      var $81=(($80)|0);
      var $82=(($81+28)|0);
      HEAP32[(($82)>>2)]=$79;
      __label__ = 12; break;
    case 12: 
      var $84=$2;
      var $85=$self;
      var $86=(($85+56)|0);
      HEAP32[(($86)>>2)]=$84;
      var $87=$3;
      var $88=$self;
      var $89=(($88+60)|0);
      HEAP32[(($89)>>2)]=$87;
      var $90=$self;
      $1=$90;
      __label__ = 13; break;
    case 13: 
      var $92=$1;
      STACKTOP = __stackBase__;
      return $92;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_member_new["X"]=1;

function _ast_member_delete($self) {
  ;
  var __label__;

  var $1;
  $1=$self;
  var $2=$1;
  var $3=$2;
  _ast_expression_delete($3);
  var $4=$1;
  var $5=$4;
  _util_memory_d($5, 548, ((STRING_TABLE.__str)|0));
  ;
  return;
}


function _ast_member_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $vec=__stackBase__;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      var $9=$2;
      var $10=(($9)|0);
      var $11=(($10+48)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$2;
      var $16=(($15)|0);
      var $17=(($16+48)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$5;
      HEAP32[(($19)>>2)]=$18;
      $1=1;
      __label__ = 11; break;
    case 4: 
      var $21=$2;
      var $22=(($21+56)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$23;
      var $25=(($24+20)|0);
      var $26=HEAP32[(($25)>>2)];
      $cgen=$26;
      var $27=$cgen;
      var $28=$2;
      var $29=(($28+56)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=$3;
      var $32=FUNCTION_TABLE[$27]($30, $31, 1, $vec);
      if ($32) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 11; break;
    case 6: 
      var $35=HEAP32[(($vec)>>2)];
      var $36=(($35+4)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)|0)!=3;
      if ($38) { __label__ = 7; break; } else { __label__ = 10; break; }
    case 7: 
      var $40=HEAP32[(($vec)>>2)];
      var $41=(($40+4)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=(($42)|0)==5;
      if ($43) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $45=$2;
      var $46=(($45+56)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      var $49=(($48+28)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=$50;
      var $52=(($51+24)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($53)|0)==3;
      if ($54) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $57=HEAP32[(($vec)>>2)];
      var $58=$2;
      var $59=(($58+60)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=_ir_value_vector_member($57, $60);
      var $62=$5;
      HEAP32[(($62)>>2)]=$61;
      var $63=$5;
      var $64=HEAP32[(($63)>>2)];
      var $65=$2;
      var $66=(($65)|0);
      var $67=(($66+48)|0);
      HEAP32[(($67)>>2)]=$64;
      var $68=$5;
      var $69=HEAP32[(($68)>>2)];
      var $70=(($69)|0)!=0;
      $1=$70;
      __label__ = 11; break;
    case 11: 
      var $72=$1;
      STACKTOP = __stackBase__;
      return $72;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_member_codegen["X"]=1;

function _ast_shallow_type($ctx_0, $ctx_1, $vtype) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $self;
      var $3=(($ctx)|0);
      HEAP32[(($3)>>2)]=$ctx_0;
      var $4=(($ctx+4)|0);
      HEAP32[(($4)>>2)]=$ctx_1;
      $2=$vtype;
      var $5=_util_memory_a(92, 145, ((STRING_TABLE.__str)|0));
      var $6=$5;
      $self=$6;
      var $7=$self;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $11=$self;
      var $12=$11;
      var $13=(($ctx)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($ctx+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _ast_node_init($12, $14, $16, 1);
      var $17=$self;
      var $18=$17;
      var $19=$18;
      var $20=(($19+8)|0);
      HEAP32[(($20)>>2)]=(22);
      var $21=$self;
      _ast_expression_init($21, 0);
      var $22=$self;
      var $23=$22;
      var $24=(($23+20)|0);
      HEAP32[(($24)>>2)]=0;
      var $25=$self;
      var $26=$25;
      var $27=(($26+28)|0);
      HEAP32[(($27)>>2)]=0;
      var $28=$2;
      var $29=$self;
      var $30=$29;
      var $31=(($30+24)|0);
      HEAP32[(($31)>>2)]=$28;
      var $32=$self;
      $1=$32;
      __label__ = 5; break;
    case 5: 
      var $34=$1;
      STACKTOP = __stackBase__;
      return $34;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_ifthen_new($ctx_0, $ctx_1, $cond, $ontrue, $onfalse) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $4;
      var $self;
      var $5=(($ctx)|0);
      HEAP32[(($5)>>2)]=$ctx_0;
      var $6=(($ctx+4)|0);
      HEAP32[(($6)>>2)]=$ctx_1;
      $2=$cond;
      $3=$ontrue;
      $4=$onfalse;
      var $7=_util_memory_a(68, 553, ((STRING_TABLE.__str)|0));
      var $8=$7;
      $self=$8;
      var $9=$self;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $13=$self;
      var $14=$13;
      var $15=(($ctx)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($ctx+4)|0);
      var $18=HEAP32[(($17)>>2)];
      _ast_node_init($14, $16, $18, 9);
      var $19=$self;
      var $20=$19;
      var $21=$20;
      var $22=(($21+8)|0);
      HEAP32[(($22)>>2)]=(18);
      var $23=$3;
      var $24=(($23)|0)!=0;
      if ($24) { __label__ = 7; break; } else { __label__ = 5; break; }
    case 5: 
      var $26=$4;
      var $27=(($26)|0)!=0;
      if ($27) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $29=$self;
      var $30=$29;
      _util_memory_d($30, 556, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 8; break;
    case 7: 
      var $32=$self;
      var $33=$32;
      _ast_expression_init($33, (4));
      var $34=$2;
      var $35=$self;
      var $36=(($35+56)|0);
      HEAP32[(($36)>>2)]=$34;
      var $37=$3;
      var $38=$self;
      var $39=(($38+60)|0);
      HEAP32[(($39)>>2)]=$37;
      var $40=$4;
      var $41=$self;
      var $42=(($41+64)|0);
      HEAP32[(($42)>>2)]=$40;
      var $43=$self;
      $1=$43;
      __label__ = 8; break;
    case 8: 
      var $45=$1;
      STACKTOP = __stackBase__;
      return $45;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_ifthen_new["X"]=1;

function _ast_ifthen_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+56)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+56)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+56)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $25=$1;
      var $26=(($25+60)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27)|0)!=0;
      if ($28) { __label__ = 7; break; } else { __label__ = 12; break; }
    case 7: 
      __label__ = 8; break;
    case 8: 
      var $31=$1;
      var $32=(($31+60)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=$33;
      var $35=$34;
      var $36=(($35+16)|0);
      var $37=HEAP8[($36)];
      var $38=(($37) & 1);
      if ($38) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $40=$1;
      var $41=(($40+60)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$42;
      var $44=$43;
      var $45=(($44+8)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$1;
      var $48=(($47+60)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=$49;
      FUNCTION_TABLE[$46]($50);
      __label__ = 10; break;
    case 10: 
      __label__ = 11; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $54=$1;
      var $55=(($54+64)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56)|0)!=0;
      if ($57) { __label__ = 13; break; } else { __label__ = 18; break; }
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $60=$1;
      var $61=(($60+64)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=$62;
      var $64=$63;
      var $65=(($64+16)|0);
      var $66=HEAP8[($65)];
      var $67=(($66) & 1);
      if ($67) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $69=$1;
      var $70=(($69+64)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$71;
      var $73=$72;
      var $74=(($73+8)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$1;
      var $77=(($76+64)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$78;
      FUNCTION_TABLE[$75]($79);
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $83=$1;
      var $84=$83;
      _ast_expression_delete($84);
      var $85=$1;
      var $86=$85;
      _util_memory_d($86, 576, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_ifthen_delete["X"]=1;

function _ast_ifthen_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $condval=__stackBase__;
      var $dummy=(__stackBase__)+(4);
      var $cond;
      var $ontrue;
      var $onfalse;
      var $ontrue_endblock;
      var $onfalse_endblock;
      var $merge;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$3;
      var $8=(($7+36)|0);
      var $9=HEAP32[(($8)>>2)];
      $cond=$9;
      $ontrue_endblock=0;
      $onfalse_endblock=0;
      var $10=$5;
      var $11=$4;
      var $12=(($11) & 1);
      var $13=$2;
      var $14=(($13)|0);
      var $15=(($14+52)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $19=$2;
      var $20=$19;
      var $21=(($20)|0);
      var $22=(($21)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($21+4)|0);
      var $25=HEAP32[(($24)>>2)];
      _asterror($23, $25, ((STRING_TABLE.__str26)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 39; break;
    case 4: 
      var $27=$2;
      var $28=(($27)|0);
      var $29=(($28+52)|0);
      HEAP32[(($29)>>2)]=1;
      var $30=$cond;
      var $31=$3;
      var $32=(($31+36)|0);
      HEAP32[(($32)>>2)]=$30;
      var $33=$2;
      var $34=(($33+56)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$35;
      var $37=(($36+20)|0);
      var $38=HEAP32[(($37)>>2)];
      $cgen=$38;
      var $39=$cgen;
      var $40=$2;
      var $41=(($40+56)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$3;
      var $44=FUNCTION_TABLE[$39]($42, $43, 0, $condval);
      if ($44) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 39; break;
    case 6: 
      var $47=$2;
      var $48=(($47+60)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($49)|0)!=0;
      if ($50) { __label__ = 7; break; } else { __label__ = 12; break; }
    case 7: 
      var $52=$3;
      var $53=(($52+32)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=$3;
      var $56=_ast_function_label($55, ((STRING_TABLE.__str27)|0));
      var $57=_ir_function_create_block($54, $56);
      $ontrue=$57;
      var $58=$ontrue;
      var $59=(($58)|0)!=0;
      if ($59) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 39; break;
    case 9: 
      var $62=$ontrue;
      var $63=$3;
      var $64=(($63+36)|0);
      HEAP32[(($64)>>2)]=$62;
      var $65=$2;
      var $66=(($65+60)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=(($68+20)|0);
      var $70=HEAP32[(($69)>>2)];
      $cgen=$70;
      var $71=$cgen;
      var $72=$2;
      var $73=(($72+60)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=$3;
      var $76=FUNCTION_TABLE[$71]($74, $75, 0, $dummy);
      if ($76) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 39; break;
    case 11: 
      var $79=$3;
      var $80=(($79+36)|0);
      var $81=HEAP32[(($80)>>2)];
      $ontrue_endblock=$81;
      __label__ = 13; break;
    case 12: 
      $ontrue=0;
      __label__ = 13; break;
    case 13: 
      var $84=$2;
      var $85=(($84+64)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=(($86)|0)!=0;
      if ($87) { __label__ = 14; break; } else { __label__ = 19; break; }
    case 14: 
      var $89=$3;
      var $90=(($89+32)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=$3;
      var $93=_ast_function_label($92, ((STRING_TABLE.__str28)|0));
      var $94=_ir_function_create_block($91, $93);
      $onfalse=$94;
      var $95=$onfalse;
      var $96=(($95)|0)!=0;
      if ($96) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 39; break;
    case 16: 
      var $99=$onfalse;
      var $100=$3;
      var $101=(($100+36)|0);
      HEAP32[(($101)>>2)]=$99;
      var $102=$2;
      var $103=(($102+64)|0);
      var $104=HEAP32[(($103)>>2)];
      var $105=$104;
      var $106=(($105+20)|0);
      var $107=HEAP32[(($106)>>2)];
      $cgen=$107;
      var $108=$cgen;
      var $109=$2;
      var $110=(($109+64)|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=$3;
      var $113=FUNCTION_TABLE[$108]($111, $112, 0, $dummy);
      if ($113) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 39; break;
    case 18: 
      var $116=$3;
      var $117=(($116+36)|0);
      var $118=HEAP32[(($117)>>2)];
      $onfalse_endblock=$118;
      __label__ = 20; break;
    case 19: 
      $onfalse=0;
      __label__ = 20; break;
    case 20: 
      var $121=$3;
      var $122=(($121+32)|0);
      var $123=HEAP32[(($122)>>2)];
      var $124=$3;
      var $125=_ast_function_label($124, ((STRING_TABLE.__str29)|0));
      var $126=_ir_function_create_block($123, $125);
      $merge=$126;
      var $127=$merge;
      var $128=(($127)|0)!=0;
      if ($128) { __label__ = 22; break; } else { __label__ = 21; break; }
    case 21: 
      $1=0;
      __label__ = 39; break;
    case 22: 
      var $131=$ontrue;
      var $132=(($131)|0)!=0;
      if ($132) { __label__ = 23; break; } else { __label__ = 26; break; }
    case 23: 
      var $134=$ontrue_endblock;
      var $135=(($134+12)|0);
      var $136=HEAP8[($135)];
      var $137=(($136) & 1);
      if ($137) { __label__ = 26; break; } else { __label__ = 24; break; }
    case 24: 
      var $139=$ontrue_endblock;
      var $140=$merge;
      var $141=_ir_block_create_jump($139, $140);
      if ($141) { __label__ = 26; break; } else { __label__ = 25; break; }
    case 25: 
      $1=0;
      __label__ = 39; break;
    case 26: 
      var $144=$onfalse;
      var $145=(($144)|0)!=0;
      if ($145) { __label__ = 27; break; } else { __label__ = 30; break; }
    case 27: 
      var $147=$onfalse_endblock;
      var $148=(($147+12)|0);
      var $149=HEAP8[($148)];
      var $150=(($149) & 1);
      if ($150) { __label__ = 30; break; } else { __label__ = 28; break; }
    case 28: 
      var $152=$onfalse_endblock;
      var $153=$merge;
      var $154=_ir_block_create_jump($152, $153);
      if ($154) { __label__ = 30; break; } else { __label__ = 29; break; }
    case 29: 
      $1=0;
      __label__ = 39; break;
    case 30: 
      var $157=$cond;
      var $158=HEAP32[(($condval)>>2)];
      var $159=$ontrue;
      var $160=(($159)|0)!=0;
      if ($160) { __label__ = 31; break; } else { __label__ = 32; break; }
    case 31: 
      var $162=$ontrue;
      var $166 = $162;__label__ = 33; break;
    case 32: 
      var $164=$merge;
      var $166 = $164;__label__ = 33; break;
    case 33: 
      var $166;
      var $167=$onfalse;
      var $168=(($167)|0)!=0;
      if ($168) { __label__ = 34; break; } else { __label__ = 35; break; }
    case 34: 
      var $170=$onfalse;
      var $174 = $170;__label__ = 36; break;
    case 35: 
      var $172=$merge;
      var $174 = $172;__label__ = 36; break;
    case 36: 
      var $174;
      var $175=_ir_block_create_if($157, $158, $166, $174);
      if ($175) { __label__ = 38; break; } else { __label__ = 37; break; }
    case 37: 
      $1=0;
      __label__ = 39; break;
    case 38: 
      var $178=$merge;
      var $179=$3;
      var $180=(($179+36)|0);
      HEAP32[(($180)>>2)]=$178;
      $1=1;
      __label__ = 39; break;
    case 39: 
      var $182=$1;
      STACKTOP = __stackBase__;
      return $182;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_ifthen_codegen["X"]=1;

function _ast_loop_new($ctx_0, $ctx_1, $initexpr, $precond, $postcond, $increment, $body) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $self;
      var $7=(($ctx)|0);
      HEAP32[(($7)>>2)]=$ctx_0;
      var $8=(($ctx+4)|0);
      HEAP32[(($8)>>2)]=$ctx_1;
      $2=$initexpr;
      $3=$precond;
      $4=$postcond;
      $5=$increment;
      $6=$body;
      var $9=_util_memory_a(76, 613, ((STRING_TABLE.__str)|0));
      var $10=$9;
      $self=$10;
      var $11=$self;
      var $12=(($11)|0)!=0;
      if ($12) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $15=$self;
      var $16=$15;
      var $17=(($ctx)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($ctx+4)|0);
      var $20=HEAP32[(($19)>>2)];
      _ast_node_init($16, $18, $20, 11);
      var $21=$self;
      var $22=$21;
      var $23=$22;
      var $24=(($23+8)|0);
      HEAP32[(($24)>>2)]=(28);
      var $25=$self;
      var $26=$25;
      _ast_expression_init($26, (50));
      var $27=$2;
      var $28=$self;
      var $29=(($28+56)|0);
      HEAP32[(($29)>>2)]=$27;
      var $30=$3;
      var $31=$self;
      var $32=(($31+60)|0);
      HEAP32[(($32)>>2)]=$30;
      var $33=$4;
      var $34=$self;
      var $35=(($34+64)|0);
      HEAP32[(($35)>>2)]=$33;
      var $36=$5;
      var $37=$self;
      var $38=(($37+68)|0);
      HEAP32[(($38)>>2)]=$36;
      var $39=$6;
      var $40=$self;
      var $41=(($40+72)|0);
      HEAP32[(($41)>>2)]=$39;
      var $42=$self;
      $1=$42;
      __label__ = 5; break;
    case 5: 
      var $44=$1;
      STACKTOP = __stackBase__;
      return $44;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_loop_new["X"]=1;

function _ast_loop_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      var $2=$1;
      var $3=(($2+56)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 8; break; }
    case 3: 
      __label__ = 4; break;
    case 4: 
      var $8=$1;
      var $9=(($8+56)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=$10;
      var $12=$11;
      var $13=(($12+16)|0);
      var $14=HEAP8[($13)];
      var $15=(($14) & 1);
      if ($15) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $17=$1;
      var $18=(($17+56)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$19;
      var $21=$20;
      var $22=(($21+8)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$1;
      var $25=(($24+56)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$26;
      FUNCTION_TABLE[$23]($27);
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      var $31=$1;
      var $32=(($31+60)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33)|0)!=0;
      if ($34) { __label__ = 9; break; } else { __label__ = 14; break; }
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $37=$1;
      var $38=(($37+60)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$40;
      var $42=(($41+16)|0);
      var $43=HEAP8[($42)];
      var $44=(($43) & 1);
      if ($44) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      var $46=$1;
      var $47=(($46+60)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      var $50=$49;
      var $51=(($50+8)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=$1;
      var $54=(($53+60)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$55;
      FUNCTION_TABLE[$52]($56);
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $60=$1;
      var $61=(($60+64)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)!=0;
      if ($63) { __label__ = 15; break; } else { __label__ = 20; break; }
    case 15: 
      __label__ = 16; break;
    case 16: 
      var $66=$1;
      var $67=(($66+64)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$68;
      var $70=$69;
      var $71=(($70+16)|0);
      var $72=HEAP8[($71)];
      var $73=(($72) & 1);
      if ($73) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $75=$1;
      var $76=(($75+64)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=$77;
      var $79=$78;
      var $80=(($79+8)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=$1;
      var $83=(($82+64)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=$84;
      FUNCTION_TABLE[$81]($85);
      __label__ = 18; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      var $89=$1;
      var $90=(($89+68)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($91)|0)!=0;
      if ($92) { __label__ = 21; break; } else { __label__ = 26; break; }
    case 21: 
      __label__ = 22; break;
    case 22: 
      var $95=$1;
      var $96=(($95+68)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=$97;
      var $99=$98;
      var $100=(($99+16)|0);
      var $101=HEAP8[($100)];
      var $102=(($101) & 1);
      if ($102) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $104=$1;
      var $105=(($104+68)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=$106;
      var $108=$107;
      var $109=(($108+8)|0);
      var $110=HEAP32[(($109)>>2)];
      var $111=$1;
      var $112=(($111+68)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$113;
      FUNCTION_TABLE[$110]($114);
      __label__ = 24; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      var $118=$1;
      var $119=(($118+72)|0);
      var $120=HEAP32[(($119)>>2)];
      var $121=(($120)|0)!=0;
      if ($121) { __label__ = 27; break; } else { __label__ = 32; break; }
    case 27: 
      __label__ = 28; break;
    case 28: 
      var $124=$1;
      var $125=(($124+72)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=$126;
      var $128=$127;
      var $129=(($128+16)|0);
      var $130=HEAP8[($129)];
      var $131=(($130) & 1);
      if ($131) { __label__ = 30; break; } else { __label__ = 29; break; }
    case 29: 
      var $133=$1;
      var $134=(($133+72)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=$135;
      var $137=$136;
      var $138=(($137+8)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=$1;
      var $141=(($140+72)|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=$142;
      FUNCTION_TABLE[$139]($143);
      __label__ = 30; break;
    case 30: 
      __label__ = 31; break;
    case 31: 
      __label__ = 32; break;
    case 32: 
      var $147=$1;
      var $148=$147;
      _ast_expression_delete($148);
      var $149=$1;
      var $150=$149;
      _util_memory_d($150, 638, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_loop_delete["X"]=1;

function _ast_loop_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $dummy=__stackBase__;
      var $precond=(__stackBase__)+(4);
      var $postcond=(__stackBase__)+(8);
      var $bbody;
      var $end_bbody;
      var $bprecond;
      var $end_bprecond;
      var $bpostcond;
      var $end_bpostcond;
      var $bincrement;
      var $end_bincrement;
      var $bout;
      var $bin;
      var $bout_id;
      var $bcontinue;
      var $bbreak;
      var $old_bcontinue;
      var $old_bbreak;
      var $tmpblock;
      var $ontrue;
      var $onfalse;
      var $ontrue1;
      var $onfalse2;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      HEAP32[(($dummy)>>2)]=0;
      HEAP32[(($precond)>>2)]=0;
      HEAP32[(($postcond)>>2)]=0;
      $bbody=0;
      $end_bbody=0;
      $bprecond=0;
      $end_bprecond=0;
      $bpostcond=0;
      $end_bpostcond=0;
      $bincrement=0;
      $end_bincrement=0;
      $bout=0;
      $bin=0;
      $bcontinue=0;
      $bbreak=0;
      $old_bcontinue=0;
      $old_bbreak=0;
      $tmpblock=0;
      var $7=$4;
      var $8=(($7) & 1);
      var $9=$5;
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+52)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $16=$2;
      var $17=$16;
      var $18=(($17)|0);
      var $19=(($18)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($18+4)|0);
      var $22=HEAP32[(($21)>>2)];
      _asterror($20, $22, ((STRING_TABLE.__str34)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 109; break;
    case 4: 
      var $24=$2;
      var $25=(($24)|0);
      var $26=(($25+52)|0);
      HEAP32[(($26)>>2)]=1;
      var $27=$2;
      var $28=(($27+56)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $32=$2;
      var $33=(($32+56)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$34;
      var $36=(($35+20)|0);
      var $37=HEAP32[(($36)>>2)];
      $cgen=$37;
      var $38=$cgen;
      var $39=$2;
      var $40=(($39+56)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$3;
      var $43=FUNCTION_TABLE[$38]($41, $42, 0, $dummy);
      if ($43) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      $1=0;
      __label__ = 109; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      var $47=$3;
      var $48=(($47+36)|0);
      var $49=HEAP32[(($48)>>2)];
      $bin=$49;
      var $50=$2;
      var $51=(($50+60)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=(($52)|0)!=0;
      if ($53) { __label__ = 9; break; } else { __label__ = 14; break; }
    case 9: 
      var $55=$3;
      var $56=(($55+32)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=$3;
      var $59=_ast_function_label($58, ((STRING_TABLE.__str35)|0));
      var $60=_ir_function_create_block($57, $59);
      $bprecond=$60;
      var $61=$bprecond;
      var $62=(($61)|0)!=0;
      if ($62) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 109; break;
    case 11: 
      var $65=$bprecond;
      $bcontinue=$65;
      var $66=$bprecond;
      var $67=$3;
      var $68=(($67+36)|0);
      HEAP32[(($68)>>2)]=$66;
      var $69=$2;
      var $70=(($69+60)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$71;
      var $73=(($72+20)|0);
      var $74=HEAP32[(($73)>>2)];
      $cgen=$74;
      var $75=$cgen;
      var $76=$2;
      var $77=(($76+60)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$3;
      var $80=FUNCTION_TABLE[$75]($78, $79, 0, $precond);
      if ($80) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      $1=0;
      __label__ = 109; break;
    case 13: 
      var $83=$3;
      var $84=(($83+36)|0);
      var $85=HEAP32[(($84)>>2)];
      $end_bprecond=$85;
      __label__ = 15; break;
    case 14: 
      $end_bprecond=0;
      $bprecond=0;
      __label__ = 15; break;
    case 15: 
      var $88=$2;
      var $89=(($88+68)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=(($90)|0)!=0;
      if ($91) { __label__ = 16; break; } else { __label__ = 19; break; }
    case 16: 
      var $93=$3;
      var $94=(($93+32)|0);
      var $95=HEAP32[(($94)>>2)];
      var $96=$3;
      var $97=_ast_function_label($96, ((STRING_TABLE.__str36)|0));
      var $98=_ir_function_create_block($95, $97);
      $bincrement=$98;
      var $99=$bincrement;
      var $100=(($99)|0)!=0;
      if ($100) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 109; break;
    case 18: 
      var $103=$bincrement;
      $bcontinue=$103;
      __label__ = 20; break;
    case 19: 
      $end_bincrement=0;
      $bincrement=0;
      __label__ = 20; break;
    case 20: 
      var $106=$2;
      var $107=(($106+64)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($108)|0)!=0;
      if ($109) { __label__ = 21; break; } else { __label__ = 24; break; }
    case 21: 
      var $111=$3;
      var $112=(($111+32)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$3;
      var $115=_ast_function_label($114, ((STRING_TABLE.__str37)|0));
      var $116=_ir_function_create_block($113, $115);
      $bpostcond=$116;
      var $117=$bpostcond;
      var $118=(($117)|0)!=0;
      if ($118) { __label__ = 23; break; } else { __label__ = 22; break; }
    case 22: 
      $1=0;
      __label__ = 109; break;
    case 23: 
      var $121=$bpostcond;
      $bcontinue=$121;
      __label__ = 25; break;
    case 24: 
      $end_bpostcond=0;
      $bpostcond=0;
      __label__ = 25; break;
    case 25: 
      var $124=$3;
      var $125=(($124+32)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=(($126+24)|0);
      var $128=HEAP32[(($127)>>2)];
      $bout_id=$128;
      var $129=$3;
      var $130=(($129+32)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=$3;
      var $133=_ast_function_label($132, ((STRING_TABLE.__str38)|0));
      var $134=_ir_function_create_block($131, $133);
      $bout=$134;
      var $135=$bout;
      var $136=(($135)|0)!=0;
      if ($136) { __label__ = 27; break; } else { __label__ = 26; break; }
    case 26: 
      $1=0;
      __label__ = 109; break;
    case 27: 
      var $139=$bout;
      $bbreak=$139;
      var $140=$2;
      var $141=(($140+72)|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=(($142)|0)!=0;
      if ($143) { __label__ = 28; break; } else { __label__ = 33; break; }
    case 28: 
      var $145=$3;
      var $146=(($145+32)|0);
      var $147=HEAP32[(($146)>>2)];
      var $148=$3;
      var $149=_ast_function_label($148, ((STRING_TABLE.__str39)|0));
      var $150=_ir_function_create_block($147, $149);
      $bbody=$150;
      var $151=$bbody;
      var $152=(($151)|0)!=0;
      if ($152) { __label__ = 30; break; } else { __label__ = 29; break; }
    case 29: 
      $1=0;
      __label__ = 109; break;
    case 30: 
      var $155=$bbody;
      var $156=$3;
      var $157=(($156+36)|0);
      HEAP32[(($157)>>2)]=$155;
      var $158=$3;
      var $159=(($158+40)|0);
      var $160=HEAP32[(($159)>>2)];
      $old_bbreak=$160;
      var $161=$3;
      var $162=(($161+44)|0);
      var $163=HEAP32[(($162)>>2)];
      $old_bcontinue=$163;
      var $164=$bbreak;
      var $165=$3;
      var $166=(($165+40)|0);
      HEAP32[(($166)>>2)]=$164;
      var $167=$bcontinue;
      var $168=$3;
      var $169=(($168+44)|0);
      HEAP32[(($169)>>2)]=$167;
      var $170=$2;
      var $171=(($170+72)|0);
      var $172=HEAP32[(($171)>>2)];
      var $173=$172;
      var $174=(($173+20)|0);
      var $175=HEAP32[(($174)>>2)];
      $cgen=$175;
      var $176=$cgen;
      var $177=$2;
      var $178=(($177+72)|0);
      var $179=HEAP32[(($178)>>2)];
      var $180=$3;
      var $181=FUNCTION_TABLE[$176]($179, $180, 0, $dummy);
      if ($181) { __label__ = 32; break; } else { __label__ = 31; break; }
    case 31: 
      $1=0;
      __label__ = 109; break;
    case 32: 
      var $184=$3;
      var $185=(($184+36)|0);
      var $186=HEAP32[(($185)>>2)];
      $end_bbody=$186;
      var $187=$old_bbreak;
      var $188=$3;
      var $189=(($188+40)|0);
      HEAP32[(($189)>>2)]=$187;
      var $190=$old_bcontinue;
      var $191=$3;
      var $192=(($191+44)|0);
      HEAP32[(($192)>>2)]=$190;
      __label__ = 33; break;
    case 33: 
      var $194=$2;
      var $195=(($194+64)|0);
      var $196=HEAP32[(($195)>>2)];
      var $197=(($196)|0)!=0;
      if ($197) { __label__ = 34; break; } else { __label__ = 37; break; }
    case 34: 
      var $199=$bpostcond;
      var $200=$3;
      var $201=(($200+36)|0);
      HEAP32[(($201)>>2)]=$199;
      var $202=$2;
      var $203=(($202+64)|0);
      var $204=HEAP32[(($203)>>2)];
      var $205=$204;
      var $206=(($205+20)|0);
      var $207=HEAP32[(($206)>>2)];
      $cgen=$207;
      var $208=$cgen;
      var $209=$2;
      var $210=(($209+64)|0);
      var $211=HEAP32[(($210)>>2)];
      var $212=$3;
      var $213=FUNCTION_TABLE[$208]($211, $212, 0, $postcond);
      if ($213) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      $1=0;
      __label__ = 109; break;
    case 36: 
      var $216=$3;
      var $217=(($216+36)|0);
      var $218=HEAP32[(($217)>>2)];
      $end_bpostcond=$218;
      __label__ = 37; break;
    case 37: 
      var $220=$2;
      var $221=(($220+68)|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=(($222)|0)!=0;
      if ($223) { __label__ = 38; break; } else { __label__ = 41; break; }
    case 38: 
      var $225=$bincrement;
      var $226=$3;
      var $227=(($226+36)|0);
      HEAP32[(($227)>>2)]=$225;
      var $228=$2;
      var $229=(($228+68)|0);
      var $230=HEAP32[(($229)>>2)];
      var $231=$230;
      var $232=(($231+20)|0);
      var $233=HEAP32[(($232)>>2)];
      $cgen=$233;
      var $234=$cgen;
      var $235=$2;
      var $236=(($235+68)|0);
      var $237=HEAP32[(($236)>>2)];
      var $238=$3;
      var $239=FUNCTION_TABLE[$234]($237, $238, 0, $dummy);
      if ($239) { __label__ = 40; break; } else { __label__ = 39; break; }
    case 39: 
      $1=0;
      __label__ = 109; break;
    case 40: 
      var $242=$3;
      var $243=(($242+36)|0);
      var $244=HEAP32[(($243)>>2)];
      $end_bincrement=$244;
      __label__ = 41; break;
    case 41: 
      var $246=$bout;
      var $247=$3;
      var $248=(($247+36)|0);
      HEAP32[(($248)>>2)]=$246;
      var $249=$bprecond;
      var $250=(($249)|0)!=0;
      if ($250) { __label__ = 42; break; } else { __label__ = 43; break; }
    case 42: 
      var $252=$bprecond;
      $tmpblock=$252;
      __label__ = 50; break;
    case 43: 
      var $254=$bbody;
      var $255=(($254)|0)!=0;
      if ($255) { __label__ = 44; break; } else { __label__ = 45; break; }
    case 44: 
      var $257=$bbody;
      $tmpblock=$257;
      __label__ = 49; break;
    case 45: 
      var $259=$bpostcond;
      var $260=(($259)|0)!=0;
      if ($260) { __label__ = 46; break; } else { __label__ = 47; break; }
    case 46: 
      var $262=$bpostcond;
      $tmpblock=$262;
      __label__ = 48; break;
    case 47: 
      var $264=$bout;
      $tmpblock=$264;
      __label__ = 48; break;
    case 48: 
      __label__ = 49; break;
    case 49: 
      __label__ = 50; break;
    case 50: 
      var $268=$bin;
      var $269=$tmpblock;
      var $270=_ir_block_create_jump($268, $269);
      if ($270) { __label__ = 52; break; } else { __label__ = 51; break; }
    case 51: 
      $1=0;
      __label__ = 109; break;
    case 52: 
      var $273=$bprecond;
      var $274=(($273)|0)!=0;
      if ($274) { __label__ = 53; break; } else { __label__ = 65; break; }
    case 53: 
      var $276=$bbody;
      var $277=(($276)|0)!=0;
      if ($277) { __label__ = 54; break; } else { __label__ = 55; break; }
    case 54: 
      var $279=$bbody;
      $ontrue=$279;
      __label__ = 62; break;
    case 55: 
      var $281=$bincrement;
      var $282=(($281)|0)!=0;
      if ($282) { __label__ = 56; break; } else { __label__ = 57; break; }
    case 56: 
      var $284=$bincrement;
      $ontrue=$284;
      __label__ = 61; break;
    case 57: 
      var $286=$bpostcond;
      var $287=(($286)|0)!=0;
      if ($287) { __label__ = 58; break; } else { __label__ = 59; break; }
    case 58: 
      var $289=$bpostcond;
      $ontrue=$289;
      __label__ = 60; break;
    case 59: 
      var $291=$bprecond;
      $ontrue=$291;
      __label__ = 60; break;
    case 60: 
      __label__ = 61; break;
    case 61: 
      __label__ = 62; break;
    case 62: 
      var $295=$bout;
      $onfalse=$295;
      var $296=$end_bprecond;
      var $297=HEAP32[(($precond)>>2)];
      var $298=$ontrue;
      var $299=$onfalse;
      var $300=_ir_block_create_if($296, $297, $298, $299);
      if ($300) { __label__ = 64; break; } else { __label__ = 63; break; }
    case 63: 
      $1=0;
      __label__ = 109; break;
    case 64: 
      __label__ = 65; break;
    case 65: 
      var $304=$bbody;
      var $305=(($304)|0)!=0;
      if ($305) { __label__ = 66; break; } else { __label__ = 79; break; }
    case 66: 
      var $307=$bincrement;
      var $308=(($307)|0)!=0;
      if ($308) { __label__ = 67; break; } else { __label__ = 68; break; }
    case 67: 
      var $310=$bincrement;
      $tmpblock=$310;
      __label__ = 75; break;
    case 68: 
      var $312=$bpostcond;
      var $313=(($312)|0)!=0;
      if ($313) { __label__ = 69; break; } else { __label__ = 70; break; }
    case 69: 
      var $315=$bpostcond;
      $tmpblock=$315;
      __label__ = 74; break;
    case 70: 
      var $317=$bprecond;
      var $318=(($317)|0)!=0;
      if ($318) { __label__ = 71; break; } else { __label__ = 72; break; }
    case 71: 
      var $320=$bprecond;
      $tmpblock=$320;
      __label__ = 73; break;
    case 72: 
      var $322=$bout;
      $tmpblock=$322;
      __label__ = 73; break;
    case 73: 
      __label__ = 74; break;
    case 74: 
      __label__ = 75; break;
    case 75: 
      var $326=$end_bbody;
      var $327=(($326+12)|0);
      var $328=HEAP8[($327)];
      var $329=(($328) & 1);
      if ($329) { __label__ = 78; break; } else { __label__ = 76; break; }
    case 76: 
      var $331=$end_bbody;
      var $332=$tmpblock;
      var $333=_ir_block_create_jump($331, $332);
      if ($333) { __label__ = 78; break; } else { __label__ = 77; break; }
    case 77: 
      $1=0;
      __label__ = 109; break;
    case 78: 
      __label__ = 79; break;
    case 79: 
      var $337=$bincrement;
      var $338=(($337)|0)!=0;
      if ($338) { __label__ = 80; break; } else { __label__ = 92; break; }
    case 80: 
      var $340=$bpostcond;
      var $341=(($340)|0)!=0;
      if ($341) { __label__ = 81; break; } else { __label__ = 82; break; }
    case 81: 
      var $343=$bpostcond;
      $tmpblock=$343;
      __label__ = 89; break;
    case 82: 
      var $345=$bprecond;
      var $346=(($345)|0)!=0;
      if ($346) { __label__ = 83; break; } else { __label__ = 84; break; }
    case 83: 
      var $348=$bprecond;
      $tmpblock=$348;
      __label__ = 88; break;
    case 84: 
      var $350=$bbody;
      var $351=(($350)|0)!=0;
      if ($351) { __label__ = 85; break; } else { __label__ = 86; break; }
    case 85: 
      var $353=$bbody;
      $tmpblock=$353;
      __label__ = 87; break;
    case 86: 
      var $355=$bout;
      $tmpblock=$355;
      __label__ = 87; break;
    case 87: 
      __label__ = 88; break;
    case 88: 
      __label__ = 89; break;
    case 89: 
      var $359=$end_bincrement;
      var $360=$tmpblock;
      var $361=_ir_block_create_jump($359, $360);
      if ($361) { __label__ = 91; break; } else { __label__ = 90; break; }
    case 90: 
      $1=0;
      __label__ = 109; break;
    case 91: 
      __label__ = 92; break;
    case 92: 
      var $365=$bpostcond;
      var $366=(($365)|0)!=0;
      if ($366) { __label__ = 93; break; } else { __label__ = 105; break; }
    case 93: 
      var $368=$bprecond;
      var $369=(($368)|0)!=0;
      if ($369) { __label__ = 94; break; } else { __label__ = 95; break; }
    case 94: 
      var $371=$bprecond;
      $ontrue1=$371;
      __label__ = 102; break;
    case 95: 
      var $373=$bbody;
      var $374=(($373)|0)!=0;
      if ($374) { __label__ = 96; break; } else { __label__ = 97; break; }
    case 96: 
      var $376=$bbody;
      $ontrue1=$376;
      __label__ = 101; break;
    case 97: 
      var $378=$bincrement;
      var $379=(($378)|0)!=0;
      if ($379) { __label__ = 98; break; } else { __label__ = 99; break; }
    case 98: 
      var $381=$bincrement;
      $ontrue1=$381;
      __label__ = 100; break;
    case 99: 
      var $383=$bpostcond;
      $ontrue1=$383;
      __label__ = 100; break;
    case 100: 
      __label__ = 101; break;
    case 101: 
      __label__ = 102; break;
    case 102: 
      var $387=$bout;
      $onfalse2=$387;
      var $388=$end_bpostcond;
      var $389=HEAP32[(($postcond)>>2)];
      var $390=$ontrue1;
      var $391=$onfalse2;
      var $392=_ir_block_create_if($388, $389, $390, $391);
      if ($392) { __label__ = 104; break; } else { __label__ = 103; break; }
    case 103: 
      $1=0;
      __label__ = 109; break;
    case 104: 
      __label__ = 105; break;
    case 105: 
      var $396=$3;
      var $397=(($396+32)|0);
      var $398=HEAP32[(($397)>>2)];
      var $399=$bout_id;
      var $400=_ir_function_blocks_remove($398, $399);
      if ($400) { __label__ = 106; break; } else { __label__ = 107; break; }
    case 106: 
      var $402=$3;
      var $403=(($402+32)|0);
      var $404=HEAP32[(($403)>>2)];
      var $405=$bout;
      var $406=_ir_function_blocks_add($404, $405);
      if ($406) { __label__ = 108; break; } else { __label__ = 107; break; }
    case 107: 
      var $408=$bout;
      _ir_block_delete($408);
      $1=0;
      __label__ = 109; break;
    case 108: 
      $1=1;
      __label__ = 109; break;
    case 109: 
      var $411=$1;
      STACKTOP = __stackBase__;
      return $411;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_loop_codegen["X"]=1;

function _ast_call_new($ctx_0, $ctx_1, $funcexpr) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $self;
      var $3=(($ctx)|0);
      HEAP32[(($3)>>2)]=$ctx_0;
      var $4=(($ctx+4)|0);
      HEAP32[(($4)>>2)]=$ctx_1;
      $2=$funcexpr;
      var $5=_util_memory_a(72, 644, ((STRING_TABLE.__str)|0));
      var $6=$5;
      $self=$6;
      var $7=$self;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $11=$self;
      var $12=$11;
      var $13=(($ctx)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($ctx+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _ast_node_init($12, $14, $16, 12);
      var $17=$self;
      var $18=$17;
      var $19=$18;
      var $20=(($19+8)|0);
      HEAP32[(($20)>>2)]=(42);
      var $21=$self;
      var $22=$21;
      _ast_expression_init($22, (52));
      var $23=$self;
      var $24=(($23+60)|0);
      HEAP32[(($24)>>2)]=0;
      var $25=$self;
      var $26=(($25+64)|0);
      HEAP32[(($26)>>2)]=0;
      var $27=$self;
      var $28=(($27+68)|0);
      HEAP32[(($28)>>2)]=0;
      var $29=$2;
      var $30=$self;
      var $31=(($30+56)|0);
      HEAP32[(($31)>>2)]=$29;
      var $32=$2;
      var $33=$32;
      var $34=(($33+28)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$35;
      var $37=(($36+24)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=$self;
      var $40=(($39)|0);
      var $41=(($40+24)|0);
      HEAP32[(($41)>>2)]=$38;
      var $42=$2;
      var $43=$42;
      var $44=(($43+28)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$45;
      var $47=(($46+28)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48)|0)!=0;
      if ($49) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $51=$2;
      var $52=$51;
      var $53=(($52+28)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=$54;
      var $56=(($55+28)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=(($ctx)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=(($ctx+4)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=_ast_type_copy($59, $61, $57);
      var $63=$self;
      var $64=(($63)|0);
      var $65=(($64+28)|0);
      HEAP32[(($65)>>2)]=$62;
      __label__ = 6; break;
    case 6: 
      var $67=$self;
      $1=$67;
      __label__ = 7; break;
    case 7: 
      var $69=$1;
      STACKTOP = __stackBase__;
      return $69;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_call_new["X"]=1;

function _ast_call_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=$1;
      var $5=(($4+64)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($3)>>>0) < (($6)>>>0);
      if ($7) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $10=$i;
      var $11=$1;
      var $12=(($11+60)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$15;
      var $17=$16;
      var $18=(($17+16)|0);
      var $19=HEAP8[($18)];
      var $20=(($19) & 1);
      if ($20) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $22=$i;
      var $23=$1;
      var $24=(($23+60)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+($22<<2))|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$27;
      var $29=$28;
      var $30=(($29+8)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=$i;
      var $33=$1;
      var $34=(($33+60)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+($32<<2))|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      FUNCTION_TABLE[$31]($38);
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $42=$i;
      var $43=((($42)+(1))|0);
      $i=$43;
      __label__ = 3; break;
    case 10: 
      var $45=$1;
      var $46=(($45+60)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($47)|0)!=0;
      if ($48) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $50=$1;
      var $51=(($50+60)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=$52;
      _util_memory_d($53, 664, ((STRING_TABLE.__str)|0));
      __label__ = 12; break;
    case 12: 
      var $55=$1;
      var $56=(($55+60)|0);
      HEAP32[(($56)>>2)]=0;
      var $57=$1;
      var $58=(($57+64)|0);
      HEAP32[(($58)>>2)]=0;
      var $59=$1;
      var $60=(($59+68)|0);
      HEAP32[(($60)>>2)]=0;
      var $61=$1;
      var $62=(($61+56)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63)|0)!=0;
      if ($64) { __label__ = 13; break; } else { __label__ = 18; break; }
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $67=$1;
      var $68=(($67+56)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=$69;
      var $71=$70;
      var $72=(($71+16)|0);
      var $73=HEAP8[($72)];
      var $74=(($73) & 1);
      if ($74) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $76=$1;
      var $77=(($76+56)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$78;
      var $80=$79;
      var $81=(($80+8)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=$1;
      var $84=(($83+56)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=$85;
      FUNCTION_TABLE[$82]($86);
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $90=$1;
      var $91=$90;
      _ast_expression_delete($91);
      var $92=$1;
      var $93=$92;
      _util_memory_d($93, 670, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_call_delete["X"]=1;

function _ast_call_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 20; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $params=__stackBase__;
      var $callinstr;
      var $i;
      var $funval=(__stackBase__)+(12);
      var $param=(__stackBase__)+(16);
      var $expr;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      HEAP32[(($funval)>>2)]=0;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str40)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 34; break;
    case 4: 
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $24=$2;
      var $25=(($24)|0);
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$5;
      HEAP32[(($28)>>2)]=$27;
      $1=1;
      __label__ = 34; break;
    case 6: 
      var $30=$2;
      var $31=(($30+56)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$32;
      var $34=(($33+20)|0);
      var $35=HEAP32[(($34)>>2)];
      $cgen=$35;
      var $36=$cgen;
      var $37=$2;
      var $38=(($37+56)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$3;
      var $41=FUNCTION_TABLE[$36]($39, $40, 0, $funval);
      if ($41) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 34; break;
    case 8: 
      var $44=HEAP32[(($funval)>>2)];
      var $45=(($44)|0)!=0;
      if ($45) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 34; break;
    case 10: 
      var $48=(($params)|0);
      HEAP32[(($48)>>2)]=0;
      var $49=(($params+4)|0);
      HEAP32[(($49)>>2)]=0;
      var $50=(($params+8)|0);
      HEAP32[(($50)>>2)]=0;
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $52=$i;
      var $53=$2;
      var $54=(($53+64)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=(($52)>>>0) < (($55)>>>0);
      if ($56) { __label__ = 12; break; } else { __label__ = 20; break; }
    case 12: 
      var $58=$i;
      var $59=$2;
      var $60=(($59+60)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($61+($58<<2))|0);
      var $63=HEAP32[(($62)>>2)];
      $expr=$63;
      var $64=$expr;
      var $65=$64;
      var $66=(($65+20)|0);
      var $67=HEAP32[(($66)>>2)];
      $cgen=$67;
      var $68=$cgen;
      var $69=$expr;
      var $70=$3;
      var $71=FUNCTION_TABLE[$68]($69, $70, 0, $param);
      if ($71) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      __label__ = 31; break;
    case 14: 
      var $74=HEAP32[(($param)>>2)];
      var $75=(($74)|0)!=0;
      if ($75) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      __label__ = 31; break;
    case 16: 
      var $78=HEAP32[(($param)>>2)];
      var $79=_ir_value_vector_v_add($params, $78);
      if ($79) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      __label__ = 31; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      var $83=$i;
      var $84=((($83)+(1))|0);
      $i=$84;
      __label__ = 11; break;
    case 20: 
      var $86=$3;
      var $87=(($86+36)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=$3;
      var $90=_ast_function_label($89, ((STRING_TABLE.__str41)|0));
      var $91=HEAP32[(($funval)>>2)];
      var $92=_ir_block_create_call($88, $90, $91);
      $callinstr=$92;
      var $93=$callinstr;
      var $94=(($93)|0)!=0;
      if ($94) { __label__ = 22; break; } else { __label__ = 21; break; }
    case 21: 
      __label__ = 31; break;
    case 22: 
      $i=0;
      __label__ = 23; break;
    case 23: 
      var $98=$i;
      var $99=(($params+4)|0);
      var $100=HEAP32[(($99)>>2)];
      var $101=(($98)>>>0) < (($100)>>>0);
      if ($101) { __label__ = 24; break; } else { __label__ = 28; break; }
    case 24: 
      var $103=$callinstr;
      var $104=$i;
      var $105=(($params)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=(($106+($104<<2))|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=_ir_call_param($103, $108);
      if ($109) { __label__ = 26; break; } else { __label__ = 25; break; }
    case 25: 
      __label__ = 31; break;
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $113=$i;
      var $114=((($113)+(1))|0);
      $i=$114;
      __label__ = 23; break;
    case 28: 
      var $116=$callinstr;
      var $117=_ir_call_value($116);
      var $118=$5;
      HEAP32[(($118)>>2)]=$117;
      var $119=$5;
      var $120=HEAP32[(($119)>>2)];
      var $121=$2;
      var $122=(($121)|0);
      var $123=(($122+52)|0);
      HEAP32[(($123)>>2)]=$120;
      var $124=(($params)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=(($125)|0)!=0;
      if ($126) { __label__ = 29; break; } else { __label__ = 30; break; }
    case 29: 
      var $128=(($params)|0);
      var $129=HEAP32[(($128)>>2)];
      var $130=$129;
      _util_memory_d($130, 1892, ((STRING_TABLE.__str)|0));
      __label__ = 30; break;
    case 30: 
      var $132=(($params)|0);
      HEAP32[(($132)>>2)]=0;
      var $133=(($params+4)|0);
      HEAP32[(($133)>>2)]=0;
      var $134=(($params+8)|0);
      HEAP32[(($134)>>2)]=0;
      $1=1;
      __label__ = 34; break;
    case 31: 
      var $136=(($params)|0);
      var $137=HEAP32[(($136)>>2)];
      var $138=(($137)|0)!=0;
      if ($138) { __label__ = 32; break; } else { __label__ = 33; break; }
    case 32: 
      var $140=(($params)|0);
      var $141=HEAP32[(($140)>>2)];
      var $142=$141;
      _util_memory_d($142, 1895, ((STRING_TABLE.__str)|0));
      __label__ = 33; break;
    case 33: 
      var $144=(($params)|0);
      HEAP32[(($144)>>2)]=0;
      var $145=(($params+4)|0);
      HEAP32[(($145)>>2)]=0;
      var $146=(($params+8)|0);
      HEAP32[(($146)>>2)]=0;
      $1=0;
      __label__ = 34; break;
    case 34: 
      var $148=$1;
      STACKTOP = __stackBase__;
      return $148;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_call_codegen["X"]=1;

function _ast_call_params_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+64)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+68)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+68)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+68)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+68)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+68)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 657, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+60)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+64)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+60)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 657, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+60)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+64)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+60)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_call_params_add["X"]=1;

function _ast_call_check_types($self) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      var $retval;
      var $func;
      var $count;
      $1=$self;
      $retval=1;
      var $2=$1;
      var $3=(($2+56)|0);
      var $4=HEAP32[(($3)>>2)];
      $func=$4;
      var $5=$1;
      var $6=(($5+64)|0);
      var $7=HEAP32[(($6)>>2)];
      $count=$7;
      var $8=$count;
      var $9=$func;
      var $10=$9;
      var $11=(($10+36)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($8)>>>0) > (($12)>>>0);
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$func;
      var $16=$15;
      var $17=(($16+36)|0);
      var $18=HEAP32[(($17)>>2)];
      $count=$18;
      __label__ = 4; break;
    case 4: 
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $21=$i;
      var $22=$count;
      var $23=(($21)>>>0) < (($22)>>>0);
      if ($23) { __label__ = 6; break; } else { __label__ = 10; break; }
    case 6: 
      var $25=$i;
      var $26=$1;
      var $27=(($26+60)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28+($25<<2))|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=$i;
      var $32=$func;
      var $33=$32;
      var $34=(($33+32)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+($31<<2))|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=_ast_compare_type($30, $38);
      if ($39) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $41=$1;
      var $42=$41;
      var $43=(($42)|0);
      var $44=$i;
      var $45=((($44)+(1))|0);
      var $46=(($43)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($43+4)|0);
      var $49=HEAP32[(($48)>>2)];
      _asterror($47, $49, ((STRING_TABLE.__str3)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$45,tempInt));
      $retval=0;
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $52=$i;
      var $53=((($52)+(1))|0);
      $i=$53;
      __label__ = 5; break;
    case 10: 
      var $55=$retval;
      var $56=(($55) & 1);
      STACKTOP = __stackBase__;
      return $56;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_call_check_types["X"]=1;

function _ast_store_new($ctx_0, $ctx_1, $op, $dest, $source) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $4;
      var $self;
      var $5=(($ctx)|0);
      HEAP32[(($5)>>2)]=$ctx_0;
      var $6=(($ctx+4)|0);
      HEAP32[(($6)>>2)]=$ctx_1;
      $2=$op;
      $3=$dest;
      $4=$source;
      var $7=_util_memory_a(68, 696, ((STRING_TABLE.__str)|0));
      var $8=$7;
      $self=$8;
      var $9=$self;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 10; break;
    case 4: 
      var $13=$self;
      var $14=$13;
      var $15=(($ctx)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($ctx+4)|0);
      var $18=HEAP32[(($17)>>2)];
      _ast_node_init($14, $16, $18, 6);
      var $19=$self;
      var $20=$19;
      var $21=$20;
      var $22=(($21+8)|0);
      HEAP32[(($22)>>2)]=(26);
      var $23=$self;
      var $24=$23;
      _ast_expression_init($24, (48));
      var $25=$2;
      var $26=$self;
      var $27=(($26+56)|0);
      HEAP32[(($27)>>2)]=$25;
      var $28=$3;
      var $29=$self;
      var $30=(($29+60)|0);
      HEAP32[(($30)>>2)]=$28;
      var $31=$4;
      var $32=$self;
      var $33=(($32+64)|0);
      HEAP32[(($33)>>2)]=$31;
      var $34=$3;
      var $35=$34;
      var $36=(($35+24)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$self;
      var $39=(($38)|0);
      var $40=(($39+24)|0);
      HEAP32[(($40)>>2)]=$37;
      var $41=$3;
      var $42=$41;
      var $43=(($42+28)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($44)|0)!=0;
      if ($45) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $47=$3;
      var $48=(($ctx)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($ctx+4)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=_ast_type_copy($49, $51, $47);
      var $53=$self;
      var $54=(($53)|0);
      var $55=(($54+28)|0);
      HEAP32[(($55)>>2)]=$52;
      var $56=$self;
      var $57=(($56)|0);
      var $58=(($57+28)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $62=$self;
      var $63=$62;
      var $64=$63;
      var $65=(($64+8)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=$self;
      var $68=$67;
      FUNCTION_TABLE[$66]($68);
      $1=0;
      __label__ = 10; break;
    case 7: 
      __label__ = 9; break;
    case 8: 
      var $71=$self;
      var $72=(($71)|0);
      var $73=(($72+28)|0);
      HEAP32[(($73)>>2)]=0;
      __label__ = 9; break;
    case 9: 
      var $75=$self;
      $1=$75;
      __label__ = 10; break;
    case 10: 
      var $77=$1;
      STACKTOP = __stackBase__;
      return $77;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_store_new["X"]=1;

function _ast_store_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      __label__ = 3; break;
    case 3: 
      var $3=$1;
      var $4=(($3+60)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$5;
      var $7=$6;
      var $8=(($7+16)|0);
      var $9=HEAP8[($8)];
      var $10=(($9) & 1);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$1;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$14;
      var $16=$15;
      var $17=(($16+8)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$1;
      var $20=(($19+60)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$18]($22);
      __label__ = 5; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $26=$1;
      var $27=(($26+64)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28;
      var $30=$29;
      var $31=(($30+16)|0);
      var $32=HEAP8[($31)];
      var $33=(($32) & 1);
      if ($33) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $35=$1;
      var $36=(($35+64)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=$38;
      var $40=(($39+8)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$1;
      var $43=(($42+64)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=$44;
      FUNCTION_TABLE[$41]($45);
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=$48;
      _ast_expression_delete($49);
      var $50=$1;
      var $51=$50;
      _util_memory_d($51, 722, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_store_delete["X"]=1;

function _ast_store_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $cgen;
      var $left=__stackBase__;
      var $right=(__stackBase__)+(4);
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+48)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $16=$2;
      var $17=(($16)|0);
      var $18=(($17+48)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$5;
      HEAP32[(($20)>>2)]=$19;
      $1=1;
      __label__ = 18; break;
    case 5: 
      var $22=$4;
      var $23=(($22) & 1);
      if ($23) { __label__ = 8; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$2;
      var $26=(($25)|0);
      var $27=(($26+52)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $31=$2;
      var $32=(($31)|0);
      var $33=(($32+52)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$5;
      HEAP32[(($35)>>2)]=$34;
      $1=1;
      __label__ = 18; break;
    case 8: 
      var $37=$2;
      var $38=(($37+60)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=(($40+20)|0);
      var $42=HEAP32[(($41)>>2)];
      $cgen=$42;
      var $43=$cgen;
      var $44=$2;
      var $45=(($44+60)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$3;
      var $48=FUNCTION_TABLE[$43]($46, $47, 1, $left);
      if ($48) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 18; break;
    case 10: 
      var $51=HEAP32[(($left)>>2)];
      var $52=$2;
      var $53=(($52)|0);
      var $54=(($53+48)|0);
      HEAP32[(($54)>>2)]=$51;
      var $55=$2;
      var $56=(($55+64)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=$57;
      var $59=(($58+20)|0);
      var $60=HEAP32[(($59)>>2)];
      $cgen=$60;
      var $61=$cgen;
      var $62=$2;
      var $63=(($62+64)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=$3;
      var $66=FUNCTION_TABLE[$61]($64, $65, 0, $right);
      if ($66) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 18; break;
    case 12: 
      var $69=$3;
      var $70=(($69+36)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$2;
      var $73=(($72+56)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=HEAP32[(($left)>>2)];
      var $76=HEAP32[(($right)>>2)];
      var $77=_ir_block_create_store_op($71, $74, $75, $76);
      if ($77) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      $1=0;
      __label__ = 18; break;
    case 14: 
      var $80=HEAP32[(($right)>>2)];
      var $81=$2;
      var $82=(($81)|0);
      var $83=(($82+52)|0);
      HEAP32[(($83)>>2)]=$80;
      var $84=$4;
      var $85=(($84) & 1);
      if ($85) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $87=HEAP32[(($left)>>2)];
      var $91 = $87;__label__ = 17; break;
    case 16: 
      var $89=HEAP32[(($right)>>2)];
      var $91 = $89;__label__ = 17; break;
    case 17: 
      var $91;
      var $92=$5;
      HEAP32[(($92)>>2)]=$91;
      $1=1;
      __label__ = 18; break;
    case 18: 
      var $94=$1;
      STACKTOP = __stackBase__;
      return $94;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_store_codegen["X"]=1;

function _ast_block_new($ctx_0, $ctx_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $self;
      var $2=(($ctx)|0);
      HEAP32[(($2)>>2)]=$ctx_0;
      var $3=(($ctx+4)|0);
      HEAP32[(($3)>>2)]=$ctx_1;
      var $4=_util_memory_a(92, 727, ((STRING_TABLE.__str)|0));
      var $5=$4;
      $self=$5;
      var $6=$self;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $10=$self;
      var $11=$10;
      var $12=(($ctx)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($ctx+4)|0);
      var $15=HEAP32[(($14)>>2)];
      _ast_node_init($11, $13, $15, 4);
      var $16=$self;
      var $17=$16;
      var $18=$17;
      var $19=(($18+8)|0);
      HEAP32[(($19)>>2)]=(54);
      var $20=$self;
      var $21=$20;
      _ast_expression_init($21, (56));
      var $22=$self;
      var $23=(($22+56)|0);
      HEAP32[(($23)>>2)]=0;
      var $24=$self;
      var $25=(($24+60)|0);
      HEAP32[(($25)>>2)]=0;
      var $26=$self;
      var $27=(($26+64)|0);
      HEAP32[(($27)>>2)]=0;
      var $28=$self;
      var $29=(($28+68)|0);
      HEAP32[(($29)>>2)]=0;
      var $30=$self;
      var $31=(($30+72)|0);
      HEAP32[(($31)>>2)]=0;
      var $32=$self;
      var $33=(($32+76)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$self;
      var $35=(($34+80)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$self;
      var $37=(($36+84)|0);
      HEAP32[(($37)>>2)]=0;
      var $38=$self;
      var $39=(($38+88)|0);
      HEAP32[(($39)>>2)]=0;
      var $40=$self;
      $1=$40;
      __label__ = 5; break;
    case 5: 
      var $42=$1;
      STACKTOP = __stackBase__;
      return $42;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_new["X"]=1;

function _ast_block_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=$1;
      var $5=(($4+72)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($3)>>>0) < (($6)>>>0);
      if ($7) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $10=$i;
      var $11=$1;
      var $12=(($11+68)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$15;
      var $17=$16;
      var $18=(($17+16)|0);
      var $19=HEAP8[($18)];
      var $20=(($19) & 1);
      if ($20) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $22=$i;
      var $23=$1;
      var $24=(($23+68)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+($22<<2))|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$27;
      var $29=$28;
      var $30=(($29+8)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=$i;
      var $33=$1;
      var $34=(($33+68)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+($32<<2))|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      FUNCTION_TABLE[$31]($38);
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $42=$i;
      var $43=((($42)+(1))|0);
      $i=$43;
      __label__ = 3; break;
    case 10: 
      var $45=$1;
      var $46=(($45+68)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($47)|0)!=0;
      if ($48) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $50=$1;
      var $51=(($50+68)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=$52;
      _util_memory_d($53, 754, ((STRING_TABLE.__str)|0));
      __label__ = 12; break;
    case 12: 
      var $55=$1;
      var $56=(($55+68)|0);
      HEAP32[(($56)>>2)]=0;
      var $57=$1;
      var $58=(($57+72)|0);
      HEAP32[(($58)>>2)]=0;
      var $59=$1;
      var $60=(($59+76)|0);
      HEAP32[(($60)>>2)]=0;
      $i=0;
      __label__ = 13; break;
    case 13: 
      var $62=$i;
      var $63=$1;
      var $64=(($63+60)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($62)>>>0) < (($65)>>>0);
      if ($66) { __label__ = 14; break; } else { __label__ = 16; break; }
    case 14: 
      var $68=$i;
      var $69=$1;
      var $70=(($69+56)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=(($71+($68<<2))|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=$73;
      var $75=$74;
      var $76=(($75+8)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=$i;
      var $79=$1;
      var $80=(($79+56)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81+($78<<2))|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=$83;
      FUNCTION_TABLE[$77]($84);
      __label__ = 15; break;
    case 15: 
      var $86=$i;
      var $87=((($86)+(1))|0);
      $i=$87;
      __label__ = 13; break;
    case 16: 
      var $89=$1;
      var $90=(($89+56)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($91)|0)!=0;
      if ($92) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      var $94=$1;
      var $95=(($94+56)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=$96;
      _util_memory_d($97, 757, ((STRING_TABLE.__str)|0));
      __label__ = 18; break;
    case 18: 
      var $99=$1;
      var $100=(($99+56)|0);
      HEAP32[(($100)>>2)]=0;
      var $101=$1;
      var $102=(($101+60)|0);
      HEAP32[(($102)>>2)]=0;
      var $103=$1;
      var $104=(($103+64)|0);
      HEAP32[(($104)>>2)]=0;
      $i=0;
      __label__ = 19; break;
    case 19: 
      var $106=$i;
      var $107=$1;
      var $108=(($107+84)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=(($106)>>>0) < (($109)>>>0);
      if ($110) { __label__ = 20; break; } else { __label__ = 22; break; }
    case 20: 
      var $112=$i;
      var $113=$1;
      var $114=(($113+80)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=(($115+($112<<2))|0);
      var $117=HEAP32[(($116)>>2)];
      var $118=$117;
      var $119=$118;
      var $120=(($119+8)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=$i;
      var $123=$1;
      var $124=(($123+80)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=(($125+($122<<2))|0);
      var $127=HEAP32[(($126)>>2)];
      var $128=$127;
      FUNCTION_TABLE[$121]($128);
      __label__ = 21; break;
    case 21: 
      var $130=$i;
      var $131=((($130)+(1))|0);
      $i=$131;
      __label__ = 19; break;
    case 22: 
      var $133=$1;
      var $134=(($133+80)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=(($135)|0)!=0;
      if ($136) { __label__ = 23; break; } else { __label__ = 24; break; }
    case 23: 
      var $138=$1;
      var $139=(($138+80)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=$140;
      _util_memory_d($141, 760, ((STRING_TABLE.__str)|0));
      __label__ = 24; break;
    case 24: 
      var $143=$1;
      var $144=(($143+80)|0);
      HEAP32[(($144)>>2)]=0;
      var $145=$1;
      var $146=(($145+84)|0);
      HEAP32[(($146)>>2)]=0;
      var $147=$1;
      var $148=(($147+88)|0);
      HEAP32[(($148)>>2)]=0;
      var $149=$1;
      var $150=$149;
      _ast_expression_delete($150);
      var $151=$1;
      var $152=$151;
      _util_memory_d($152, 762, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_delete["X"]=1;

function _ast_block_codegen($self, $func, $lvalue, $out) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $i;
      var $gen;
      $2=$self;
      $3=$func;
      var $6=(($lvalue)&1);
      $4=$6;
      $5=$out;
      var $7=$4;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str13)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 21; break;
    case 4: 
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $24=$2;
      var $25=(($24)|0);
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$5;
      HEAP32[(($28)>>2)]=$27;
      $1=1;
      __label__ = 21; break;
    case 6: 
      var $30=$5;
      HEAP32[(($30)>>2)]=0;
      $i=0;
      __label__ = 7; break;
    case 7: 
      var $32=$i;
      var $33=$2;
      var $34=(($33+60)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($32)>>>0) < (($35)>>>0);
      if ($36) { __label__ = 8; break; } else { __label__ = 14; break; }
    case 8: 
      var $38=$i;
      var $39=$2;
      var $40=(($39+56)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=(($41+($38<<2))|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=$3;
      var $45=(($44+32)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=_ast_local_codegen($43, $46, 0);
      if ($47) { __label__ = 12; break; } else { __label__ = 9; break; }
    case 9: 
      var $49=HEAP8[(_opts_debug)];
      var $50=(($49) & 1);
      if ($50) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $52=$2;
      var $53=$52;
      var $54=(($53)|0);
      var $55=$i;
      var $56=$2;
      var $57=(($56+56)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58+($55<<2))|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+56)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($54)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($54+4)|0);
      var $66=HEAP32[(($65)>>2)];
      _asterror($64, $66, ((STRING_TABLE.__str14)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$62,tempInt));
      __label__ = 11; break;
    case 11: 
      $1=0;
      __label__ = 21; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $70=$i;
      var $71=((($70)+(1))|0);
      $i=$71;
      __label__ = 7; break;
    case 14: 
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $74=$i;
      var $75=$2;
      var $76=(($75+72)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=(($74)>>>0) < (($77)>>>0);
      if ($78) { __label__ = 16; break; } else { __label__ = 20; break; }
    case 16: 
      var $80=$i;
      var $81=$2;
      var $82=(($81+68)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=(($83+($80<<2))|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=$85;
      var $87=(($86+20)|0);
      var $88=HEAP32[(($87)>>2)];
      $gen=$88;
      var $89=$gen;
      var $90=$i;
      var $91=$2;
      var $92=(($91+68)|0);
      var $93=HEAP32[(($92)>>2)];
      var $94=(($93+($90<<2))|0);
      var $95=HEAP32[(($94)>>2)];
      var $96=$3;
      var $97=$5;
      var $98=FUNCTION_TABLE[$89]($95, $96, 0, $97);
      if ($98) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 21; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      var $102=$i;
      var $103=((($102)+(1))|0);
      $i=$103;
      __label__ = 15; break;
    case 20: 
      var $105=$5;
      var $106=HEAP32[(($105)>>2)];
      var $107=$2;
      var $108=(($107)|0);
      var $109=(($108+52)|0);
      HEAP32[(($109)>>2)]=$106;
      $1=1;
      __label__ = 21; break;
    case 21: 
      var $111=$1;
      STACKTOP = __stackBase__;
      return $111;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_codegen["X"]=1;

function _ast_block_locals_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+60)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+64)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+64)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+64)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+64)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+64)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 737, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+56)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+60)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+56)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 737, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+56)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+60)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+56)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_locals_add["X"]=1;

function _ast_block_exprs_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+72)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+76)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+76)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+76)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+76)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+76)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 738, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+68)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+72)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+68)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 738, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+68)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+72)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+68)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_exprs_add["X"]=1;

function _ast_block_collect_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+84)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+88)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+88)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+88)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+88)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+88)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 739, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+80)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+84)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+80)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 739, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+80)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+84)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+80)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_collect_add["X"]=1;

function _ast_block_collect($self, $expr) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$expr;
      var $4=$2;
      var $5=$3;
      var $6=_ast_block_collect_add($4, $5);
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $9=$3;
      var $10=$9;
      var $11=(($10)|0);
      var $12=(($11+16)|0);
      HEAP8[($12)]=1;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $14=$1;
      ;
      return $14;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ast_block_set_type($self, $from) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$from;
      var $4=$2;
      var $5=(($4)|0);
      var $6=(($5+28)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $10=$2;
      var $11=(($10)|0);
      var $12=(($11+28)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$13;
      var $15=$14;
      var $16=(($15+8)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$2;
      var $19=(($18)|0);
      var $20=(($19+28)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21;
      FUNCTION_TABLE[$17]($22);
      __label__ = 4; break;
    case 4: 
      var $24=$3;
      var $25=$24;
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$2;
      var $29=(($28)|0);
      var $30=(($29+24)|0);
      HEAP32[(($30)>>2)]=$27;
      var $31=$3;
      var $32=$31;
      var $33=(($32+28)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($34)|0)!=0;
      if ($35) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $37=$2;
      var $38=(($37)|0);
      var $39=(($38)|0);
      var $40=(($39)|0);
      var $41=$3;
      var $42=$41;
      var $43=(($42+28)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($40)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($40+4)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=_ast_type_copy($46, $48, $44);
      var $50=$2;
      var $51=(($50)|0);
      var $52=(($51+28)|0);
      HEAP32[(($52)>>2)]=$49;
      var $53=$2;
      var $54=(($53)|0);
      var $55=(($54+28)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56)|0)!=0;
      if ($57) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      $1=0;
      __label__ = 10; break;
    case 7: 
      __label__ = 9; break;
    case 8: 
      var $61=$2;
      var $62=(($61)|0);
      var $63=(($62+28)|0);
      HEAP32[(($63)>>2)]=0;
      __label__ = 9; break;
    case 9: 
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $66=$1;
      ;
      return $66;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_block_set_type["X"]=1;

function _ast_function_new($ctx_0, $ctx_1, $name, $vtype) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $self;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$name;
      $3=$vtype;
      var $6=_util_memory_a(128, 782, ((STRING_TABLE.__str)|0));
      var $7=$6;
      $self=$7;
      var $8=$self;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 12; break;
    case 4: 
      var $12=$self;
      var $13=$12;
      var $14=(($ctx)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($ctx+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _ast_node_init($13, $15, $17, 3);
      var $18=$self;
      var $19=$18;
      var $20=$19;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=(32);
      var $22=$3;
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 5: 
      var $25=$3;
      var $26=(($25+60)|0);
      var $27=HEAP8[($26)];
      var $28=(($27) & 1);
      if ($28) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $30=$3;
      var $31=(($30)|0);
      var $32=(($31+24)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33)|0)!=6;
      if ($34) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $36=$self;
      var $37=$36;
      _util_memory_d($37, 788, ((STRING_TABLE.__str)|0));
      $1=0;
      __label__ = 12; break;
    case 8: 
      var $39=$3;
      var $40=$self;
      var $41=(($40+20)|0);
      HEAP32[(($41)>>2)]=$39;
      var $42=$2;
      var $43=(($42)|0)!=0;
      if ($43) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $45=$2;
      var $46=_util_strdup($45);
      var $49 = $46;__label__ = 11; break;
    case 10: 
      var $49 = 0;__label__ = 11; break;
    case 11: 
      var $49;
      var $50=$self;
      var $51=(($50+24)|0);
      HEAP32[(($51)>>2)]=$49;
      var $52=$self;
      var $53=(($52+116)|0);
      HEAP32[(($53)>>2)]=0;
      var $54=$self;
      var $55=(($54+120)|0);
      HEAP32[(($55)>>2)]=0;
      var $56=$self;
      var $57=(($56+124)|0);
      HEAP32[(($57)>>2)]=0;
      var $58=$self;
      var $59=(($58+48)|0);
      HEAP32[(($59)>>2)]=0;
      var $60=$self;
      var $61=(($60+28)|0);
      HEAP32[(($61)>>2)]=0;
      var $62=$self;
      var $63=(($62+32)|0);
      HEAP32[(($63)>>2)]=0;
      var $64=$self;
      var $65=(($64+36)|0);
      HEAP32[(($65)>>2)]=0;
      var $66=$self;
      var $67=(($66+40)|0);
      HEAP32[(($67)>>2)]=0;
      var $68=$self;
      var $69=(($68+44)|0);
      HEAP32[(($69)>>2)]=0;
      var $70=$3;
      var $71=(($70+60)|0);
      HEAP8[($71)]=1;
      var $72=$self;
      var $73=$3;
      var $74=(($73+64)|0);
      var $75=$74;
      HEAP32[(($75)>>2)]=$72;
      var $76=$self;
      $1=$76;
      __label__ = 12; break;
    case 12: 
      var $78=$1;
      STACKTOP = __stackBase__;
      return $78;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_function_new["X"]=1;

function _ast_function_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2+24)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7+24)|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 817, ((STRING_TABLE.__str)|0));
      __label__ = 4; break;
    case 4: 
      var $11=$1;
      var $12=(($11+20)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 5; break; } else { __label__ = 10; break; }
    case 5: 
      var $16=$1;
      var $17=(($16+20)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18+60)|0);
      HEAP8[($19)]=0;
      var $20=$1;
      var $21=(($20+20)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22+64)|0);
      var $24=$23;
      HEAP32[(($24)>>2)]=0;
      __label__ = 6; break;
    case 6: 
      var $26=$1;
      var $27=(($26+20)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$28;
      var $30=$29;
      var $31=(($30+16)|0);
      var $32=HEAP8[($31)];
      var $33=(($32) & 1);
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $35=$1;
      var $36=(($35+20)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$37;
      var $39=$38;
      var $40=(($39+8)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$1;
      var $43=(($42+20)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=$44;
      FUNCTION_TABLE[$41]($45);
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $50=$i;
      var $51=$1;
      var $52=(($51+120)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($50)>>>0) < (($53)>>>0);
      if ($54) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $56=$i;
      var $57=$1;
      var $58=(($57+116)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=(($59+($56<<2))|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=$61;
      var $63=$62;
      var $64=(($63+8)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=$i;
      var $67=$1;
      var $68=(($67+116)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=(($69+($66<<2))|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$71;
      FUNCTION_TABLE[$65]($72);
      __label__ = 13; break;
    case 13: 
      var $74=$i;
      var $75=((($74)+(1))|0);
      $i=$75;
      __label__ = 11; break;
    case 14: 
      var $77=$1;
      var $78=(($77+116)|0);
      var $79=HEAP32[(($78)>>2)];
      var $80=(($79)|0)!=0;
      if ($80) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $82=$1;
      var $83=(($82+116)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=$84;
      _util_memory_d($85, 829, ((STRING_TABLE.__str)|0));
      __label__ = 16; break;
    case 16: 
      var $87=$1;
      var $88=(($87+116)|0);
      HEAP32[(($88)>>2)]=0;
      var $89=$1;
      var $90=(($89+120)|0);
      HEAP32[(($90)>>2)]=0;
      var $91=$1;
      var $92=(($91+124)|0);
      HEAP32[(($92)>>2)]=0;
      var $93=$1;
      var $94=$93;
      _util_memory_d($94, 830, ((STRING_TABLE.__str)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_function_delete["X"]=1;

function _ast_function_blocks_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+120)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+124)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+124)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+124)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+124)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+124)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 811, ((STRING_TABLE.__str)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+116)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+120)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+116)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 811, ((STRING_TABLE.__str)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+116)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+120)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+116)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_function_blocks_add["X"]=1;

function _ast_function_label($self, $prefix) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $id;
      var $len;
      var $from;
      var $digit;
      $2=$self;
      $3=$prefix;
      var $4=HEAP8[(_opts_dump)];
      var $5=(($4) & 1);
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $8=$2;
      var $9=(($8+48)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=((($10)+(1))|0);
      HEAP32[(($9)>>2)]=$11;
      $id=$10;
      var $12=$3;
      var $13=_strlen($12);
      $len=$13;
      var $14=$2;
      var $15=(($14+52)|0);
      var $16=(($15)|0);
      var $17=(($16+64)|0);
      var $18=((($17)-(1))|0);
      $from=$18;
      var $19=$from;
      var $20=((($19)-(1))|0);
      $from=$20;
      HEAP8[($19)]=0;
      __label__ = 5; break;
    case 5: 
      var $22=$id;
      var $23=((($22)>>>0))%(10);
      $digit=$23;
      var $24=$digit;
      var $25=((($24)+(48))|0);
      var $26=(($25) & 255);
      var $27=$from;
      HEAP8[($27)]=$26;
      var $28=$id;
      var $29=Math.floor(((($28)>>>0))/(10));
      $id=$29;
      __label__ = 6; break;
    case 6: 
      var $31=$id;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 7: 
      var $34=$from;
      var $35=$len;
      var $36=(((-$35))|0);
      var $37=(($34+$36)|0);
      var $38=$3;
      var $39=$len;
      assert($39 % 1 === 0, 'memcpy given ' + $39 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $38, $39, 1);
      var $40=$from;
      var $41=$len;
      var $42=(((-$41))|0);
      var $43=(($40+$42)|0);
      $1=$43;
      __label__ = 8; break;
    case 8: 
      var $45=$1;
      ;
      return $45;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_function_label["X"]=1;

function _ast_global_codegen($self, $ir) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $v;
      var $func;
      $2=$self;
      $3=$ir;
      $v=0;
      var $4=$2;
      var $5=(($4+60)|0);
      var $6=HEAP8[($5)];
      var $7=(($6) & 1);
      if ($7) { __label__ = 3; break; } else { __label__ = 7; break; }
    case 3: 
      var $9=$2;
      var $10=(($9)|0);
      var $11=(($10+24)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)==6;
      if ($13) { __label__ = 4; break; } else { __label__ = 7; break; }
    case 4: 
      var $15=$3;
      var $16=$2;
      var $17=(($16+56)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$2;
      var $20=(($19)|0);
      var $21=(($20+28)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=$22;
      var $24=(($23+24)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=_ir_builder_create_function($15, $18, $25);
      $func=$26;
      var $27=$func;
      var $28=(($27)|0)!=0;
      if ($28) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 31; break;
    case 6: 
      var $31=$func;
      var $32=(($31+76)|0);
      var $33=$2;
      var $34=$33;
      var $35=(($34)|0);
      var $36=$32;
      var $37=$35;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($36)>>2)]=HEAP32[(($37)>>2)];HEAP32[((($36)+(4))>>2)]=HEAP32[((($37)+(4))>>2)];
      var $38=$func;
      var $39=(($38+36)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40+12)|0);
      var $42=$2;
      var $43=$42;
      var $44=(($43)|0);
      var $45=$41;
      var $46=$44;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($45)>>2)]=HEAP32[(($46)>>2)];HEAP32[((($45)+(4))>>2)]=HEAP32[((($46)+(4))>>2)];
      var $47=$func;
      var $48=$2;
      var $49=(($48+64)|0);
      var $50=$49;
      var $51=HEAP32[(($50)>>2)];
      var $52=(($51+32)|0);
      HEAP32[(($52)>>2)]=$47;
      var $53=$func;
      var $54=(($53+36)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$2;
      var $57=(($56+80)|0);
      HEAP32[(($57)>>2)]=$55;
      $1=1;
      __label__ = 31; break;
    case 7: 
      var $59=$2;
      var $60=(($59)|0);
      var $61=(($60+24)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)==5;
      if ($63) { __label__ = 8; break; } else { __label__ = 13; break; }
    case 8: 
      var $65=$3;
      var $66=$2;
      var $67=(($66+56)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$2;
      var $70=(($69)|0);
      var $71=(($70+28)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=$72;
      var $74=(($73+24)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=_ir_builder_create_field($65, $68, $75);
      $v=$76;
      var $77=$v;
      var $78=(($77)|0)!=0;
      if ($78) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 31; break;
    case 10: 
      var $81=$v;
      var $82=(($81+12)|0);
      var $83=$2;
      var $84=$83;
      var $85=(($84)|0);
      var $86=$82;
      var $87=$85;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($86)>>2)]=HEAP32[(($87)>>2)];HEAP32[((($86)+(4))>>2)]=HEAP32[((($87)+(4))>>2)];
      var $88=$2;
      var $89=(($88+60)|0);
      var $90=HEAP8[($89)];
      var $91=(($90) & 1);
      if ($91) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $93=$2;
      var $94=$93;
      var $95=(($94)|0);
      var $96=(($95)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($95+4)|0);
      var $99=HEAP32[(($98)>>2)];
      _asterror($97, $99, ((STRING_TABLE.__str5)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 30; break;
    case 12: 
      var $101=$v;
      var $102=$2;
      var $103=(($102+80)|0);
      HEAP32[(($103)>>2)]=$101;
      $1=1;
      __label__ = 31; break;
    case 13: 
      var $105=$3;
      var $106=$2;
      var $107=(($106+56)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=$2;
      var $110=(($109)|0);
      var $111=(($110+24)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=_ir_builder_create_global($105, $108, $112);
      $v=$113;
      var $114=$v;
      var $115=(($114)|0)!=0;
      if ($115) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      var $117=$2;
      var $118=$117;
      var $119=(($118)|0);
      var $120=(($119)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=(($119+4)|0);
      var $123=HEAP32[(($122)>>2)];
      _asterror($121, $123, ((STRING_TABLE.__str6)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 31; break;
    case 15: 
      var $125=$v;
      var $126=(($125+12)|0);
      var $127=$2;
      var $128=$127;
      var $129=(($128)|0);
      var $130=$126;
      var $131=$129;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($130)>>2)]=HEAP32[(($131)>>2)];HEAP32[((($130)+(4))>>2)]=HEAP32[((($131)+(4))>>2)];
      var $132=$2;
      var $133=(($132+60)|0);
      var $134=HEAP8[($133)];
      var $135=(($134) & 1);
      if ($135) { __label__ = 16; break; } else { __label__ = 29; break; }
    case 16: 
      var $137=$2;
      var $138=(($137)|0);
      var $139=(($138+24)|0);
      var $140=HEAP32[(($139)>>2)];
      if ((($140)|0) == 2) {
        __label__ = 17; break;
      }
      else if ((($140)|0) == 3) {
        __label__ = 20; break;
      }
      else if ((($140)|0) == 1) {
        __label__ = 23; break;
      }
      else if ((($140)|0) == 6) {
        __label__ = 26; break;
      }
      else {
      __label__ = 27; break;
      }
      
    case 17: 
      var $142=$v;
      var $143=$2;
      var $144=(($143+64)|0);
      var $145=$144;
      var $146=(tempDoubleI32[0]=HEAP32[(($145)>>2)],tempDoubleI32[1]=HEAP32[((($145)+(4))>>2)],tempDoubleF64[0]);
      var $147=$146;
      var $148=_ir_value_set_float($142, $147);
      if ($148) { __label__ = 19; break; } else { __label__ = 18; break; }
    case 18: 
      __label__ = 30; break;
    case 19: 
      __label__ = 28; break;
    case 20: 
      var $152=$v;
      var $153=$2;
      var $154=(($153+64)|0);
      var $155=$154;
      var $156=(($155)|0);
      var $157=HEAPF32[(($156)>>2)];
      var $158=(($155+4)|0);
      var $159=HEAPF32[(($158)>>2)];
      var $160=(($155+8)|0);
      var $161=HEAPF32[(($160)>>2)];
      var $162=_ir_value_set_vector($152, $157, $159, $161);
      if ($162) { __label__ = 22; break; } else { __label__ = 21; break; }
    case 21: 
      __label__ = 30; break;
    case 22: 
      __label__ = 28; break;
    case 23: 
      var $166=$v;
      var $167=$2;
      var $168=(($167+64)|0);
      var $169=$168;
      var $170=HEAP32[(($169)>>2)];
      var $171=_ir_value_set_string($166, $170);
      if ($171) { __label__ = 25; break; } else { __label__ = 24; break; }
    case 24: 
      __label__ = 30; break;
    case 25: 
      __label__ = 28; break;
    case 26: 
      var $175=$2;
      var $176=$175;
      var $177=(($176)|0);
      var $178=(($177)|0);
      var $179=HEAP32[(($178)>>2)];
      var $180=(($177+4)|0);
      var $181=HEAP32[(($180)>>2)];
      _asterror($179, $181, ((STRING_TABLE.__str7)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 30; break;
    case 27: 
      var $183=$2;
      var $184=$183;
      var $185=(($184)|0);
      var $186=$2;
      var $187=(($186)|0);
      var $188=(($187+24)|0);
      var $189=HEAP32[(($188)>>2)];
      var $190=(($185)|0);
      var $191=HEAP32[(($190)>>2)];
      var $192=(($185+4)|0);
      var $193=HEAP32[(($192)>>2)];
      _asterror($191, $193, ((STRING_TABLE.__str8)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$189,tempInt));
      __label__ = 28; break;
    case 28: 
      __label__ = 29; break;
    case 29: 
      var $196=$v;
      var $197=$2;
      var $198=(($197+80)|0);
      HEAP32[(($198)>>2)]=$196;
      $1=1;
      __label__ = 31; break;
    case 30: 
      var $200=$v;
      _ir_value_delete($200);
      $1=0;
      __label__ = 31; break;
    case 31: 
      var $202=$1;
      STACKTOP = __stackBase__;
      return $202;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_global_codegen["X"]=1;

function _ast_local_codegen($self, $func, $param) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $v;
      $2=$self;
      $3=$func;
      var $5=(($param)&1);
      $4=$5;
      $v=0;
      var $6=$2;
      var $7=(($6+60)|0);
      var $8=HEAP8[($7)];
      var $9=(($8) & 1);
      if ($9) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $11=$2;
      var $12=(($11)|0);
      var $13=(($12+24)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)==6;
      if ($15) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      $1=0;
      __label__ = 22; break;
    case 5: 
      var $18=$3;
      var $19=$2;
      var $20=(($19+56)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$2;
      var $23=(($22)|0);
      var $24=(($23+24)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=$4;
      var $27=(($26) & 1);
      var $28=_ir_function_create_local($18, $21, $25, $27);
      $v=$28;
      var $29=$v;
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      $1=0;
      __label__ = 22; break;
    case 7: 
      var $33=$v;
      var $34=(($33+12)|0);
      var $35=$2;
      var $36=$35;
      var $37=(($36)|0);
      var $38=$34;
      var $39=$37;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($38)>>2)]=HEAP32[(($39)>>2)];HEAP32[((($38)+(4))>>2)]=HEAP32[((($39)+(4))>>2)];
      var $40=$2;
      var $41=(($40+60)|0);
      var $42=HEAP8[($41)];
      var $43=(($42) & 1);
      if ($43) { __label__ = 8; break; } else { __label__ = 20; break; }
    case 8: 
      var $45=$2;
      var $46=(($45)|0);
      var $47=(($46+24)|0);
      var $48=HEAP32[(($47)>>2)];
      if ((($48)|0) == 2) {
        __label__ = 9; break;
      }
      else if ((($48)|0) == 3) {
        __label__ = 12; break;
      }
      else if ((($48)|0) == 1) {
        __label__ = 15; break;
      }
      else {
      __label__ = 18; break;
      }
      
    case 9: 
      var $50=$v;
      var $51=$2;
      var $52=(($51+64)|0);
      var $53=$52;
      var $54=(tempDoubleI32[0]=HEAP32[(($53)>>2)],tempDoubleI32[1]=HEAP32[((($53)+(4))>>2)],tempDoubleF64[0]);
      var $55=$54;
      var $56=_ir_value_set_float($50, $55);
      if ($56) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      __label__ = 21; break;
    case 11: 
      __label__ = 19; break;
    case 12: 
      var $60=$v;
      var $61=$2;
      var $62=(($61+64)|0);
      var $63=$62;
      var $64=(($63)|0);
      var $65=HEAPF32[(($64)>>2)];
      var $66=(($63+4)|0);
      var $67=HEAPF32[(($66)>>2)];
      var $68=(($63+8)|0);
      var $69=HEAPF32[(($68)>>2)];
      var $70=_ir_value_set_vector($60, $65, $67, $69);
      if ($70) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      __label__ = 21; break;
    case 14: 
      __label__ = 19; break;
    case 15: 
      var $74=$v;
      var $75=$2;
      var $76=(($75+64)|0);
      var $77=$76;
      var $78=HEAP32[(($77)>>2)];
      var $79=_ir_value_set_string($74, $78);
      if ($79) { __label__ = 17; break; } else { __label__ = 16; break; }
    case 16: 
      __label__ = 21; break;
    case 17: 
      __label__ = 19; break;
    case 18: 
      var $83=$2;
      var $84=$83;
      var $85=(($84)|0);
      var $86=$2;
      var $87=(($86)|0);
      var $88=(($87+24)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($85)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($85+4)|0);
      var $93=HEAP32[(($92)>>2)];
      _asterror($91, $93, ((STRING_TABLE.__str8)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$89,tempInt));
      __label__ = 19; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      var $96=$v;
      var $97=$2;
      var $98=(($97+80)|0);
      HEAP32[(($98)>>2)]=$96;
      $1=1;
      __label__ = 22; break;
    case 21: 
      var $100=$v;
      _ir_value_delete($100);
      $1=0;
      __label__ = 22; break;
    case 22: 
      var $102=$1;
      STACKTOP = __stackBase__;
      return $102;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_local_codegen["X"]=1;

function _code_alloc_field($qcsize) {
  ;
  var __label__;

  var $1;
  var $pos;
  $1=$qcsize;
  var $2=HEAP32[((_code_entfields)>>2)];
  $pos=$2;
  var $3=$1;
  var $4=HEAP32[((_code_entfields)>>2)];
  var $5=((($4)+($3))|0);
  HEAP32[((_code_entfields)>>2)]=$5;
  var $6=$pos;
  ;
  return $6;
}


function _ast_function_codegen($self, $ir) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $irf;
      var $dummy=__stackBase__;
      var $ec;
      var $i;
      var $gen;
      $2=$self;
      $3=$ir;
      var $4=$2;
      var $5=(($4+32)|0);
      var $6=HEAP32[(($5)>>2)];
      $irf=$6;
      var $7=$irf;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $10=$2;
      var $11=$10;
      var $12=(($11)|0);
      var $13=(($12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($12+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _asterror($14, $16, ((STRING_TABLE.__str9)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 29; break;
    case 4: 
      var $18=$2;
      var $19=(($18+20)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20)|0);
      $ec=$21;
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $23=$i;
      var $24=$ec;
      var $25=(($24+36)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($23)>>>0) < (($26)>>>0);
      if ($27) { __label__ = 6; break; } else { __label__ = 14; break; }
    case 6: 
      var $29=$irf;
      var $30=$i;
      var $31=$ec;
      var $32=(($31+32)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33+($30<<2))|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0);
      var $37=(($36+24)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=_ir_function_params_add($29, $38);
      if ($39) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 29; break;
    case 8: 
      var $42=$2;
      var $43=(($42+28)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($44)|0)!=0;
      if ($45) { __label__ = 12; break; } else { __label__ = 9; break; }
    case 9: 
      var $47=$i;
      var $48=$ec;
      var $49=(($48+32)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($50+($47<<2))|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=$2;
      var $54=(($53+32)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=_ast_local_codegen($52, $55, 1);
      if ($56) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 29; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $61=$i;
      var $62=((($61)+(1))|0);
      $i=$62;
      __label__ = 5; break;
    case 14: 
      var $64=$2;
      var $65=(($64+28)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=(($66)|0)!=0;
      if ($67) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $69=$2;
      var $70=(($69+28)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$irf;
      var $73=(($72+32)|0);
      HEAP32[(($73)>>2)]=$71;
      $1=1;
      __label__ = 29; break;
    case 16: 
      var $75=$2;
      var $76=(($75+120)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=(($77)|0)!=0;
      if ($78) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $80=$2;
      var $81=$80;
      var $82=(($81)|0);
      var $83=$2;
      var $84=(($83+24)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=(($82)|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=(($82+4)|0);
      var $89=HEAP32[(($88)>>2)];
      _asterror($87, $89, ((STRING_TABLE.__str10)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$85,tempInt));
      $1=0;
      __label__ = 29; break;
    case 18: 
      var $91=$irf;
      var $92=_ir_function_create_block($91, ((STRING_TABLE.__str11)|0));
      var $93=$2;
      var $94=(($93+36)|0);
      HEAP32[(($94)>>2)]=$92;
      var $95=$2;
      var $96=(($95+36)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($97)|0)!=0;
      if ($98) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      var $100=$2;
      var $101=$100;
      var $102=(($101)|0);
      var $103=$2;
      var $104=(($103+24)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=(($102)|0);
      var $107=HEAP32[(($106)>>2)];
      var $108=(($102+4)|0);
      var $109=HEAP32[(($108)>>2)];
      _asterror($107, $109, ((STRING_TABLE.__str12)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$105,tempInt));
      $1=0;
      __label__ = 29; break;
    case 20: 
      $i=0;
      __label__ = 21; break;
    case 21: 
      var $112=$i;
      var $113=$2;
      var $114=(($113+120)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=(($112)>>>0) < (($115)>>>0);
      if ($116) { __label__ = 22; break; } else { __label__ = 26; break; }
    case 22: 
      var $118=$i;
      var $119=$2;
      var $120=(($119+116)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=(($121+($118<<2))|0);
      var $123=HEAP32[(($122)>>2)];
      var $124=(($123)|0);
      var $125=(($124+20)|0);
      var $126=HEAP32[(($125)>>2)];
      $gen=$126;
      var $127=$gen;
      var $128=$i;
      var $129=$2;
      var $130=(($129+116)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=(($131+($128<<2))|0);
      var $133=HEAP32[(($132)>>2)];
      var $134=$133;
      var $135=$2;
      var $136=FUNCTION_TABLE[$127]($134, $135, 0, $dummy);
      if ($136) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      $1=0;
      __label__ = 29; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $140=$i;
      var $141=((($140)+(1))|0);
      $i=$141;
      __label__ = 21; break;
    case 26: 
      var $143=$2;
      var $144=(($143+36)|0);
      var $145=HEAP32[(($144)>>2)];
      var $146=(($145+68)|0);
      var $147=HEAP8[($146)];
      var $148=(($147) & 1);
      if ($148) { __label__ = 28; break; } else { __label__ = 27; break; }
    case 27: 
      var $150=$2;
      var $151=(($150+36)|0);
      var $152=HEAP32[(($151)>>2)];
      var $153=_ir_block_create_return($152, 0);
      $1=$153;
      __label__ = 29; break;
    case 28: 
      $1=1;
      __label__ = 29; break;
    case 29: 
      var $156=$1;
      STACKTOP = __stackBase__;
      return $156;
    default: assert(0, "bad label: " + __label__);
  }
}
_ast_function_codegen["X"]=1;

function _code_statements_add($element) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $element; $element = STACKTOP;STACKTOP += 8;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");HEAP32[(($element)>>2)]=HEAP32[((tempParam)>>2)];HEAP32[((($element)+(4))>>2)]=HEAP32[(((tempParam)+(4))>>2)];
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $temp;
      $temp=0;
      var $2=HEAP32[((_code_statements_elements)>>2)];
      var $3=HEAP32[((_code_statements_allocated)>>2)];
      var $4=(($2)|0)==(($3)|0);
      if ($4) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $6=HEAP32[((_code_statements_allocated)>>2)];
      var $7=(($6)|0)==0;
      if ($7) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_statements_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $10=HEAP32[((_code_statements_allocated)>>2)];
      var $11=((($10<<1))|0);
      HEAP32[((_code_statements_allocated)>>2)]=$11;
      __label__ = 6; break;
    case 6: 
      var $13=HEAP32[((_code_statements_allocated)>>2)];
      var $14=((($13<<3))|0);
      var $15=_util_memory_a($14, 59, ((STRING_TABLE.__str112)|0));
      $temp=$15;
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $18=$temp;
      _util_memory_d($18, 59, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $20=$temp;
      var $21=HEAP32[((_code_statements_data)>>2)];
      var $22=$21;
      var $23=HEAP32[((_code_statements_elements)>>2)];
      var $24=((($23<<3))|0);
      assert($24 % 1 === 0, 'memcpy given ' + $24 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($20, $22, $24, 1);
      var $25=HEAP32[((_code_statements_data)>>2)];
      var $26=$25;
      _util_memory_d($26, 59, ((STRING_TABLE.__str112)|0));
      var $27=$temp;
      var $28=$27;
      HEAP32[((_code_statements_data)>>2)]=$28;
      __label__ = 9; break;
    case 9: 
      var $30=HEAP32[((_code_statements_elements)>>2)];
      var $31=HEAP32[((_code_statements_data)>>2)];
      var $32=(($31+($30<<3))|0);
      var $33=$32;
      var $34=$element;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP16[(($33)>>1)]=HEAP16[(($34)>>1)];HEAP16[((($33)+(2))>>1)]=HEAP16[((($34)+(2))>>1)];HEAP16[((($33)+(4))>>1)]=HEAP16[((($34)+(4))>>1)];HEAP16[((($33)+(6))>>1)]=HEAP16[((($34)+(6))>>1)];
      var $35=HEAP32[((_code_statements_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_code_statements_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      STACKTOP = __stackBase__;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_statements_add["X"]=1;

function _code_defs_add($element) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $element; $element = STACKTOP;STACKTOP += 8;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");HEAP32[(($element)>>2)]=HEAP32[((tempParam)>>2)];HEAP32[((($element)+(4))>>2)]=HEAP32[(((tempParam)+(4))>>2)];
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $temp;
      $temp=0;
      var $2=HEAP32[((_code_defs_elements)>>2)];
      var $3=HEAP32[((_code_defs_allocated)>>2)];
      var $4=(($2)|0)==(($3)|0);
      if ($4) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $6=HEAP32[((_code_defs_allocated)>>2)];
      var $7=(($6)|0)==0;
      if ($7) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_defs_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $10=HEAP32[((_code_defs_allocated)>>2)];
      var $11=((($10<<1))|0);
      HEAP32[((_code_defs_allocated)>>2)]=$11;
      __label__ = 6; break;
    case 6: 
      var $13=HEAP32[((_code_defs_allocated)>>2)];
      var $14=((($13<<3))|0);
      var $15=_util_memory_a($14, 60, ((STRING_TABLE.__str112)|0));
      $temp=$15;
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $18=$temp;
      _util_memory_d($18, 60, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $20=$temp;
      var $21=HEAP32[((_code_defs_data)>>2)];
      var $22=$21;
      var $23=HEAP32[((_code_defs_elements)>>2)];
      var $24=((($23<<3))|0);
      assert($24 % 1 === 0, 'memcpy given ' + $24 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($20, $22, $24, 1);
      var $25=HEAP32[((_code_defs_data)>>2)];
      var $26=$25;
      _util_memory_d($26, 60, ((STRING_TABLE.__str112)|0));
      var $27=$temp;
      var $28=$27;
      HEAP32[((_code_defs_data)>>2)]=$28;
      __label__ = 9; break;
    case 9: 
      var $30=HEAP32[((_code_defs_elements)>>2)];
      var $31=HEAP32[((_code_defs_data)>>2)];
      var $32=(($31+($30<<3))|0);
      var $33=$32;
      var $34=$element;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($33)>>2)]=HEAP32[(($34)>>2)];HEAP32[((($33)+(4))>>2)]=HEAP32[((($34)+(4))>>2)];
      var $35=HEAP32[((_code_defs_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_code_defs_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      STACKTOP = __stackBase__;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_defs_add["X"]=1;

function _code_fields_add($element) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $element; $element = STACKTOP;STACKTOP += 8;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");HEAP32[(($element)>>2)]=HEAP32[((tempParam)>>2)];HEAP32[((($element)+(4))>>2)]=HEAP32[(((tempParam)+(4))>>2)];
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $temp;
      $temp=0;
      var $2=HEAP32[((_code_fields_elements)>>2)];
      var $3=HEAP32[((_code_fields_allocated)>>2)];
      var $4=(($2)|0)==(($3)|0);
      if ($4) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $6=HEAP32[((_code_fields_allocated)>>2)];
      var $7=(($6)|0)==0;
      if ($7) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_fields_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $10=HEAP32[((_code_fields_allocated)>>2)];
      var $11=((($10<<1))|0);
      HEAP32[((_code_fields_allocated)>>2)]=$11;
      __label__ = 6; break;
    case 6: 
      var $13=HEAP32[((_code_fields_allocated)>>2)];
      var $14=((($13<<3))|0);
      var $15=_util_memory_a($14, 61, ((STRING_TABLE.__str112)|0));
      $temp=$15;
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $18=$temp;
      _util_memory_d($18, 61, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $20=$temp;
      var $21=HEAP32[((_code_fields_data)>>2)];
      var $22=$21;
      var $23=HEAP32[((_code_fields_elements)>>2)];
      var $24=((($23<<3))|0);
      assert($24 % 1 === 0, 'memcpy given ' + $24 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($20, $22, $24, 1);
      var $25=HEAP32[((_code_fields_data)>>2)];
      var $26=$25;
      _util_memory_d($26, 61, ((STRING_TABLE.__str112)|0));
      var $27=$temp;
      var $28=$27;
      HEAP32[((_code_fields_data)>>2)]=$28;
      __label__ = 9; break;
    case 9: 
      var $30=HEAP32[((_code_fields_elements)>>2)];
      var $31=HEAP32[((_code_fields_data)>>2)];
      var $32=(($31+($30<<3))|0);
      var $33=$32;
      var $34=$element;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($33)>>2)]=HEAP32[(($34)>>2)];HEAP32[((($33)+(4))>>2)]=HEAP32[((($34)+(4))>>2)];
      var $35=HEAP32[((_code_fields_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_code_fields_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      STACKTOP = __stackBase__;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_fields_add["X"]=1;

function _code_functions_add($element) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $element; $element = STACKTOP;STACKTOP += 36;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");for (var $$src = tempParam>>2, $$dest = $element>>2, $$stop = $$src + 9; $$src < $$stop; $$src++, $$dest++) {
  HEAP32[$$dest] = HEAP32[$$src]
};
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $temp;
      $temp=0;
      var $2=HEAP32[((_code_functions_elements)>>2)];
      var $3=HEAP32[((_code_functions_allocated)>>2)];
      var $4=(($2)|0)==(($3)|0);
      if ($4) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $6=HEAP32[((_code_functions_allocated)>>2)];
      var $7=(($6)|0)==0;
      if ($7) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_functions_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $10=HEAP32[((_code_functions_allocated)>>2)];
      var $11=((($10<<1))|0);
      HEAP32[((_code_functions_allocated)>>2)]=$11;
      __label__ = 6; break;
    case 6: 
      var $13=HEAP32[((_code_functions_allocated)>>2)];
      var $14=((($13)*(36))|0);
      var $15=_util_memory_a($14, 62, ((STRING_TABLE.__str112)|0));
      $temp=$15;
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $18=$temp;
      _util_memory_d($18, 62, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $20=$temp;
      var $21=HEAP32[((_code_functions_data)>>2)];
      var $22=$21;
      var $23=HEAP32[((_code_functions_elements)>>2)];
      var $24=((($23)*(36))|0);
      assert($24 % 1 === 0, 'memcpy given ' + $24 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($20, $22, $24, 1);
      var $25=HEAP32[((_code_functions_data)>>2)];
      var $26=$25;
      _util_memory_d($26, 62, ((STRING_TABLE.__str112)|0));
      var $27=$temp;
      var $28=$27;
      HEAP32[((_code_functions_data)>>2)]=$28;
      __label__ = 9; break;
    case 9: 
      var $30=HEAP32[((_code_functions_elements)>>2)];
      var $31=HEAP32[((_code_functions_data)>>2)];
      var $32=(($31+($30)*(36))|0);
      var $33=$32;
      var $34=$element;
      assert(36 % 1 === 0, 'memcpy given ' + 36 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');for (var $$src = $34>>2, $$dest = $33>>2, $$stop = $$src + 9; $$src < $$stop; $$src++, $$dest++) {
        HEAP32[$$dest] = HEAP32[$$src]
      };
      var $35=HEAP32[((_code_functions_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_code_functions_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      STACKTOP = __stackBase__;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_functions_add["X"]=1;

function _code_globals_add($element) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $temp;
      $2=$element;
      $temp=0;
      var $3=HEAP32[((_code_globals_elements)>>2)];
      var $4=HEAP32[((_code_globals_allocated)>>2)];
      var $5=(($3)|0)==(($4)|0);
      if ($5) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $7=HEAP32[((_code_globals_allocated)>>2)];
      var $8=(($7)|0)==0;
      if ($8) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_globals_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $11=HEAP32[((_code_globals_allocated)>>2)];
      var $12=((($11<<1))|0);
      HEAP32[((_code_globals_allocated)>>2)]=$12;
      __label__ = 6; break;
    case 6: 
      var $14=HEAP32[((_code_globals_allocated)>>2)];
      var $15=((($14<<2))|0);
      var $16=_util_memory_a($15, 63, ((STRING_TABLE.__str112)|0));
      $temp=$16;
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $19=$temp;
      _util_memory_d($19, 63, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $21=$temp;
      var $22=HEAP32[((_code_globals_data)>>2)];
      var $23=$22;
      var $24=HEAP32[((_code_globals_elements)>>2)];
      var $25=((($24<<2))|0);
      assert($25 % 1 === 0, 'memcpy given ' + $25 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($21, $23, $25, 1);
      var $26=HEAP32[((_code_globals_data)>>2)];
      var $27=$26;
      _util_memory_d($27, 63, ((STRING_TABLE.__str112)|0));
      var $28=$temp;
      var $29=$28;
      HEAP32[((_code_globals_data)>>2)]=$29;
      __label__ = 9; break;
    case 9: 
      var $31=$2;
      var $32=HEAP32[((_code_globals_elements)>>2)];
      var $33=HEAP32[((_code_globals_data)>>2)];
      var $34=(($33+($32<<2))|0);
      HEAP32[(($34)>>2)]=$31;
      var $35=HEAP32[((_code_globals_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_code_globals_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      ;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_globals_add["X"]=1;

function _code_chars_add($element) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $temp;
      $2=$element;
      $temp=0;
      var $3=HEAP32[((_code_chars_elements)>>2)];
      var $4=HEAP32[((_code_chars_allocated)>>2)];
      var $5=(($3)|0)==(($4)|0);
      if ($5) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $7=HEAP32[((_code_chars_allocated)>>2)];
      var $8=(($7)|0)==0;
      if ($8) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_code_chars_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $11=HEAP32[((_code_chars_allocated)>>2)];
      var $12=((($11<<1))|0);
      HEAP32[((_code_chars_allocated)>>2)]=$12;
      __label__ = 6; break;
    case 6: 
      var $14=HEAP32[((_code_chars_allocated)>>2)];
      var $15=(($14)|0);
      var $16=_util_memory_a($15, 64, ((STRING_TABLE.__str112)|0));
      $temp=$16;
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $19=$temp;
      _util_memory_d($19, 64, ((STRING_TABLE.__str112)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $21=$temp;
      var $22=HEAP32[((_code_chars_data)>>2)];
      var $23=HEAP32[((_code_chars_elements)>>2)];
      var $24=(($23)|0);
      assert($24 % 1 === 0, 'memcpy given ' + $24 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($21, $22, $24, 1);
      var $25=HEAP32[((_code_chars_data)>>2)];
      _util_memory_d($25, 64, ((STRING_TABLE.__str112)|0));
      var $26=$temp;
      HEAP32[((_code_chars_data)>>2)]=$26;
      __label__ = 9; break;
    case 9: 
      var $28=$2;
      var $29=HEAP32[((_code_chars_elements)>>2)];
      var $30=HEAP32[((_code_chars_data)>>2)];
      var $31=(($30+$29)|0);
      HEAP8[($31)]=$28;
      var $32=HEAP32[((_code_chars_elements)>>2)];
      var $33=((($32)+(1))|0);
      HEAP32[((_code_chars_elements)>>2)]=$33;
      $1=$32;
      __label__ = 10; break;
    case 10: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_chars_add["X"]=1;

function _code_init() {
  var __stackBase__  = STACKTOP; STACKTOP += 52; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $empty_function=__stackBase__;
      var $empty_statement=(__stackBase__)+(36);
      var $empty_def=(__stackBase__)+(44);
      var $i;
      var $1=$empty_function;
      for (var $$dest = $1>>2, $$stop = $$dest + 9; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      var $2=$empty_statement;
      HEAP16[(($2)>>1)]=0; HEAP16[((($2)+(2))>>1)]=0; HEAP16[((($2)+(4))>>1)]=0; HEAP16[((($2)+(6))>>1)]=0;
      var $3=$empty_def;
      HEAP32[(($3)>>2)]=0; HEAP32[((($3)+(4))>>2)]=0;
      $i=0;
      HEAP32[((_code_entfields)>>2)]=0;
      var $4=HEAP32[((((_opts_flags)|0))>>2)];
      var $5=$4 & 4;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      __label__ = 9; break;
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $10=$i;
      var $11=(($10)|0) < 28;
      if ($11) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $13=_code_globals_add(0);
      __label__ = 7; break;
    case 7: 
      var $15=$i;
      var $16=((($15)+(1))|0);
      $i=$16;
      __label__ = 5; break;
    case 8: 
      var $18=_code_chars_add(0);
      var $19=_code_functions_add($empty_function);
      var $20=_code_statements_add($empty_statement);
      var $21=_code_defs_add($empty_def);
      var $22=_code_fields_add($empty_def);
      __label__ = 9; break;
    case 9: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _code_genstring($str) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $off;
      $1=$str;
      var $2=HEAP32[((_code_chars_elements)>>2)];
      $off=$2;
      __label__ = 3; break;
    case 3: 
      var $4=$1;
      var $5=HEAP8[($4)];
      var $6=(($5 << 24) >> 24)!=0;
      if ($6) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $8=$1;
      var $9=HEAP8[($8)];
      var $10=_code_chars_add($9);
      var $11=$1;
      var $12=(($11+1)|0);
      $1=$12;
      __label__ = 3; break;
    case 5: 
      var $14=_code_chars_add(0);
      var $15=$off;
      ;
      return $15;
    default: assert(0, "bad label: " + __label__);
  }
}


function __ast_node_destroy($self) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  $1=$self;
  var $2=HEAP32[((_stderr)>>2)];
  var $3=_fprintf($2, ((STRING_TABLE.__str111)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  _abort();
  throw "Reached an unreachable!"
  STACKTOP = __stackBase__;
  return;
}


function _code_write($filename) {
  var __stackBase__  = STACKTOP; STACKTOP += 60; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $code_header=__stackBase__;
      var $fp;
      var $it;
      var $j;
      $2=$filename;
      $fp=0;
      $it=2;
      var $3=HEAP32[((((_opts_flags)|0))>>2)];
      var $4=$3 & 4;
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      __label__ = 4; break;
    case 4: 
      var $8=(($code_header+8)|0);
      var $9=(($8)|0);
      HEAP32[(($9)>>2)]=60;
      var $10=HEAP32[((_code_statements_elements)>>2)];
      var $11=(($code_header+8)|0);
      var $12=(($11+4)|0);
      HEAP32[(($12)>>2)]=$10;
      var $13=(($code_header+8)|0);
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=HEAP32[((_code_statements_elements)>>2)];
      var $17=((($16<<3))|0);
      var $18=((($15)+($17))|0);
      var $19=(($code_header+16)|0);
      var $20=(($19)|0);
      HEAP32[(($20)>>2)]=$18;
      var $21=HEAP32[((_code_defs_elements)>>2)];
      var $22=(($code_header+16)|0);
      var $23=(($22+4)|0);
      HEAP32[(($23)>>2)]=$21;
      var $24=(($code_header+16)|0);
      var $25=(($24)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=HEAP32[((_code_defs_elements)>>2)];
      var $28=((($27<<3))|0);
      var $29=((($26)+($28))|0);
      var $30=(($code_header+24)|0);
      var $31=(($30)|0);
      HEAP32[(($31)>>2)]=$29;
      var $32=HEAP32[((_code_fields_elements)>>2)];
      var $33=(($code_header+24)|0);
      var $34=(($33+4)|0);
      HEAP32[(($34)>>2)]=$32;
      var $35=(($code_header+24)|0);
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=HEAP32[((_code_fields_elements)>>2)];
      var $39=((($38<<3))|0);
      var $40=((($37)+($39))|0);
      var $41=(($code_header+32)|0);
      var $42=(($41)|0);
      HEAP32[(($42)>>2)]=$40;
      var $43=HEAP32[((_code_functions_elements)>>2)];
      var $44=(($code_header+32)|0);
      var $45=(($44+4)|0);
      HEAP32[(($45)>>2)]=$43;
      var $46=(($code_header+32)|0);
      var $47=(($46)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=HEAP32[((_code_functions_elements)>>2)];
      var $50=((($49)*(36))|0);
      var $51=((($48)+($50))|0);
      var $52=(($code_header+48)|0);
      var $53=(($52)|0);
      HEAP32[(($53)>>2)]=$51;
      var $54=HEAP32[((_code_globals_elements)>>2)];
      var $55=(($code_header+48)|0);
      var $56=(($55+4)|0);
      HEAP32[(($56)>>2)]=$54;
      var $57=(($code_header+48)|0);
      var $58=(($57)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=HEAP32[((_code_globals_elements)>>2)];
      var $61=((($60<<2))|0);
      var $62=((($59)+($61))|0);
      var $63=(($code_header+40)|0);
      var $64=(($63)|0);
      HEAP32[(($64)>>2)]=$62;
      var $65=HEAP32[((_code_chars_elements)>>2)];
      var $66=(($code_header+40)|0);
      var $67=(($66+4)|0);
      HEAP32[(($67)>>2)]=$65;
      var $68=(($code_header)|0);
      HEAP32[(($68)>>2)]=6;
      var $69=HEAP8[(_opts_forcecrc)];
      var $70=(($69) & 1);
      if ($70) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $72=HEAP16[((_opts_forced_crc)>>1)];
      var $73=(($code_header+4)|0);
      HEAP16[(($73)>>1)]=$72;
      __label__ = 7; break;
    case 6: 
      var $75=HEAP16[((_code_crc)>>1)];
      var $76=(($code_header+4)|0);
      HEAP16[(($76)>>1)]=$75;
      __label__ = 7; break;
    case 7: 
      var $78=HEAP32[((_code_entfields)>>2)];
      var $79=(($code_header+56)|0);
      HEAP32[(($79)>>2)]=$78;
      var $80=HEAP32[((((_opts_flags)|0))>>2)];
      var $81=$80 & 2;
      var $82=(($81)|0)!=0;
      if ($82) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str9121)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $84=_code_chars_add(0);
      var $85=_code_chars_add(0);
      var $86=_code_chars_add(0);
      __label__ = 9; break;
    case 9: 
      var $88=$code_header;
      _util_endianswap($88, 1, 60);
      var $89=HEAP32[((_code_statements_data)>>2)];
      var $90=$89;
      var $91=HEAP32[((_code_statements_elements)>>2)];
      _util_endianswap($90, $91, 8);
      var $92=HEAP32[((_code_defs_data)>>2)];
      var $93=$92;
      var $94=HEAP32[((_code_defs_elements)>>2)];
      _util_endianswap($93, $94, 8);
      var $95=HEAP32[((_code_fields_data)>>2)];
      var $96=$95;
      var $97=HEAP32[((_code_fields_elements)>>2)];
      _util_endianswap($96, $97, 8);
      var $98=HEAP32[((_code_functions_data)>>2)];
      var $99=$98;
      var $100=HEAP32[((_code_functions_elements)>>2)];
      _util_endianswap($99, $100, 36);
      var $101=HEAP32[((_code_globals_data)>>2)];
      var $102=$101;
      var $103=HEAP32[((_code_globals_elements)>>2)];
      _util_endianswap($102, $103, 4);
      var $104=$2;
      var $105=_util_fopen($104, ((STRING_TABLE.__str10122)|0));
      $fp=$105;
      var $106=$fp;
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 31; break;
    case 11: 
      var $110=$code_header;
      var $111=$fp;
      var $112=_fwrite($110, 60, 1, $111);
      var $113=1!=(($112)|0);
      if ($113) { __label__ = 18; break; } else { __label__ = 12; break; }
    case 12: 
      var $115=HEAP32[((_code_statements_elements)>>2)];
      var $116=HEAP32[((_code_statements_data)>>2)];
      var $117=$116;
      var $118=HEAP32[((_code_statements_elements)>>2)];
      var $119=$fp;
      var $120=_fwrite($117, 8, $118, $119);
      var $121=(($115)|0)!=(($120)|0);
      if ($121) { __label__ = 18; break; } else { __label__ = 13; break; }
    case 13: 
      var $123=HEAP32[((_code_defs_elements)>>2)];
      var $124=HEAP32[((_code_defs_data)>>2)];
      var $125=$124;
      var $126=HEAP32[((_code_defs_elements)>>2)];
      var $127=$fp;
      var $128=_fwrite($125, 8, $126, $127);
      var $129=(($123)|0)!=(($128)|0);
      if ($129) { __label__ = 18; break; } else { __label__ = 14; break; }
    case 14: 
      var $131=HEAP32[((_code_fields_elements)>>2)];
      var $132=HEAP32[((_code_fields_data)>>2)];
      var $133=$132;
      var $134=HEAP32[((_code_fields_elements)>>2)];
      var $135=$fp;
      var $136=_fwrite($133, 8, $134, $135);
      var $137=(($131)|0)!=(($136)|0);
      if ($137) { __label__ = 18; break; } else { __label__ = 15; break; }
    case 15: 
      var $139=HEAP32[((_code_functions_elements)>>2)];
      var $140=HEAP32[((_code_functions_data)>>2)];
      var $141=$140;
      var $142=HEAP32[((_code_functions_elements)>>2)];
      var $143=$fp;
      var $144=_fwrite($141, 36, $142, $143);
      var $145=(($139)|0)!=(($144)|0);
      if ($145) { __label__ = 18; break; } else { __label__ = 16; break; }
    case 16: 
      var $147=HEAP32[((_code_globals_elements)>>2)];
      var $148=HEAP32[((_code_globals_data)>>2)];
      var $149=$148;
      var $150=HEAP32[((_code_globals_elements)>>2)];
      var $151=$fp;
      var $152=_fwrite($149, 4, $150, $151);
      var $153=(($147)|0)!=(($152)|0);
      if ($153) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $155=HEAP32[((_code_chars_elements)>>2)];
      var $156=HEAP32[((_code_chars_data)>>2)];
      var $157=HEAP32[((_code_chars_elements)>>2)];
      var $158=$fp;
      var $159=_fwrite($156, 1, $157, $158);
      var $160=(($155)|0)!=(($159)|0);
      if ($160) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      var $162=$fp;
      var $163=_fclose($162);
      $1=0;
      __label__ = 31; break;
    case 19: 
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str11123)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $165=(($code_header)|0);
      var $166=HEAP32[(($165)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str12124)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$166,tempInt));
      var $167=(($code_header+4)|0);
      var $168=HEAP16[(($167)>>1)];
      var $169=(($168)&65535);
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str13125)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$169,tempInt));
      var $170=(($code_header+56)|0);
      var $171=HEAP32[(($170)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str14126)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$171,tempInt));
      var $172=(($code_header+8)|0);
      var $173=(($172)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=(($code_header+8)|0);
      var $176=(($175+4)|0);
      var $177=HEAP32[(($176)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str15127)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$174,HEAP32[(((tempInt)+(4))>>2)]=$177,tempInt));
      var $178=(($code_header+16)|0);
      var $179=(($178)|0);
      var $180=HEAP32[(($179)>>2)];
      var $181=(($code_header+16)|0);
      var $182=(($181+4)|0);
      var $183=HEAP32[(($182)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str16128)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$180,HEAP32[(((tempInt)+(4))>>2)]=$183,tempInt));
      var $184=(($code_header+24)|0);
      var $185=(($184)|0);
      var $186=HEAP32[(($185)>>2)];
      var $187=(($code_header+24)|0);
      var $188=(($187+4)|0);
      var $189=HEAP32[(($188)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str17129)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$186,HEAP32[(((tempInt)+(4))>>2)]=$189,tempInt));
      var $190=(($code_header+32)|0);
      var $191=(($190)|0);
      var $192=HEAP32[(($191)>>2)];
      var $193=(($code_header+32)|0);
      var $194=(($193+4)|0);
      var $195=HEAP32[(($194)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str18130)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$192,HEAP32[(((tempInt)+(4))>>2)]=$195,tempInt));
      var $196=(($code_header+48)|0);
      var $197=(($196)|0);
      var $198=HEAP32[(($197)>>2)];
      var $199=(($code_header+48)|0);
      var $200=(($199+4)|0);
      var $201=HEAP32[(($200)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str19131)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$198,HEAP32[(((tempInt)+(4))>>2)]=$201,tempInt));
      var $202=(($code_header+40)|0);
      var $203=(($202)|0);
      var $204=HEAP32[(($203)>>2)];
      var $205=(($code_header+40)|0);
      var $206=(($205+4)|0);
      var $207=HEAP32[(($206)>>2)];
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str20132)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$204,HEAP32[(((tempInt)+(4))>>2)]=$207,tempInt));
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str21133)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 20; break;
    case 20: 
      var $209=$it;
      var $210=HEAP32[((_code_functions_elements)>>2)];
      var $211=(($209)>>>0) < (($210)>>>0);
      if ($211) { __label__ = 21; break; } else { __label__ = 30; break; }
    case 21: 
      var $213=$it;
      var $214=HEAP32[((_code_functions_data)>>2)];
      var $215=(($214+($213)*(36))|0);
      var $216=(($215)|0);
      var $217=HEAP32[(($216)>>2)];
      $j=$217;
      var $218=$it;
      var $219=HEAP32[((_code_functions_data)>>2)];
      var $220=(($219+($218)*(36))|0);
      var $221=(($220)|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=$it;
      var $224=HEAP32[((_code_functions_data)>>2)];
      var $225=(($224+($223)*(36))|0);
      var $226=(($225+4)|0);
      var $227=HEAP32[(($226)>>2)];
      var $228=$it;
      var $229=HEAP32[((_code_functions_data)>>2)];
      var $230=(($229+($228)*(36))|0);
      var $231=(($230+8)|0);
      var $232=HEAP32[(($231)>>2)];
      var $233=$it;
      var $234=HEAP32[((_code_functions_data)>>2)];
      var $235=(($234+($233)*(36))|0);
      var $236=(($235+12)|0);
      var $237=HEAP32[(($236)>>2)];
      var $238=$it;
      var $239=HEAP32[((_code_functions_data)>>2)];
      var $240=(($239+($238)*(36))|0);
      var $241=(($240+16)|0);
      var $242=HEAP32[(($241)>>2)];
      var $243=$it;
      var $244=HEAP32[((_code_functions_data)>>2)];
      var $245=(($244+($243)*(36))|0);
      var $246=(($245+20)|0);
      var $247=HEAP32[(($246)>>2)];
      var $248=$it;
      var $249=HEAP32[((_code_functions_data)>>2)];
      var $250=(($249+($248)*(36))|0);
      var $251=(($250+24)|0);
      var $252=HEAP32[(($251)>>2)];
      var $253=$it;
      var $254=HEAP32[((_code_functions_data)>>2)];
      var $255=(($254+($253)*(36))|0);
      var $256=(($255+28)|0);
      var $257=(($256)|0);
      var $258=HEAP8[($257)];
      var $259=(($258)&255);
      var $260=$it;
      var $261=HEAP32[((_code_functions_data)>>2)];
      var $262=(($261+($260)*(36))|0);
      var $263=(($262+28)|0);
      var $264=(($263+1)|0);
      var $265=HEAP8[($264)];
      var $266=(($265)&255);
      var $267=$it;
      var $268=HEAP32[((_code_functions_data)>>2)];
      var $269=(($268+($267)*(36))|0);
      var $270=(($269+28)|0);
      var $271=(($270+2)|0);
      var $272=HEAP8[($271)];
      var $273=(($272)&255);
      var $274=$it;
      var $275=HEAP32[((_code_functions_data)>>2)];
      var $276=(($275+($274)*(36))|0);
      var $277=(($276+28)|0);
      var $278=(($277+3)|0);
      var $279=HEAP8[($278)];
      var $280=(($279)&255);
      var $281=$it;
      var $282=HEAP32[((_code_functions_data)>>2)];
      var $283=(($282+($281)*(36))|0);
      var $284=(($283+28)|0);
      var $285=(($284+4)|0);
      var $286=HEAP8[($285)];
      var $287=(($286)&255);
      var $288=$it;
      var $289=HEAP32[((_code_functions_data)>>2)];
      var $290=(($289+($288)*(36))|0);
      var $291=(($290+28)|0);
      var $292=(($291+5)|0);
      var $293=HEAP8[($292)];
      var $294=(($293)&255);
      var $295=$it;
      var $296=HEAP32[((_code_functions_data)>>2)];
      var $297=(($296+($295)*(36))|0);
      var $298=(($297+28)|0);
      var $299=(($298+6)|0);
      var $300=HEAP8[($299)];
      var $301=(($300)&255);
      var $302=$it;
      var $303=HEAP32[((_code_functions_data)>>2)];
      var $304=(($303+($302)*(36))|0);
      var $305=(($304+28)|0);
      var $306=(($305+7)|0);
      var $307=HEAP8[($306)];
      var $308=(($307)&255);
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str22134)|0), (tempInt=STACKTOP,STACKTOP += 60,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$222,HEAP32[(((tempInt)+(4))>>2)]=$227,HEAP32[(((tempInt)+(8))>>2)]=$232,HEAP32[(((tempInt)+(12))>>2)]=$237,HEAP32[(((tempInt)+(16))>>2)]=$242,HEAP32[(((tempInt)+(20))>>2)]=$247,HEAP32[(((tempInt)+(24))>>2)]=$252,HEAP32[(((tempInt)+(28))>>2)]=$259,HEAP32[(((tempInt)+(32))>>2)]=$266,HEAP32[(((tempInt)+(36))>>2)]=$273,HEAP32[(((tempInt)+(40))>>2)]=$280,HEAP32[(((tempInt)+(44))>>2)]=$287,HEAP32[(((tempInt)+(48))>>2)]=$294,HEAP32[(((tempInt)+(52))>>2)]=$301,HEAP32[(((tempInt)+(56))>>2)]=$308,tempInt));
      var $309=$it;
      var $310=HEAP32[((_code_functions_data)>>2)];
      var $311=(($310+($309)*(36))|0);
      var $312=(($311+16)|0);
      var $313=HEAP32[(($312)>>2)];
      var $314=HEAP32[((_code_chars_data)>>2)];
      var $315=(($314+$313)|0);
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str23135)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$315,tempInt));
      var $316=$it;
      var $317=HEAP32[((_code_functions_data)>>2)];
      var $318=(($317+($316)*(36))|0);
      var $319=(($318)|0);
      var $320=HEAP32[(($319)>>2)];
      var $321=(($320)|0) >= 0;
      if ($321) { __label__ = 22; break; } else { __label__ = 28; break; }
    case 22: 
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str24136)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 23; break;
    case 23: 
      var $324=$j;
      var $325=HEAP32[((_code_statements_data)>>2)];
      var $326=(($325+($324<<3))|0);
      var $327=(($326)|0);
      var $328=HEAP16[(($327)>>1)];
      var $329=(($328)&65535);
      var $330=(($329)|0)!=66;
      if ($330) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      var $332=$j;
      var $333=HEAP32[((_code_statements_data)>>2)];
      var $334=(($333+($332<<3))|0);
      var $335=(($334)|0);
      var $336=HEAP16[(($335)>>1)];
      var $337=(($336)&65535);
      var $338=((_asm_instr138+($337)*(12))|0);
      var $339=(($338)|0);
      var $340=HEAP32[(($339)>>2)];
      var $341=$j;
      var $342=HEAP32[((_code_statements_data)>>2)];
      var $343=(($342+($341<<3))|0);
      var $344=(($343+2)|0);
      var $345=$344;
      var $346=HEAP16[(($345)>>1)];
      var $347=(($346 << 16) >> 16);
      var $348=$j;
      var $349=HEAP32[((_code_statements_data)>>2)];
      var $350=(($349+($348<<3))|0);
      var $351=(($350+4)|0);
      var $352=$351;
      var $353=HEAP16[(($352)>>1)];
      var $354=(($353 << 16) >> 16);
      var $355=$j;
      var $356=HEAP32[((_code_statements_data)>>2)];
      var $357=(($356+($355<<3))|0);
      var $358=(($357+6)|0);
      var $359=$358;
      var $360=HEAP16[(($359)>>1)];
      var $361=(($360 << 16) >> 16);
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str25137)|0), (tempInt=STACKTOP,STACKTOP += 16,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$340,HEAP32[(((tempInt)+(4))>>2)]=$347,HEAP32[(((tempInt)+(8))>>2)]=$354,HEAP32[(((tempInt)+(12))>>2)]=$361,tempInt));
      __label__ = 26; break;
    case 25: 
      _util_debug(((STRING_TABLE.__str8120)|0), ((STRING_TABLE.__str26139)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 27; break;
    case 26: 
      var $364=$j;
      var $365=((($364)+(1))|0);
      $j=$365;
      __label__ = 23; break;
    case 27: 
      __label__ = 28; break;
    case 28: 
      __label__ = 29; break;
    case 29: 
      var $369=$it;
      var $370=((($369)+(1))|0);
      $it=$370;
      __label__ = 20; break;
    case 30: 
      var $372=HEAP32[((_code_statements_data)>>2)];
      var $373=$372;
      _util_memory_d($373, 283, ((STRING_TABLE.__str112)|0));
      var $374=HEAP32[((_code_defs_data)>>2)];
      var $375=$374;
      _util_memory_d($375, 284, ((STRING_TABLE.__str112)|0));
      var $376=HEAP32[((_code_fields_data)>>2)];
      var $377=$376;
      _util_memory_d($377, 285, ((STRING_TABLE.__str112)|0));
      var $378=HEAP32[((_code_functions_data)>>2)];
      var $379=$378;
      _util_memory_d($379, 286, ((STRING_TABLE.__str112)|0));
      var $380=HEAP32[((_code_globals_data)>>2)];
      var $381=$380;
      _util_memory_d($381, 287, ((STRING_TABLE.__str112)|0));
      var $382=HEAP32[((_code_chars_data)>>2)];
      _util_memory_d($382, 288, ((STRING_TABLE.__str112)|0));
      var $383=$fp;
      var $384=_fclose($383);
      $1=1;
      __label__ = 31; break;
    case 31: 
      var $386=$1;
      STACKTOP = __stackBase__;
      return $386;
    default: assert(0, "bad label: " + __label__);
  }
}
_code_write["X"]=1;

function _vprintmsg($level, $name, $line, $msgtype, $msg, $ap) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  var $2;
  var $3;
  var $4;
  var $5;
  var $6;
  $1=$level;
  $2=$name;
  $3=$line;
  $4=$msgtype;
  $5=$msg;
  $6=$ap;
  var $7=HEAP32[((_stderr)>>2)];
  var $8=$2;
  var $9=$3;
  var $10=$1;
  var $11=((_levelcolor+($10<<2))|0);
  var $12=HEAP32[(($11)>>2)];
  var $13=$4;
  var $14=_fprintf($7, ((STRING_TABLE.__str207)|0), (tempInt=STACKTOP,STACKTOP += 20,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=36,HEAP32[(((tempInt)+(4))>>2)]=$8,HEAP32[(((tempInt)+(8))>>2)]=$9,HEAP32[(((tempInt)+(12))>>2)]=$12,HEAP32[(((tempInt)+(16))>>2)]=$13,tempInt));
  var $15=HEAP32[((_stderr)>>2)];
  var $16=$5;
  var $17=$6;
  var $18=_vfprintf($15, $16, $17);
  var $19=HEAP32[((_stderr)>>2)];
  var $20=_fprintf($19, ((STRING_TABLE.__str1208)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  STACKTOP = __stackBase__;
  return;
}


function _cvprintmsg($ctx_0, $ctx_1, $lvl, $msgtype, $msg, $ap) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $2;
  var $3;
  var $4;
  var $5=(($ctx)|0);
  HEAP32[(($5)>>2)]=$ctx_0;
  var $6=(($ctx+4)|0);
  HEAP32[(($6)>>2)]=$ctx_1;
  $1=$lvl;
  $2=$msgtype;
  $3=$msg;
  $4=$ap;
  var $7=$1;
  var $8=(($ctx)|0);
  var $9=HEAP32[(($8)>>2)];
  var $10=(($ctx+4)|0);
  var $11=HEAP32[(($10)>>2)];
  var $12=$2;
  var $13=$3;
  var $14=$4;
  _vprintmsg($7, $9, $11, $12, $13, $14);
  STACKTOP = __stackBase__;
  return;
}


function _ir_value_vector_v_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+8)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+8)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+8)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+8)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+8)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 142, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+4)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 142, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_vector_v_add["X"]=1;

function _ir_builder_new($modulename) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $self;
      $2=$modulename;
      var $3=_util_memory_a(68, 182, ((STRING_TABLE.__str9222)|0));
      var $4=$3;
      $self=$4;
      var $5=$self;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $9=$self;
      var $10=(($9+4)|0);
      HEAP32[(($10)>>2)]=0;
      var $11=$self;
      var $12=(($11+8)|0);
      HEAP32[(($12)>>2)]=0;
      var $13=$self;
      var $14=(($13+12)|0);
      HEAP32[(($14)>>2)]=0;
      var $15=$self;
      var $16=(($15+16)|0);
      HEAP32[(($16)>>2)]=0;
      var $17=$self;
      var $18=(($17+20)|0);
      HEAP32[(($18)>>2)]=0;
      var $19=$self;
      var $20=(($19+24)|0);
      HEAP32[(($20)>>2)]=0;
      var $21=$self;
      var $22=(($21+28)|0);
      HEAP32[(($22)>>2)]=0;
      var $23=$self;
      var $24=(($23+32)|0);
      HEAP32[(($24)>>2)]=0;
      var $25=$self;
      var $26=(($25+36)|0);
      HEAP32[(($26)>>2)]=0;
      var $27=$self;
      var $28=(($27+40)|0);
      HEAP32[(($28)>>2)]=0;
      var $29=$self;
      var $30=(($29+44)|0);
      HEAP32[(($30)>>2)]=0;
      var $31=$self;
      var $32=(($31+48)|0);
      HEAP32[(($32)>>2)]=0;
      var $33=$self;
      var $34=(($33+52)|0);
      HEAP32[(($34)>>2)]=0;
      var $35=$self;
      var $36=(($35+56)|0);
      HEAP32[(($36)>>2)]=0;
      var $37=$self;
      var $38=(($37+60)|0);
      HEAP32[(($38)>>2)]=0;
      var $39=$self;
      var $40=(($39+64)|0);
      HEAP32[(($40)>>2)]=0;
      var $41=$self;
      var $42=(($41)|0);
      HEAP32[(($42)>>2)]=0;
      var $43=$self;
      var $44=$2;
      var $45=_ir_builder_set_name($43, $44);
      if ($45) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $47=$self;
      var $48=$47;
      _util_memory_d($48, 194, ((STRING_TABLE.__str9222)|0));
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $50=$self;
      $1=$50;
      __label__ = 7; break;
    case 7: 
      var $52=$1;
      ;
      return $52;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_new["X"]=1;

function _ir_builder_set_name($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$name;
      var $3=$1;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      _util_memory_d($10, 231, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$2;
      var $13=_util_strdup($12);
      var $14=$1;
      var $15=(($14)|0);
      HEAP32[(($15)>>2)]=$13;
      var $16=$1;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=$20 ^ 1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_builder_globals_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+20)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+24)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+24)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+24)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+24)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 201, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+16)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+20)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+16)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 201, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+16)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+20)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+16)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_globals_add["X"]=1;

function _ir_builder_fields_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+32)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+36)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+36)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+36)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+36)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+36)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 202, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+28)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+32)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+28)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 202, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+28)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+32)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+28)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_fields_add["X"]=1;

function _ir_builder_functions_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+8)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+12)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+12)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+12)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+12)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 203, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+4)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+8)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+4)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 203, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+4)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+8)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+4)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_functions_add["X"]=1;

function _ir_builder_filenames_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+44)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+48)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+48)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+48)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+48)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+48)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 204, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+40)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+44)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+40)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 204, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+40)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+44)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+40)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_filenames_add["X"]=1;

function _ir_builder_filestrings_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+56)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+60)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+60)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+60)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+60)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 205, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+52)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+56)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+52)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 205, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+52)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+56)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+52)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_filestrings_add["X"]=1;

function _ir_builder_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      _util_memory_d($4, 210, ((STRING_TABLE.__str9222)|0));
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$1;
      var $8=(($7+8)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)!=(($9)|0);
      if ($10) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $12=$i;
      var $13=$1;
      var $14=(($13+4)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      _ir_function_delete_quick($17);
      __label__ = 5; break;
    case 5: 
      var $19=$i;
      var $20=((($19)+(1))|0);
      $i=$20;
      __label__ = 3; break;
    case 6: 
      var $22=$1;
      var $23=(($22+4)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $27=$1;
      var $28=(($27+4)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=$29;
      _util_memory_d($30, 214, ((STRING_TABLE.__str9222)|0));
      __label__ = 8; break;
    case 8: 
      var $32=$1;
      var $33=(($32+4)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$1;
      var $35=(($34+8)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$1;
      var $37=(($36+12)|0);
      HEAP32[(($37)>>2)]=0;
      $i=0;
      __label__ = 9; break;
    case 9: 
      var $39=$i;
      var $40=$1;
      var $41=(($40+20)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=(($39)|0)!=(($42)|0);
      if ($43) { __label__ = 10; break; } else { __label__ = 12; break; }
    case 10: 
      var $45=$i;
      var $46=$1;
      var $47=(($46+16)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48+($45<<2))|0);
      var $50=HEAP32[(($49)>>2)];
      _ir_value_delete($50);
      __label__ = 11; break;
    case 11: 
      var $52=$i;
      var $53=((($52)+(1))|0);
      $i=$53;
      __label__ = 9; break;
    case 12: 
      var $55=$1;
      var $56=(($55+16)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=(($57)|0)!=0;
      if ($58) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $60=$1;
      var $61=(($60+16)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=$62;
      _util_memory_d($63, 218, ((STRING_TABLE.__str9222)|0));
      __label__ = 14; break;
    case 14: 
      var $65=$1;
      var $66=(($65+16)|0);
      HEAP32[(($66)>>2)]=0;
      var $67=$1;
      var $68=(($67+20)|0);
      HEAP32[(($68)>>2)]=0;
      var $69=$1;
      var $70=(($69+24)|0);
      HEAP32[(($70)>>2)]=0;
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $72=$i;
      var $73=$1;
      var $74=(($73+32)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=(($72)|0)!=(($75)|0);
      if ($76) { __label__ = 16; break; } else { __label__ = 18; break; }
    case 16: 
      var $78=$i;
      var $79=$1;
      var $80=(($79+28)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81+($78<<2))|0);
      var $83=HEAP32[(($82)>>2)];
      _ir_value_delete($83);
      __label__ = 17; break;
    case 17: 
      var $85=$i;
      var $86=((($85)+(1))|0);
      $i=$86;
      __label__ = 15; break;
    case 18: 
      var $88=$1;
      var $89=(($88+28)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=(($90)|0)!=0;
      if ($91) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $93=$1;
      var $94=(($93+28)|0);
      var $95=HEAP32[(($94)>>2)];
      var $96=$95;
      _util_memory_d($96, 222, ((STRING_TABLE.__str9222)|0));
      __label__ = 20; break;
    case 20: 
      var $98=$1;
      var $99=(($98+28)|0);
      HEAP32[(($99)>>2)]=0;
      var $100=$1;
      var $101=(($100+32)|0);
      HEAP32[(($101)>>2)]=0;
      var $102=$1;
      var $103=(($102+36)|0);
      HEAP32[(($103)>>2)]=0;
      var $104=$1;
      var $105=(($104+40)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $109=$1;
      var $110=(($109+40)|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=$111;
      _util_memory_d($112, 223, ((STRING_TABLE.__str9222)|0));
      __label__ = 22; break;
    case 22: 
      var $114=$1;
      var $115=(($114+40)|0);
      HEAP32[(($115)>>2)]=0;
      var $116=$1;
      var $117=(($116+44)|0);
      HEAP32[(($117)>>2)]=0;
      var $118=$1;
      var $119=(($118+48)|0);
      HEAP32[(($119)>>2)]=0;
      var $120=$1;
      var $121=(($120+52)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=(($122)|0)!=0;
      if ($123) { __label__ = 23; break; } else { __label__ = 24; break; }
    case 23: 
      var $125=$1;
      var $126=(($125+52)|0);
      var $127=HEAP32[(($126)>>2)];
      var $128=$127;
      _util_memory_d($128, 224, ((STRING_TABLE.__str9222)|0));
      __label__ = 24; break;
    case 24: 
      var $130=$1;
      var $131=(($130+52)|0);
      HEAP32[(($131)>>2)]=0;
      var $132=$1;
      var $133=(($132+56)|0);
      HEAP32[(($133)>>2)]=0;
      var $134=$1;
      var $135=(($134+60)|0);
      HEAP32[(($135)>>2)]=0;
      var $136=$1;
      var $137=$136;
      _util_memory_d($137, 225, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_delete["X"]=1;

function _ir_function_delete_quick($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      _util_memory_d($4, 389, ((STRING_TABLE.__str9222)|0));
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$1;
      var $8=(($7+24)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)!=(($9)|0);
      if ($10) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $12=$i;
      var $13=$1;
      var $14=(($13+20)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      _ir_block_delete_quick($17);
      __label__ = 5; break;
    case 5: 
      var $19=$i;
      var $20=((($19)+(1))|0);
      $i=$20;
      __label__ = 3; break;
    case 6: 
      var $22=$1;
      var $23=(($22+20)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $27=$1;
      var $28=(($27+20)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=$29;
      _util_memory_d($30, 393, ((STRING_TABLE.__str9222)|0));
      __label__ = 8; break;
    case 8: 
      var $32=$1;
      var $33=(($32+20)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$1;
      var $35=(($34+24)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$1;
      var $37=(($36+28)|0);
      HEAP32[(($37)>>2)]=0;
      var $38=$1;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40)|0)!=0;
      if ($41) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $43=$1;
      var $44=(($43+8)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$45;
      _util_memory_d($46, 395, ((STRING_TABLE.__str9222)|0));
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=(($48+8)|0);
      HEAP32[(($49)>>2)]=0;
      var $50=$1;
      var $51=(($50+12)|0);
      HEAP32[(($51)>>2)]=0;
      var $52=$1;
      var $53=(($52+16)|0);
      HEAP32[(($53)>>2)]=0;
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $55=$i;
      var $56=$1;
      var $57=(($56+44)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($55)|0)!=(($58)|0);
      if ($59) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $61=$i;
      var $62=$1;
      var $63=(($62+40)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($64+($61<<2))|0);
      var $66=HEAP32[(($65)>>2)];
      _ir_value_delete($66);
      __label__ = 13; break;
    case 13: 
      var $68=$i;
      var $69=((($68)+(1))|0);
      $i=$69;
      __label__ = 11; break;
    case 14: 
      var $71=$1;
      var $72=(($71+40)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=(($73)|0)!=0;
      if ($74) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $76=$1;
      var $77=(($76+40)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$78;
      _util_memory_d($79, 399, ((STRING_TABLE.__str9222)|0));
      __label__ = 16; break;
    case 16: 
      var $81=$1;
      var $82=(($81+40)|0);
      HEAP32[(($82)>>2)]=0;
      var $83=$1;
      var $84=(($83+44)|0);
      HEAP32[(($84)>>2)]=0;
      var $85=$1;
      var $86=(($85+48)|0);
      HEAP32[(($86)>>2)]=0;
      $i=0;
      __label__ = 17; break;
    case 17: 
      var $88=$i;
      var $89=$1;
      var $90=(($89+56)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($88)|0)!=(($91)|0);
      if ($92) { __label__ = 18; break; } else { __label__ = 20; break; }
    case 18: 
      var $94=$i;
      var $95=$1;
      var $96=(($95+52)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($97+($94<<2))|0);
      var $99=HEAP32[(($98)>>2)];
      _ir_value_delete($99);
      __label__ = 19; break;
    case 19: 
      var $101=$i;
      var $102=((($101)+(1))|0);
      $i=$102;
      __label__ = 17; break;
    case 20: 
      var $104=$1;
      var $105=(($104+52)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $109=$1;
      var $110=(($109+52)|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=$111;
      _util_memory_d($112, 403, ((STRING_TABLE.__str9222)|0));
      __label__ = 22; break;
    case 22: 
      var $114=$1;
      var $115=(($114+52)|0);
      HEAP32[(($115)>>2)]=0;
      var $116=$1;
      var $117=(($116+56)|0);
      HEAP32[(($117)>>2)]=0;
      var $118=$1;
      var $119=(($118+60)|0);
      HEAP32[(($119)>>2)]=0;
      var $120=$1;
      var $121=$120;
      _util_memory_d($121, 407, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_delete_quick["X"]=1;

function _ir_value_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7)|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 785, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $11=$1;
      var $12=(($11+52)|0);
      var $13=HEAP8[($12)];
      var $14=(($13) & 1);
      if ($14) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $16=$1;
      var $17=(($16+4)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)==1;
      if ($19) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $21=$1;
      var $22=(($21+56)|0);
      var $23=$22;
      var $24=HEAP32[(($23)>>2)];
      _util_memory_d($24, 789, ((STRING_TABLE.__str9222)|0));
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      $i=0;
      __label__ = 9; break;
    case 9: 
      var $28=$i;
      var $29=(($28)>>>0) < 3;
      if ($29) { __label__ = 10; break; } else { __label__ = 14; break; }
    case 10: 
      var $31=$i;
      var $32=$1;
      var $33=(($32+84)|0);
      var $34=(($33+($31<<2))|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)!=0;
      if ($36) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $38=$i;
      var $39=$1;
      var $40=(($39+84)|0);
      var $41=(($40+($38<<2))|0);
      var $42=HEAP32[(($41)>>2)];
      _ir_value_delete($42);
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $45=$i;
      var $46=((($45)+(1))|0);
      $i=$46;
      __label__ = 9; break;
    case 14: 
      var $48=$1;
      var $49=(($48+28)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($50)|0)!=0;
      if ($51) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $53=$1;
      var $54=(($53+28)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$55;
      _util_memory_d($56, 795, ((STRING_TABLE.__str9222)|0));
      __label__ = 16; break;
    case 16: 
      var $58=$1;
      var $59=(($58+28)|0);
      HEAP32[(($59)>>2)]=0;
      var $60=$1;
      var $61=(($60+32)|0);
      HEAP32[(($61)>>2)]=0;
      var $62=$1;
      var $63=(($62+36)|0);
      HEAP32[(($63)>>2)]=0;
      var $64=$1;
      var $65=(($64+40)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=(($66)|0)!=0;
      if ($67) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      var $69=$1;
      var $70=(($69+40)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$71;
      _util_memory_d($72, 796, ((STRING_TABLE.__str9222)|0));
      __label__ = 18; break;
    case 18: 
      var $74=$1;
      var $75=(($74+40)|0);
      HEAP32[(($75)>>2)]=0;
      var $76=$1;
      var $77=(($76+44)|0);
      HEAP32[(($77)>>2)]=0;
      var $78=$1;
      var $79=(($78+48)|0);
      HEAP32[(($79)>>2)]=0;
      var $80=$1;
      var $81=(($80+100)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=(($82)|0)!=0;
      if ($83) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $85=$1;
      var $86=(($85+100)|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=$87;
      _util_memory_d($88, 797, ((STRING_TABLE.__str9222)|0));
      __label__ = 20; break;
    case 20: 
      var $90=$1;
      var $91=(($90+100)|0);
      HEAP32[(($91)>>2)]=0;
      var $92=$1;
      var $93=(($92+104)|0);
      HEAP32[(($93)>>2)]=0;
      var $94=$1;
      var $95=(($94+108)|0);
      HEAP32[(($95)>>2)]=0;
      var $96=$1;
      var $97=$96;
      _util_memory_d($97, 798, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_delete["X"]=1;

function _ir_builder_get_function($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$self;
      $3=$name;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+8)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$3;
      var $12=$i;
      var $13=$2;
      var $14=(($13+4)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=_strcmp($11, $19);
      var $21=(($20)|0)!=0;
      if ($21) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $23=$i;
      var $24=$2;
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<2))|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      $1=0;
      __label__ = 9; break;
    case 9: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_builder_create_function($self, $name, $outtype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $fn;
      $2=$self;
      $3=$name;
      $4=$outtype;
      var $5=$2;
      var $6=$3;
      var $7=_ir_builder_get_function($5, $6);
      $fn=$7;
      var $8=$fn;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 10; break;
    case 4: 
      var $12=$2;
      var $13=$4;
      var $14=_ir_function_new($12, $13);
      $fn=$14;
      var $15=$fn;
      var $16=$3;
      var $17=_ir_function_set_name($15, $16);
      if ($17) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $19=$2;
      var $20=$fn;
      var $21=_ir_builder_functions_add($19, $20);
      if ($21) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $23=$fn;
      _ir_function_delete($23);
      $1=0;
      __label__ = 10; break;
    case 7: 
      var $25=$2;
      var $26=$fn;
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=_ir_builder_create_global($25, $28, 6);
      var $30=$fn;
      var $31=(($30+36)|0);
      HEAP32[(($31)>>2)]=$29;
      var $32=$fn;
      var $33=(($32+36)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($34)|0)!=0;
      if ($35) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $37=$fn;
      _ir_function_delete($37);
      $1=0;
      __label__ = 10; break;
    case 9: 
      var $39=$fn;
      var $40=(($39+36)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=(($41+52)|0);
      HEAP8[($42)]=1;
      var $43=$4;
      var $44=$fn;
      var $45=(($44+36)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($46+24)|0);
      HEAP32[(($47)>>2)]=$43;
      var $48=$fn;
      var $49=$fn;
      var $50=(($49+36)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=(($51+56)|0);
      var $53=$52;
      HEAP32[(($53)>>2)]=$48;
      var $54=$fn;
      var $55=(($54+36)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+12)|0);
      var $58=$fn;
      var $59=(($58+76)|0);
      var $60=$57;
      var $61=$59;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($60)>>2)]=HEAP32[(($61)>>2)];HEAP32[((($60)+(4))>>2)]=HEAP32[((($61)+(4))>>2)];
      var $62=$fn;
      $1=$62;
      __label__ = 10; break;
    case 10: 
      var $64=$1;
      ;
      return $64;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_create_function["X"]=1;

function _ir_function_new($owner, $outtype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $self;
      $2=$owner;
      $3=$outtype;
      var $4=_util_memory_a(96, 344, ((STRING_TABLE.__str9222)|0));
      var $5=$4;
      $self=$5;
      var $6=$self;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $10=$self;
      var $11=$10;
      for (var $$dest = $11>>2, $$stop = $$dest + 24; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      var $12=$self;
      var $13=(($12)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=$self;
      var $15=_ir_function_set_name($14, ((STRING_TABLE.__str10223)|0));
      if ($15) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $17=$self;
      var $18=$17;
      _util_memory_d($18, 353, ((STRING_TABLE.__str9222)|0));
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $20=$2;
      var $21=$self;
      var $22=(($21+92)|0);
      HEAP32[(($22)>>2)]=$20;
      var $23=$self;
      var $24=(($23+76)|0);
      var $25=(($24)|0);
      HEAP32[(($25)>>2)]=((STRING_TABLE.__str11224)|0);
      var $26=$self;
      var $27=(($26+76)|0);
      var $28=(($27+4)|0);
      HEAP32[(($28)>>2)]=0;
      var $29=$3;
      var $30=$self;
      var $31=(($30+4)|0);
      HEAP32[(($31)>>2)]=$29;
      var $32=$self;
      var $33=(($32+36)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$self;
      var $35=(($34+32)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$self;
      var $37=(($36+8)|0);
      HEAP32[(($37)>>2)]=0;
      var $38=$self;
      var $39=(($38+12)|0);
      HEAP32[(($39)>>2)]=0;
      var $40=$self;
      var $41=(($40+16)|0);
      HEAP32[(($41)>>2)]=0;
      var $42=$self;
      var $43=(($42+20)|0);
      HEAP32[(($43)>>2)]=0;
      var $44=$self;
      var $45=(($44+24)|0);
      HEAP32[(($45)>>2)]=0;
      var $46=$self;
      var $47=(($46+28)|0);
      HEAP32[(($47)>>2)]=0;
      var $48=$self;
      var $49=(($48+40)|0);
      HEAP32[(($49)>>2)]=0;
      var $50=$self;
      var $51=(($50+44)|0);
      HEAP32[(($51)>>2)]=0;
      var $52=$self;
      var $53=(($52+48)|0);
      HEAP32[(($53)>>2)]=0;
      var $54=$self;
      var $55=(($54+52)|0);
      HEAP32[(($55)>>2)]=0;
      var $56=$self;
      var $57=(($56+56)|0);
      HEAP32[(($57)>>2)]=0;
      var $58=$self;
      var $59=(($58+60)|0);
      HEAP32[(($59)>>2)]=0;
      var $60=$self;
      var $61=(($60+84)|0);
      HEAP32[(($61)>>2)]=-1;
      var $62=$self;
      var $63=(($62+64)|0);
      HEAP32[(($63)>>2)]=0;
      var $64=$self;
      var $65=(($64+88)|0);
      HEAP32[(($65)>>2)]=0;
      var $66=$self;
      $1=$66;
      __label__ = 7; break;
    case 7: 
      var $68=$1;
      ;
      return $68;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_new["X"]=1;

function _ir_function_set_name($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$name;
      var $3=$1;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      _util_memory_d($10, 381, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$2;
      var $13=_util_strdup($12);
      var $14=$1;
      var $15=(($14)|0);
      HEAP32[(($15)>>2)]=$13;
      var $16=$1;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=$20 ^ 1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_function_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      _util_memory_d($4, 413, ((STRING_TABLE.__str9222)|0));
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$1;
      var $8=(($7+24)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)!=(($9)|0);
      if ($10) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $12=$i;
      var $13=$1;
      var $14=(($13+20)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      _ir_block_delete($17);
      __label__ = 5; break;
    case 5: 
      var $19=$i;
      var $20=((($19)+(1))|0);
      $i=$20;
      __label__ = 3; break;
    case 6: 
      var $22=$1;
      var $23=(($22+20)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $27=$1;
      var $28=(($27+20)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=$29;
      _util_memory_d($30, 417, ((STRING_TABLE.__str9222)|0));
      __label__ = 8; break;
    case 8: 
      var $32=$1;
      var $33=(($32+20)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$1;
      var $35=(($34+24)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$1;
      var $37=(($36+28)|0);
      HEAP32[(($37)>>2)]=0;
      var $38=$1;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40)|0)!=0;
      if ($41) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $43=$1;
      var $44=(($43+8)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$45;
      _util_memory_d($46, 419, ((STRING_TABLE.__str9222)|0));
      __label__ = 10; break;
    case 10: 
      var $48=$1;
      var $49=(($48+8)|0);
      HEAP32[(($49)>>2)]=0;
      var $50=$1;
      var $51=(($50+12)|0);
      HEAP32[(($51)>>2)]=0;
      var $52=$1;
      var $53=(($52+16)|0);
      HEAP32[(($53)>>2)]=0;
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $55=$i;
      var $56=$1;
      var $57=(($56+44)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($55)|0)!=(($58)|0);
      if ($59) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $61=$i;
      var $62=$1;
      var $63=(($62+40)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($64+($61<<2))|0);
      var $66=HEAP32[(($65)>>2)];
      _ir_value_delete($66);
      __label__ = 13; break;
    case 13: 
      var $68=$i;
      var $69=((($68)+(1))|0);
      $i=$69;
      __label__ = 11; break;
    case 14: 
      var $71=$1;
      var $72=(($71+40)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=(($73)|0)!=0;
      if ($74) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $76=$1;
      var $77=(($76+40)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$78;
      _util_memory_d($79, 423, ((STRING_TABLE.__str9222)|0));
      __label__ = 16; break;
    case 16: 
      var $81=$1;
      var $82=(($81+40)|0);
      HEAP32[(($82)>>2)]=0;
      var $83=$1;
      var $84=(($83+44)|0);
      HEAP32[(($84)>>2)]=0;
      var $85=$1;
      var $86=(($85+48)|0);
      HEAP32[(($86)>>2)]=0;
      $i=0;
      __label__ = 17; break;
    case 17: 
      var $88=$i;
      var $89=$1;
      var $90=(($89+56)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($88)|0)!=(($91)|0);
      if ($92) { __label__ = 18; break; } else { __label__ = 20; break; }
    case 18: 
      var $94=$i;
      var $95=$1;
      var $96=(($95+52)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($97+($94<<2))|0);
      var $99=HEAP32[(($98)>>2)];
      _ir_value_delete($99);
      __label__ = 19; break;
    case 19: 
      var $101=$i;
      var $102=((($101)+(1))|0);
      $i=$102;
      __label__ = 17; break;
    case 20: 
      var $104=$1;
      var $105=(($104+52)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $109=$1;
      var $110=(($109+52)|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=$111;
      _util_memory_d($112, 427, ((STRING_TABLE.__str9222)|0));
      __label__ = 22; break;
    case 22: 
      var $114=$1;
      var $115=(($114+52)|0);
      HEAP32[(($115)>>2)]=0;
      var $116=$1;
      var $117=(($116+56)|0);
      HEAP32[(($117)>>2)]=0;
      var $118=$1;
      var $119=(($118+60)|0);
      HEAP32[(($119)>>2)]=0;
      var $120=$1;
      var $121=$120;
      _util_memory_d($121, 431, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_delete["X"]=1;

function _ir_builder_create_global($self, $name, $vtype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ve;
      $2=$self;
      $3=$name;
      $4=$vtype;
      var $5=$3;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 7; break; }
    case 3: 
      var $8=$3;
      var $9=(($8)|0);
      var $10=HEAP8[($9)];
      var $11=(($10 << 24) >> 24);
      var $12=(($11)|0)!=35;
      if ($12) { __label__ = 4; break; } else { __label__ = 7; break; }
    case 4: 
      var $14=$2;
      var $15=$3;
      var $16=_ir_builder_get_global($14, $15);
      $ve=$16;
      var $17=$ve;
      var $18=(($17)|0)!=0;
      if ($18) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 10; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $22=$3;
      var $23=$4;
      var $24=_ir_value_var($22, 0, $23);
      $ve=$24;
      var $25=$2;
      var $26=$ve;
      var $27=_ir_builder_globals_add($25, $26);
      if ($27) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $29=$ve;
      _ir_value_delete($29);
      $1=0;
      __label__ = 10; break;
    case 9: 
      var $31=$ve;
      $1=$31;
      __label__ = 10; break;
    case 10: 
      var $33=$1;
      ;
      return $33;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_builder_get_global($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$self;
      $3=$name;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+20)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+16)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<2))|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$3;
      var $20=_strcmp($18, $19);
      var $21=(($20)|0)!=0;
      if ($21) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $23=$i;
      var $24=$2;
      var $25=(($24+16)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<2))|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      $1=0;
      __label__ = 9; break;
    case 9: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_var($name, $storetype, $vtype) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $self;
      $2=$name;
      $3=$storetype;
      $4=$vtype;
      var $5=_util_memory_a(112, 693, ((STRING_TABLE.__str9222)|0));
      var $6=$5;
      $self=$6;
      var $7=$4;
      var $8=$self;
      var $9=(($8+4)|0);
      HEAP32[(($9)>>2)]=$7;
      var $10=$self;
      var $11=(($10+20)|0);
      HEAP32[(($11)>>2)]=0;
      var $12=$self;
      var $13=(($12+24)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=$3;
      var $15=$self;
      var $16=(($15+8)|0);
      HEAP32[(($16)>>2)]=$14;
      var $17=$self;
      var $18=(($17+28)|0);
      HEAP32[(($18)>>2)]=0;
      var $19=$self;
      var $20=(($19+32)|0);
      HEAP32[(($20)>>2)]=0;
      var $21=$self;
      var $22=(($21+36)|0);
      HEAP32[(($22)>>2)]=0;
      var $23=$self;
      var $24=(($23+40)|0);
      HEAP32[(($24)>>2)]=0;
      var $25=$self;
      var $26=(($25+44)|0);
      HEAP32[(($26)>>2)]=0;
      var $27=$self;
      var $28=(($27+48)|0);
      HEAP32[(($28)>>2)]=0;
      var $29=$self;
      var $30=(($29+52)|0);
      HEAP8[($30)]=0;
      var $31=$self;
      var $32=(($31+12)|0);
      var $33=(($32)|0);
      HEAP32[(($33)>>2)]=((STRING_TABLE.__str11224)|0);
      var $34=$self;
      var $35=(($34+12)|0);
      var $36=(($35+4)|0);
      HEAP32[(($36)>>2)]=0;
      var $37=$self;
      var $38=(($37)|0);
      HEAP32[(($38)>>2)]=0;
      var $39=$2;
      var $40=(($39)|0)!=0;
      if ($40) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $42=$self;
      var $43=$2;
      var $44=_ir_value_set_name($42, $43);
      if ($44) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $46=$self;
      var $47=(($46+12)|0);
      var $48=(($47)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($47+4)|0);
      var $51=HEAP32[(($50)>>2)];
      _irerror($49, $51, ((STRING_TABLE.__str13226)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $52=$self;
      var $53=$52;
      _util_memory_d($53, 706, ((STRING_TABLE.__str9222)|0));
      $1=0;
      __label__ = 6; break;
    case 5: 
      var $55=$self;
      var $56=(($55+56)|0);
      var $57=$56;
      HEAP32[(($57)>>2)]=0; HEAP32[((($57)+(4))>>2)]=0; HEAP32[((($57)+(8))>>2)]=0;
      var $58=$self;
      var $59=(($58+68)|0);
      var $60=$59;
      HEAP32[(($60)>>2)]=0; HEAP32[((($60)+(4))>>2)]=0; HEAP32[((($60)+(8))>>2)]=0; HEAP32[((($60)+(12))>>2)]=0;
      var $61=$self;
      var $62=(($61+84)|0);
      var $63=(($62)|0);
      HEAP32[(($63)>>2)]=0;
      var $64=$self;
      var $65=(($64+84)|0);
      var $66=(($65+4)|0);
      HEAP32[(($66)>>2)]=0;
      var $67=$self;
      var $68=(($67+84)|0);
      var $69=(($68+8)|0);
      HEAP32[(($69)>>2)]=0;
      var $70=$self;
      var $71=(($70+96)|0);
      HEAP32[(($71)>>2)]=0;
      var $72=$self;
      var $73=(($72+100)|0);
      HEAP32[(($73)>>2)]=0;
      var $74=$self;
      var $75=(($74+104)|0);
      HEAP32[(($75)>>2)]=0;
      var $76=$self;
      var $77=(($76+108)|0);
      HEAP32[(($77)>>2)]=0;
      var $78=$self;
      $1=$78;
      __label__ = 6; break;
    case 6: 
      var $80=$1;
      STACKTOP = __stackBase__;
      return $80;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_var["X"]=1;

function _ir_builder_get_field($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$self;
      $3=$name;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+32)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+28)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<2))|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=$3;
      var $20=_strcmp($18, $19);
      var $21=(($20)|0)!=0;
      if ($21) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $23=$i;
      var $24=$2;
      var $25=(($24+28)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<2))|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      $1=0;
      __label__ = 9; break;
    case 9: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_builder_create_field($self, $name, $vtype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ve;
      $2=$self;
      $3=$name;
      $4=$vtype;
      var $5=$2;
      var $6=$3;
      var $7=_ir_builder_get_field($5, $6);
      $ve=$7;
      var $8=$ve;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $12=$3;
      var $13=_ir_value_var($12, 0, 5);
      $ve=$13;
      var $14=$4;
      var $15=$ve;
      var $16=(($15+20)|0);
      HEAP32[(($16)>>2)]=$14;
      var $17=$2;
      var $18=$ve;
      var $19=_ir_builder_fields_add($17, $18);
      if ($19) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $21=$ve;
      _ir_value_delete($21);
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $23=$ve;
      $1=$23;
      __label__ = 7; break;
    case 7: 
      var $25=$1;
      ;
      return $25;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_function_values_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+44)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+48)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+48)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+48)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+48)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+48)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 373, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+40)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+44)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+40)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 373, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+40)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+44)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+40)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_values_add["X"]=1;

function _ir_function_blocks_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+24)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+24)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+20)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+20)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+24)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+24)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+24)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+28)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+24)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 374, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+20)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+24)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+20)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 374, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+20)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_blocks_remove["X"]=1;

function _ir_function_blocks_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+24)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+28)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+28)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+28)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+28)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+28)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 374, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+20)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+24)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+20)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 374, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+20)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+24)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+20)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_blocks_add["X"]=1;

function _ir_function_locals_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+56)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+60)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+60)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+60)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+60)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 375, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+52)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+56)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+52)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 375, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+52)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+56)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+52)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_locals_add["X"]=1;

function _ir_function_params_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+12)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+16)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+16)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+16)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+16)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+16)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 376, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+8)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+12)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+8)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 376, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+8)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+12)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+8)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_params_add["X"]=1;

function _ir_block_delete($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7)|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 558, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $12=$i;
      var $13=$1;
      var $14=(($13+20)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($12)|0)!=(($15)|0);
      if ($16) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $18=$i;
      var $19=$1;
      var $20=(($19+16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+($18<<2))|0);
      var $23=HEAP32[(($22)>>2)];
      _ir_instr_delete($23);
      __label__ = 7; break;
    case 7: 
      var $25=$i;
      var $26=((($25)+(1))|0);
      $i=$26;
      __label__ = 5; break;
    case 8: 
      var $28=$1;
      var $29=(($28+16)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $33=$1;
      var $34=(($33+16)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$35;
      _util_memory_d($36, 561, ((STRING_TABLE.__str9222)|0));
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      var $39=(($38+16)|0);
      HEAP32[(($39)>>2)]=0;
      var $40=$1;
      var $41=(($40+20)|0);
      HEAP32[(($41)>>2)]=0;
      var $42=$1;
      var $43=(($42+24)|0);
      HEAP32[(($43)>>2)]=0;
      var $44=$1;
      var $45=(($44+28)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($46)|0)!=0;
      if ($47) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $49=$1;
      var $50=(($49+28)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=$51;
      _util_memory_d($52, 562, ((STRING_TABLE.__str9222)|0));
      __label__ = 12; break;
    case 12: 
      var $54=$1;
      var $55=(($54+28)|0);
      HEAP32[(($55)>>2)]=0;
      var $56=$1;
      var $57=(($56+32)|0);
      HEAP32[(($57)>>2)]=0;
      var $58=$1;
      var $59=(($58+36)|0);
      HEAP32[(($59)>>2)]=0;
      var $60=$1;
      var $61=(($60+40)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)!=0;
      if ($63) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $65=$1;
      var $66=(($65+40)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      _util_memory_d($68, 563, ((STRING_TABLE.__str9222)|0));
      __label__ = 14; break;
    case 14: 
      var $70=$1;
      var $71=(($70+40)|0);
      HEAP32[(($71)>>2)]=0;
      var $72=$1;
      var $73=(($72+44)|0);
      HEAP32[(($73)>>2)]=0;
      var $74=$1;
      var $75=(($74+48)|0);
      HEAP32[(($75)>>2)]=0;
      var $76=$1;
      var $77=(($76+52)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($78)|0)!=0;
      if ($79) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $81=$1;
      var $82=(($81+52)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=$83;
      _util_memory_d($84, 564, ((STRING_TABLE.__str9222)|0));
      __label__ = 16; break;
    case 16: 
      var $86=$1;
      var $87=(($86+52)|0);
      HEAP32[(($87)>>2)]=0;
      var $88=$1;
      var $89=(($88+56)|0);
      HEAP32[(($89)>>2)]=0;
      var $90=$1;
      var $91=(($90+60)|0);
      HEAP32[(($91)>>2)]=0;
      var $92=$1;
      var $93=$92;
      _util_memory_d($93, 565, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_delete["X"]=1;

function _ir_function_collect_value($self, $v) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$self;
  $2=$v;
  var $3=$1;
  var $4=$2;
  var $5=_ir_function_values_add($3, $4);
  ;
  return $5;
}


function _ir_function_create_block($self, $label) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $bn;
      $2=$self;
      $3=$label;
      var $4=$2;
      var $5=$3;
      var $6=_ir_block_new($4, $5);
      $bn=$6;
      var $7=$bn;
      var $8=(($7+4)|0);
      var $9=$8;
      var $10=$2;
      var $11=(($10+76)|0);
      var $12=$11;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($9)>>2)]=HEAP32[(($12)>>2)];HEAP32[((($9)+(4))>>2)]=HEAP32[((($12)+(4))>>2)];
      var $13=$2;
      var $14=$bn;
      var $15=_ir_function_blocks_add($13, $14);
      if ($15) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $17=$bn;
      _ir_block_delete($17);
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $19=$bn;
      $1=$19;
      __label__ = 5; break;
    case 5: 
      var $21=$1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_new($owner, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $self;
      $2=$owner;
      $3=$name;
      var $4=_util_memory_a(88, 509, ((STRING_TABLE.__str9222)|0));
      var $5=$4;
      $self=$5;
      var $6=$self;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $10=$self;
      var $11=$10;
      for (var $$dest = $11>>2, $$stop = $$dest + 22; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      var $12=$self;
      var $13=(($12)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=$3;
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 5: 
      var $17=$self;
      var $18=$3;
      var $19=_ir_block_set_label($17, $18);
      if ($19) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $21=$self;
      var $22=$21;
      _util_memory_d($22, 517, ((STRING_TABLE.__str9222)|0));
      $1=0;
      __label__ = 8; break;
    case 7: 
      var $24=$2;
      var $25=$self;
      var $26=(($25+76)|0);
      HEAP32[(($26)>>2)]=$24;
      var $27=$self;
      var $28=(($27+4)|0);
      var $29=(($28)|0);
      HEAP32[(($29)>>2)]=((STRING_TABLE.__str11224)|0);
      var $30=$self;
      var $31=(($30+4)|0);
      var $32=(($31+4)|0);
      HEAP32[(($32)>>2)]=0;
      var $33=$self;
      var $34=(($33+12)|0);
      HEAP8[($34)]=0;
      var $35=$self;
      var $36=(($35+16)|0);
      HEAP32[(($36)>>2)]=0;
      var $37=$self;
      var $38=(($37+20)|0);
      HEAP32[(($38)>>2)]=0;
      var $39=$self;
      var $40=(($39+24)|0);
      HEAP32[(($40)>>2)]=0;
      var $41=$self;
      var $42=(($41+28)|0);
      HEAP32[(($42)>>2)]=0;
      var $43=$self;
      var $44=(($43+32)|0);
      HEAP32[(($44)>>2)]=0;
      var $45=$self;
      var $46=(($45+36)|0);
      HEAP32[(($46)>>2)]=0;
      var $47=$self;
      var $48=(($47+40)|0);
      HEAP32[(($48)>>2)]=0;
      var $49=$self;
      var $50=(($49+44)|0);
      HEAP32[(($50)>>2)]=0;
      var $51=$self;
      var $52=(($51+48)|0);
      HEAP32[(($52)>>2)]=0;
      var $53=$self;
      var $54=(($53+64)|0);
      HEAP32[(($54)>>2)]=0;
      var $55=$self;
      var $56=(($55+68)|0);
      HEAP8[($56)]=0;
      var $57=$self;
      var $58=(($57+72)|0);
      HEAP32[(($58)>>2)]=0;
      var $59=$self;
      var $60=(($59+52)|0);
      HEAP32[(($60)>>2)]=0;
      var $61=$self;
      var $62=(($61+56)|0);
      HEAP32[(($62)>>2)]=0;
      var $63=$self;
      var $64=(($63+60)|0);
      HEAP32[(($64)>>2)]=0;
      var $65=$self;
      var $66=(($65+80)|0);
      HEAP8[($66)]=0;
      var $67=$self;
      $1=$67;
      __label__ = 8; break;
    case 8: 
      var $69=$1;
      ;
      return $69;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_new["X"]=1;

function _ir_function_finalize($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$self;
      var $3=$2;
      var $4=(($3+32)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 11; break;
    case 4: 
      var $9=$2;
      var $10=_ir_function_naive_phi($9);
      if ($10) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 11; break;
    case 6: 
      var $13=$2;
      _ir_function_enumerate($13);
      var $14=$2;
      var $15=_ir_function_calculate_liferanges($14);
      if ($15) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 11; break;
    case 8: 
      var $18=$2;
      var $19=_ir_function_allocate_locals($18);
      if ($19) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 11; break;
    case 10: 
      $1=1;
      __label__ = 11; break;
    case 11: 
      var $23=$1;
      ;
      return $23;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_function_naive_phi($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      $2=$self;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $4=$i;
      var $5=$2;
      var $6=(($5+24)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) < (($7)>>>0);
      if ($8) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $10=$i;
      var $11=$2;
      var $12=(($11+20)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=_ir_block_naive_phi($15);
      if ($16) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      $i=$21;
      __label__ = 3; break;
    case 8: 
      $1=1;
      __label__ = 9; break;
    case 9: 
      var $24=$1;
      ;
      return $24;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_function_enumerate($self) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      var $instruction_id=__stackBase__;
      $1=$self;
      HEAP32[(($instruction_id)>>2)]=0;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=$1;
      var $5=(($4+24)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($3)>>>0) < (($6)>>>0);
      if ($7) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $9=$i;
      var $10=$i;
      var $11=$1;
      var $12=(($11+20)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+64)|0);
      HEAP32[(($16)>>2)]=$9;
      var $17=$i;
      var $18=$1;
      var $19=(($18+20)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20+($17<<2))|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22+72)|0);
      HEAP32[(($23)>>2)]=0;
      var $24=$i;
      var $25=$1;
      var $26=(($25+20)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27+($24<<2))|0);
      var $29=HEAP32[(($28)>>2)];
      _ir_block_enumerate($29, $instruction_id);
      __label__ = 5; break;
    case 5: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 6: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_function_calculate_liferanges($self) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $changed=__stackBase__;
      var $block;
      var $v;
      $2=$self;
      __label__ = 3; break;
    case 3: 
      var $4=$2;
      var $5=(($4+88)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=((($6)+(1))|0);
      HEAP32[(($5)>>2)]=$7;
      HEAP8[($changed)]=0;
      $i=0;
      __label__ = 4; break;
    case 4: 
      var $9=$i;
      var $10=$2;
      var $11=(($10+24)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($9)|0)!=(($12)|0);
      if ($13) { __label__ = 5; break; } else { __label__ = 11; break; }
    case 5: 
      var $15=$i;
      var $16=$2;
      var $17=(($16+20)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18+($15<<2))|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20+68)|0);
      var $22=HEAP8[($21)];
      var $23=(($22) & 1);
      if ($23) { __label__ = 6; break; } else { __label__ = 9; break; }
    case 6: 
      var $25=$i;
      var $26=$2;
      var $27=(($26+20)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28+($25<<2))|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+56)|0);
      HEAP32[(($31)>>2)]=0;
      var $32=$i;
      var $33=$2;
      var $34=(($33+20)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+($32<<2))|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=_ir_block_life_propagate($37, 0, $changed);
      if ($38) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 25; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $43=$i;
      var $44=((($43)+(1))|0);
      $i=$44;
      __label__ = 4; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $47=HEAP8[($changed)];
      var $48=(($47) & 1);
      if ($48) { __label__ = 3; break; } else { __label__ = 13; break; }
    case 13: 
      var $50=$2;
      var $51=(($50+24)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=(($52)|0)!=0;
      if ($53) { __label__ = 14; break; } else { __label__ = 24; break; }
    case 14: 
      var $55=$2;
      var $56=(($55+20)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=(($57)|0);
      var $59=HEAP32[(($58)>>2)];
      $block=$59;
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $61=$i;
      var $62=$block;
      var $63=(($62+56)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($61)>>>0) < (($64)>>>0);
      if ($65) { __label__ = 16; break; } else { __label__ = 23; break; }
    case 16: 
      var $67=$i;
      var $68=$block;
      var $69=(($68+52)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=(($70+($67<<2))|0);
      var $72=HEAP32[(($71)>>2)];
      $v=$72;
      var $73=$v;
      var $74=(($73+96)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=(($75)|0)!=0;
      if ($76) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $78=$v;
      var $79=(($78+8)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=(($80)|0)!=1;
      if ($81) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      __label__ = 22; break;
    case 19: 
      var $84=$v;
      var $85=(($84+12)|0);
      var $86=$v;
      var $87=(($86)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=(($85)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=(($85+4)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=_irwarning($90, $92, 2, ((STRING_TABLE.__str20234)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$88,tempInt));
      if ($93) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      $1=0;
      __label__ = 25; break;
    case 21: 
      __label__ = 22; break;
    case 22: 
      var $97=$i;
      var $98=((($97)+(1))|0);
      $i=$98;
      __label__ = 15; break;
    case 23: 
      __label__ = 24; break;
    case 24: 
      $1=1;
      __label__ = 25; break;
    case 25: 
      var $102=$1;
      STACKTOP = __stackBase__;
      return $102;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_calculate_liferanges["X"]=1;

function _ir_function_allocate_locals($self) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $a;
      var $retval;
      var $pos;
      var $slot;
      var $v;
      var $alloc=__stackBase__;
      $2=$self;
      $retval=1;
      var $3=$2;
      var $4=(($3+56)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 5; break; } else { __label__ = 3; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+44)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($10)|0)!=0;
      if ($11) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      $1=1;
      __label__ = 61; break;
    case 5: 
      var $14=(($alloc)|0);
      HEAP32[(($14)>>2)]=0;
      var $15=(($alloc+4)|0);
      HEAP32[(($15)>>2)]=0;
      var $16=(($alloc+8)|0);
      HEAP32[(($16)>>2)]=0;
      var $17=(($alloc+12)|0);
      HEAP32[(($17)>>2)]=0;
      var $18=(($alloc+16)|0);
      HEAP32[(($18)>>2)]=0;
      var $19=(($alloc+20)|0);
      HEAP32[(($19)>>2)]=0;
      var $20=(($alloc+24)|0);
      HEAP32[(($20)>>2)]=0;
      var $21=(($alloc+28)|0);
      HEAP32[(($21)>>2)]=0;
      var $22=(($alloc+32)|0);
      HEAP32[(($22)>>2)]=0;
      $i=0;
      __label__ = 6; break;
    case 6: 
      var $24=$i;
      var $25=$2;
      var $26=(($25+56)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($24)>>>0) < (($27)>>>0);
      if ($28) { __label__ = 7; break; } else { __label__ = 11; break; }
    case 7: 
      var $30=$i;
      var $31=$2;
      var $32=(($31+52)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33+($30<<2))|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=_function_allocator_alloc($alloc, $35);
      if ($36) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      __label__ = 49; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $40=$i;
      var $41=((($40)+(1))|0);
      $i=$41;
      __label__ = 6; break;
    case 11: 
      $i=0;
      __label__ = 12; break;
    case 12: 
      var $44=$i;
      var $45=$2;
      var $46=(($45+44)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($44)>>>0) < (($47)>>>0);
      if ($48) { __label__ = 13; break; } else { __label__ = 31; break; }
    case 13: 
      var $50=$i;
      var $51=$2;
      var $52=(($51+40)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($53+($50<<2))|0);
      var $55=HEAP32[(($54)>>2)];
      $v=$55;
      var $56=$v;
      var $57=(($56+104)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58)|0)!=0;
      if ($59) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      __label__ = 30; break;
    case 15: 
      $a=0;
      __label__ = 16; break;
    case 16: 
      var $63=$a;
      var $64=(($alloc+4)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($63)>>>0) < (($65)>>>0);
      if ($66) { __label__ = 17; break; } else { __label__ = 25; break; }
    case 17: 
      var $68=$a;
      var $69=(($alloc)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=(($70+($68<<2))|0);
      var $72=HEAP32[(($71)>>2)];
      $slot=$72;
      var $73=$v;
      var $74=$slot;
      var $75=_ir_values_overlap($73, $74);
      if ($75) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      __label__ = 24; break;
    case 19: 
      var $78=$slot;
      var $79=$v;
      var $80=_ir_value_life_merge_into($78, $79);
      if ($80) { __label__ = 21; break; } else { __label__ = 20; break; }
    case 20: 
      __label__ = 49; break;
    case 21: 
      var $83=$a;
      var $84=(($alloc+12)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=(($85+($83<<2))|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=$v;
      var $89=(($88+4)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=((_type_sizeof+($90<<2))|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=(($87)>>>0) < (($92)>>>0);
      if ($93) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $95=$v;
      var $96=(($95+4)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=((_type_sizeof+($97<<2))|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=$a;
      var $101=(($alloc+12)|0);
      var $102=HEAP32[(($101)>>2)];
      var $103=(($102+($100<<2))|0);
      HEAP32[(($103)>>2)]=$99;
      __label__ = 23; break;
    case 23: 
      var $105=$a;
      var $106=$i;
      var $107=$2;
      var $108=(($107+40)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=(($109+($106<<2))|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=(($111+68)|0);
      var $113=(($112+8)|0);
      HEAP32[(($113)>>2)]=$105;
      __label__ = 25; break;
    case 24: 
      var $115=$a;
      var $116=((($115)+(1))|0);
      $a=$116;
      __label__ = 16; break;
    case 25: 
      var $118=$a;
      var $119=(($alloc+4)|0);
      var $120=HEAP32[(($119)>>2)];
      var $121=(($118)>>>0) >= (($120)>>>0);
      if ($121) { __label__ = 26; break; } else { __label__ = 29; break; }
    case 26: 
      var $123=(($alloc+4)|0);
      var $124=HEAP32[(($123)>>2)];
      var $125=$i;
      var $126=$2;
      var $127=(($126+40)|0);
      var $128=HEAP32[(($127)>>2)];
      var $129=(($128+($125<<2))|0);
      var $130=HEAP32[(($129)>>2)];
      var $131=(($130+68)|0);
      var $132=(($131+8)|0);
      HEAP32[(($132)>>2)]=$124;
      var $133=$v;
      var $134=_function_allocator_alloc($alloc, $133);
      if ($134) { __label__ = 28; break; } else { __label__ = 27; break; }
    case 27: 
      __label__ = 49; break;
    case 28: 
      __label__ = 29; break;
    case 29: 
      __label__ = 30; break;
    case 30: 
      var $139=$i;
      var $140=((($139)+(1))|0);
      $i=$140;
      __label__ = 12; break;
    case 31: 
      var $142=(($alloc+12)|0);
      var $143=HEAP32[(($142)>>2)];
      var $144=(($143)|0)!=0;
      if ($144) { __label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      __label__ = 50; break;
    case 33: 
      var $147=_function_allocator_positions_add($alloc, 0);
      if ($147) { __label__ = 35; break; } else { __label__ = 34; break; }
    case 34: 
      __label__ = 49; break;
    case 35: 
      var $150=(($alloc+16)|0);
      var $151=HEAP32[(($150)>>2)];
      var $152=(($151)|0)!=0;
      if ($152) { __label__ = 36; break; } else { __label__ = 37; break; }
    case 36: 
      var $154=(($alloc+24)|0);
      var $155=HEAP32[(($154)>>2)];
      var $156=(($155)|0);
      var $157=HEAP32[(($156)>>2)];
      var $158=(($alloc+12)|0);
      var $159=HEAP32[(($158)>>2)];
      var $160=(($159)|0);
      var $161=HEAP32[(($160)>>2)];
      var $162=((($157)+($161))|0);
      $pos=$162;
      __label__ = 38; break;
    case 37: 
      $pos=0;
      __label__ = 38; break;
    case 38: 
      $i=1;
      __label__ = 39; break;
    case 39: 
      var $166=$i;
      var $167=(($alloc+16)|0);
      var $168=HEAP32[(($167)>>2)];
      var $169=(($166)>>>0) < (($168)>>>0);
      if ($169) { __label__ = 40; break; } else { __label__ = 44; break; }
    case 40: 
      var $171=$i;
      var $172=((($171)-(1))|0);
      var $173=(($alloc+24)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=(($174+($172<<2))|0);
      var $176=HEAP32[(($175)>>2)];
      var $177=$i;
      var $178=((($177)-(1))|0);
      var $179=(($alloc+12)|0);
      var $180=HEAP32[(($179)>>2)];
      var $181=(($180+($178<<2))|0);
      var $182=HEAP32[(($181)>>2)];
      var $183=((($176)+($182))|0);
      $pos=$183;
      var $184=$pos;
      var $185=_function_allocator_positions_add($alloc, $184);
      if ($185) { __label__ = 42; break; } else { __label__ = 41; break; }
    case 41: 
      __label__ = 49; break;
    case 42: 
      __label__ = 43; break;
    case 43: 
      var $189=$i;
      var $190=((($189)+(1))|0);
      $i=$190;
      __label__ = 39; break;
    case 44: 
      var $192=$pos;
      var $193=(($alloc+16)|0);
      var $194=HEAP32[(($193)>>2)];
      var $195=((($194)-(1))|0);
      var $196=(($alloc+12)|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=(($197+($195<<2))|0);
      var $199=HEAP32[(($198)>>2)];
      var $200=((($192)+($199))|0);
      var $201=$2;
      var $202=(($201+64)|0);
      HEAP32[(($202)>>2)]=$200;
      $i=0;
      __label__ = 45; break;
    case 45: 
      var $204=$i;
      var $205=$2;
      var $206=(($205+44)|0);
      var $207=HEAP32[(($206)>>2)];
      var $208=(($204)>>>0) < (($207)>>>0);
      if ($208) { __label__ = 46; break; } else { __label__ = 48; break; }
    case 46: 
      var $210=$i;
      var $211=$2;
      var $212=(($211+40)|0);
      var $213=HEAP32[(($212)>>2)];
      var $214=(($213+($210<<2))|0);
      var $215=HEAP32[(($214)>>2)];
      var $216=(($215+68)|0);
      var $217=(($216+8)|0);
      var $218=HEAP32[(($217)>>2)];
      var $219=(($alloc+24)|0);
      var $220=HEAP32[(($219)>>2)];
      var $221=(($220+($218<<2))|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=$i;
      var $224=$2;
      var $225=(($224+40)|0);
      var $226=HEAP32[(($225)>>2)];
      var $227=(($226+($223<<2))|0);
      var $228=HEAP32[(($227)>>2)];
      var $229=(($228+68)|0);
      var $230=(($229+8)|0);
      HEAP32[(($230)>>2)]=$222;
      __label__ = 47; break;
    case 47: 
      var $232=$i;
      var $233=((($232)+(1))|0);
      $i=$233;
      __label__ = 45; break;
    case 48: 
      __label__ = 50; break;
    case 49: 
      $retval=0;
      __label__ = 50; break;
    case 50: 
      $i=0;
      __label__ = 51; break;
    case 51: 
      var $238=$i;
      var $239=(($alloc+4)|0);
      var $240=HEAP32[(($239)>>2)];
      var $241=(($238)>>>0) < (($240)>>>0);
      if ($241) { __label__ = 52; break; } else { __label__ = 54; break; }
    case 52: 
      var $243=$i;
      var $244=(($alloc)|0);
      var $245=HEAP32[(($244)>>2)];
      var $246=(($245+($243<<2))|0);
      var $247=HEAP32[(($246)>>2)];
      _ir_value_delete($247);
      __label__ = 53; break;
    case 53: 
      var $249=$i;
      var $250=((($249)+(1))|0);
      $i=$250;
      __label__ = 51; break;
    case 54: 
      var $252=(($alloc)|0);
      var $253=HEAP32[(($252)>>2)];
      var $254=(($253)|0)!=0;
      if ($254) { __label__ = 55; break; } else { __label__ = 56; break; }
    case 55: 
      var $256=(($alloc)|0);
      var $257=HEAP32[(($256)>>2)];
      var $258=$257;
      _util_memory_d($258, 2043, ((STRING_TABLE.__str9222)|0));
      __label__ = 56; break;
    case 56: 
      var $260=(($alloc)|0);
      HEAP32[(($260)>>2)]=0;
      var $261=(($alloc+4)|0);
      HEAP32[(($261)>>2)]=0;
      var $262=(($alloc+8)|0);
      HEAP32[(($262)>>2)]=0;
      var $263=(($alloc+12)|0);
      var $264=HEAP32[(($263)>>2)];
      var $265=(($264)|0)!=0;
      if ($265) { __label__ = 57; break; } else { __label__ = 58; break; }
    case 57: 
      var $267=(($alloc+12)|0);
      var $268=HEAP32[(($267)>>2)];
      var $269=$268;
      _util_memory_d($269, 2044, ((STRING_TABLE.__str9222)|0));
      __label__ = 58; break;
    case 58: 
      var $271=(($alloc+12)|0);
      HEAP32[(($271)>>2)]=0;
      var $272=(($alloc+16)|0);
      HEAP32[(($272)>>2)]=0;
      var $273=(($alloc+20)|0);
      HEAP32[(($273)>>2)]=0;
      var $274=(($alloc+24)|0);
      var $275=HEAP32[(($274)>>2)];
      var $276=(($275)|0)!=0;
      if ($276) { __label__ = 59; break; } else { __label__ = 60; break; }
    case 59: 
      var $278=(($alloc+24)|0);
      var $279=HEAP32[(($278)>>2)];
      var $280=$279;
      _util_memory_d($280, 2045, ((STRING_TABLE.__str9222)|0));
      __label__ = 60; break;
    case 60: 
      var $282=(($alloc+24)|0);
      HEAP32[(($282)>>2)]=0;
      var $283=(($alloc+28)|0);
      HEAP32[(($283)>>2)]=0;
      var $284=(($alloc+32)|0);
      HEAP32[(($284)>>2)]=0;
      var $285=$retval;
      var $286=(($285) & 1);
      $1=$286;
      __label__ = 61; break;
    case 61: 
      var $288=$1;
      STACKTOP = __stackBase__;
      return $288;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_allocate_locals["X"]=1;

function _ir_function_create_local($self, $name, $vtype, $param) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $ve;
      $2=$self;
      $3=$name;
      $4=$vtype;
      var $6=(($param)&1);
      $5=$6;
      var $7=$5;
      var $8=(($7) & 1);
      if ($8) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $10=$2;
      var $11=(($10+56)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $15=$2;
      var $16=(($15+56)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=((($17)-(1))|0);
      var $19=$2;
      var $20=(($19+52)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+($18<<2))|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+8)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)!=2;
      if ($26) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $28=$2;
      var $29=(($28+76)|0);
      var $30=(($29)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($29+4)|0);
      var $33=HEAP32[(($32)>>2)];
      _irerror($31, $33, ((STRING_TABLE.__str12225)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 9; break;
    case 6: 
      var $35=$3;
      var $36=$5;
      var $37=(($36) & 1);
      var $38=$37 ? 2 : 1;
      var $39=$4;
      var $40=_ir_value_var($35, $38, $39);
      $ve=$40;
      var $41=$2;
      var $42=$ve;
      var $43=_ir_function_locals_add($41, $42);
      if ($43) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $45=$ve;
      _ir_value_delete($45);
      $1=0;
      __label__ = 9; break;
    case 8: 
      var $47=$ve;
      $1=$47;
      __label__ = 9; break;
    case 9: 
      var $49=$1;
      STACKTOP = __stackBase__;
      return $49;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_create_local["X"]=1;

function _irerror($ctx_0, $ctx_1, $msg) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $ap=(__stackBase__)+(8);
  var $2=(($ctx)|0);
  HEAP32[(($2)>>2)]=$ctx_0;
  var $3=(($ctx+4)|0);
  HEAP32[(($3)>>2)]=$ctx_1;
  $1=$msg;
  var $4=$ap;
  HEAP32[(($4)>>2)]=arguments[_irerror.length];
  var $5=$1;
  var $6=HEAP32[(($ap)>>2)];
  var $7=(($ctx)|0);
  var $8=HEAP32[(($7)>>2)];
  var $9=(($ctx+4)|0);
  var $10=HEAP32[(($9)>>2)];
  _cvprintmsg($8, $10, 2, ((STRING_TABLE.__str153)|0), $5, $6);
  var $11=$ap;
  ;
  STACKTOP = __stackBase__;
  return;
}


function _ir_block_set_label($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$name;
      var $3=$1;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      _util_memory_d($10, 571, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$2;
      var $13=_util_strdup($12);
      var $14=$1;
      var $15=(($14)|0);
      HEAP32[(($15)>>2)]=$13;
      var $16=$1;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=$20 ^ 1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_instr_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+20)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+20)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+16)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+16)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+20)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+20)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+20)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+24)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+20)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 537, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+16)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+20)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+16)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 537, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+16)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_instr_remove["X"]=1;

function _ir_block_instr_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+20)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+24)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+24)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+24)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+24)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 537, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+16)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+20)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+16)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 537, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+16)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+20)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+16)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_instr_add["X"]=1;

function _ir_block_living_find($self, $obj, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      $2=$self;
      $3=$obj;
      $4=$idx;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$2;
      var $8=(($7+56)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)>>>0) < (($9)>>>0);
      if ($10) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      var $12=$i;
      var $13=$2;
      var $14=(($13+52)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$3;
      var $19=(($17)|0)==(($18)|0);
      if ($19) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $21=$4;
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $24=$i;
      var $25=$4;
      HEAP32[(($25)>>2)]=$24;
      __label__ = 7; break;
    case 7: 
      $1=1;
      __label__ = 11; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $29=$i;
      var $30=((($29)+(1))|0);
      $i=$30;
      __label__ = 3; break;
    case 10: 
      $1=0;
      __label__ = 11; break;
    case 11: 
      var $33=$1;
      ;
      return $33;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_entries_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+32)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+36)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+36)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+36)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+36)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+36)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 538, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+28)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+32)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+28)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 538, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+28)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+32)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+28)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_entries_add["X"]=1;

function _ir_block_exits_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+44)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+48)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+48)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+48)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+48)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+48)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 539, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+40)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+44)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+40)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 539, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+40)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+44)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+40)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_exits_add["X"]=1;

function _ir_block_living_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+56)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+56)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+52)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+52)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+56)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+56)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+56)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+60)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+56)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 540, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+52)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+56)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+52)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 540, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+52)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_living_remove["X"]=1;

function _ir_block_living_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+56)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+60)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+60)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+60)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+60)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+60)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 540, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+52)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+56)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+52)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 540, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+52)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+56)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+52)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_living_add["X"]=1;

function _ir_instr_delete($self) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      var $idx=__stackBase__;
      var $idx1=(__stackBase__)+(4);
      $1=$self;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=$1;
      var $5=(($4+36)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($3)>>>0) < (($6)>>>0);
      if ($7) { __label__ = 4; break; } else { __label__ = 18; break; }
    case 4: 
      var $9=$i;
      var $10=$1;
      var $11=(($10+32)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12+($9<<3))|0);
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$1;
      var $17=_ir_value_writes_find($15, $16, $idx);
      if ($17) { __label__ = 5; break; } else { __label__ = 10; break; }
    case 5: 
      var $19=$i;
      var $20=$1;
      var $21=(($20+32)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22+($19<<3))|0);
      var $24=(($23)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=HEAP32[(($idx)>>2)];
      var $27=_ir_value_writes_remove($25, $26);
      if ($27) { __label__ = 6; break; } else { __label__ = 9; break; }
    case 6: 
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $33=$i;
      var $34=$1;
      var $35=(($34+32)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36+($33<<3))|0);
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$1;
      var $41=_ir_value_reads_find($39, $40, $idx);
      if ($41) { __label__ = 11; break; } else { __label__ = 16; break; }
    case 11: 
      var $43=$i;
      var $44=$1;
      var $45=(($44+32)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($46+($43<<3))|0);
      var $48=(($47)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=HEAP32[(($idx)>>2)];
      var $51=_ir_value_reads_remove($49, $50);
      if ($51) { __label__ = 12; break; } else { __label__ = 15; break; }
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      __label__ = 15; break;
    case 15: 
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $58=$i;
      var $59=((($58)+(1))|0);
      $i=$59;
      __label__ = 3; break;
    case 18: 
      var $61=$1;
      var $62=(($61+32)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63)|0)!=0;
      if ($64) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $66=$1;
      var $67=(($66+32)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$68;
      _util_memory_d($69, 628, ((STRING_TABLE.__str9222)|0));
      __label__ = 20; break;
    case 20: 
      var $71=$1;
      var $72=(($71+32)|0);
      HEAP32[(($72)>>2)]=0;
      var $73=$1;
      var $74=(($73+36)|0);
      HEAP32[(($74)>>2)]=0;
      var $75=$1;
      var $76=(($75+40)|0);
      HEAP32[(($76)>>2)]=0;
      $i=0;
      __label__ = 21; break;
    case 21: 
      var $78=$i;
      var $79=$1;
      var $80=(($79+48)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($78)>>>0) < (($81)>>>0);
      if ($82) { __label__ = 22; break; } else { __label__ = 36; break; }
    case 22: 
      var $84=$i;
      var $85=$1;
      var $86=(($85+44)|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=(($87+($84<<2))|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$1;
      var $91=_ir_value_writes_find($89, $90, $idx1);
      if ($91) { __label__ = 23; break; } else { __label__ = 28; break; }
    case 23: 
      var $93=$i;
      var $94=$1;
      var $95=(($94+44)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=(($96+($93<<2))|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=HEAP32[(($idx1)>>2)];
      var $100=_ir_value_writes_remove($98, $99);
      if ($100) { __label__ = 24; break; } else { __label__ = 27; break; }
    case 24: 
      __label__ = 25; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      __label__ = 27; break;
    case 27: 
      __label__ = 28; break;
    case 28: 
      var $106=$i;
      var $107=$1;
      var $108=(($107+44)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=(($109+($106<<2))|0);
      var $111=HEAP32[(($110)>>2)];
      var $112=$1;
      var $113=_ir_value_reads_find($111, $112, $idx1);
      if ($113) { __label__ = 29; break; } else { __label__ = 34; break; }
    case 29: 
      var $115=$i;
      var $116=$1;
      var $117=(($116+44)|0);
      var $118=HEAP32[(($117)>>2)];
      var $119=(($118+($115<<2))|0);
      var $120=HEAP32[(($119)>>2)];
      var $121=HEAP32[(($idx1)>>2)];
      var $122=_ir_value_reads_remove($120, $121);
      if ($122) { __label__ = 30; break; } else { __label__ = 33; break; }
    case 30: 
      __label__ = 31; break;
    case 31: 
      __label__ = 32; break;
    case 32: 
      __label__ = 33; break;
    case 33: 
      __label__ = 34; break;
    case 34: 
      __label__ = 35; break;
    case 35: 
      var $129=$i;
      var $130=((($129)+(1))|0);
      $i=$130;
      __label__ = 21; break;
    case 36: 
      var $132=$1;
      var $133=(($132+44)|0);
      var $134=HEAP32[(($133)>>2)];
      var $135=(($134)|0)!=0;
      if ($135) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      var $137=$1;
      var $138=(($137+44)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=$139;
      _util_memory_d($140, 636, ((STRING_TABLE.__str9222)|0));
      __label__ = 38; break;
    case 38: 
      var $142=$1;
      var $143=(($142+44)|0);
      HEAP32[(($143)>>2)]=0;
      var $144=$1;
      var $145=(($144+48)|0);
      HEAP32[(($145)>>2)]=0;
      var $146=$1;
      var $147=(($146+52)|0);
      HEAP32[(($147)>>2)]=0;
      var $148=$1;
      var $149=_ir_instr_op($148, 0, 0, 0);
      if ($149) { __label__ = 39; break; } else { __label__ = 42; break; }
    case 39: 
      __label__ = 40; break;
    case 40: 
      __label__ = 41; break;
    case 41: 
      __label__ = 42; break;
    case 42: 
      var $154=$1;
      var $155=_ir_instr_op($154, 1, 0, 0);
      if ($155) { __label__ = 43; break; } else { __label__ = 46; break; }
    case 43: 
      __label__ = 44; break;
    case 44: 
      __label__ = 45; break;
    case 45: 
      __label__ = 46; break;
    case 46: 
      var $160=$1;
      var $161=_ir_instr_op($160, 2, 0, 0);
      if ($161) { __label__ = 47; break; } else { __label__ = 50; break; }
    case 47: 
      __label__ = 48; break;
    case 48: 
      __label__ = 49; break;
    case 49: 
      __label__ = 50; break;
    case 50: 
      var $166=$1;
      var $167=$166;
      _util_memory_d($167, 640, ((STRING_TABLE.__str9222)|0));
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_delete["X"]=1;

function _ir_instr_new($owner, $op) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $self;
      $2=$owner;
      $3=$op;
      var $4=_util_memory_a(64, 583, ((STRING_TABLE.__str9222)|0));
      var $5=$4;
      $self=$5;
      var $6=$self;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $10=$2;
      var $11=$self;
      var $12=(($11+60)|0);
      HEAP32[(($12)>>2)]=$10;
      var $13=$self;
      var $14=(($13+4)|0);
      var $15=(($14)|0);
      HEAP32[(($15)>>2)]=((STRING_TABLE.__str11224)|0);
      var $16=$self;
      var $17=(($16+4)|0);
      var $18=(($17+4)|0);
      HEAP32[(($18)>>2)]=0;
      var $19=$3;
      var $20=$self;
      var $21=(($20)|0);
      HEAP32[(($21)>>2)]=$19;
      var $22=$self;
      var $23=(($22+12)|0);
      var $24=(($23)|0);
      HEAP32[(($24)>>2)]=0;
      var $25=$self;
      var $26=(($25+12)|0);
      var $27=(($26+4)|0);
      HEAP32[(($27)>>2)]=0;
      var $28=$self;
      var $29=(($28+12)|0);
      var $30=(($29+8)|0);
      HEAP32[(($30)>>2)]=0;
      var $31=$self;
      var $32=(($31+24)|0);
      var $33=(($32)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$self;
      var $35=(($34+24)|0);
      var $36=(($35+4)|0);
      HEAP32[(($36)>>2)]=0;
      var $37=$self;
      var $38=(($37+32)|0);
      HEAP32[(($38)>>2)]=0;
      var $39=$self;
      var $40=(($39+36)|0);
      HEAP32[(($40)>>2)]=0;
      var $41=$self;
      var $42=(($41+40)|0);
      HEAP32[(($42)>>2)]=0;
      var $43=$self;
      var $44=(($43+44)|0);
      HEAP32[(($44)>>2)]=0;
      var $45=$self;
      var $46=(($45+48)|0);
      HEAP32[(($46)>>2)]=0;
      var $47=$self;
      var $48=(($47+52)|0);
      HEAP32[(($48)>>2)]=0;
      var $49=$self;
      var $50=(($49+56)|0);
      HEAP32[(($50)>>2)]=0;
      var $51=$self;
      $1=$51;
      __label__ = 5; break;
    case 5: 
      var $53=$1;
      ;
      return $53;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_new["X"]=1;

function _ir_instr_params_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+48)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+48)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+44)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+44)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+48)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+48)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+48)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+52)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+48)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 603, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+44)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+48)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+44)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 603, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+44)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_params_remove["X"]=1;

function _ir_value_writes_find($self, $obj, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      $2=$self;
      $3=$obj;
      $4=$idx;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$2;
      var $8=(($7+44)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)>>>0) < (($9)>>>0);
      if ($10) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      var $12=$i;
      var $13=$2;
      var $14=(($13+40)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$3;
      var $19=(($17)|0)==(($18)|0);
      if ($19) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $21=$4;
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $24=$i;
      var $25=$4;
      HEAP32[(($25)>>2)]=$24;
      __label__ = 7; break;
    case 7: 
      $1=1;
      __label__ = 11; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $29=$i;
      var $30=((($29)+(1))|0);
      $i=$30;
      __label__ = 3; break;
    case 10: 
      $1=0;
      __label__ = 11; break;
    case 11: 
      var $33=$1;
      ;
      return $33;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_reads_find($self, $obj, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      $2=$self;
      $3=$obj;
      $4=$idx;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$2;
      var $8=(($7+32)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)>>>0) < (($9)>>>0);
      if ($10) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      var $12=$i;
      var $13=$2;
      var $14=(($13+28)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$3;
      var $19=(($17)|0)==(($18)|0);
      if ($19) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $21=$4;
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $24=$i;
      var $25=$4;
      HEAP32[(($25)>>2)]=$24;
      __label__ = 7; break;
    case 7: 
      $1=1;
      __label__ = 11; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $29=$i;
      var $30=((($29)+(1))|0);
      $i=$30;
      __label__ = 3; break;
    case 10: 
      $1=0;
      __label__ = 11; break;
    case 11: 
      var $33=$1;
      ;
      return $33;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_code_setaddr($self, $gaddr) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$gaddr;
      var $3=$2;
      var $4=$1;
      var $5=(($4+68)|0);
      var $6=(($5)|0);
      HEAP32[(($6)>>2)]=$3;
      var $7=$1;
      var $8=(($7+84)|0);
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($10)|0)!=0;
      if ($11) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $13=$2;
      var $14=$1;
      var $15=(($14+84)|0);
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17+68)|0);
      var $19=(($18)|0);
      HEAP32[(($19)>>2)]=$13;
      __label__ = 4; break;
    case 4: 
      var $21=$1;
      var $22=(($21+84)|0);
      var $23=(($22+4)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $27=$2;
      var $28=$1;
      var $29=(($28+84)|0);
      var $30=(($29+4)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($31+68)|0);
      var $33=(($32)|0);
      HEAP32[(($33)>>2)]=$27;
      __label__ = 6; break;
    case 6: 
      var $35=$1;
      var $36=(($35+84)|0);
      var $37=(($36+8)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=(($38)|0)!=0;
      if ($39) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $41=$2;
      var $42=$1;
      var $43=(($42+84)|0);
      var $44=(($43+8)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($45+68)|0);
      var $47=(($46)|0);
      HEAP32[(($47)>>2)]=$41;
      __label__ = 8; break;
    case 8: 
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_code_setaddr["X"]=1;

function _ir_value_code_addr($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$self;
      var $3=$2;
      var $4=(($3+8)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)==4;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+68)|0);
      var $10=(($9+12)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=((($11)+(1))|0);
      $1=$12;
      __label__ = 5; break;
    case 4: 
      var $14=$2;
      var $15=(($14+68)|0);
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$2;
      var $19=(($18+68)|0);
      var $20=(($19+12)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=((($17)+($21))|0);
      $1=$22;
      __label__ = 5; break;
    case 5: 
      var $24=$1;
      ;
      return $24;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_instr_params_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+48)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+52)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+52)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+52)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+52)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 603, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+44)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+48)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+44)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 603, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+44)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+48)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+44)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_params_add["X"]=1;

function _ir_value_writes_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+44)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+44)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+40)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+40)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+44)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+44)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+44)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+48)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+44)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 766, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+40)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+44)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+40)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 766, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+40)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_writes_remove["X"]=1;

function _ir_value_reads_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+32)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+32)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=((($20)+(1))|0);
      var $22=$2;
      var $23=(($22+28)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<2))|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$i;
      var $28=$2;
      var $29=(($28+28)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+($27<<2))|0);
      HEAP32[(($31)>>2)]=$26;
      __label__ = 7; break;
    case 7: 
      var $33=$i;
      var $34=((($33)+(1))|0);
      $i=$34;
      __label__ = 5; break;
    case 8: 
      var $36=$2;
      var $37=(($36+32)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=((($38)-(1))|0);
      HEAP32[(($37)>>2)]=$39;
      var $40=$2;
      var $41=(($40+32)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$2;
      var $44=(($43+32)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=Math.floor(((($45)>>>0))/(2));
      var $47=(($42)>>>0) < (($46)>>>0);
      if ($47) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $49=$2;
      var $50=(($49+36)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=Math.floor(((($51)>>>0))/(2));
      HEAP32[(($50)>>2)]=$52;
      var $53=$2;
      var $54=(($53+32)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=((($55<<2))|0);
      var $57=_util_memory_a($56, 765, ((STRING_TABLE.__str9222)|0));
      var $58=$57;
      $reall=$58;
      var $59=$reall;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $63=$reall;
      var $64=$63;
      var $65=$2;
      var $66=(($65+28)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      var $69=$2;
      var $70=(($69+32)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=((($71<<2))|0);
      assert($72 % 1 === 0, 'memcpy given ' + $72 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($64, $68, $72, 4);
      var $73=$2;
      var $74=(($73+28)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      _util_memory_d($76, 765, ((STRING_TABLE.__str9222)|0));
      var $77=$reall;
      var $78=$2;
      var $79=(($78+28)|0);
      HEAP32[(($79)>>2)]=$77;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $82=$1;
      ;
      return $82;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_reads_remove["X"]=1;

function _ir_instr_op($self, $op, $v, $writing) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $idx=__stackBase__;
      $2=$self;
      $3=$op;
      $4=$v;
      var $6=(($writing)&1);
      $5=$6;
      var $7=$3;
      var $8=$2;
      var $9=(($8+12)|0);
      var $10=(($9+($7<<2))|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($11)|0)!=0;
      if ($12) { __label__ = 3; break; } else { __label__ = 14; break; }
    case 3: 
      var $14=$5;
      var $15=(($14) & 1);
      if ($15) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $17=$3;
      var $18=$2;
      var $19=(($18+12)|0);
      var $20=(($19+($17<<2))|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$2;
      var $23=_ir_value_writes_find($21, $22, $idx);
      if ($23) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $25=$3;
      var $26=$2;
      var $27=(($26+12)|0);
      var $28=(($27+($25<<2))|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=HEAP32[(($idx)>>2)];
      var $31=_ir_value_writes_remove($29, $30);
      if ($31) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      $1=0;
      __label__ = 24; break;
    case 7: 
      __label__ = 13; break;
    case 8: 
      var $35=$3;
      var $36=$2;
      var $37=(($36+12)|0);
      var $38=(($37+($35<<2))|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$2;
      var $41=_ir_value_reads_find($39, $40, $idx);
      if ($41) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $43=$3;
      var $44=$2;
      var $45=(($44+12)|0);
      var $46=(($45+($43<<2))|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=HEAP32[(($idx)>>2)];
      var $49=_ir_value_reads_remove($47, $48);
      if ($49) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 24; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $55=$4;
      var $56=(($55)|0)!=0;
      if ($56) { __label__ = 15; break; } else { __label__ = 23; break; }
    case 15: 
      var $58=$5;
      var $59=(($58) & 1);
      if ($59) { __label__ = 16; break; } else { __label__ = 19; break; }
    case 16: 
      var $61=$4;
      var $62=$2;
      var $63=_ir_value_writes_add($61, $62);
      if ($63) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 24; break;
    case 18: 
      __label__ = 22; break;
    case 19: 
      var $67=$4;
      var $68=$2;
      var $69=_ir_value_reads_add($67, $68);
      if ($69) { __label__ = 21; break; } else { __label__ = 20; break; }
    case 20: 
      $1=0;
      __label__ = 24; break;
    case 21: 
      __label__ = 22; break;
    case 22: 
      __label__ = 23; break;
    case 23: 
      var $74=$4;
      var $75=$3;
      var $76=$2;
      var $77=(($76+12)|0);
      var $78=(($77+($75<<2))|0);
      HEAP32[(($78)>>2)]=$74;
      $1=1;
      __label__ = 24; break;
    case 24: 
      var $80=$1;
      STACKTOP = __stackBase__;
      return $80;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_op["X"]=1;

function _ir_value_writes_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+44)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+48)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+48)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+48)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+48)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+48)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 766, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+40)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+44)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+40)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 766, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+40)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+44)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+40)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_writes_add["X"]=1;

function _ir_value_reads_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+32)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+36)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+36)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+36)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+36)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+36)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 765, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+28)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+32)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+28)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 765, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+28)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+32)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+28)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_reads_add["X"]=1;

function _ir_value_set_name($self, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$self;
      $2=$name;
      var $3=$1;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$1;
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      _util_memory_d($10, 804, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$2;
      var $13=_util_strdup($12);
      var $14=$1;
      var $15=(($14)|0);
      HEAP32[(($15)>>2)]=$13;
      var $16=$1;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=0;
      var $20=$19 ^ 1;
      var $21=$20 ^ 1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_set_float($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=2;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $10=$3;
      var $11=$2;
      var $12=(($11+56)|0);
      var $13=$12;
      HEAPF32[(($13)>>2)]=$10;
      var $14=$2;
      var $15=(($14+52)|0);
      HEAP8[($15)]=1;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $17=$1;
      ;
      return $17;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_set_field($self, $fld) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$fld;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=5;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $10=$3;
      var $11=$2;
      var $12=(($11+56)|0);
      var $13=$12;
      HEAP32[(($13)>>2)]=$10;
      var $14=$2;
      var $15=(($14+52)|0);
      HEAP8[($15)]=1;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $17=$1;
      ;
      return $17;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_vector_member($self, $member) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $m;
      $2=$self;
      $3=$member;
      var $4=$3;
      var $5=(($4)>>>0) >= 3;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 19; break;
    case 4: 
      var $8=$3;
      var $9=$2;
      var $10=(($9+84)|0);
      var $11=(($10+($8<<2))|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $15=$3;
      var $16=$2;
      var $17=(($16+84)|0);
      var $18=(($17+($15<<2))|0);
      var $19=HEAP32[(($18)>>2)];
      $1=$19;
      __label__ = 19; break;
    case 6: 
      var $21=$2;
      var $22=(($21+4)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23)|0)==3;
      if ($24) { __label__ = 7; break; } else { __label__ = 10; break; }
    case 7: 
      var $26=$2;
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$2;
      var $30=(($29+8)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=_ir_value_var($28, $31, 2);
      $m=$32;
      var $33=$m;
      var $34=(($33)|0)!=0;
      if ($34) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 19; break;
    case 9: 
      var $37=$m;
      var $38=(($37+12)|0);
      var $39=$2;
      var $40=(($39+12)|0);
      var $41=$38;
      var $42=$40;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($41)>>2)]=HEAP32[(($42)>>2)];HEAP32[((($41)+(4))>>2)]=HEAP32[((($42)+(4))>>2)];
      var $43=$m;
      var $44=$3;
      var $45=$2;
      var $46=(($45+84)|0);
      var $47=(($46+($44<<2))|0);
      HEAP32[(($47)>>2)]=$43;
      var $48=$3;
      var $49=$m;
      var $50=(($49+68)|0);
      var $51=(($50+12)|0);
      HEAP32[(($51)>>2)]=$48;
      __label__ = 18; break;
    case 10: 
      var $53=$2;
      var $54=(($53+4)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=(($55)|0)==5;
      if ($56) { __label__ = 11; break; } else { __label__ = 16; break; }
    case 11: 
      var $58=$2;
      var $59=(($58+20)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60)|0)!=3;
      if ($61) { __label__ = 12; break; } else { __label__ = 13; break; }
    case 12: 
      $1=0;
      __label__ = 19; break;
    case 13: 
      var $64=$2;
      var $65=(($64)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=$2;
      var $68=(($67+8)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=_ir_value_var($66, $69, 5);
      $m=$70;
      var $71=$m;
      var $72=(($71)|0)!=0;
      if ($72) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      $1=0;
      __label__ = 19; break;
    case 15: 
      var $75=$m;
      var $76=(($75+20)|0);
      HEAP32[(($76)>>2)]=2;
      var $77=$m;
      var $78=(($77+12)|0);
      var $79=$2;
      var $80=(($79+12)|0);
      var $81=$78;
      var $82=$80;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($81)>>2)]=HEAP32[(($82)>>2)];HEAP32[((($81)+(4))>>2)]=HEAP32[((($82)+(4))>>2)];
      var $83=$m;
      var $84=$3;
      var $85=$2;
      var $86=(($85+84)|0);
      var $87=(($86+($84<<2))|0);
      HEAP32[(($87)>>2)]=$83;
      var $88=$3;
      var $89=$m;
      var $90=(($89+68)|0);
      var $91=(($90+12)|0);
      HEAP32[(($91)>>2)]=$88;
      __label__ = 17; break;
    case 16: 
      var $93=$2;
      var $94=(($93+12)|0);
      var $95=$2;
      var $96=(($95)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($94)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=(($94+4)|0);
      var $101=HEAP32[(($100)>>2)];
      _irerror($99, $101, ((STRING_TABLE.__str14227)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$97,tempInt));
      $1=0;
      __label__ = 19; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $104=$2;
      var $105=$m;
      var $106=(($105+96)|0);
      HEAP32[(($106)>>2)]=$104;
      var $107=$m;
      $1=$107;
      __label__ = 19; break;
    case 19: 
      var $109=$1;
      STACKTOP = __stackBase__;
      return $109;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_vector_member["X"]=1;

function _ir_value_life_remove($self, $idx) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $reall;
      $2=$self;
      $3=$idx;
      var $4=$3;
      var $5=$2;
      var $6=(($5+104)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) >= (($7)>>>0);
      if ($8) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 13; break;
    case 4: 
      var $11=$3;
      $i=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+104)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=(($13)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $20=$i;
      var $21=$2;
      var $22=(($21+100)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+($20<<3))|0);
      var $25=$i;
      var $26=((($25)+(1))|0);
      var $27=$2;
      var $28=(($27+100)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+($26<<3))|0);
      var $31=$24;
      var $32=$30;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($31)>>2)]=HEAP32[(($32)>>2)];HEAP32[((($31)+(4))>>2)]=HEAP32[((($32)+(4))>>2)];
      __label__ = 7; break;
    case 7: 
      var $34=$i;
      var $35=((($34)+(1))|0);
      $i=$35;
      __label__ = 5; break;
    case 8: 
      var $37=$2;
      var $38=(($37+104)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=((($39)-(1))|0);
      HEAP32[(($38)>>2)]=$40;
      var $41=$2;
      var $42=(($41+104)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=$2;
      var $45=(($44+104)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=Math.floor(((($46)>>>0))/(2));
      var $48=(($43)>>>0) < (($47)>>>0);
      if ($48) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $50=$2;
      var $51=(($50+108)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=Math.floor(((($52)>>>0))/(2));
      HEAP32[(($51)>>2)]=$53;
      var $54=$2;
      var $55=(($54+104)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56<<3))|0);
      var $58=_util_memory_a($57, 764, ((STRING_TABLE.__str9222)|0));
      var $59=$58;
      $reall=$59;
      var $60=$reall;
      var $61=(($60)|0)!=0;
      if ($61) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 13; break;
    case 11: 
      var $64=$reall;
      var $65=$64;
      var $66=$2;
      var $67=(($66+100)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$68;
      var $70=$2;
      var $71=(($70+104)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=((($72<<3))|0);
      assert($73 % 1 === 0, 'memcpy given ' + $73 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($65, $69, $73, 4);
      var $74=$2;
      var $75=(($74+100)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=$76;
      _util_memory_d($77, 764, ((STRING_TABLE.__str9222)|0));
      var $78=$reall;
      var $79=$2;
      var $80=(($79+100)|0);
      HEAP32[(($80)>>2)]=$78;
      __label__ = 12; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $83=$1;
      ;
      return $83;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_life_remove["X"]=1;

function _ir_value_life_add($self, $f_0, $f_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $f=__stackBase__;
      var $reall;
      $2=$self;
      var $3=(($f)|0);
      HEAP32[(($3)>>2)]=$f_0;
      var $4=(($f+4)|0);
      HEAP32[(($4)>>2)]=$f_1;
      var $5=$2;
      var $6=(($5+104)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=(($8+108)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)|0)==(($10)|0);
      if ($11) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $13=$2;
      var $14=(($13+108)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $18=$2;
      var $19=(($18+108)|0);
      HEAP32[(($19)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $21=$2;
      var $22=(($21+108)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=((($23<<1))|0);
      HEAP32[(($22)>>2)]=$24;
      __label__ = 6; break;
    case 6: 
      var $26=$2;
      var $27=(($26+108)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=((($28<<3))|0);
      var $30=_util_memory_a($29, 764, ((STRING_TABLE.__str9222)|0));
      var $31=$30;
      $reall=$31;
      var $32=$reall;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $36=$reall;
      var $37=$36;
      var $38=$2;
      var $39=(($38+100)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      var $42=$2;
      var $43=(($42+104)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44<<3))|0);
      assert($45 % 1 === 0, 'memcpy given ' + $45 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $41, $45, 4);
      var $46=$2;
      var $47=(($46+100)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      _util_memory_d($49, 764, ((STRING_TABLE.__str9222)|0));
      var $50=$reall;
      var $51=$2;
      var $52=(($51+100)|0);
      HEAP32[(($52)>>2)]=$50;
      __label__ = 9; break;
    case 9: 
      var $54=$2;
      var $55=(($54+104)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+100)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<3))|0);
      var $62=$61;
      var $63=$f;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($62)>>2)]=HEAP32[(($63)>>2)];HEAP32[((($62)+(4))>>2)]=HEAP32[((($63)+(4))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_life_add["X"]=1;

function _ir_value_out($owner, $name, $storetype, $vtype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $v;
      $2=$owner;
      $3=$name;
      $4=$storetype;
      $5=$vtype;
      var $6=$3;
      var $7=$4;
      var $8=$5;
      var $9=_ir_value_var($6, $7, $8);
      $v=$9;
      var $10=$v;
      var $11=(($10)|0)!=0;
      if ($11) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $14=$2;
      var $15=$v;
      var $16=_ir_function_collect_value($14, $15);
      if ($16) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $18=$v;
      _ir_value_delete($18);
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $20=$v;
      $1=$20;
      __label__ = 7; break;
    case 7: 
      var $22=$1;
      ;
      return $22;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_set_vector($self, $v_0, $v_1, $v_2) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $v=__stackBase__;
      $2=$self;
      var $3=(($v)|0);
      HEAPF32[(($3)>>2)]=$v_0;
      var $4=(($v+4)|0);
      HEAPF32[(($4)>>2)]=$v_1;
      var $5=(($v+8)|0);
      HEAPF32[(($5)>>2)]=$v_2;
      var $6=$2;
      var $7=(($6+4)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|0)!=3;
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $12=$2;
      var $13=(($12+56)|0);
      var $14=$13;
      var $15=$14;
      var $16=$v;
      assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($15)>>2)]=HEAP32[(($16)>>2)];HEAP32[((($15)+(4))>>2)]=HEAP32[((($16)+(4))>>2)];HEAP32[((($15)+(8))>>2)]=HEAP32[((($16)+(8))>>2)];
      var $17=$2;
      var $18=(($17+52)|0);
      HEAP8[($18)]=1;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $20=$1;
      STACKTOP = __stackBase__;
      return $20;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_set_string($self, $str) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$str;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=1;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $10=$3;
      var $11=_ir_strdup($10);
      var $12=$2;
      var $13=(($12+56)|0);
      var $14=$13;
      HEAP32[(($14)>>2)]=$11;
      var $15=$2;
      var $16=(($15+52)|0);
      HEAP8[($16)]=1;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $18=$1;
      ;
      return $18;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_strdup($str) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $out;
      $2=$str;
      var $3=$2;
      var $4=(($3)|0)!=0;
      if ($4) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $6=$2;
      var $7=HEAP8[($6)];
      var $8=(($7 << 24) >> 24)!=0;
      if ($8) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $10=_util_memory_a(1, 849, ((STRING_TABLE.__str9222)|0));
      $out=$10;
      var $11=$out;
      HEAP8[($11)]=0;
      var $12=$out;
      $1=$12;
      __label__ = 6; break;
    case 5: 
      var $14=$2;
      var $15=_util_strdup($14);
      $1=$15;
      __label__ = 6; break;
    case 6: 
      var $17=$1;
      ;
      return $17;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_value_life_insert($self, $idx, $e_0, $e_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $e=__stackBase__;
      var $k;
      $2=$self;
      $3=$idx;
      var $4=(($e)|0);
      HEAP32[(($4)>>2)]=$e_0;
      var $5=(($e+4)|0);
      HEAP32[(($5)>>2)]=$e_1;
      var $6=$2;
      var $7=(($e)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($e+4)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=_ir_value_life_add($6, $8, $10);
      if ($11) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 9; break;
    case 4: 
      var $14=$2;
      var $15=(($14+104)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      $k=$17;
      __label__ = 5; break;
    case 5: 
      var $19=$k;
      var $20=$3;
      var $21=(($19)>>>0) > (($20)>>>0);
      if ($21) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $23=$k;
      var $24=$2;
      var $25=(($24+100)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<3))|0);
      var $28=$k;
      var $29=((($28)-(1))|0);
      var $30=$2;
      var $31=(($30+100)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=(($32+($29<<3))|0);
      var $34=$27;
      var $35=$33;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($34)>>2)]=HEAP32[(($35)>>2)];HEAP32[((($34)+(4))>>2)]=HEAP32[((($35)+(4))>>2)];
      __label__ = 7; break;
    case 7: 
      var $37=$k;
      var $38=((($37)-(1))|0);
      $k=$38;
      __label__ = 5; break;
    case 8: 
      var $40=$3;
      var $41=$2;
      var $42=(($41+100)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($43+($40<<3))|0);
      var $45=$44;
      var $46=$e;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($45)>>2)]=HEAP32[(($46)>>2)];HEAP32[((($45)+(4))>>2)]=HEAP32[((($46)+(4))>>2)];
      $1=1;
      __label__ = 9; break;
    case 9: 
      var $48=$1;
      STACKTOP = __stackBase__;
      return $48;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_life_insert["X"]=1;

function _ir_value_life_merge($self, $s) {
  var __stackBase__  = STACKTOP; STACKTOP += 16; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $life;
      var $before;
      var $new_entry=__stackBase__;
      var $e=(__stackBase__)+(8);
      $2=$self;
      $3=$s;
      $life=0;
      $before=0;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+104)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$life;
      $before=$11;
      var $12=$i;
      var $13=$2;
      var $14=(($13+100)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<3))|0);
      $life=$16;
      var $17=$life;
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$3;
      var $21=(($19)>>>0) > (($20)>>>0);
      if ($21) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      __label__ = 8; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $25=$i;
      var $26=((($25)+(1))|0);
      $i=$26;
      __label__ = 3; break;
    case 8: 
      var $28=$i;
      var $29=$2;
      var $30=(($29+104)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($28)|0)==(($31)|0);
      if ($32) { __label__ = 9; break; } else { __label__ = 18; break; }
    case 9: 
      var $34=$life;
      var $35=(($34)|0)!=0;
      if ($35) { __label__ = 10; break; } else { __label__ = 12; break; }
    case 10: 
      var $37=$life;
      var $38=(($37+4)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=((($39)+(1))|0);
      var $41=$3;
      var $42=(($40)|0)==(($41)|0);
      if ($42) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $44=$life;
      var $45=(($44+4)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=((($46)+(1))|0);
      HEAP32[(($45)>>2)]=$47;
      $1=1;
      __label__ = 32; break;
    case 12: 
      var $49=$life;
      var $50=(($49)|0)!=0;
      if ($50) { __label__ = 13; break; } else { __label__ = 15; break; }
    case 13: 
      var $52=$life;
      var $53=(($52+4)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=$3;
      var $56=(($54)>>>0) >= (($55)>>>0);
      if ($56) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      $1=0;
      __label__ = 32; break;
    case 15: 
      var $59=$3;
      var $60=(($e+4)|0);
      HEAP32[(($60)>>2)]=$59;
      var $61=(($e)|0);
      HEAP32[(($61)>>2)]=$59;
      var $62=$2;
      var $63=(($e)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($e+4)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=_ir_value_life_add($62, $64, $66);
      if ($67) { __label__ = 17; break; } else { __label__ = 16; break; }
    case 16: 
      $1=0;
      __label__ = 32; break;
    case 17: 
      $1=1;
      __label__ = 32; break;
    case 18: 
      var $71=$before;
      var $72=(($71)|0)!=0;
      if ($72) { __label__ = 19; break; } else { __label__ = 29; break; }
    case 19: 
      var $74=$before;
      var $75=(($74+4)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=((($76)+(1))|0);
      var $78=$3;
      var $79=(($77)|0)==(($78)|0);
      if ($79) { __label__ = 20; break; } else { __label__ = 24; break; }
    case 20: 
      var $81=$life;
      var $82=(($81)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=((($83)-(1))|0);
      var $85=$3;
      var $86=(($84)|0)==(($85)|0);
      if ($86) { __label__ = 21; break; } else { __label__ = 24; break; }
    case 21: 
      var $88=$life;
      var $89=(($88+4)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=$before;
      var $92=(($91+4)|0);
      HEAP32[(($92)>>2)]=$90;
      var $93=$2;
      var $94=$i;
      var $95=_ir_value_life_remove($93, $94);
      if ($95) { __label__ = 23; break; } else { __label__ = 22; break; }
    case 22: 
      $1=0;
      __label__ = 32; break;
    case 23: 
      $1=1;
      __label__ = 32; break;
    case 24: 
      var $99=$before;
      var $100=(($99+4)|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=((($101)+(1))|0);
      var $103=$3;
      var $104=(($102)|0)==(($103)|0);
      if ($104) { __label__ = 25; break; } else { __label__ = 26; break; }
    case 25: 
      var $106=$before;
      var $107=(($106+4)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=((($108)+(1))|0);
      HEAP32[(($107)>>2)]=$109;
      $1=1;
      __label__ = 32; break;
    case 26: 
      var $111=$before;
      var $112=(($111+4)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$3;
      var $115=(($113)>>>0) >= (($114)>>>0);
      if ($115) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      $1=0;
      __label__ = 32; break;
    case 28: 
      __label__ = 29; break;
    case 29: 
      var $119=$life;
      var $120=(($119)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=((($121)-(1))|0);
      var $123=$3;
      var $124=(($122)|0)==(($123)|0);
      if ($124) { __label__ = 30; break; } else { __label__ = 31; break; }
    case 30: 
      var $126=$life;
      var $127=(($126)|0);
      var $128=HEAP32[(($127)>>2)];
      var $129=((($128)-(1))|0);
      HEAP32[(($127)>>2)]=$129;
      $1=1;
      __label__ = 32; break;
    case 31: 
      var $131=$3;
      var $132=(($new_entry+4)|0);
      HEAP32[(($132)>>2)]=$131;
      var $133=(($new_entry)|0);
      HEAP32[(($133)>>2)]=$131;
      var $134=$2;
      var $135=$i;
      var $136=(($new_entry)|0);
      var $137=HEAP32[(($136)>>2)];
      var $138=(($new_entry+4)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=_ir_value_life_insert($134, $135, $137, $139);
      $1=$140;
      __label__ = 32; break;
    case 32: 
      var $142=$1;
      STACKTOP = __stackBase__;
      return $142;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_life_merge["X"]=1;

function _ir_values_overlap($a, $b) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $la;
      var $lb;
      var $enda;
      var $endb;
      $2=$a;
      $3=$b;
      var $4=$2;
      var $5=(($4+104)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$3;
      var $10=(($9+104)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($11)|0)!=0;
      if ($12) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      $1=0;
      __label__ = 18; break;
    case 5: 
      var $15=$2;
      var $16=(($15+100)|0);
      var $17=HEAP32[(($16)>>2)];
      $la=$17;
      var $18=$3;
      var $19=(($18+100)|0);
      var $20=HEAP32[(($19)>>2)];
      $lb=$20;
      var $21=$la;
      var $22=$2;
      var $23=(($22+104)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($21+($24<<3))|0);
      $enda=$25;
      var $26=$lb;
      var $27=$3;
      var $28=(($27+104)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($26+($29<<3))|0);
      $endb=$30;
      __label__ = 6; break;
    case 6: 
      var $32=$la;
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$lb;
      var $36=(($35+4)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($34)>>>0) < (($37)>>>0);
      if ($38) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $40=$lb;
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$la;
      var $44=(($43+4)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=(($42)>>>0) < (($45)>>>0);
      if ($46) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      $1=1;
      __label__ = 18; break;
    case 9: 
      var $49=$la;
      var $50=(($49)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=$lb;
      var $53=(($52)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=(($51)>>>0) < (($54)>>>0);
      if ($55) { __label__ = 10; break; } else { __label__ = 13; break; }
    case 10: 
      var $57=$la;
      var $58=(($57+8)|0);
      $la=$58;
      var $59=$enda;
      var $60=(($58)|0)==(($59)|0);
      if ($60) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      __label__ = 17; break;
    case 12: 
      __label__ = 16; break;
    case 13: 
      var $64=$lb;
      var $65=(($64+8)|0);
      $lb=$65;
      var $66=$endb;
      var $67=(($65)|0)==(($66)|0);
      if ($67) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      __label__ = 17; break;
    case 15: 
      __label__ = 16; break;
    case 16: 
      __label__ = 6; break;
    case 17: 
      $1=0;
      __label__ = 18; break;
    case 18: 
      var $73=$1;
      ;
      return $73;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_values_overlap["X"]=1;

function _ir_call_value($self) {
  ;
  var __label__;

  var $1;
  $1=$self;
  var $2=$1;
  var $3=(($2+12)|0);
  var $4=(($3)|0);
  var $5=HEAP32[(($4)>>2)];
  ;
  return $5;
}


function _ir_value_life_merge_into($self, $other) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $myi;
      var $life;
      var $entry;
      $2=$self;
      $3=$other;
      var $4=$3;
      var $5=(($4+104)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=1;
      __label__ = 44; break;
    case 4: 
      var $10=$2;
      var $11=(($10+104)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 12; break; } else { __label__ = 5; break; }
    case 5: 
      $i=0;
      __label__ = 6; break;
    case 6: 
      var $16=$i;
      var $17=$3;
      var $18=(($17+104)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($16)>>>0) < (($19)>>>0);
      if ($20) { __label__ = 7; break; } else { __label__ = 11; break; }
    case 7: 
      var $22=$2;
      var $23=$i;
      var $24=$3;
      var $25=(($24+100)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<3))|0);
      var $28=(($27)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($27+4)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=_ir_value_life_add($22, $29, $31);
      if ($32) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 44; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $36=$i;
      var $37=((($36)+(1))|0);
      $i=$37;
      __label__ = 6; break;
    case 11: 
      $1=1;
      __label__ = 44; break;
    case 12: 
      $myi=0;
      $i=0;
      __label__ = 13; break;
    case 13: 
      var $41=$i;
      var $42=$3;
      var $43=(($42+104)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($41)>>>0) < (($44)>>>0);
      if ($45) { __label__ = 14; break; } else { __label__ = 43; break; }
    case 14: 
      var $47=$i;
      var $48=$3;
      var $49=(($48+100)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($50+($47<<3))|0);
      $life=$51;
      __label__ = 15; break;
    case 15: 
      var $53=$myi;
      var $54=$2;
      var $55=(($54+100)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+($53<<3))|0);
      $entry=$57;
      var $58=$life;
      var $59=(($58+4)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=((($60)+(1))|0);
      var $62=$entry;
      var $63=(($62)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($61)>>>0) < (($64)>>>0);
      if ($65) { __label__ = 16; break; } else { __label__ = 19; break; }
    case 16: 
      var $67=$2;
      var $68=$myi;
      var $69=$life;
      var $70=(($69)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=(($69+4)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=_ir_value_life_insert($67, $68, $71, $73);
      if ($74) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 44; break;
    case 18: 
      var $77=$myi;
      var $78=((($77)+(1))|0);
      $myi=$78;
      __label__ = 41; break;
    case 19: 
      var $80=$life;
      var $81=(($80)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=$entry;
      var $84=(($83)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=(($82)>>>0) < (($85)>>>0);
      if ($86) { __label__ = 20; break; } else { __label__ = 22; break; }
    case 20: 
      var $88=$life;
      var $89=(($88+4)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=((($90)+(1))|0);
      var $92=$entry;
      var $93=(($92)|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=(($91)>>>0) >= (($94)>>>0);
      if ($95) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $97=$life;
      var $98=(($97)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=$entry;
      var $101=(($100)|0);
      HEAP32[(($101)>>2)]=$99;
      __label__ = 22; break;
    case 22: 
      var $103=$life;
      var $104=(($103+4)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=$entry;
      var $107=(($106+4)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($105)>>>0) > (($108)>>>0);
      if ($109) { __label__ = 23; break; } else { __label__ = 25; break; }
    case 23: 
      var $111=$life;
      var $112=(($111)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$entry;
      var $115=(($114+4)|0);
      var $116=HEAP32[(($115)>>2)];
      var $117=((($116)+(1))|0);
      var $118=(($113)>>>0) <= (($117)>>>0);
      if ($118) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      var $120=$life;
      var $121=(($120+4)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=$entry;
      var $124=(($123+4)|0);
      HEAP32[(($124)>>2)]=$122;
      __label__ = 25; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      var $127=$myi;
      var $128=((($127)+(1))|0);
      var $129=$2;
      var $130=(($129+104)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=(($128)>>>0) < (($131)>>>0);
      if ($132) { __label__ = 27; break; } else { var $148 = 0;__label__ = 28; break; }
    case 27: 
      var $134=$entry;
      var $135=(($134+4)|0);
      var $136=HEAP32[(($135)>>2)];
      var $137=((($136)+(1))|0);
      var $138=$myi;
      var $139=((($138)+(1))|0);
      var $140=$2;
      var $141=(($140+100)|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=(($142+($139<<3))|0);
      var $144=(($143)|0);
      var $145=HEAP32[(($144)>>2)];
      var $146=(($137)>>>0) >= (($145)>>>0);
      var $148 = $146;__label__ = 28; break;
    case 28: 
      var $148;
      if ($148) { __label__ = 29; break; } else { __label__ = 34; break; }
    case 29: 
      var $150=$entry;
      var $151=(($150+4)|0);
      var $152=HEAP32[(($151)>>2)];
      var $153=$myi;
      var $154=((($153)+(1))|0);
      var $155=$2;
      var $156=(($155+100)|0);
      var $157=HEAP32[(($156)>>2)];
      var $158=(($157+($154<<3))|0);
      var $159=(($158+4)|0);
      var $160=HEAP32[(($159)>>2)];
      var $161=(($152)>>>0) < (($160)>>>0);
      if ($161) { __label__ = 30; break; } else { __label__ = 31; break; }
    case 30: 
      var $163=$myi;
      var $164=((($163)+(1))|0);
      var $165=$2;
      var $166=(($165+100)|0);
      var $167=HEAP32[(($166)>>2)];
      var $168=(($167+($164<<3))|0);
      var $169=(($168+4)|0);
      var $170=HEAP32[(($169)>>2)];
      var $171=$entry;
      var $172=(($171+4)|0);
      HEAP32[(($172)>>2)]=$170;
      __label__ = 31; break;
    case 31: 
      var $174=$2;
      var $175=$myi;
      var $176=((($175)+(1))|0);
      var $177=_ir_value_life_remove($174, $176);
      if ($177) { __label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      $1=0;
      __label__ = 44; break;
    case 33: 
      var $180=$myi;
      var $181=$2;
      var $182=(($181+100)|0);
      var $183=HEAP32[(($182)>>2)];
      var $184=(($183+($180<<3))|0);
      $entry=$184;
      __label__ = 26; break;
    case 34: 
      var $186=$life;
      var $187=(($186)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=$entry;
      var $190=(($189+4)|0);
      var $191=HEAP32[(($190)>>2)];
      var $192=(($188)>>>0) > (($191)>>>0);
      if ($192) { __label__ = 35; break; } else { __label__ = 40; break; }
    case 35: 
      var $194=$myi;
      var $195=((($194)+(1))|0);
      $myi=$195;
      var $196=$myi;
      var $197=$2;
      var $198=(($197+104)|0);
      var $199=HEAP32[(($198)>>2)];
      var $200=(($196)>>>0) >= (($199)>>>0);
      if ($200) { __label__ = 36; break; } else { __label__ = 39; break; }
    case 36: 
      var $202=$2;
      var $203=$life;
      var $204=(($203)|0);
      var $205=HEAP32[(($204)>>2)];
      var $206=(($203+4)|0);
      var $207=HEAP32[(($206)>>2)];
      var $208=_ir_value_life_add($202, $205, $207);
      if ($208) { __label__ = 38; break; } else { __label__ = 37; break; }
    case 37: 
      $1=0;
      __label__ = 44; break;
    case 38: 
      __label__ = 41; break;
    case 39: 
      __label__ = 15; break;
    case 40: 
      __label__ = 41; break;
    case 41: 
      __label__ = 42; break;
    case 42: 
      var $215=$i;
      var $216=((($215)+(1))|0);
      $i=$216;
      __label__ = 13; break;
    case 43: 
      $1=1;
      __label__ = 44; break;
    case 44: 
      var $219=$1;
      ;
      return $219;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_life_merge_into["X"]=1;

function _ir_block_create_store_op($self, $op, $target, $what) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $in;
      $2=$self;
      $3=$op;
      $4=$target;
      $5=$what;
      var $6=$2;
      var $7=$3;
      var $8=_ir_instr_new($6, $7);
      $in=$8;
      var $9=$in;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 13; break;
    case 4: 
      var $13=$4;
      var $14=(($13+8)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)==3;
      if ($16) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $18=$3;
      var $19=(($18)|0) < 37;
      if ($19) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $21=$3;
      var $22=(($21)|0) > 42;
      if ($22) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $24=$2;
      var $25=(($24+4)|0);
      var $26=(($25)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($25+4)|0);
      var $29=HEAP32[(($28)>>2)];
      _irerror($27, $29, ((STRING_TABLE.__str15228)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $30=$2;
      var $31=(($30+4)|0);
      var $32=$4;
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$5;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($31)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($31+4)|0);
      var $41=HEAP32[(($40)>>2)];
      _irerror($39, $41, ((STRING_TABLE.__str16229)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$34,HEAP32[(((tempInt)+(4))>>2)]=$37,tempInt));
      var $42=$2;
      var $43=(($42+4)|0);
      var $44=$3;
      var $45=((_asm_instr231+($44)*(12))|0);
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($43)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($43+4)|0);
      var $51=HEAP32[(($50)>>2)];
      _irerror($49, $51, ((STRING_TABLE.__str17230)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$47,tempInt));
      $1=0;
      __label__ = 13; break;
    case 8: 
      var $53=$in;
      var $54=$4;
      var $55=_ir_instr_op($53, 0, $54, 1);
      if ($55) { __label__ = 9; break; } else { __label__ = 11; break; }
    case 9: 
      var $57=$in;
      var $58=$5;
      var $59=_ir_instr_op($57, 1, $58, 0);
      if ($59) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $61=$2;
      var $62=$in;
      var $63=_ir_block_instr_add($61, $62);
      if ($63) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 13; break;
    case 12: 
      $1=1;
      __label__ = 13; break;
    case 13: 
      var $67=$1;
      STACKTOP = __stackBase__;
      return $67;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_store_op["X"]=1;

function _ir_block_create_store($self, $target, $what) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $op;
      var $vtype;
      $1=$self;
      $2=$target;
      $3=$what;
      $op=0;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)==9;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$3;
      var $10=(($9+4)|0);
      var $11=HEAP32[(($10)>>2)];
      $vtype=$11;
      __label__ = 5; break;
    case 4: 
      var $13=$2;
      var $14=(($13+4)|0);
      var $15=HEAP32[(($14)>>2)];
      $vtype=$15;
      __label__ = 5; break;
    case 5: 
      var $17=$vtype;
      var $18=((_type_store_instr+($17<<1))|0);
      var $19=HEAP16[(($18)>>1)];
      var $20=(($19)&65535);
      $op=$20;
      var $21=HEAP32[((((_opts_flags)|0))>>2)];
      var $22=$21 & 8;
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 6; break; } else { __label__ = 10; break; }
    case 6: 
      var $25=$op;
      var $26=(($25)|0)==35;
      if ($26) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $28=$3;
      var $29=(($28+20)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)==3;
      if ($31) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      $op=32;
      __label__ = 9; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $35=$1;
      var $36=$op;
      var $37=$2;
      var $38=$3;
      var $39=_ir_block_create_store_op($35, $36, $37, $38);
      ;
      return $39;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_store["X"]=1;

function _ir_block_create_return($self, $v) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $in;
      $2=$self;
      $3=$v;
      var $4=$2;
      var $5=(($4+12)|0);
      var $6=HEAP8[($5)];
      var $7=(($6) & 1);
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$2;
      var $10=(($9+4)|0);
      var $11=$2;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($10)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($10+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _irerror($15, $17, ((STRING_TABLE.__str18232)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$13,tempInt));
      $1=0;
      __label__ = 12; break;
    case 4: 
      var $19=$2;
      var $20=(($19+12)|0);
      HEAP8[($20)]=1;
      var $21=$2;
      var $22=(($21+68)|0);
      HEAP8[($22)]=1;
      var $23=$2;
      var $24=_ir_instr_new($23, 43);
      $in=$24;
      var $25=$in;
      var $26=(($25)|0)!=0;
      if ($26) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 12; break;
    case 6: 
      var $29=$3;
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $32=$in;
      var $33=$3;
      var $34=_ir_instr_op($32, 0, $33, 0);
      if ($34) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 12; break;
    case 9: 
      var $37=$2;
      var $38=$in;
      var $39=_ir_block_instr_add($37, $38);
      if ($39) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 12; break;
    case 11: 
      $1=1;
      __label__ = 12; break;
    case 12: 
      var $43=$1;
      STACKTOP = __stackBase__;
      return $43;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_return["X"]=1;

function _ir_block_create_if($self, $v, $ontrue, $onfalse) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $in;
      $2=$self;
      $3=$v;
      $4=$ontrue;
      $5=$onfalse;
      var $6=$2;
      var $7=(($6+12)|0);
      var $8=HEAP8[($7)];
      var $9=(($8) & 1);
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $11=$2;
      var $12=(($11+4)|0);
      var $13=$2;
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($12)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($12+4)|0);
      var $19=HEAP32[(($18)>>2)];
      _irerror($17, $19, ((STRING_TABLE.__str18232)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$15,tempInt));
      $1=0;
      __label__ = 16; break;
    case 4: 
      var $21=$2;
      var $22=(($21+12)|0);
      HEAP8[($22)]=1;
      var $23=$2;
      var $24=_ir_instr_new($23, 69);
      $in=$24;
      var $25=$in;
      var $26=(($25)|0)!=0;
      if ($26) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 16; break;
    case 6: 
      var $29=$in;
      var $30=$3;
      var $31=_ir_instr_op($29, 0, $30, 0);
      if ($31) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $33=$in;
      _ir_instr_delete($33);
      $1=0;
      __label__ = 16; break;
    case 8: 
      var $35=$4;
      var $36=$in;
      var $37=(($36+24)|0);
      var $38=(($37)|0);
      HEAP32[(($38)>>2)]=$35;
      var $39=$5;
      var $40=$in;
      var $41=(($40+24)|0);
      var $42=(($41+4)|0);
      HEAP32[(($42)>>2)]=$39;
      var $43=$2;
      var $44=$in;
      var $45=_ir_block_instr_add($43, $44);
      if ($45) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 16; break;
    case 10: 
      var $48=$2;
      var $49=$4;
      var $50=_ir_block_exits_add($48, $49);
      if ($50) { __label__ = 11; break; } else { __label__ = 14; break; }
    case 11: 
      var $52=$2;
      var $53=$5;
      var $54=_ir_block_exits_add($52, $53);
      if ($54) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $56=$4;
      var $57=$2;
      var $58=_ir_block_entries_add($56, $57);
      if ($58) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $60=$5;
      var $61=$2;
      var $62=_ir_block_entries_add($60, $61);
      if ($62) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      $1=0;
      __label__ = 16; break;
    case 15: 
      $1=1;
      __label__ = 16; break;
    case 16: 
      var $66=$1;
      STACKTOP = __stackBase__;
      return $66;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_if["X"]=1;

function _ir_block_create_jump($self, $to) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $in;
      $2=$self;
      $3=$to;
      var $4=$2;
      var $5=(($4+12)|0);
      var $6=HEAP8[($5)];
      var $7=(($6) & 1);
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$2;
      var $10=(($9+4)|0);
      var $11=$2;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($10)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($10+4)|0);
      var $17=HEAP32[(($16)>>2)];
      _irerror($15, $17, ((STRING_TABLE.__str18232)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$13,tempInt));
      $1=0;
      __label__ = 12; break;
    case 4: 
      var $19=$2;
      var $20=(($19+12)|0);
      HEAP8[($20)]=1;
      var $21=$2;
      var $22=_ir_instr_new($21, 68);
      $in=$22;
      var $23=$in;
      var $24=(($23)|0)!=0;
      if ($24) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 12; break;
    case 6: 
      var $27=$3;
      var $28=$in;
      var $29=(($28+24)|0);
      var $30=(($29)|0);
      HEAP32[(($30)>>2)]=$27;
      var $31=$2;
      var $32=$in;
      var $33=_ir_block_instr_add($31, $32);
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 12; break;
    case 8: 
      var $36=$2;
      var $37=$3;
      var $38=_ir_block_exits_add($36, $37);
      if ($38) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $40=$3;
      var $41=$2;
      var $42=_ir_block_entries_add($40, $41);
      if ($42) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 12; break;
    case 11: 
      $1=1;
      __label__ = 12; break;
    case 12: 
      var $46=$1;
      STACKTOP = __stackBase__;
      return $46;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_jump["X"]=1;

function _ir_block_create_call($self, $label, $func) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $out;
      var $in;
      $2=$self;
      $3=$label;
      $4=$func;
      var $5=$2;
      var $6=_ir_instr_new($5, 51);
      $in=$6;
      var $7=$in;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $11=$2;
      var $12=(($11+76)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$3;
      var $15=$4;
      var $16=(($15+24)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17)|0)==0;
      var $19=$18 ? 4 : 3;
      var $20=$4;
      var $21=(($20+24)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=_ir_value_out($13, $14, $19, $22);
      $out=$23;
      var $24=$out;
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $27=$in;
      _ir_instr_delete($27);
      $1=0;
      __label__ = 11; break;
    case 6: 
      var $29=$in;
      var $30=$out;
      var $31=_ir_instr_op($29, 0, $30, 1);
      if ($31) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $33=$in;
      var $34=$4;
      var $35=_ir_instr_op($33, 1, $34, 0);
      if ($35) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $37=$2;
      var $38=$in;
      var $39=_ir_block_instr_add($37, $38);
      if ($39) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $41=$in;
      _ir_instr_delete($41);
      var $42=$out;
      _ir_value_delete($42);
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $44=$in;
      $1=$44;
      __label__ = 11; break;
    case 11: 
      var $46=$1;
      ;
      return $46;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_call["X"]=1;

function _ir_block_enumerate($self, $_eid) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $eid;
      $1=$self;
      $2=$_eid;
      var $3=$2;
      var $4=HEAP32[(($3)>>2)];
      $eid=$4;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$1;
      var $8=(($7+20)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)>>>0) < (($9)>>>0);
      if ($10) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $12=$eid;
      var $13=((($12)+(1))|0);
      $eid=$13;
      var $14=$i;
      var $15=$1;
      var $16=(($15+16)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17+($14<<2))|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($19+56)|0);
      HEAP32[(($20)>>2)]=$12;
      __label__ = 5; break;
    case 5: 
      var $22=$i;
      var $23=((($22)+(1))|0);
      $i=$23;
      __label__ = 3; break;
    case 6: 
      var $25=$eid;
      var $26=$2;
      HEAP32[(($26)>>2)]=$25;
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_call_param($self, $v) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$self;
      $3=$v;
      var $4=$2;
      var $5=$3;
      var $6=_ir_instr_params_add($4, $5);
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $9=$3;
      var $10=$2;
      var $11=_ir_value_reads_add($9, $10);
      if ($11) { __label__ = 10; break; } else { __label__ = 5; break; }
    case 5: 
      var $13=$2;
      var $14=$2;
      var $15=(($14+48)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=((($16)-(1))|0);
      var $18=_ir_instr_params_remove($13, $17);
      if ($18) { __label__ = 9; break; } else { __label__ = 6; break; }
    case 6: 
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      $1=0;
      __label__ = 11; break;
    case 10: 
      $1=1;
      __label__ = 11; break;
    case 11: 
      var $25=$1;
      ;
      return $25;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_create_binop($self, $label, $opcode, $left, $right) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $ot;
      $2=$self;
      $3=$label;
      $4=$opcode;
      $5=$left;
      $6=$right;
      $ot=0;
      var $7=$4;
      if ((($7)|0) == 6 || (($7)|0) == 8 || (($7)|0) == 5 || (($7)|0) == 1 || (($7)|0) == 2 || (($7)|0) == 62 || (($7)|0) == 63 || (($7)|0) == 64 || (($7)|0) == 65) {
        __label__ = 3; break;
      }
      else if ((($7)|0) == 7 || (($7)|0) == 9 || (($7)|0) == 4 || (($7)|0) == 3) {
        __label__ = 4; break;
      }
      else {
      __label__ = 5; break;
      }
      
    case 3: 
      $ot=2;
      __label__ = 13; break;
    case 4: 
      $ot=3;
      __label__ = 13; break;
    case 5: 
      var $11=$4;
      var $12=(($11)|0) >= 10;
      if ($12) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $14=$4;
      var $15=(($14)|0) <= 23;
      if ($15) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      $ot=2;
      __label__ = 12; break;
    case 8: 
      var $18=$4;
      var $19=(($18)|0) >= 20;
      if ($19) { __label__ = 9; break; } else { __label__ = 11; break; }
    case 9: 
      var $21=$4;
      var $22=(($21)|0) <= 23;
      if ($22) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      $ot=2;
      __label__ = 11; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $27=$ot;
      var $28=(($27)|0)==0;
      if ($28) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      $1=0;
      __label__ = 16; break;
    case 15: 
      var $31=$2;
      var $32=$3;
      var $33=$4;
      var $34=$5;
      var $35=$6;
      var $36=$ot;
      var $37=_ir_block_create_general_instr($31, $32, $33, $34, $35, $36);
      $1=$37;
      __label__ = 16; break;
    case 16: 
      var $39=$1;
      ;
      return $39;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_binop["X"]=1;

function _ir_block_create_general_instr($self, $label, $op, $a, $b, $outype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $7;
      var $instr;
      var $out;
      $2=$self;
      $3=$label;
      $4=$op;
      $5=$a;
      $6=$b;
      $7=$outype;
      var $8=$2;
      var $9=(($8+76)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=$3;
      var $12=$7;
      var $13=_ir_value_out($10, $11, 3, $12);
      $out=$13;
      var $14=$out;
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 14; break;
    case 4: 
      var $18=$2;
      var $19=$4;
      var $20=_ir_instr_new($18, $19);
      $instr=$20;
      var $21=$instr;
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $24=$out;
      _ir_value_delete($24);
      $1=0;
      __label__ = 14; break;
    case 6: 
      var $26=$instr;
      var $27=$out;
      var $28=_ir_instr_op($26, 0, $27, 1);
      if ($28) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $30=$instr;
      var $31=$5;
      var $32=_ir_instr_op($30, 1, $31, 0);
      if ($32) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $34=$instr;
      var $35=$6;
      var $36=_ir_instr_op($34, 2, $35, 0);
      if ($36) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      __label__ = 13; break;
    case 10: 
      var $39=$2;
      var $40=$instr;
      var $41=_ir_block_instr_add($39, $40);
      if ($41) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      __label__ = 13; break;
    case 12: 
      var $44=$out;
      $1=$44;
      __label__ = 14; break;
    case 13: 
      var $46=$instr;
      _ir_instr_delete($46);
      var $47=$out;
      _ir_value_delete($47);
      $1=0;
      __label__ = 14; break;
    case 14: 
      var $49=$1;
      ;
      return $49;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_general_instr["X"]=1;

function _ir_block_create_unary($self, $label, $opcode, $operand) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $ot;
      $2=$self;
      $3=$label;
      $4=$opcode;
      $5=$operand;
      $ot=2;
      var $6=$4;
      if ((($6)|0) == 44 || (($6)|0) == 45 || (($6)|0) == 46 || (($6)|0) == 47 || (($6)|0) == 48) {
        __label__ = 3; break;
      }
      else {
      __label__ = 4; break;
      }
      
    case 3: 
      $ot=2;
      __label__ = 5; break;
    case 4: 
      var $9=$5;
      var $10=(($9+4)|0);
      var $11=HEAP32[(($10)>>2)];
      $ot=$11;
      __label__ = 5; break;
    case 5: 
      var $13=$ot;
      var $14=(($13)|0)==0;
      if ($14) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      $1=0;
      __label__ = 8; break;
    case 7: 
      var $17=$2;
      var $18=$3;
      var $19=$4;
      var $20=$5;
      var $21=$ot;
      var $22=_ir_block_create_general_instr($17, $18, $19, $20, 0, $21);
      $1=$22;
      __label__ = 8; break;
    case 8: 
      var $24=$1;
      ;
      return $24;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_create_fieldaddress($self, $label, $ent, $field) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $v;
      $2=$self;
      $3=$label;
      $4=$ent;
      $5=$field;
      var $6=$4;
      var $7=(($6+4)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|0)!=4;
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $12=$5;
      var $13=(($12+4)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=5;
      if ($15) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $18=$2;
      var $19=$3;
      var $20=$4;
      var $21=$5;
      var $22=_ir_block_create_general_instr($18, $19, 30, $20, $21, 7);
      $v=$22;
      var $23=$5;
      var $24=(($23+20)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=$v;
      var $27=(($26+20)|0);
      HEAP32[(($27)>>2)]=$25;
      var $28=$v;
      $1=$28;
      __label__ = 7; break;
    case 7: 
      var $30=$1;
      ;
      return $30;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_block_create_load_from_ent($self, $label, $ent, $field, $outype) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $op;
      $2=$self;
      $3=$label;
      $4=$ent;
      $5=$field;
      $6=$outype;
      var $7=$4;
      var $8=(($7+4)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($9)|0)!=4;
      if ($10) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 15; break;
    case 4: 
      var $13=$5;
      var $14=(($13+4)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=5;
      if ($16) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 15; break;
    case 6: 
      var $19=$6;
      if ((($19)|0) == 2) {
        __label__ = 7; break;
      }
      else if ((($19)|0) == 3) {
        __label__ = 8; break;
      }
      else if ((($19)|0) == 1) {
        __label__ = 9; break;
      }
      else if ((($19)|0) == 5) {
        __label__ = 10; break;
      }
      else if ((($19)|0) == 4) {
        __label__ = 11; break;
      }
      else if ((($19)|0) == 6) {
        __label__ = 12; break;
      }
      else {
      __label__ = 13; break;
      }
      
    case 7: 
      $op=24;
      __label__ = 14; break;
    case 8: 
      $op=25;
      __label__ = 14; break;
    case 9: 
      $op=26;
      __label__ = 14; break;
    case 10: 
      $op=28;
      __label__ = 14; break;
    case 11: 
      $op=27;
      __label__ = 14; break;
    case 12: 
      $op=29;
      __label__ = 14; break;
    case 13: 
      $1=0;
      __label__ = 15; break;
    case 14: 
      var $28=$2;
      var $29=$3;
      var $30=$op;
      var $31=$4;
      var $32=$5;
      var $33=$6;
      var $34=_ir_block_create_general_instr($28, $29, $30, $31, $32, $33);
      $1=$34;
      __label__ = 15; break;
    case 15: 
      var $36=$1;
      ;
      return $36;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_create_load_from_ent["X"]=1;

function _ir_block_naive_phi($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $p;
      var $w;
      var $instr;
      var $v;
      var $old;
      var $r;
      var $op;
      var $ri;
      $2=$self;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $4=$i;
      var $5=$2;
      var $6=(($5+20)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)>>>0) < (($7)>>>0);
      if ($8) { __label__ = 4; break; } else { __label__ = 48; break; }
    case 4: 
      var $10=$i;
      var $11=$2;
      var $12=(($11+16)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      $instr=$15;
      var $16=$instr;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)!=67;
      if ($19) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      __label__ = 47; break;
    case 6: 
      var $22=$2;
      var $23=$i;
      var $24=_ir_block_instr_remove($22, $23);
      if ($24) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 49; break;
    case 8: 
      var $27=$i;
      var $28=((($27)-(1))|0);
      $i=$28;
      $p=0;
      __label__ = 9; break;
    case 9: 
      var $30=$p;
      var $31=$instr;
      var $32=(($31+36)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($30)>>>0) < (($33)>>>0);
      if ($34) { __label__ = 10; break; } else { __label__ = 46; break; }
    case 10: 
      var $36=$p;
      var $37=$instr;
      var $38=(($37+32)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($39+($36<<3))|0);
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      $v=$42;
      $w=0;
      __label__ = 11; break;
    case 11: 
      var $44=$w;
      var $45=$v;
      var $46=(($45+44)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($44)>>>0) < (($47)>>>0);
      if ($48) { __label__ = 12; break; } else { __label__ = 44; break; }
    case 12: 
      var $50=$w;
      var $51=$v;
      var $52=(($51+40)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($53+($50<<2))|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=(($55+12)|0);
      var $57=(($56)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58)|0)!=0;
      if ($59) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      __label__ = 43; break;
    case 14: 
      var $62=$w;
      var $63=$v;
      var $64=(($63+40)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($65+($62<<2))|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=(($67+12)|0);
      var $69=(($68)|0);
      var $70=HEAP32[(($69)>>2)];
      $old=$70;
      var $71=$w;
      var $72=$v;
      var $73=(($72+40)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=(($74+($71<<2))|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($76+12)|0);
      var $78=(($77)|0);
      var $79=HEAP32[(($78)>>2)];
      var $80=$v;
      var $81=(($79)|0)==(($80)|0);
      if ($81) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $83=$instr;
      var $84=(($83+12)|0);
      var $85=(($84)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=$w;
      var $88=$v;
      var $89=(($88+40)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=(($90+($87<<2))|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=(($92+12)|0);
      var $94=(($93)|0);
      HEAP32[(($94)>>2)]=$86;
      __label__ = 16; break;
    case 16: 
      var $96=$old;
      var $97=(($96+8)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=(($98)|0)!=3;
      if ($99) { __label__ = 17; break; } else { __label__ = 25; break; }
    case 17: 
      var $101=$old;
      var $102=(($101+8)|0);
      var $103=HEAP32[(($102)>>2)];
      var $104=(($103)|0)!=1;
      if ($104) { __label__ = 18; break; } else { __label__ = 25; break; }
    case 18: 
      var $106=$old;
      var $107=(($106+8)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($108)|0)!=2;
      if ($109) { __label__ = 19; break; } else { __label__ = 25; break; }
    case 19: 
      var $111=$2;
      var $112=$i;
      var $113=((($112)+(1))|0);
      var $114=$old;
      var $115=$v;
      var $116=_ir_naive_phi_emit_store($111, $113, $114, $115);
      if ($116) { __label__ = 21; break; } else { __label__ = 20; break; }
    case 20: 
      $1=0;
      __label__ = 49; break;
    case 21: 
      var $119=$i;
      var $120=((($119)+(1))|0);
      var $121=$2;
      var $122=(($121+20)|0);
      var $123=HEAP32[(($122)>>2)];
      var $124=(($120)>>>0) < (($123)>>>0);
      if ($124) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $126=$i;
      var $127=((($126)+(1))|0);
      var $128=$2;
      var $129=(($128+16)|0);
      var $130=HEAP32[(($129)>>2)];
      var $131=(($130+($127<<2))|0);
      var $132=HEAP32[(($131)>>2)];
      $instr=$132;
      __label__ = 24; break;
    case 23: 
      $instr=0;
      __label__ = 24; break;
    case 24: 
      __label__ = 42; break;
    case 25: 
      $r=0;
      __label__ = 26; break;
    case 26: 
      var $137=$r;
      var $138=$old;
      var $139=(($138+32)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=(($137)>>>0) < (($140)>>>0);
      if ($141) { __label__ = 27; break; } else { __label__ = 41; break; }
    case 27: 
      var $143=$r;
      var $144=$old;
      var $145=(($144+28)|0);
      var $146=HEAP32[(($145)>>2)];
      var $147=(($146+($143<<2))|0);
      var $148=HEAP32[(($147)>>2)];
      $ri=$148;
      $op=0;
      __label__ = 28; break;
    case 28: 
      var $150=$op;
      var $151=$ri;
      var $152=(($151+36)|0);
      var $153=HEAP32[(($152)>>2)];
      var $154=(($150)>>>0) < (($153)>>>0);
      if ($154) { __label__ = 29; break; } else { __label__ = 33; break; }
    case 29: 
      var $156=$op;
      var $157=$ri;
      var $158=(($157+32)|0);
      var $159=HEAP32[(($158)>>2)];
      var $160=(($159+($156<<3))|0);
      var $161=(($160)|0);
      var $162=HEAP32[(($161)>>2)];
      var $163=$old;
      var $164=(($162)|0)==(($163)|0);
      if ($164) { __label__ = 30; break; } else { __label__ = 31; break; }
    case 30: 
      var $166=$v;
      var $167=$op;
      var $168=$ri;
      var $169=(($168+32)|0);
      var $170=HEAP32[(($169)>>2)];
      var $171=(($170+($167<<3))|0);
      var $172=(($171)|0);
      HEAP32[(($172)>>2)]=$166;
      __label__ = 31; break;
    case 31: 
      __label__ = 32; break;
    case 32: 
      var $175=$op;
      var $176=((($175)+(1))|0);
      $op=$176;
      __label__ = 28; break;
    case 33: 
      $op=0;
      __label__ = 34; break;
    case 34: 
      var $179=$op;
      var $180=(($179)>>>0) < 3;
      if ($180) { __label__ = 35; break; } else { __label__ = 39; break; }
    case 35: 
      var $182=$op;
      var $183=$ri;
      var $184=(($183+12)|0);
      var $185=(($184+($182<<2))|0);
      var $186=HEAP32[(($185)>>2)];
      var $187=$old;
      var $188=(($186)|0)==(($187)|0);
      if ($188) { __label__ = 36; break; } else { __label__ = 37; break; }
    case 36: 
      var $190=$v;
      var $191=$op;
      var $192=$ri;
      var $193=(($192+12)|0);
      var $194=(($193+($191<<2))|0);
      HEAP32[(($194)>>2)]=$190;
      __label__ = 37; break;
    case 37: 
      __label__ = 38; break;
    case 38: 
      var $197=$op;
      var $198=((($197)+(1))|0);
      $op=$198;
      __label__ = 34; break;
    case 39: 
      __label__ = 40; break;
    case 40: 
      var $201=$r;
      var $202=((($201)+(1))|0);
      $r=$202;
      __label__ = 26; break;
    case 41: 
      __label__ = 42; break;
    case 42: 
      __label__ = 43; break;
    case 43: 
      var $206=$w;
      var $207=((($206)+(1))|0);
      $w=$207;
      __label__ = 11; break;
    case 44: 
      __label__ = 45; break;
    case 45: 
      var $210=$p;
      var $211=((($210)+(1))|0);
      $p=$211;
      __label__ = 9; break;
    case 46: 
      var $213=$instr;
      _ir_instr_delete($213);
      __label__ = 47; break;
    case 47: 
      var $215=$i;
      var $216=((($215)+(1))|0);
      $i=$216;
      __label__ = 3; break;
    case 48: 
      $1=1;
      __label__ = 49; break;
    case 49: 
      var $219=$1;
      ;
      return $219;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_naive_phi["X"]=1;

function _ir_block_life_propagate($self, $prev, $changed) {
  var __stackBase__  = STACKTOP; STACKTOP += 28; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $instr;
      var $value;
      var $tempbool;
      var $i;
      var $o;
      var $p;
      var $read=__stackBase__;
      var $write=(__stackBase__)+(4);
      var $dbg_ind=(__stackBase__)+(8);
      var $idx=(__stackBase__)+(24);
      var $in_living;
      var $entry;
      $2=$self;
      $3=$prev;
      $4=$changed;
      var $5=$dbg_ind;
      assert(16 % 1 === 0, 'memcpy given ' + 16 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');for (var $$src = ((STRING_TABLE._ir_block_life_propagate_dbg_ind)|0), $$dest = $5, $$stop = $$src + 16; $$src < $$stop; $$src++, $$dest++) {
        HEAP8[$$dest] = HEAP8[$$src]
      };
      var $6=(($dbg_ind)|0);
      var $7=$3;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $10=$2;
      var $11=$3;
      var $12=$4;
      var $13=_ir_block_life_prop_previous($10, $11, $12);
      if ($13) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      $1=0;
      __label__ = 73; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $17=$2;
      var $18=(($17+20)|0);
      var $19=HEAP32[(($18)>>2)];
      $i=$19;
      __label__ = 7; break;
    case 7: 
      var $21=$i;
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 8; break; } else { __label__ = 66; break; }
    case 8: 
      var $24=$i;
      var $25=((($24)-(1))|0);
      $i=$25;
      var $26=$i;
      var $27=$2;
      var $28=(($27+16)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+($26<<2))|0);
      var $31=HEAP32[(($30)>>2)];
      $instr=$31;
      $p=0;
      __label__ = 9; break;
    case 9: 
      var $33=$p;
      var $34=$instr;
      var $35=(($34+36)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($33)>>>0) < (($36)>>>0);
      if ($37) { __label__ = 10; break; } else { __label__ = 17; break; }
    case 10: 
      var $39=$p;
      var $40=$instr;
      var $41=(($40+32)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=(($42+($39<<3))|0);
      var $44=(($43)|0);
      var $45=HEAP32[(($44)>>2)];
      $value=$45;
      var $46=$value;
      var $47=(($46+96)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48)|0)!=0;
      if ($49) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $51=$value;
      var $52=(($51+96)|0);
      var $53=HEAP32[(($52)>>2)];
      $value=$53;
      __label__ = 12; break;
    case 12: 
      var $55=$2;
      var $56=$value;
      var $57=_ir_block_living_find($55, $56, 0);
      if ($57) { __label__ = 15; break; } else { __label__ = 13; break; }
    case 13: 
      var $59=$2;
      var $60=$value;
      var $61=_ir_block_living_add($59, $60);
      if ($61) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      $1=0;
      __label__ = 73; break;
    case 15: 
      __label__ = 16; break;
    case 16: 
      var $65=$p;
      var $66=((($65)+(1))|0);
      $p=$66;
      __label__ = 9; break;
    case 17: 
      $p=0;
      __label__ = 18; break;
    case 18: 
      var $69=$p;
      var $70=$instr;
      var $71=(($70+48)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=(($69)>>>0) < (($72)>>>0);
      if ($73) { __label__ = 19; break; } else { __label__ = 26; break; }
    case 19: 
      var $75=$p;
      var $76=$instr;
      var $77=(($76+44)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($78+($75<<2))|0);
      var $80=HEAP32[(($79)>>2)];
      $value=$80;
      var $81=$value;
      var $82=(($81+96)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=(($83)|0)!=0;
      if ($84) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      var $86=$value;
      var $87=(($86+96)|0);
      var $88=HEAP32[(($87)>>2)];
      $value=$88;
      __label__ = 21; break;
    case 21: 
      var $90=$2;
      var $91=$value;
      var $92=_ir_block_living_find($90, $91, 0);
      if ($92) { __label__ = 24; break; } else { __label__ = 22; break; }
    case 22: 
      var $94=$2;
      var $95=$value;
      var $96=_ir_block_living_add($94, $95);
      if ($96) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      $1=0;
      __label__ = 73; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $100=$p;
      var $101=((($100)+(1))|0);
      $p=$101;
      __label__ = 18; break;
    case 26: 
      var $103=$instr;
      var $104=(($103)|0);
      var $105=HEAP32[(($104)>>2)];
      _ir_op_read_write($105, $read, $write);
      var $106=$instr;
      var $107=(($106)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($108)|0)==4;
      if ($109) { __label__ = 27; break; } else { __label__ = 30; break; }
    case 27: 
      var $111=$instr;
      var $112=(($111+12)|0);
      var $113=(($112+8)|0);
      var $114=HEAP32[(($113)>>2)];
      var $115=$instr;
      var $116=(($115+56)|0);
      var $117=HEAP32[(($116)>>2)];
      var $118=((($117)+(1))|0);
      var $119=_ir_value_life_merge($114, $118);
      var $120=(($119)&1);
      $tempbool=$120;
      var $121=$4;
      var $122=HEAP8[($121)];
      var $123=(($122) & 1);
      if ($123) { var $128 = 1;__label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      var $125=$tempbool;
      var $126=(($125) & 1);
      var $128 = $126;__label__ = 29; break;
    case 29: 
      var $128;
      var $129=$4;
      var $130=(($128)&1);
      HEAP8[($129)]=$130;
      __label__ = 35; break;
    case 30: 
      var $132=$instr;
      var $133=(($132)|0);
      var $134=HEAP32[(($133)>>2)];
      var $135=(($134)|0)==3;
      if ($135) { __label__ = 31; break; } else { __label__ = 34; break; }
    case 31: 
      var $137=$instr;
      var $138=(($137+12)|0);
      var $139=(($138+4)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=$instr;
      var $142=(($141+56)|0);
      var $143=HEAP32[(($142)>>2)];
      var $144=((($143)+(1))|0);
      var $145=_ir_value_life_merge($140, $144);
      var $146=(($145)&1);
      $tempbool=$146;
      var $147=$4;
      var $148=HEAP8[($147)];
      var $149=(($148) & 1);
      if ($149) { var $154 = 1;__label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      var $151=$tempbool;
      var $152=(($151) & 1);
      var $154 = $152;__label__ = 33; break;
    case 33: 
      var $154;
      var $155=$4;
      var $156=(($154)&1);
      HEAP8[($155)]=$156;
      __label__ = 34; break;
    case 34: 
      __label__ = 35; break;
    case 35: 
      $o=0;
      __label__ = 36; break;
    case 36: 
      var $160=$o;
      var $161=(($160)>>>0) < 3;
      if ($161) { __label__ = 37; break; } else { __label__ = 63; break; }
    case 37: 
      var $163=$o;
      var $164=$instr;
      var $165=(($164+12)|0);
      var $166=(($165+($163<<2))|0);
      var $167=HEAP32[(($166)>>2)];
      var $168=(($167)|0)!=0;
      if ($168) { __label__ = 39; break; } else { __label__ = 38; break; }
    case 38: 
      __label__ = 62; break;
    case 39: 
      var $171=$o;
      var $172=$instr;
      var $173=(($172+12)|0);
      var $174=(($173+($171<<2))|0);
      var $175=HEAP32[(($174)>>2)];
      $value=$175;
      var $176=$value;
      var $177=(($176+96)|0);
      var $178=HEAP32[(($177)>>2)];
      var $179=(($178)|0)!=0;
      if ($179) { __label__ = 40; break; } else { __label__ = 41; break; }
    case 40: 
      var $181=$value;
      var $182=(($181+96)|0);
      var $183=HEAP32[(($182)>>2)];
      $value=$183;
      __label__ = 41; break;
    case 41: 
      var $185=$value;
      var $186=(($185+8)|0);
      var $187=HEAP32[(($186)>>2)];
      var $188=(($187)|0)!=3;
      if ($188) { __label__ = 42; break; } else { __label__ = 45; break; }
    case 42: 
      var $190=$value;
      var $191=(($190+8)|0);
      var $192=HEAP32[(($191)>>2)];
      var $193=(($192)|0)!=1;
      if ($193) { __label__ = 43; break; } else { __label__ = 45; break; }
    case 43: 
      var $195=$value;
      var $196=(($195+8)|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=(($197)|0)!=2;
      if ($198) { __label__ = 44; break; } else { __label__ = 45; break; }
    case 44: 
      __label__ = 62; break;
    case 45: 
      var $201=HEAP32[(($read)>>2)];
      var $202=$o;
      var $203=1 << $202;
      var $204=$201 & $203;
      var $205=(($204)|0)!=0;
      if ($205) { __label__ = 46; break; } else { __label__ = 50; break; }
    case 46: 
      var $207=$2;
      var $208=$value;
      var $209=_ir_block_living_find($207, $208, 0);
      if ($209) { __label__ = 49; break; } else { __label__ = 47; break; }
    case 47: 
      var $211=$2;
      var $212=$value;
      var $213=_ir_block_living_add($211, $212);
      if ($213) { __label__ = 49; break; } else { __label__ = 48; break; }
    case 48: 
      $1=0;
      __label__ = 73; break;
    case 49: 
      __label__ = 50; break;
    case 50: 
      var $217=HEAP32[(($write)>>2)];
      var $218=$o;
      var $219=1 << $218;
      var $220=$217 & $219;
      var $221=(($220)|0)!=0;
      if ($221) { __label__ = 51; break; } else { __label__ = 61; break; }
    case 51: 
      var $223=$2;
      var $224=$value;
      var $225=_ir_block_living_find($223, $224, $idx);
      var $226=(($225)&1);
      $in_living=$226;
      var $227=$in_living;
      var $228=(($227) & 1);
      if ($228) { __label__ = 55; break; } else { __label__ = 52; break; }
    case 52: 
      var $230=$value;
      var $231=$instr;
      var $232=(($231+56)|0);
      var $233=HEAP32[(($232)>>2)];
      var $234=_ir_value_life_merge($230, $233);
      var $235=(($234)&1);
      $tempbool=$235;
      var $236=$4;
      var $237=HEAP8[($236)];
      var $238=(($237) & 1);
      if ($238) { var $243 = 1;__label__ = 54; break; } else { __label__ = 53; break; }
    case 53: 
      var $240=$tempbool;
      var $241=(($240) & 1);
      var $243 = $241;__label__ = 54; break;
    case 54: 
      var $243;
      var $244=$4;
      var $245=(($243)&1);
      HEAP8[($244)]=$245;
      __label__ = 60; break;
    case 55: 
      var $247=$value;
      var $248=$instr;
      var $249=(($248+56)|0);
      var $250=HEAP32[(($249)>>2)];
      var $251=_ir_value_life_merge($247, $250);
      var $252=(($251)&1);
      $tempbool=$252;
      var $253=$4;
      var $254=HEAP8[($253)];
      var $255=(($254) & 1);
      if ($255) { var $260 = 1;__label__ = 57; break; } else { __label__ = 56; break; }
    case 56: 
      var $257=$tempbool;
      var $258=(($257) & 1);
      var $260 = $258;__label__ = 57; break;
    case 57: 
      var $260;
      var $261=$4;
      var $262=(($260)&1);
      HEAP8[($261)]=$262;
      var $263=$2;
      var $264=HEAP32[(($idx)>>2)];
      var $265=_ir_block_living_remove($263, $264);
      if ($265) { __label__ = 59; break; } else { __label__ = 58; break; }
    case 58: 
      $1=0;
      __label__ = 73; break;
    case 59: 
      __label__ = 60; break;
    case 60: 
      __label__ = 61; break;
    case 61: 
      __label__ = 62; break;
    case 62: 
      var $271=$o;
      var $272=((($271)+(1))|0);
      $o=$272;
      __label__ = 36; break;
    case 63: 
      var $274=$2;
      var $275=$instr;
      var $276=(($275+56)|0);
      var $277=HEAP32[(($276)>>2)];
      var $278=_ir_block_living_add_instr($274, $277);
      var $279=(($278)&1);
      $tempbool=$279;
      var $280=$4;
      var $281=HEAP8[($280)];
      var $282=(($281) & 1);
      if ($282) { var $287 = 1;__label__ = 65; break; } else { __label__ = 64; break; }
    case 64: 
      var $284=$tempbool;
      var $285=(($284) & 1);
      var $287 = $285;__label__ = 65; break;
    case 65: 
      var $287;
      var $288=$4;
      var $289=(($287)&1);
      HEAP8[($288)]=$289;
      __label__ = 7; break;
    case 66: 
      var $291=$2;
      var $292=(($291+72)|0);
      var $293=HEAP32[(($292)>>2)];
      var $294=$2;
      var $295=(($294+76)|0);
      var $296=HEAP32[(($295)>>2)];
      var $297=(($296+88)|0);
      var $298=HEAP32[(($297)>>2)];
      var $299=(($293)|0)==(($298)|0);
      if ($299) { __label__ = 67; break; } else { __label__ = 68; break; }
    case 67: 
      $1=1;
      __label__ = 73; break;
    case 68: 
      var $302=$2;
      var $303=(($302+76)|0);
      var $304=HEAP32[(($303)>>2)];
      var $305=(($304+88)|0);
      var $306=HEAP32[(($305)>>2)];
      var $307=$2;
      var $308=(($307+72)|0);
      HEAP32[(($308)>>2)]=$306;
      $i=0;
      __label__ = 69; break;
    case 69: 
      var $310=$i;
      var $311=$2;
      var $312=(($311+32)|0);
      var $313=HEAP32[(($312)>>2)];
      var $314=(($310)>>>0) < (($313)>>>0);
      if ($314) { __label__ = 70; break; } else { __label__ = 72; break; }
    case 70: 
      var $316=$i;
      var $317=$2;
      var $318=(($317+28)|0);
      var $319=HEAP32[(($318)>>2)];
      var $320=(($319+($316<<2))|0);
      var $321=HEAP32[(($320)>>2)];
      $entry=$321;
      var $322=$entry;
      var $323=$2;
      var $324=$4;
      var $325=_ir_block_life_propagate($322, $323, $324);
      __label__ = 71; break;
    case 71: 
      var $327=$i;
      var $328=((($327)+(1))|0);
      $i=$328;
      __label__ = 69; break;
    case 72: 
      $1=1;
      __label__ = 73; break;
    case 73: 
      var $331=$1;
      STACKTOP = __stackBase__;
      return $331;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_life_propagate["X"]=1;

function _irwarning($ctx_0, $ctx_1, $warntype, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $ap=(__stackBase__)+(8);
      var $lvl;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$warntype;
      $3=$fmt;
      $lvl=1;
      var $6=$2;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $9=$2;
      var $10=((((($9)|0))/(32))&-1);
      var $11=((_opts_warn+($10<<2))|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=$2;
      var $14=((($13)|0))%(32);
      var $15=1 << $14;
      var $16=$12 & $15;
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      $1=0;
      __label__ = 8; break;
    case 5: 
      var $20=HEAP8[(_opts_werror)];
      var $21=(($20) & 1);
      if ($21) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      $lvl=2;
      __label__ = 7; break;
    case 7: 
      var $24=$ap;
      HEAP32[(($24)>>2)]=arguments[_irwarning.length];
      var $25=$lvl;
      var $26=(($ctx)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($ctx+4)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=$3;
      var $31=HEAP32[(($ap)>>2)];
      _vprintmsg($25, $27, $29, ((STRING_TABLE.__str85299)|0), $30, $31);
      var $32=$ap;
      ;
      var $33=HEAP8[(_opts_werror)];
      var $34=(($33) & 1);
      $1=$34;
      __label__ = 8; break;
    case 8: 
      var $36=$1;
      STACKTOP = __stackBase__;
      return $36;
    default: assert(0, "bad label: " + __label__);
  }
}
_irwarning["X"]=1;

function _function_allocator_locals_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+8)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+8)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+8)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+8)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+8)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 1925, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+4)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 1925, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_function_allocator_locals_add["X"]=1;

function _function_allocator_sizes_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+16)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+20)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+20)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+20)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+20)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 1926, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+12)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+16)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+12)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 1926, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+12)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+16)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+12)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_function_allocator_sizes_add["X"]=1;

function _function_allocator_positions_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+28)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+32)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+32)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+32)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+32)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+32)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 1927, ((STRING_TABLE.__str9222)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+24)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+28)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+24)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 1927, ((STRING_TABLE.__str9222)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+24)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+28)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+24)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_function_allocator_positions_add["X"]=1;

function _function_allocator_alloc($alloc, $var) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $slot;
      var $vsize;
      $2=$alloc;
      $3=$var;
      var $4=$3;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=((_type_sizeof+($6<<2))|0);
      var $8=HEAP32[(($7)>>2)];
      $vsize=$8;
      var $9=$3;
      var $10=(($9+4)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=_ir_value_var(((STRING_TABLE.__str84298)|0), 0, $11);
      $slot=$12;
      var $13=$slot;
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 12; break;
    case 4: 
      var $17=$slot;
      var $18=$3;
      var $19=_ir_value_life_merge_into($17, $18);
      if ($19) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      __label__ = 11; break;
    case 6: 
      var $22=$2;
      var $23=$slot;
      var $24=_function_allocator_locals_add($22, $23);
      if ($24) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      __label__ = 11; break;
    case 8: 
      var $27=$2;
      var $28=$vsize;
      var $29=_function_allocator_sizes_add($27, $28);
      if ($29) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      __label__ = 11; break;
    case 10: 
      $1=1;
      __label__ = 12; break;
    case 11: 
      var $33=$slot;
      _ir_value_delete($33);
      $1=0;
      __label__ = 12; break;
    case 12: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_builder_generate($self, $filename) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $stmt=__stackBase__;
      var $i;
      $2=$self;
      $3=$filename;
      _code_init();
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+20)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$2;
      var $12=$i;
      var $13=$2;
      var $14=(($13+16)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15+($12<<2))|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=_ir_builder_gen_global($11, $17, 0);
      if ($18) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 25; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $22=$i;
      var $23=((($22)+(1))|0);
      $i=$23;
      __label__ = 3; break;
    case 8: 
      $i=0;
      __label__ = 9; break;
    case 9: 
      var $26=$i;
      var $27=$2;
      var $28=(($27+32)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($26)>>>0) < (($29)>>>0);
      if ($30) { __label__ = 10; break; } else { __label__ = 14; break; }
    case 10: 
      var $32=$2;
      var $33=$i;
      var $34=$2;
      var $35=(($34+28)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36+($33<<2))|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=_ir_builder_gen_field($32, $38);
      if ($39) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=0;
      __label__ = 25; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $43=$i;
      var $44=((($43)+(1))|0);
      $i=$44;
      __label__ = 9; break;
    case 14: 
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $47=$i;
      var $48=$2;
      var $49=(($48+20)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($47)>>>0) < (($50)>>>0);
      if ($51) { __label__ = 16; break; } else { __label__ = 22; break; }
    case 16: 
      var $53=$i;
      var $54=$2;
      var $55=(($54+16)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+($53<<2))|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58+4)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60)|0)==6;
      if ($61) { __label__ = 17; break; } else { __label__ = 20; break; }
    case 17: 
      var $63=$2;
      var $64=$i;
      var $65=$2;
      var $66=(($65+16)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=(($67+($64<<2))|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=_gen_global_function_code($63, $69);
      if ($70) { __label__ = 19; break; } else { __label__ = 18; break; }
    case 18: 
      $1=0;
      __label__ = 25; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $75=$i;
      var $76=((($75)+(1))|0);
      $i=$76;
      __label__ = 15; break;
    case 22: 
      var $78=(($stmt)|0);
      HEAP16[(($78)>>1)]=0;
      var $79=(($stmt+2)|0);
      var $80=$79;
      HEAP16[(($80)>>1)]=0;
      var $81=(($stmt+4)|0);
      var $82=$81;
      HEAP16[(($82)>>1)]=0;
      var $83=(($stmt+6)|0);
      var $84=$83;
      HEAP16[(($84)>>1)]=0;
      var $85=_code_statements_add($stmt);
      var $86=(($85)|0) < 0;
      if ($86) { __label__ = 23; break; } else { __label__ = 24; break; }
    case 23: 
      $1=0;
      __label__ = 25; break;
    case 24: 
      var $89=$3;
      var $90=_printf(((STRING_TABLE.__str21235)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$89,tempInt));
      var $91=$3;
      var $92=_code_write($91);
      $1=$92;
      __label__ = 25; break;
    case 25: 
      var $94=$1;
      STACKTOP = __stackBase__;
      return $94;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_generate["X"]=1;

function _ir_builder_gen_global($self, $global, $islocal) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      var $iptr;
      var $def=__stackBase__;
      var $d;
      $2=$self;
      $3=$global;
      var $5=(($islocal)&1);
      $4=$5;
      var $6=$3;
      var $7=(($6+4)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8) & 65535);
      var $10=(($def)|0);
      HEAP16[(($10)>>1)]=$9;
      var $11=HEAP32[((_code_globals_elements)>>2)];
      var $12=(($11) & 65535);
      var $13=(($def+2)|0);
      HEAP16[(($13)>>1)]=$12;
      var $14=$3;
      var $15=(($14)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $19=$3;
      var $20=(($19)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0);
      var $23=HEAP8[($22)];
      var $24=(($23 << 24) >> 24);
      var $25=(($24)|0)==35;
      if ($25) { __label__ = 4; break; } else { __label__ = 7; break; }
    case 4: 
      var $27=$2;
      var $28=(($27+64)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $32=_code_genstring(((STRING_TABLE.__str74288)|0));
      var $33=$2;
      var $34=(($33+64)|0);
      HEAP32[(($34)>>2)]=$32;
      __label__ = 6; break;
    case 6: 
      var $36=$2;
      var $37=(($36+64)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=$3;
      var $40=(($39+68)|0);
      var $41=(($40+4)|0);
      HEAP32[(($41)>>2)]=$38;
      var $42=(($def+4)|0);
      HEAP32[(($42)>>2)]=$38;
      __label__ = 8; break;
    case 7: 
      var $44=$3;
      var $45=(($44)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=_code_genstring($46);
      var $48=$3;
      var $49=(($48+68)|0);
      var $50=(($49+4)|0);
      HEAP32[(($50)>>2)]=$47;
      var $51=(($def+4)|0);
      HEAP32[(($51)>>2)]=$47;
      __label__ = 8; break;
    case 8: 
      __label__ = 10; break;
    case 9: 
      var $54=(($def+4)|0);
      HEAP32[(($54)>>2)]=0;
      __label__ = 10; break;
    case 10: 
      var $56=$3;
      var $57=(($56+4)|0);
      var $58=HEAP32[(($57)>>2)];
      if ((($58)|0) == 0) {
        __label__ = 11; break;
      }
      else if ((($58)|0) == 7) {
        __label__ = 20; break;
      }
      else if ((($58)|0) == 5) {
        __label__ = 23; break;
      }
      else if ((($58)|0) == 4 || (($58)|0) == 2) {
        __label__ = 26; break;
      }
      else if ((($58)|0) == 1) {
        __label__ = 34; break;
      }
      else if ((($58)|0) == 3) {
        __label__ = 42; break;
      }
      else if ((($58)|0) == 6) {
        __label__ = 66; break;
      }
      else if ((($58)|0) == 9) {
        __label__ = 78; break;
      }
      else {
      __label__ = 83; break;
      }
      
    case 11: 
      var $60=$3;
      var $61=(($60)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=_strcmp($62, ((STRING_TABLE.__str75289)|0));
      var $64=(($63)|0)!=0;
      if ($64) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      __label__ = 17; break;
    case 13: 
      var $67=$3;
      var $68=(($67)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=_strcmp($69, ((STRING_TABLE.__str76290)|0));
      var $71=(($70)|0)!=0;
      if ($71) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      __label__ = 16; break;
    case 15: 
      var $74=$3;
      var $75=(($74+12)|0);
      var $76=$3;
      var $77=(($76)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($75)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=(($75+4)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=_irwarning($80, $82, 10, ((STRING_TABLE.__str77291)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$78,tempInt));
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $86=$3;
      var $87=_code_globals_add(0);
      _ir_value_code_setaddr($86, $87);
      var $88=_code_defs_add($def);
      var $89=(($88)|0) < 0;
      if ($89) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      $1=0;
      __label__ = 84; break;
    case 19: 
      $1=1;
      __label__ = 84; break;
    case 20: 
      var $93=_code_defs_add($def);
      var $94=(($93)|0) < 0;
      if ($94) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      $1=0;
      __label__ = 84; break;
    case 22: 
      var $97=$3;
      var $98=_gen_global_pointer($97);
      $1=$98;
      __label__ = 84; break;
    case 23: 
      var $100=_code_defs_add($def);
      var $101=(($100)|0) < 0;
      if ($101) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      $1=0;
      __label__ = 84; break;
    case 25: 
      var $104=$3;
      var $105=_gen_global_field($104);
      $1=$105;
      __label__ = 84; break;
    case 26: 
      var $107=$3;
      var $108=(($107+52)|0);
      var $109=HEAP8[($108)];
      var $110=(($109) & 1);
      if ($110) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      var $112=$3;
      var $113=(($112+56)|0);
      var $114=$113;
      var $115=(($114)|0);
      $iptr=$115;
      var $116=$3;
      var $117=$iptr;
      var $118=HEAP32[(($117)>>2)];
      var $119=_code_globals_add($118);
      _ir_value_code_setaddr($116, $119);
      __label__ = 31; break;
    case 28: 
      var $121=$3;
      var $122=_code_globals_add(0);
      _ir_value_code_setaddr($121, $122);
      var $123=$4;
      var $124=(($123) & 1);
      if ($124) { __label__ = 30; break; } else { __label__ = 29; break; }
    case 29: 
      var $126=(($def)|0);
      var $127=HEAP16[(($126)>>1)];
      var $128=(($127)&65535);
      var $129=$128 | 32768;
      var $130=(($129) & 65535);
      HEAP16[(($126)>>1)]=$130;
      __label__ = 30; break;
    case 30: 
      __label__ = 31; break;
    case 31: 
      var $133=_code_defs_add($def);
      var $134=(($133)|0) < 0;
      if ($134) { __label__ = 32; break; } else { __label__ = 33; break; }
    case 32: 
      $1=0;
      __label__ = 84; break;
    case 33: 
      var $137=$3;
      var $138=(($137+68)|0);
      var $139=(($138)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=(($140)|0) >= 0;
      $1=$141;
      __label__ = 84; break;
    case 34: 
      var $143=$3;
      var $144=(($143+52)|0);
      var $145=HEAP8[($144)];
      var $146=(($145) & 1);
      if ($146) { __label__ = 35; break; } else { __label__ = 36; break; }
    case 35: 
      var $148=$3;
      var $149=$3;
      var $150=(($149+56)|0);
      var $151=$150;
      var $152=HEAP32[(($151)>>2)];
      var $153=_code_genstring($152);
      var $154=_code_globals_add($153);
      _ir_value_code_setaddr($148, $154);
      __label__ = 39; break;
    case 36: 
      var $156=$3;
      var $157=_code_globals_add(0);
      _ir_value_code_setaddr($156, $157);
      var $158=$4;
      var $159=(($158) & 1);
      if ($159) { __label__ = 38; break; } else { __label__ = 37; break; }
    case 37: 
      var $161=(($def)|0);
      var $162=HEAP16[(($161)>>1)];
      var $163=(($162)&65535);
      var $164=$163 | 32768;
      var $165=(($164) & 65535);
      HEAP16[(($161)>>1)]=$165;
      __label__ = 38; break;
    case 38: 
      __label__ = 39; break;
    case 39: 
      var $168=_code_defs_add($def);
      var $169=(($168)|0) < 0;
      if ($169) { __label__ = 40; break; } else { __label__ = 41; break; }
    case 40: 
      $1=0;
      __label__ = 84; break;
    case 41: 
      var $172=$3;
      var $173=(($172+68)|0);
      var $174=(($173)|0);
      var $175=HEAP32[(($174)>>2)];
      var $176=(($175)|0) >= 0;
      $1=$176;
      __label__ = 84; break;
    case 42: 
      var $178=$3;
      var $179=(($178+52)|0);
      var $180=HEAP8[($179)];
      var $181=(($180) & 1);
      if ($181) { __label__ = 43; break; } else { __label__ = 52; break; }
    case 43: 
      var $183=$3;
      var $184=(($183+56)|0);
      var $185=$184;
      var $186=(($185)|0);
      $iptr=$186;
      var $187=$3;
      var $188=$iptr;
      var $189=(($188)|0);
      var $190=HEAP32[(($189)>>2)];
      var $191=_code_globals_add($190);
      _ir_value_code_setaddr($187, $191);
      var $192=$3;
      var $193=(($192+68)|0);
      var $194=(($193)|0);
      var $195=HEAP32[(($194)>>2)];
      var $196=(($195)|0) < 0;
      if ($196) { __label__ = 44; break; } else { __label__ = 45; break; }
    case 44: 
      $1=0;
      __label__ = 84; break;
    case 45: 
      $d=1;
      __label__ = 46; break;
    case 46: 
      var $200=$d;
      var $201=$3;
      var $202=(($201+4)|0);
      var $203=HEAP32[(($202)>>2)];
      var $204=((_type_sizeof+($203<<2))|0);
      var $205=HEAP32[(($204)>>2)];
      var $206=(($200)>>>0) < (($205)>>>0);
      if ($206) { __label__ = 47; break; } else { __label__ = 51; break; }
    case 47: 
      var $208=$d;
      var $209=$iptr;
      var $210=(($209+($208<<2))|0);
      var $211=HEAP32[(($210)>>2)];
      var $212=_code_globals_add($211);
      var $213=(($212)|0) < 0;
      if ($213) { __label__ = 48; break; } else { __label__ = 49; break; }
    case 48: 
      $1=0;
      __label__ = 84; break;
    case 49: 
      __label__ = 50; break;
    case 50: 
      var $217=$d;
      var $218=((($217)+(1))|0);
      $d=$218;
      __label__ = 46; break;
    case 51: 
      __label__ = 63; break;
    case 52: 
      var $221=$3;
      var $222=_code_globals_add(0);
      _ir_value_code_setaddr($221, $222);
      var $223=$3;
      var $224=(($223+68)|0);
      var $225=(($224)|0);
      var $226=HEAP32[(($225)>>2)];
      var $227=(($226)|0) < 0;
      if ($227) { __label__ = 53; break; } else { __label__ = 54; break; }
    case 53: 
      $1=0;
      __label__ = 84; break;
    case 54: 
      $d=1;
      __label__ = 55; break;
    case 55: 
      var $231=$d;
      var $232=$3;
      var $233=(($232+4)|0);
      var $234=HEAP32[(($233)>>2)];
      var $235=((_type_sizeof+($234<<2))|0);
      var $236=HEAP32[(($235)>>2)];
      var $237=(($231)>>>0) < (($236)>>>0);
      if ($237) { __label__ = 56; break; } else { __label__ = 60; break; }
    case 56: 
      var $239=_code_globals_add(0);
      var $240=(($239)|0) < 0;
      if ($240) { __label__ = 57; break; } else { __label__ = 58; break; }
    case 57: 
      $1=0;
      __label__ = 84; break;
    case 58: 
      __label__ = 59; break;
    case 59: 
      var $244=$d;
      var $245=((($244)+(1))|0);
      $d=$245;
      __label__ = 55; break;
    case 60: 
      var $247=$4;
      var $248=(($247) & 1);
      if ($248) { __label__ = 62; break; } else { __label__ = 61; break; }
    case 61: 
      var $250=(($def)|0);
      var $251=HEAP16[(($250)>>1)];
      var $252=(($251)&65535);
      var $253=$252 | 32768;
      var $254=(($253) & 65535);
      HEAP16[(($250)>>1)]=$254;
      __label__ = 62; break;
    case 62: 
      __label__ = 63; break;
    case 63: 
      var $257=_code_defs_add($def);
      var $258=(($257)|0) < 0;
      if ($258) { __label__ = 64; break; } else { __label__ = 65; break; }
    case 64: 
      $1=0;
      __label__ = 84; break;
    case 65: 
      var $261=$3;
      var $262=(($261+68)|0);
      var $263=(($262)|0);
      var $264=HEAP32[(($263)>>2)];
      var $265=(($264)|0) >= 0;
      $1=$265;
      __label__ = 84; break;
    case 66: 
      var $267=$3;
      var $268=(($267+52)|0);
      var $269=HEAP8[($268)];
      var $270=(($269) & 1);
      if ($270) { __label__ = 70; break; } else { __label__ = 67; break; }
    case 67: 
      var $272=$3;
      var $273=_code_globals_add(0);
      _ir_value_code_setaddr($272, $273);
      var $274=$3;
      var $275=(($274+68)|0);
      var $276=(($275)|0);
      var $277=HEAP32[(($276)>>2)];
      var $278=(($277)|0) < 0;
      if ($278) { __label__ = 68; break; } else { __label__ = 69; break; }
    case 68: 
      $1=0;
      __label__ = 84; break;
    case 69: 
      __label__ = 75; break;
    case 70: 
      var $282=$3;
      var $283=HEAP32[((_code_globals_elements)>>2)];
      _ir_value_code_setaddr($282, $283);
      var $284=HEAP32[((_code_functions_elements)>>2)];
      var $285=_code_globals_add($284);
      var $286=$2;
      var $287=$3;
      var $288=_gen_global_function($286, $287);
      if ($288) { __label__ = 72; break; } else { __label__ = 71; break; }
    case 71: 
      $1=0;
      __label__ = 84; break;
    case 72: 
      var $291=$4;
      var $292=(($291) & 1);
      if ($292) { __label__ = 74; break; } else { __label__ = 73; break; }
    case 73: 
      var $294=(($def)|0);
      var $295=HEAP16[(($294)>>1)];
      var $296=(($295)&65535);
      var $297=$296 | 32768;
      var $298=(($297) & 65535);
      HEAP16[(($294)>>1)]=$298;
      __label__ = 74; break;
    case 74: 
      __label__ = 75; break;
    case 75: 
      var $301=_code_defs_add($def);
      var $302=(($301)|0) < 0;
      if ($302) { __label__ = 76; break; } else { __label__ = 77; break; }
    case 76: 
      $1=0;
      __label__ = 84; break;
    case 77: 
      $1=1;
      __label__ = 84; break;
    case 78: 
      var $306=$3;
      var $307=_code_globals_add(0);
      _ir_value_code_setaddr($306, $307);
      $i=1;
      __label__ = 79; break;
    case 79: 
      var $309=$i;
      var $310=HEAP32[((((_type_sizeof+36)|0))>>2)];
      var $311=(($309)>>>0) < (($310)>>>0);
      if ($311) { __label__ = 80; break; } else { __label__ = 82; break; }
    case 80: 
      var $313=_code_globals_add(0);
      __label__ = 81; break;
    case 81: 
      var $315=$i;
      var $316=((($315)+(1))|0);
      $i=$316;
      __label__ = 79; break;
    case 82: 
      $1=1;
      __label__ = 84; break;
    case 83: 
      var $319=$3;
      var $320=(($319+12)|0);
      var $321=$3;
      var $322=(($321)|0);
      var $323=HEAP32[(($322)>>2)];
      var $324=$3;
      var $325=(($324+4)|0);
      var $326=HEAP32[(($325)>>2)];
      var $327=((_type_name+($326<<2))|0);
      var $328=HEAP32[(($327)>>2)];
      var $329=(($320)|0);
      var $330=HEAP32[(($329)>>2)];
      var $331=(($320+4)|0);
      var $332=HEAP32[(($331)>>2)];
      _irerror($330, $332, ((STRING_TABLE.__str78292)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$323,HEAP32[(((tempInt)+(4))>>2)]=$328,tempInt));
      $1=0;
      __label__ = 84; break;
    case 84: 
      var $334=$1;
      STACKTOP = __stackBase__;
      return $334;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_gen_global["X"]=1;

function _ir_builder_gen_field($self, $field) {
  var __stackBase__  = STACKTOP; STACKTOP += 1040; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $def=__stackBase__;
      var $fld=(__stackBase__)+(8);
      var $len;
      var $name=(__stackBase__)+(16);
      $2=$self;
      $3=$field;
      var $4=$3;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6) & 65535);
      var $8=(($def)|0);
      HEAP16[(($8)>>1)]=$7;
      var $9=HEAP32[((_code_globals_elements)>>2)];
      var $10=(($9) & 65535);
      var $11=(($def+2)|0);
      HEAP16[(($11)>>1)]=$10;
      var $12=HEAP32[((_opts_standard)>>2)];
      var $13=(($12)|0)==3;
      if ($13) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $15=$3;
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=_strlen($17);
      $len=$18;
      var $19=$len;
      var $20=((($19)+(2))|0);
      var $21=(($20)>>>0) >= 1024;
      if ($21) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $23=$3;
      var $24=(($23+12)|0);
      var $25=$len;
      var $26=(($24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($24+4)|0);
      var $29=HEAP32[(($28)>>2)];
      _irerror($27, $29, ((STRING_TABLE.__str72286)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$25,tempInt));
      $1=0;
      __label__ = 22; break;
    case 5: 
      var $31=(($name)|0);
      HEAP8[($31)]=46;
      var $32=(($name)|0);
      var $33=(($32+1)|0);
      var $34=$3;
      var $35=(($34)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=$len;
      assert($37 % 1 === 0, 'memcpy given ' + $37 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($33, $36, $37, 1);
      var $38=$len;
      var $39=((($38)+(1))|0);
      var $40=(($name+$39)|0);
      HEAP8[($40)]=0;
      var $41=(($name)|0);
      var $42=_code_genstring($41);
      var $43=(($def+4)|0);
      HEAP32[(($43)>>2)]=$42;
      var $44=(($def+4)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=((($45)+(1))|0);
      var $47=(($fld+4)|0);
      HEAP32[(($47)>>2)]=$46;
      __label__ = 7; break;
    case 6: 
      var $49=$3;
      var $50=(($49)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=_code_genstring($51);
      var $53=(($def+4)|0);
      HEAP32[(($53)>>2)]=$52;
      var $54=(($def+4)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=(($fld+4)|0);
      HEAP32[(($56)>>2)]=$55;
      __label__ = 7; break;
    case 7: 
      var $58=(($def+4)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=$3;
      var $61=(($60+68)|0);
      var $62=(($61+4)|0);
      HEAP32[(($62)>>2)]=$59;
      var $63=_code_defs_add($def);
      var $64=(($63)|0) < 0;
      if ($64) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      $1=0;
      __label__ = 22; break;
    case 9: 
      var $67=$3;
      var $68=(($67+20)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=(($69) & 65535);
      var $71=(($fld)|0);
      HEAP16[(($71)>>1)]=$70;
      var $72=(($fld)|0);
      var $73=HEAP16[(($72)>>1)];
      var $74=(($73)&65535);
      var $75=(($74)|0)==0;
      if ($75) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $77=$3;
      var $78=(($77+12)|0);
      var $79=$3;
      var $80=(($79)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($78)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=(($78+4)|0);
      var $85=HEAP32[(($84)>>2)];
      _irerror($83, $85, ((STRING_TABLE.__str73287)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$81,tempInt));
      $1=0;
      __label__ = 22; break;
    case 11: 
      var $87=$3;
      var $88=(($87+20)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=((_type_sizeof+($89<<2))|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=_code_alloc_field($91);
      var $93=(($92) & 65535);
      var $94=(($fld+2)|0);
      HEAP16[(($94)>>1)]=$93;
      var $95=_code_fields_add($fld);
      var $96=(($95)|0) < 0;
      if ($96) { __label__ = 12; break; } else { __label__ = 13; break; }
    case 12: 
      $1=0;
      __label__ = 22; break;
    case 13: 
      var $99=$3;
      var $100=HEAP32[((_code_globals_elements)>>2)];
      _ir_value_code_setaddr($99, $100);
      var $101=(($fld+2)|0);
      var $102=HEAP16[(($101)>>1)];
      var $103=(($102)&65535);
      var $104=_code_globals_add($103);
      var $105=(($104)|0)!=0;
      if ($105) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      $1=0;
      __label__ = 22; break;
    case 15: 
      var $108=(($fld)|0);
      var $109=HEAP16[(($108)>>1)];
      var $110=(($109)&65535);
      var $111=(($110)|0)==3;
      if ($111) { __label__ = 16; break; } else { __label__ = 21; break; }
    case 16: 
      var $113=(($fld+2)|0);
      var $114=HEAP16[(($113)>>1)];
      var $115=(($114)&65535);
      var $116=((($115)+(1))|0);
      var $117=_code_globals_add($116);
      var $118=(($117)|0)!=0;
      if ($118) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=0;
      __label__ = 22; break;
    case 18: 
      var $121=(($fld+2)|0);
      var $122=HEAP16[(($121)>>1)];
      var $123=(($122)&65535);
      var $124=((($123)+(2))|0);
      var $125=_code_globals_add($124);
      var $126=(($125)|0)!=0;
      if ($126) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      $1=0;
      __label__ = 22; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $130=$3;
      var $131=(($130+68)|0);
      var $132=(($131)|0);
      var $133=HEAP32[(($132)>>2)];
      var $134=(($133)|0) >= 0;
      $1=$134;
      __label__ = 22; break;
    case 22: 
      var $136=$1;
      STACKTOP = __stackBase__;
      return $136;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_gen_field["X"]=1;

function _qc_opname($op) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$op;
      var $3=$2;
      var $4=(($3)|0) < 0;
      if ($4) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=((STRING_TABLE.__str22236)|0);
      __label__ = 11; break;
    case 4: 
      var $7=$2;
      var $8=(($7)>>>0) < 67;
      if ($8) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $10=$2;
      var $11=((_asm_instr231+($10)*(12))|0);
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      $1=$13;
      __label__ = 11; break;
    case 6: 
      var $15=$2;
      if ((($15)|0) == 67) {
        __label__ = 7; break;
      }
      else if ((($15)|0) == 68) {
        __label__ = 8; break;
      }
      else if ((($15)|0) == 69) {
        __label__ = 9; break;
      }
      else {
      __label__ = 10; break;
      }
      
    case 7: 
      $1=((STRING_TABLE.__str23237)|0);
      __label__ = 11; break;
    case 8: 
      $1=((STRING_TABLE.__str24238)|0);
      __label__ = 11; break;
    case 9: 
      $1=((STRING_TABLE.__str25239)|0);
      __label__ = 11; break;
    case 10: 
      $1=((STRING_TABLE.__str26240)|0);
      __label__ = 11; break;
    case 11: 
      var $21=$1;
      ;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _gen_global_function_code($ir, $global) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $fundef;
      var $irfun;
      $2=$ir;
      $3=$global;
      var $4=$3;
      var $5=(($4+56)|0);
      var $6=$5;
      var $7=HEAP32[(($6)>>2)];
      $irfun=$7;
      var $8=$irfun;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $11=$3;
      var $12=(($11+12)|0);
      var $13=$3;
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($12)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($12+4)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=_irwarning($17, $19, 11, ((STRING_TABLE.__str65279)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$15,tempInt));
      $1=1;
      __label__ = 11; break;
    case 4: 
      var $22=$irfun;
      var $23=(($22+32)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=1;
      __label__ = 11; break;
    case 6: 
      var $28=$irfun;
      var $29=(($28+84)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0) < 0;
      if ($31) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $33=$irfun;
      var $34=(($33+76)|0);
      var $35=$irfun;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($34)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($34+4)|0);
      var $41=HEAP32[(($40)>>2)];
      _irerror($39, $41, ((STRING_TABLE.__str66280)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$37,tempInt));
      $1=0;
      __label__ = 11; break;
    case 8: 
      var $43=$irfun;
      var $44=(($43+84)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=HEAP32[((_code_functions_data)>>2)];
      var $47=(($46+($45)*(36))|0);
      $fundef=$47;
      var $48=HEAP32[((_code_statements_elements)>>2)];
      var $49=$fundef;
      var $50=(($49)|0);
      HEAP32[(($50)>>2)]=$48;
      var $51=$irfun;
      var $52=_gen_function_code($51);
      if ($52) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $54=$irfun;
      var $55=(($54+76)|0);
      var $56=$irfun;
      var $57=(($56)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($55)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($55+4)|0);
      var $62=HEAP32[(($61)>>2)];
      _irerror($60, $62, ((STRING_TABLE.__str67281)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$58,tempInt));
      $1=0;
      __label__ = 11; break;
    case 10: 
      $1=1;
      __label__ = 11; break;
    case 11: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_global_function_code["X"]=1;

function _ir_builder_dump($b, $oprintf) {
  var __stackBase__  = STACKTOP; STACKTOP += 1024; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $indent=__stackBase__;
      $1=$b;
      $2=$oprintf;
      var $3=(($indent)|0);
      HEAP8[($3)]=9;
      var $4=(($indent+1)|0);
      HEAP8[($4)]=0;
      var $5=$2;
      var $6=$1;
      var $7=(($6)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=FUNCTION_TABLE[$5](((STRING_TABLE.__str27241)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$8,tempInt));
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $11=$i;
      var $12=$1;
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($11)>>>0) < (($14)>>>0);
      if ($15) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $17=$2;
      var $18=FUNCTION_TABLE[$17](((STRING_TABLE.__str28242)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $19=$i;
      var $20=$1;
      var $21=(($20+16)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22+($19<<2))|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+52)|0);
      var $26=HEAP8[($25)];
      var $27=(($26) & 1);
      if ($27) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $29=$2;
      var $30=$i;
      var $31=$1;
      var $32=(($31+16)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33+($30<<2))|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=FUNCTION_TABLE[$29](((STRING_TABLE.__str29243)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$37,tempInt));
      __label__ = 6; break;
    case 6: 
      var $40=$i;
      var $41=$1;
      var $42=(($41+16)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($43+($40<<2))|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$2;
      _ir_value_dump($45, $46);
      var $47=$2;
      var $48=FUNCTION_TABLE[$47](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 7; break;
    case 7: 
      var $50=$i;
      var $51=((($50)+(1))|0);
      $i=$51;
      __label__ = 3; break;
    case 8: 
      $i=0;
      __label__ = 9; break;
    case 9: 
      var $54=$i;
      var $55=$1;
      var $56=(($55+8)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=(($54)>>>0) < (($57)>>>0);
      if ($58) { __label__ = 10; break; } else { __label__ = 12; break; }
    case 10: 
      var $60=$i;
      var $61=$1;
      var $62=(($61+4)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63+($60<<2))|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($indent)|0);
      var $67=$2;
      _ir_function_dump($65, $66, $67);
      __label__ = 11; break;
    case 11: 
      var $69=$i;
      var $70=((($69)+(1))|0);
      $i=$70;
      __label__ = 9; break;
    case 12: 
      var $72=$2;
      var $73=$1;
      var $74=(($73)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=FUNCTION_TABLE[$72](((STRING_TABLE.__str31245)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$75,tempInt));
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_dump["X"]=1;

function _ir_value_dump($v, $oprintf) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$v;
      $2=$oprintf;
      var $3=$1;
      var $4=(($3+52)|0);
      var $5=HEAP8[($4)];
      var $6=(($5) & 1);
      if ($6) { __label__ = 3; break; } else { __label__ = 13; break; }
    case 3: 
      var $8=$1;
      var $9=(($8+4)|0);
      var $10=HEAP32[(($9)>>2)];
      if ((($10)|0) == 0) {
        __label__ = 5; break;
      }
      else if ((($10)|0) == 6) {
        __label__ = 6; break;
      }
      else if ((($10)|0) == 2) {
        __label__ = 7; break;
      }
      else if ((($10)|0) == 3) {
        __label__ = 8; break;
      }
      else if ((($10)|0) == 4) {
        __label__ = 9; break;
      }
      else if ((($10)|0) == 1) {
        __label__ = 10; break;
      }
      else if ((($10)|0) == 7) {
        __label__ = 11; break;
      }
      else {
      __label__ = 4; break;
      }
      
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $13=$2;
      var $14=FUNCTION_TABLE[$13](((STRING_TABLE.__str55269)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 12; break;
    case 6: 
      var $16=$2;
      var $17=$1;
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=FUNCTION_TABLE[$16](((STRING_TABLE.__str56270)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$19,tempInt));
      __label__ = 12; break;
    case 7: 
      var $22=$2;
      var $23=$1;
      var $24=(($23+56)|0);
      var $25=$24;
      var $26=HEAPF32[(($25)>>2)];
      var $27=$26;
      var $28=FUNCTION_TABLE[$22](((STRING_TABLE.__str57271)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),(tempDoubleF64[0]=$27,HEAP32[((tempInt)>>2)]=tempDoubleI32[0],HEAP32[(((tempInt)+(4))>>2)]=tempDoubleI32[1]),tempInt));
      __label__ = 12; break;
    case 8: 
      var $30=$2;
      var $31=$1;
      var $32=(($31+56)|0);
      var $33=$32;
      var $34=(($33)|0);
      var $35=HEAPF32[(($34)>>2)];
      var $36=$35;
      var $37=$1;
      var $38=(($37+56)|0);
      var $39=$38;
      var $40=(($39+4)|0);
      var $41=HEAPF32[(($40)>>2)];
      var $42=$41;
      var $43=$1;
      var $44=(($43+56)|0);
      var $45=$44;
      var $46=(($45+8)|0);
      var $47=HEAPF32[(($46)>>2)];
      var $48=$47;
      var $49=FUNCTION_TABLE[$30](((STRING_TABLE.__str58272)|0), (tempInt=STACKTOP,STACKTOP += 24,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),(tempDoubleF64[0]=$36,HEAP32[((tempInt)>>2)]=tempDoubleI32[0],HEAP32[(((tempInt)+(4))>>2)]=tempDoubleI32[1]),(tempDoubleF64[0]=$42,HEAP32[(((tempInt)+(8))>>2)]=tempDoubleI32[0],HEAP32[((((tempInt)+(8))+(4))>>2)]=tempDoubleI32[1]),(tempDoubleF64[0]=$48,HEAP32[(((tempInt)+(16))>>2)]=tempDoubleI32[0],HEAP32[((((tempInt)+(16))+(4))>>2)]=tempDoubleI32[1]),tempInt));
      __label__ = 12; break;
    case 9: 
      var $51=$2;
      var $52=FUNCTION_TABLE[$51](((STRING_TABLE.__str59273)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 12; break;
    case 10: 
      var $54=$2;
      var $55=$1;
      var $56=(($55+56)|0);
      var $57=$56;
      var $58=HEAP32[(($57)>>2)];
      var $59=FUNCTION_TABLE[$54](((STRING_TABLE.__str60274)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$58,tempInt));
      __label__ = 12; break;
    case 11: 
      var $61=$2;
      var $62=$1;
      var $63=(($62+56)|0);
      var $64=$63;
      var $65=HEAP32[(($64)>>2)];
      var $66=(($65)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=FUNCTION_TABLE[$61](((STRING_TABLE.__str61275)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$67,tempInt));
      __label__ = 12; break;
    case 12: 
      __label__ = 14; break;
    case 13: 
      var $71=$2;
      var $72=$1;
      var $73=(($72)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=FUNCTION_TABLE[$71](((STRING_TABLE.__str62276)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$74,tempInt));
      __label__ = 14; break;
    case 14: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_value_dump["X"]=1;

function _ir_function_dump($f, $ind, $oprintf) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $l;
      var $v;
      var $l1;
      var $v2;
      $1=$f;
      $2=$ind;
      $3=$oprintf;
      var $4=$1;
      var $5=(($4+32)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$3;
      var $10=$2;
      var $11=$1;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$1;
      var $15=(($14+32)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(((-$16))|0);
      var $18=FUNCTION_TABLE[$9](((STRING_TABLE.__str32246)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$10,HEAP32[(((tempInt)+(4))>>2)]=$13,HEAP32[(((tempInt)+(8))>>2)]=$17,tempInt));
      __label__ = 35; break;
    case 4: 
      var $20=$3;
      var $21=$2;
      var $22=$1;
      var $23=(($22)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=FUNCTION_TABLE[$20](((STRING_TABLE.__str33247)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$21,HEAP32[(((tempInt)+(4))>>2)]=$24,tempInt));
      var $26=$2;
      var $27=_strncat($26, ((STRING_TABLE.__str34248)|0), 1024);
      var $28=$1;
      var $29=(($28+56)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 5; break; } else { __label__ = 10; break; }
    case 5: 
      var $33=$3;
      var $34=$2;
      var $35=$1;
      var $36=(($35+56)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=FUNCTION_TABLE[$33](((STRING_TABLE.__str35249)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$34,HEAP32[(((tempInt)+(4))>>2)]=$37,tempInt));
      $i=0;
      __label__ = 6; break;
    case 6: 
      var $40=$i;
      var $41=$1;
      var $42=(($41+56)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($40)>>>0) < (($43)>>>0);
      if ($44) { __label__ = 7; break; } else { __label__ = 9; break; }
    case 7: 
      var $46=$3;
      var $47=$2;
      var $48=FUNCTION_TABLE[$46](((STRING_TABLE.__str36250)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$47,tempInt));
      var $49=$i;
      var $50=$1;
      var $51=(($50+52)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=(($52+($49<<2))|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=$3;
      _ir_value_dump($54, $55);
      var $56=$3;
      var $57=FUNCTION_TABLE[$56](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 8; break;
    case 8: 
      var $59=$i;
      var $60=((($59)+(1))|0);
      $i=$60;
      __label__ = 6; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $63=$3;
      var $64=$2;
      var $65=FUNCTION_TABLE[$63](((STRING_TABLE.__str37251)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$64,tempInt));
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $67=$i;
      var $68=$1;
      var $69=(($68+56)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=(($67)>>>0) < (($70)>>>0);
      if ($71) { __label__ = 12; break; } else { __label__ = 18; break; }
    case 12: 
      var $73=$i;
      var $74=$1;
      var $75=(($74+52)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($76+($73<<2))|0);
      var $78=HEAP32[(($77)>>2)];
      $v=$78;
      var $79=$3;
      var $80=$2;
      var $81=$v;
      var $82=(($81)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=FUNCTION_TABLE[$79](((STRING_TABLE.__str38252)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$80,HEAP32[(((tempInt)+(4))>>2)]=$83,tempInt));
      $l=0;
      __label__ = 13; break;
    case 13: 
      var $86=$l;
      var $87=$v;
      var $88=(($87+104)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($86)>>>0) < (($89)>>>0);
      if ($90) { __label__ = 14; break; } else { __label__ = 16; break; }
    case 14: 
      var $92=$3;
      var $93=$l;
      var $94=$v;
      var $95=(($94+100)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=(($96+($93<<3))|0);
      var $98=(($97)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=$l;
      var $101=$v;
      var $102=(($101+100)|0);
      var $103=HEAP32[(($102)>>2)];
      var $104=(($103+($100<<3))|0);
      var $105=(($104+4)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=FUNCTION_TABLE[$92](((STRING_TABLE.__str39253)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$99,HEAP32[(((tempInt)+(4))>>2)]=$106,tempInt));
      __label__ = 15; break;
    case 15: 
      var $109=$l;
      var $110=((($109)+(1))|0);
      $l=$110;
      __label__ = 13; break;
    case 16: 
      var $112=$3;
      var $113=FUNCTION_TABLE[$112](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 17; break;
    case 17: 
      var $115=$i;
      var $116=((($115)+(1))|0);
      $i=$116;
      __label__ = 11; break;
    case 18: 
      $i=0;
      __label__ = 19; break;
    case 19: 
      var $119=$i;
      var $120=$1;
      var $121=(($120+44)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=(($119)>>>0) < (($122)>>>0);
      if ($123) { __label__ = 20; break; } else { __label__ = 26; break; }
    case 20: 
      var $125=$i;
      var $126=$1;
      var $127=(($126+40)|0);
      var $128=HEAP32[(($127)>>2)];
      var $129=(($128+($125<<2))|0);
      var $130=HEAP32[(($129)>>2)];
      $v2=$130;
      var $131=$3;
      var $132=$2;
      var $133=$v2;
      var $134=(($133)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=$v2;
      var $137=(($136+68)|0);
      var $138=(($137+8)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=FUNCTION_TABLE[$131](((STRING_TABLE.__str40254)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$132,HEAP32[(((tempInt)+(4))>>2)]=$135,HEAP32[(((tempInt)+(8))>>2)]=$139,tempInt));
      $l1=0;
      __label__ = 21; break;
    case 21: 
      var $142=$l1;
      var $143=$v2;
      var $144=(($143+104)|0);
      var $145=HEAP32[(($144)>>2)];
      var $146=(($142)>>>0) < (($145)>>>0);
      if ($146) { __label__ = 22; break; } else { __label__ = 24; break; }
    case 22: 
      var $148=$3;
      var $149=$l1;
      var $150=$v2;
      var $151=(($150+100)|0);
      var $152=HEAP32[(($151)>>2)];
      var $153=(($152+($149<<3))|0);
      var $154=(($153)|0);
      var $155=HEAP32[(($154)>>2)];
      var $156=$l1;
      var $157=$v2;
      var $158=(($157+100)|0);
      var $159=HEAP32[(($158)>>2)];
      var $160=(($159+($156<<3))|0);
      var $161=(($160+4)|0);
      var $162=HEAP32[(($161)>>2)];
      var $163=FUNCTION_TABLE[$148](((STRING_TABLE.__str39253)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$155,HEAP32[(((tempInt)+(4))>>2)]=$162,tempInt));
      __label__ = 23; break;
    case 23: 
      var $165=$l1;
      var $166=((($165)+(1))|0);
      $l1=$166;
      __label__ = 21; break;
    case 24: 
      var $168=$3;
      var $169=FUNCTION_TABLE[$168](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 25; break;
    case 25: 
      var $171=$i;
      var $172=((($171)+(1))|0);
      $i=$172;
      __label__ = 19; break;
    case 26: 
      var $174=$1;
      var $175=(($174+24)|0);
      var $176=HEAP32[(($175)>>2)];
      var $177=(($176)|0)!=0;
      if ($177) { __label__ = 27; break; } else { __label__ = 34; break; }
    case 27: 
      var $179=$3;
      var $180=$2;
      var $181=$1;
      var $182=(($181+88)|0);
      var $183=HEAP32[(($182)>>2)];
      var $184=FUNCTION_TABLE[$179](((STRING_TABLE.__str41255)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$180,HEAP32[(((tempInt)+(4))>>2)]=$183,tempInt));
      $i=0;
      __label__ = 28; break;
    case 28: 
      var $186=$i;
      var $187=$1;
      var $188=(($187+24)|0);
      var $189=HEAP32[(($188)>>2)];
      var $190=(($186)>>>0) < (($189)>>>0);
      if ($190) { __label__ = 29; break; } else { __label__ = 33; break; }
    case 29: 
      var $192=$i;
      var $193=$1;
      var $194=(($193+20)|0);
      var $195=HEAP32[(($194)>>2)];
      var $196=(($195+($192<<2))|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=(($197+72)|0);
      var $199=HEAP32[(($198)>>2)];
      var $200=$1;
      var $201=(($200+88)|0);
      var $202=HEAP32[(($201)>>2)];
      var $203=(($199)|0)!=(($202)|0);
      if ($203) { __label__ = 30; break; } else { __label__ = 31; break; }
    case 30: 
      var $205=$3;
      var $206=$2;
      var $207=$i;
      var $208=$1;
      var $209=(($208+20)|0);
      var $210=HEAP32[(($209)>>2)];
      var $211=(($210+($207<<2))|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=(($212+72)|0);
      var $214=HEAP32[(($213)>>2)];
      var $215=$1;
      var $216=(($215+88)|0);
      var $217=HEAP32[(($216)>>2)];
      var $218=FUNCTION_TABLE[$205](((STRING_TABLE.__str42256)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$206,HEAP32[(((tempInt)+(4))>>2)]=$214,HEAP32[(((tempInt)+(8))>>2)]=$217,tempInt));
      __label__ = 31; break;
    case 31: 
      var $220=$i;
      var $221=$1;
      var $222=(($221+20)|0);
      var $223=HEAP32[(($222)>>2)];
      var $224=(($223+($220<<2))|0);
      var $225=HEAP32[(($224)>>2)];
      var $226=$2;
      var $227=$3;
      _ir_block_dump($225, $226, $227);
      __label__ = 32; break;
    case 32: 
      var $229=$i;
      var $230=((($229)+(1))|0);
      $i=$230;
      __label__ = 28; break;
    case 33: 
      __label__ = 34; break;
    case 34: 
      var $233=$2;
      var $234=_strlen($233);
      var $235=((($234)-(1))|0);
      var $236=$2;
      var $237=(($236+$235)|0);
      HEAP8[($237)]=0;
      var $238=$3;
      var $239=$2;
      var $240=$1;
      var $241=(($240)|0);
      var $242=HEAP32[(($241)>>2)];
      var $243=FUNCTION_TABLE[$238](((STRING_TABLE.__str43257)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$239,HEAP32[(((tempInt)+(4))>>2)]=$242,tempInt));
      __label__ = 35; break;
    case 35: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_function_dump["X"]=1;

function _ir_block_dump($b, $ind, $oprintf) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $1=$b;
      $2=$ind;
      $3=$oprintf;
      var $4=$3;
      var $5=$2;
      var $6=$1;
      var $7=(($6)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=FUNCTION_TABLE[$4](((STRING_TABLE.__str44258)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$5,HEAP32[(((tempInt)+(4))>>2)]=$8,tempInt));
      var $10=$2;
      var $11=_strncat($10, ((STRING_TABLE.__str34248)|0), 1024);
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $13=$i;
      var $14=$1;
      var $15=(($14+20)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($13)>>>0) < (($16)>>>0);
      if ($17) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $19=$i;
      var $20=$1;
      var $21=(($20+16)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22+($19<<2))|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=$2;
      var $26=$3;
      _ir_instr_dump($24, $25, $26);
      __label__ = 5; break;
    case 5: 
      var $28=$i;
      var $29=((($28)+(1))|0);
      $i=$29;
      __label__ = 3; break;
    case 6: 
      var $31=$2;
      var $32=_strlen($31);
      var $33=((($32)-(1))|0);
      var $34=$2;
      var $35=(($34+$33)|0);
      HEAP8[($35)]=0;
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_instr_dump($in, $ind, $oprintf) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $comma;
      $1=$in;
      $2=$ind;
      $3=$oprintf;
      $comma=0;
      var $4=$3;
      var $5=$2;
      var $6=$1;
      var $7=(($6+56)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=FUNCTION_TABLE[$4](((STRING_TABLE.__str47261)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$5,HEAP32[(((tempInt)+(4))>>2)]=$8,tempInt));
      var $10=$1;
      var $11=(($10)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)==67;
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$1;
      var $16=$2;
      var $17=$3;
      _dump_phi($15, $16, $17);
      __label__ = 40; break;
    case 4: 
      var $19=$2;
      var $20=_strncat($19, ((STRING_TABLE.__str34248)|0), 1024);
      var $21=$1;
      var $22=(($21+12)|0);
      var $23=(($22)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)!=0;
      if ($25) { __label__ = 5; break; } else { __label__ = 11; break; }
    case 5: 
      var $27=$1;
      var $28=(($27+12)|0);
      var $29=(($28+4)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $33=$1;
      var $34=(($33+12)|0);
      var $35=(($34+8)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36)|0)!=0;
      if ($37) { __label__ = 7; break; } else { __label__ = 11; break; }
    case 7: 
      var $39=$1;
      var $40=(($39+12)|0);
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$3;
      _ir_value_dump($42, $43);
      var $44=$1;
      var $45=(($44+12)|0);
      var $46=(($45+4)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($47)|0)!=0;
      if ($48) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      var $50=$1;
      var $51=(($50+12)|0);
      var $52=(($51+8)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=(($53)|0)!=0;
      if ($54) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $56=$3;
      var $57=FUNCTION_TABLE[$56](((STRING_TABLE.__str48262)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 10; break;
    case 10: 
      __label__ = 11; break;
    case 11: 
      var $60=$1;
      var $61=(($60)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)==51;
      if ($63) { __label__ = 12; break; } else { __label__ = 13; break; }
    case 12: 
      var $65=$3;
      var $66=$1;
      var $67=(($66+48)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=FUNCTION_TABLE[$65](((STRING_TABLE.__str49263)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$68,tempInt));
      __label__ = 14; break;
    case 13: 
      var $71=$3;
      var $72=$1;
      var $73=(($72)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=_qc_opname($74);
      var $76=FUNCTION_TABLE[$71](((STRING_TABLE.__str36250)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$75,tempInt));
      __label__ = 14; break;
    case 14: 
      var $78=$1;
      var $79=(($78+12)|0);
      var $80=(($79)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81)|0)!=0;
      if ($82) { __label__ = 15; break; } else { __label__ = 18; break; }
    case 15: 
      var $84=$1;
      var $85=(($84+12)|0);
      var $86=(($85+4)|0);
      var $87=HEAP32[(($86)>>2)];
      var $88=(($87)|0)!=0;
      if ($88) { __label__ = 18; break; } else { __label__ = 16; break; }
    case 16: 
      var $90=$1;
      var $91=(($90+12)|0);
      var $92=(($91+8)|0);
      var $93=HEAP32[(($92)>>2)];
      var $94=(($93)|0)!=0;
      if ($94) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $96=$1;
      var $97=(($96+12)|0);
      var $98=(($97)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=$3;
      _ir_value_dump($99, $100);
      $comma=((STRING_TABLE.__str50264)|0);
      __label__ = 27; break;
    case 18: 
      $i=1;
      __label__ = 19; break;
    case 19: 
      var $103=$i;
      var $104=(($103)|0)!=3;
      if ($104) { __label__ = 20; break; } else { __label__ = 26; break; }
    case 20: 
      var $106=$i;
      var $107=$1;
      var $108=(($107+12)|0);
      var $109=(($108+($106<<2))|0);
      var $110=HEAP32[(($109)>>2)];
      var $111=(($110)|0)!=0;
      if ($111) { __label__ = 21; break; } else { __label__ = 24; break; }
    case 21: 
      var $113=$comma;
      var $114=(($113)|0)!=0;
      if ($114) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $116=$3;
      var $117=$comma;
      var $118=FUNCTION_TABLE[$116]($117, (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 23; break;
    case 23: 
      var $120=$i;
      var $121=$1;
      var $122=(($121+12)|0);
      var $123=(($122+($120<<2))|0);
      var $124=HEAP32[(($123)>>2)];
      var $125=$3;
      _ir_value_dump($124, $125);
      $comma=((STRING_TABLE.__str50264)|0);
      __label__ = 24; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $128=$i;
      var $129=((($128)+(1))|0);
      $i=$129;
      __label__ = 19; break;
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $132=$1;
      var $133=(($132+24)|0);
      var $134=(($133)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=(($135)|0)!=0;
      if ($136) { __label__ = 28; break; } else { __label__ = 31; break; }
    case 28: 
      var $138=$comma;
      var $139=(($138)|0)!=0;
      if ($139) { __label__ = 29; break; } else { __label__ = 30; break; }
    case 29: 
      var $141=$3;
      var $142=$comma;
      var $143=FUNCTION_TABLE[$141]($142, (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 30; break;
    case 30: 
      var $145=$3;
      var $146=$1;
      var $147=(($146+24)|0);
      var $148=(($147)|0);
      var $149=HEAP32[(($148)>>2)];
      var $150=(($149)|0);
      var $151=HEAP32[(($150)>>2)];
      var $152=FUNCTION_TABLE[$145](((STRING_TABLE.__str51265)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$151,tempInt));
      $comma=((STRING_TABLE.__str50264)|0);
      __label__ = 31; break;
    case 31: 
      var $154=$1;
      var $155=(($154+24)|0);
      var $156=(($155+4)|0);
      var $157=HEAP32[(($156)>>2)];
      var $158=(($157)|0)!=0;
      if ($158) { __label__ = 32; break; } else { __label__ = 33; break; }
    case 32: 
      var $160=$3;
      var $161=$comma;
      var $162=$1;
      var $163=(($162+24)|0);
      var $164=(($163+4)|0);
      var $165=HEAP32[(($164)>>2)];
      var $166=(($165)|0);
      var $167=HEAP32[(($166)>>2)];
      var $168=FUNCTION_TABLE[$160](((STRING_TABLE.__str52266)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$161,HEAP32[(((tempInt)+(4))>>2)]=$167,tempInt));
      __label__ = 33; break;
    case 33: 
      var $170=$1;
      var $171=(($170+48)|0);
      var $172=HEAP32[(($171)>>2)];
      var $173=(($172)|0)!=0;
      if ($173) { __label__ = 34; break; } else { __label__ = 39; break; }
    case 34: 
      var $175=$3;
      var $176=FUNCTION_TABLE[$175](((STRING_TABLE.__str53267)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $i=0;
      __label__ = 35; break;
    case 35: 
      var $178=$i;
      var $179=$1;
      var $180=(($179+48)|0);
      var $181=HEAP32[(($180)>>2)];
      var $182=(($178)|0)!=(($181)|0);
      if ($182) { __label__ = 36; break; } else { __label__ = 38; break; }
    case 36: 
      var $184=$3;
      var $185=$i;
      var $186=$1;
      var $187=(($186+44)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=(($188+($185<<2))|0);
      var $190=HEAP32[(($189)>>2)];
      var $191=(($190)|0);
      var $192=HEAP32[(($191)>>2)];
      var $193=FUNCTION_TABLE[$184](((STRING_TABLE.__str54268)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$192,tempInt));
      __label__ = 37; break;
    case 37: 
      var $195=$i;
      var $196=((($195)+(1))|0);
      $i=$196;
      __label__ = 35; break;
    case 38: 
      __label__ = 39; break;
    case 39: 
      var $199=$3;
      var $200=FUNCTION_TABLE[$199](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $201=$2;
      var $202=_strlen($201);
      var $203=((($202)-(1))|0);
      var $204=$2;
      var $205=(($204+$203)|0);
      HEAP8[($205)]=0;
      __label__ = 40; break;
    case 40: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_instr_dump["X"]=1;

function _dump_phi($in, $ind, $oprintf) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $1=$in;
      $2=$ind;
      $3=$oprintf;
      var $4=$3;
      var $5=$1;
      var $6=(($5+12)|0);
      var $7=(($6)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=FUNCTION_TABLE[$4](((STRING_TABLE.__str45259)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$10,tempInt));
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $13=$i;
      var $14=$1;
      var $15=(($14+36)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($13)>>>0) < (($16)>>>0);
      if ($17) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $19=$3;
      var $20=$i;
      var $21=$1;
      var $22=(($21+32)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+($20<<3))|0);
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$i;
      var $30=$1;
      var $31=(($30+32)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=(($32+($29<<3))|0);
      var $34=(($33)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=FUNCTION_TABLE[$19](((STRING_TABLE.__str46260)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$28,HEAP32[(((tempInt)+(4))>>2)]=$37,tempInt));
      __label__ = 5; break;
    case 5: 
      var $40=$i;
      var $41=((($40)+(1))|0);
      $i=$41;
      __label__ = 3; break;
    case 6: 
      var $43=$3;
      var $44=FUNCTION_TABLE[$43](((STRING_TABLE.__str30244)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_dump_phi["X"]=1;

function _gen_function_code($self) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $block;
      var $stmt=__stackBase__;
      $2=$self;
      var $3=$2;
      var $4=(($3+24)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+76)|0);
      var $10=$2;
      var $11=(($10)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($9)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($9+4)|0);
      var $16=HEAP32[(($15)>>2)];
      _irerror($14, $16, ((STRING_TABLE.__str68282)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$12,tempInt));
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $18=$2;
      var $19=(($18+20)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20)|0);
      var $22=HEAP32[(($21)>>2)];
      $block=$22;
      var $23=$block;
      var $24=(($23+80)|0);
      var $25=HEAP8[($24)];
      var $26=(($25) & 1);
      if ($26) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=1;
      __label__ = 11; break;
    case 6: 
      var $29=$2;
      var $30=$block;
      var $31=_gen_blocks_recursive($29, $30);
      if ($31) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $33=$2;
      var $34=(($33+76)|0);
      var $35=$2;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($34)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($34+4)|0);
      var $41=HEAP32[(($40)>>2)];
      _irerror($39, $41, ((STRING_TABLE.__str69283)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$37,tempInt));
      $1=0;
      __label__ = 11; break;
    case 8: 
      var $43=(($stmt)|0);
      HEAP16[(($43)>>1)]=66;
      var $44=(($stmt+2)|0);
      var $45=$44;
      HEAP16[(($45)>>1)]=0;
      var $46=(($stmt+4)|0);
      var $47=$46;
      HEAP16[(($47)>>1)]=0;
      var $48=(($stmt+6)|0);
      var $49=$48;
      HEAP16[(($49)>>1)]=0;
      var $50=_code_statements_add($stmt);
      var $51=(($50)|0) < 0;
      if ($51) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      $1=0;
      __label__ = 11; break;
    case 10: 
      $1=1;
      __label__ = 11; break;
    case 11: 
      var $55=$1;
      STACKTOP = __stackBase__;
      return $55;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_function_code["X"]=1;

function _gen_blocks_recursive($func, $block) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $stmt=__stackBase__;
      var $instr;
      var $target;
      var $ontrue;
      var $onfalse;
      var $stidx;
      var $i;
      var $p;
      var $retvalue;
      var $param;
      $2=$func;
      $3=$block;
      __label__ = 3; break;
    case 3: 
      var $5=$3;
      var $6=(($5+80)|0);
      HEAP8[($6)]=1;
      var $7=HEAP32[((_code_statements_elements)>>2)];
      var $8=$3;
      var $9=(($8+84)|0);
      HEAP32[(($9)>>2)]=$7;
      $i=0;
      __label__ = 4; break;
    case 4: 
      var $11=$i;
      var $12=$3;
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($11)>>>0) < (($14)>>>0);
      if ($15) { __label__ = 5; break; } else { __label__ = 83; break; }
    case 5: 
      var $17=$i;
      var $18=$3;
      var $19=(($18+16)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20+($17<<2))|0);
      var $22=HEAP32[(($21)>>2)];
      $instr=$22;
      var $23=$instr;
      var $24=(($23)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)==67;
      if ($26) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $28=$3;
      var $29=(($28+4)|0);
      var $30=(($29)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($29+4)|0);
      var $33=HEAP32[(($32)>>2)];
      _irerror($31, $33, ((STRING_TABLE.__str70284)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 84; break;
    case 7: 
      var $35=$instr;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)|0)==68;
      if ($38) { __label__ = 8; break; } else { __label__ = 13; break; }
    case 8: 
      var $40=$instr;
      var $41=(($40+24)|0);
      var $42=(($41)|0);
      var $43=HEAP32[(($42)>>2)];
      $target=$43;
      var $44=$target;
      var $45=(($44+80)|0);
      var $46=HEAP8[($45)];
      var $47=(($46) & 1);
      if ($47) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $49=$target;
      $3=$49;
      __label__ = 3; break;
    case 10: 
      var $51=(($stmt)|0);
      HEAP16[(($51)>>1)]=61;
      var $52=$target;
      var $53=(($52+84)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=HEAP32[((_code_statements_elements)>>2)];
      var $56=((($54)-($55))|0);
      var $57=(($56) & 65535);
      var $58=(($stmt+2)|0);
      var $59=$58;
      HEAP16[(($59)>>1)]=$57;
      var $60=(($stmt+4)|0);
      var $61=$60;
      HEAP16[(($61)>>1)]=0;
      var $62=(($stmt+6)|0);
      var $63=$62;
      HEAP16[(($63)>>1)]=0;
      var $64=_code_statements_add($stmt);
      var $65=(($64)|0) < 0;
      if ($65) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      $1=0;
      __label__ = 84; break;
    case 12: 
      $1=1;
      __label__ = 84; break;
    case 13: 
      var $69=$instr;
      var $70=(($69)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=(($71)|0)==69;
      if ($72) { __label__ = 14; break; } else { __label__ = 37; break; }
    case 14: 
      var $74=$instr;
      var $75=(($74+24)|0);
      var $76=(($75)|0);
      var $77=HEAP32[(($76)>>2)];
      $ontrue=$77;
      var $78=$instr;
      var $79=(($78+24)|0);
      var $80=(($79+4)|0);
      var $81=HEAP32[(($80)>>2)];
      $onfalse=$81;
      var $82=$instr;
      var $83=(($82+12)|0);
      var $84=(($83)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=_ir_value_code_addr($85);
      var $87=(($86) & 65535);
      var $88=(($stmt+2)|0);
      var $89=$88;
      HEAP16[(($89)>>1)]=$87;
      var $90=(($stmt+4)|0);
      var $91=$90;
      HEAP16[(($91)>>1)]=0;
      var $92=(($stmt+6)|0);
      var $93=$92;
      HEAP16[(($93)>>1)]=0;
      var $94=$ontrue;
      var $95=(($94+80)|0);
      var $96=HEAP8[($95)];
      var $97=(($96) & 1);
      if ($97) { __label__ = 15; break; } else { __label__ = 18; break; }
    case 15: 
      var $99=(($stmt)|0);
      HEAP16[(($99)>>1)]=49;
      var $100=$ontrue;
      var $101=(($100+84)|0);
      var $102=HEAP32[(($101)>>2)];
      var $103=HEAP32[((_code_statements_elements)>>2)];
      var $104=((($102)-($103))|0);
      var $105=(($104) & 65535);
      var $106=(($stmt+4)|0);
      var $107=$106;
      HEAP16[(($107)>>1)]=$105;
      var $108=_code_statements_add($stmt);
      var $109=(($108)|0) < 0;
      if ($109) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      $1=0;
      __label__ = 84; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $113=$onfalse;
      var $114=(($113+80)|0);
      var $115=HEAP8[($114)];
      var $116=(($115) & 1);
      if ($116) { __label__ = 19; break; } else { __label__ = 22; break; }
    case 19: 
      var $118=(($stmt)|0);
      HEAP16[(($118)>>1)]=50;
      var $119=$onfalse;
      var $120=(($119+84)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=HEAP32[((_code_statements_elements)>>2)];
      var $123=((($121)-($122))|0);
      var $124=(($123) & 65535);
      var $125=(($stmt+4)|0);
      var $126=$125;
      HEAP16[(($126)>>1)]=$124;
      var $127=_code_statements_add($stmt);
      var $128=(($127)|0) < 0;
      if ($128) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      $1=0;
      __label__ = 84; break;
    case 21: 
      __label__ = 22; break;
    case 22: 
      var $132=$ontrue;
      var $133=(($132+80)|0);
      var $134=HEAP8[($133)];
      var $135=(($134) & 1);
      if ($135) { __label__ = 26; break; } else { __label__ = 23; break; }
    case 23: 
      var $137=$onfalse;
      var $138=(($137+80)|0);
      var $139=HEAP8[($138)];
      var $140=(($139) & 1);
      if ($140) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      var $142=$ontrue;
      $3=$142;
      __label__ = 3; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      var $145=$onfalse;
      var $146=(($145+80)|0);
      var $147=HEAP8[($146)];
      var $148=(($147) & 1);
      if ($148) { __label__ = 30; break; } else { __label__ = 27; break; }
    case 27: 
      var $150=$ontrue;
      var $151=(($150+80)|0);
      var $152=HEAP8[($151)];
      var $153=(($152) & 1);
      if ($153) { __label__ = 28; break; } else { __label__ = 29; break; }
    case 28: 
      var $155=$onfalse;
      $3=$155;
      __label__ = 3; break;
    case 29: 
      __label__ = 30; break;
    case 30: 
      var $158=(($stmt)|0);
      HEAP16[(($158)>>1)]=50;
      var $159=HEAP32[((_code_statements_elements)>>2)];
      $stidx=$159;
      var $160=_code_statements_add($stmt);
      var $161=(($160)|0) < 0;
      if ($161) { __label__ = 31; break; } else { __label__ = 32; break; }
    case 31: 
      $1=0;
      __label__ = 84; break;
    case 32: 
      var $164=$2;
      var $165=$ontrue;
      var $166=_gen_blocks_recursive($164, $165);
      if ($166) { __label__ = 34; break; } else { __label__ = 33; break; }
    case 33: 
      $1=0;
      __label__ = 84; break;
    case 34: 
      var $169=HEAP32[((_code_statements_elements)>>2)];
      var $170=$stidx;
      var $171=((($169)-($170))|0);
      var $172=(($171) & 65535);
      var $173=$stidx;
      var $174=HEAP32[((_code_statements_data)>>2)];
      var $175=(($174+($173<<3))|0);
      var $176=(($175+4)|0);
      var $177=$176;
      HEAP16[(($177)>>1)]=$172;
      var $178=$onfalse;
      var $179=(($178+80)|0);
      var $180=HEAP8[($179)];
      var $181=(($180) & 1);
      if ($181) { __label__ = 35; break; } else { __label__ = 36; break; }
    case 35: 
      var $183=$onfalse;
      var $184=(($183+84)|0);
      var $185=HEAP32[(($184)>>2)];
      var $186=$stidx;
      var $187=((($185)-($186))|0);
      var $188=(($187) & 65535);
      var $189=$stidx;
      var $190=HEAP32[((_code_statements_data)>>2)];
      var $191=(($190+($189<<3))|0);
      var $192=(($191+4)|0);
      var $193=$192;
      HEAP16[(($193)>>1)]=$188;
      var $194=(($stmt)|0);
      HEAP16[(($194)>>1)]=61;
      var $195=$onfalse;
      var $196=(($195+84)|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=HEAP32[((_code_statements_elements)>>2)];
      var $199=((($197)-($198))|0);
      var $200=(($199) & 65535);
      var $201=(($stmt+2)|0);
      var $202=$201;
      HEAP16[(($202)>>1)]=$200;
      var $203=(($stmt+4)|0);
      var $204=$203;
      HEAP16[(($204)>>1)]=0;
      var $205=(($stmt+6)|0);
      var $206=$205;
      HEAP16[(($206)>>1)]=0;
      var $207=_code_statements_add($stmt);
      var $208=(($207)|0) >= 0;
      $1=$208;
      __label__ = 84; break;
    case 36: 
      var $210=$onfalse;
      $3=$210;
      __label__ = 3; break;
    case 37: 
      var $212=$instr;
      var $213=(($212)|0);
      var $214=HEAP32[(($213)>>2)];
      var $215=(($214)|0) >= 51;
      if ($215) { __label__ = 38; break; } else { __label__ = 62; break; }
    case 38: 
      var $217=$instr;
      var $218=(($217)|0);
      var $219=HEAP32[(($218)>>2)];
      var $220=(($219)|0) <= 59;
      if ($220) { __label__ = 39; break; } else { __label__ = 62; break; }
    case 39: 
      $p=0;
      __label__ = 40; break;
    case 40: 
      var $223=$p;
      var $224=$instr;
      var $225=(($224+48)|0);
      var $226=HEAP32[(($225)>>2)];
      var $227=(($223)>>>0) < (($226)>>>0);
      if ($227) { __label__ = 41; break; } else { __label__ = 48; break; }
    case 41: 
      var $229=$p;
      var $230=$instr;
      var $231=(($230+44)|0);
      var $232=HEAP32[(($231)>>2)];
      var $233=(($232+($229<<2))|0);
      var $234=HEAP32[(($233)>>2)];
      $param=$234;
      var $235=(($stmt)|0);
      HEAP16[(($235)>>1)]=31;
      var $236=(($stmt+6)|0);
      var $237=$236;
      HEAP16[(($237)>>1)]=0;
      var $238=$param;
      var $239=(($238+4)|0);
      var $240=HEAP32[(($239)>>2)];
      var $241=(($240)|0)==5;
      if ($241) { __label__ = 42; break; } else { __label__ = 43; break; }
    case 42: 
      var $243=$param;
      var $244=(($243+20)|0);
      var $245=HEAP32[(($244)>>2)];
      var $246=((_field_store_instr+($245<<1))|0);
      var $247=HEAP16[(($246)>>1)];
      var $248=(($stmt)|0);
      HEAP16[(($248)>>1)]=$247;
      __label__ = 44; break;
    case 43: 
      var $250=$param;
      var $251=(($250+4)|0);
      var $252=HEAP32[(($251)>>2)];
      var $253=((_type_store_instr+($252<<1))|0);
      var $254=HEAP16[(($253)>>1)];
      var $255=(($stmt)|0);
      HEAP16[(($255)>>1)]=$254;
      __label__ = 44; break;
    case 44: 
      var $257=$param;
      var $258=_ir_value_code_addr($257);
      var $259=(($258) & 65535);
      var $260=(($stmt+2)|0);
      var $261=$260;
      HEAP16[(($261)>>1)]=$259;
      var $262=$p;
      var $263=((($262)*(3))|0);
      var $264=((($263)+(4))|0);
      var $265=(($264) & 65535);
      var $266=(($stmt+4)|0);
      var $267=$266;
      HEAP16[(($267)>>1)]=$265;
      var $268=_code_statements_add($stmt);
      var $269=(($268)|0) < 0;
      if ($269) { __label__ = 45; break; } else { __label__ = 46; break; }
    case 45: 
      $1=0;
      __label__ = 84; break;
    case 46: 
      __label__ = 47; break;
    case 47: 
      var $273=$p;
      var $274=((($273)+(1))|0);
      $p=$274;
      __label__ = 40; break;
    case 48: 
      var $276=$instr;
      var $277=(($276+48)|0);
      var $278=HEAP32[(($277)>>2)];
      var $279=((($278)+(51))|0);
      var $280=(($279) & 65535);
      var $281=(($stmt)|0);
      HEAP16[(($281)>>1)]=$280;
      var $282=(($stmt)|0);
      var $283=HEAP16[(($282)>>1)];
      var $284=(($283)&65535);
      var $285=(($284)|0) > 59;
      if ($285) { __label__ = 49; break; } else { __label__ = 50; break; }
    case 49: 
      var $287=(($stmt)|0);
      HEAP16[(($287)>>1)]=59;
      __label__ = 50; break;
    case 50: 
      var $289=$instr;
      var $290=(($289+12)|0);
      var $291=(($290+4)|0);
      var $292=HEAP32[(($291)>>2)];
      var $293=_ir_value_code_addr($292);
      var $294=(($293) & 65535);
      var $295=(($stmt+2)|0);
      var $296=$295;
      HEAP16[(($296)>>1)]=$294;
      var $297=(($stmt+4)|0);
      var $298=$297;
      HEAP16[(($298)>>1)]=0;
      var $299=(($stmt+6)|0);
      var $300=$299;
      HEAP16[(($300)>>1)]=0;
      var $301=_code_statements_add($stmt);
      var $302=(($301)|0) < 0;
      if ($302) { __label__ = 51; break; } else { __label__ = 52; break; }
    case 51: 
      $1=0;
      __label__ = 84; break;
    case 52: 
      var $305=$instr;
      var $306=(($305+12)|0);
      var $307=(($306)|0);
      var $308=HEAP32[(($307)>>2)];
      $retvalue=$308;
      var $309=$retvalue;
      var $310=(($309)|0)!=0;
      if ($310) { __label__ = 53; break; } else { __label__ = 61; break; }
    case 53: 
      var $312=$retvalue;
      var $313=(($312+8)|0);
      var $314=HEAP32[(($313)>>2)];
      var $315=(($314)|0)!=4;
      if ($315) { __label__ = 54; break; } else { __label__ = 61; break; }
    case 54: 
      var $317=$retvalue;
      var $318=(($317+104)|0);
      var $319=HEAP32[(($318)>>2)];
      var $320=(($319)|0)!=0;
      if ($320) { __label__ = 55; break; } else { __label__ = 61; break; }
    case 55: 
      var $322=$retvalue;
      var $323=(($322+4)|0);
      var $324=HEAP32[(($323)>>2)];
      var $325=(($324)|0)==5;
      if ($325) { __label__ = 56; break; } else { __label__ = 57; break; }
    case 56: 
      var $327=$retvalue;
      var $328=(($327+4)|0);
      var $329=HEAP32[(($328)>>2)];
      var $330=((_field_store_instr+($329<<1))|0);
      var $331=HEAP16[(($330)>>1)];
      var $332=(($stmt)|0);
      HEAP16[(($332)>>1)]=$331;
      __label__ = 58; break;
    case 57: 
      var $334=$retvalue;
      var $335=(($334+4)|0);
      var $336=HEAP32[(($335)>>2)];
      var $337=((_type_store_instr+($336<<1))|0);
      var $338=HEAP16[(($337)>>1)];
      var $339=(($stmt)|0);
      HEAP16[(($339)>>1)]=$338;
      __label__ = 58; break;
    case 58: 
      var $341=(($stmt+2)|0);
      var $342=$341;
      HEAP16[(($342)>>1)]=1;
      var $343=$retvalue;
      var $344=_ir_value_code_addr($343);
      var $345=(($344) & 65535);
      var $346=(($stmt+4)|0);
      var $347=$346;
      HEAP16[(($347)>>1)]=$345;
      var $348=(($stmt+6)|0);
      var $349=$348;
      HEAP16[(($349)>>1)]=0;
      var $350=_code_statements_add($stmt);
      var $351=(($350)|0) < 0;
      if ($351) { __label__ = 59; break; } else { __label__ = 60; break; }
    case 59: 
      $1=0;
      __label__ = 84; break;
    case 60: 
      __label__ = 61; break;
    case 61: 
      __label__ = 82; break;
    case 62: 
      var $356=$instr;
      var $357=(($356)|0);
      var $358=HEAP32[(($357)>>2)];
      var $359=(($358)|0)==60;
      if ($359) { __label__ = 63; break; } else { __label__ = 64; break; }
    case 63: 
      var $361=$3;
      var $362=(($361+4)|0);
      var $363=(($362)|0);
      var $364=HEAP32[(($363)>>2)];
      var $365=(($362+4)|0);
      var $366=HEAP32[(($365)>>2)];
      _irerror($364, $366, ((STRING_TABLE.__str71285)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 84; break;
    case 64: 
      var $368=$instr;
      var $369=(($368)|0);
      var $370=HEAP32[(($369)>>2)];
      var $371=(($370) & 65535);
      var $372=(($stmt)|0);
      HEAP16[(($372)>>1)]=$371;
      var $373=(($stmt+2)|0);
      var $374=$373;
      HEAP16[(($374)>>1)]=0;
      var $375=(($stmt+4)|0);
      var $376=$375;
      HEAP16[(($376)>>1)]=0;
      var $377=(($stmt+6)|0);
      var $378=$377;
      HEAP16[(($378)>>1)]=0;
      var $379=$instr;
      var $380=(($379+12)|0);
      var $381=(($380)|0);
      var $382=HEAP32[(($381)>>2)];
      var $383=(($382)|0)!=0;
      if ($383) { __label__ = 65; break; } else { __label__ = 66; break; }
    case 65: 
      var $385=$instr;
      var $386=(($385+12)|0);
      var $387=(($386)|0);
      var $388=HEAP32[(($387)>>2)];
      var $389=_ir_value_code_addr($388);
      var $390=(($389) & 65535);
      var $391=(($stmt+6)|0);
      var $392=$391;
      HEAP16[(($392)>>1)]=$390;
      __label__ = 66; break;
    case 66: 
      var $394=$instr;
      var $395=(($394+12)|0);
      var $396=(($395+4)|0);
      var $397=HEAP32[(($396)>>2)];
      var $398=(($397)|0)!=0;
      if ($398) { __label__ = 67; break; } else { __label__ = 68; break; }
    case 67: 
      var $400=$instr;
      var $401=(($400+12)|0);
      var $402=(($401+4)|0);
      var $403=HEAP32[(($402)>>2)];
      var $404=_ir_value_code_addr($403);
      var $405=(($404) & 65535);
      var $406=(($stmt+2)|0);
      var $407=$406;
      HEAP16[(($407)>>1)]=$405;
      __label__ = 68; break;
    case 68: 
      var $409=$instr;
      var $410=(($409+12)|0);
      var $411=(($410+8)|0);
      var $412=HEAP32[(($411)>>2)];
      var $413=(($412)|0)!=0;
      if ($413) { __label__ = 69; break; } else { __label__ = 70; break; }
    case 69: 
      var $415=$instr;
      var $416=(($415+12)|0);
      var $417=(($416+8)|0);
      var $418=HEAP32[(($417)>>2)];
      var $419=_ir_value_code_addr($418);
      var $420=(($419) & 65535);
      var $421=(($stmt+4)|0);
      var $422=$421;
      HEAP16[(($422)>>1)]=$420;
      __label__ = 70; break;
    case 70: 
      var $424=(($stmt)|0);
      var $425=HEAP16[(($424)>>1)];
      var $426=(($425)&65535);
      var $427=(($426)|0)==43;
      if ($427) { __label__ = 72; break; } else { __label__ = 71; break; }
    case 71: 
      var $429=(($stmt)|0);
      var $430=HEAP16[(($429)>>1)];
      var $431=(($430)&65535);
      var $432=(($431)|0)==0;
      if ($432) { __label__ = 72; break; } else { __label__ = 73; break; }
    case 72: 
      var $434=(($stmt+6)|0);
      var $435=$434;
      var $436=HEAP16[(($435)>>1)];
      var $437=(($stmt+2)|0);
      var $438=$437;
      HEAP16[(($438)>>1)]=$436;
      var $439=(($stmt+6)|0);
      var $440=$439;
      HEAP16[(($440)>>1)]=0;
      __label__ = 79; break;
    case 73: 
      var $442=(($stmt)|0);
      var $443=HEAP16[(($442)>>1)];
      var $444=(($443)&65535);
      var $445=(($444)|0) >= 31;
      if ($445) { __label__ = 74; break; } else { __label__ = 75; break; }
    case 74: 
      var $447=(($stmt)|0);
      var $448=HEAP16[(($447)>>1)];
      var $449=(($448)&65535);
      var $450=(($449)|0) <= 36;
      if ($450) { __label__ = 77; break; } else { __label__ = 75; break; }
    case 75: 
      var $452=(($stmt)|0);
      var $453=HEAP16[(($452)>>1)];
      var $454=(($453)&65535);
      var $455=(($454)|0) >= 37;
      if ($455) { __label__ = 76; break; } else { __label__ = 78; break; }
    case 76: 
      var $457=(($stmt)|0);
      var $458=HEAP16[(($457)>>1)];
      var $459=(($458)&65535);
      var $460=(($459)|0) <= 42;
      if ($460) { __label__ = 77; break; } else { __label__ = 78; break; }
    case 77: 
      var $462=(($stmt+6)|0);
      var $463=$462;
      var $464=HEAP16[(($463)>>1)];
      var $465=(($stmt+4)|0);
      var $466=$465;
      HEAP16[(($466)>>1)]=$464;
      var $467=(($stmt+6)|0);
      var $468=$467;
      HEAP16[(($468)>>1)]=0;
      __label__ = 78; break;
    case 78: 
      __label__ = 79; break;
    case 79: 
      var $471=_code_statements_add($stmt);
      var $472=(($471)|0) < 0;
      if ($472) { __label__ = 80; break; } else { __label__ = 81; break; }
    case 80: 
      $1=0;
      __label__ = 84; break;
    case 81: 
      __label__ = 82; break;
    case 82: 
      var $476=$i;
      var $477=((($476)+(1))|0);
      $i=$477;
      __label__ = 4; break;
    case 83: 
      $1=1;
      __label__ = 84; break;
    case 84: 
      var $480=$1;
      STACKTOP = __stackBase__;
      return $480;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_blocks_recursive["X"]=1;

function _gen_global_pointer($global) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $target;
      $2=$global;
      var $3=$2;
      var $4=(($3+52)|0);
      var $5=HEAP8[($4)];
      var $6=(($5) & 1);
      if ($6) { __label__ = 3; break; } else { __label__ = 8; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+56)|0);
      var $10=$9;
      var $11=HEAP32[(($10)>>2)];
      $target=$11;
      var $12=$target;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $15=$2;
      var $16=(($15+12)|0);
      var $17=$2;
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($16+4)|0);
      var $23=HEAP32[(($22)>>2)];
      _irerror($21, $23, ((STRING_TABLE.__str83297)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$19,tempInt));
      $1=0;
      __label__ = 12; break;
    case 5: 
      var $25=$target;
      var $26=(($25+68)|0);
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $31=$2;
      var $32=(($31+12)|0);
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($32+4)|0);
      var $36=HEAP32[(($35)>>2)];
      _irerror($34, $36, ((STRING_TABLE.__str82296)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 12; break;
    case 7: 
      var $38=$2;
      var $39=$target;
      var $40=(($39+68)|0);
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=_code_globals_add($42);
      _ir_value_code_setaddr($38, $43);
      __label__ = 9; break;
    case 8: 
      var $45=$2;
      var $46=_code_globals_add(0);
      _ir_value_code_setaddr($45, $46);
      __label__ = 9; break;
    case 9: 
      var $48=$2;
      var $49=(($48+68)|0);
      var $50=(($49)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=(($51)|0) < 0;
      if ($52) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      $1=0;
      __label__ = 12; break;
    case 11: 
      $1=1;
      __label__ = 12; break;
    case 12: 
      var $56=$1;
      STACKTOP = __stackBase__;
      return $56;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_global_pointer["X"]=1;

function _gen_global_field($global) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $fld;
      $2=$global;
      var $3=$2;
      var $4=(($3+52)|0);
      var $5=HEAP8[($4)];
      var $6=(($5) & 1);
      if ($6) { __label__ = 3; break; } else { __label__ = 10; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+56)|0);
      var $10=$9;
      var $11=HEAP32[(($10)>>2)];
      $fld=$11;
      var $12=$fld;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $15=$2;
      var $16=(($15+12)|0);
      var $17=$2;
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($16+4)|0);
      var $23=HEAP32[(($22)>>2)];
      _irerror($21, $23, ((STRING_TABLE.__str81295)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$19,tempInt));
      $1=0;
      __label__ = 16; break;
    case 5: 
      var $25=$fld;
      var $26=(($25+68)|0);
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $31=$2;
      var $32=(($31+12)|0);
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($32+4)|0);
      var $36=HEAP32[(($35)>>2)];
      _irerror($34, $36, ((STRING_TABLE.__str82296)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 7: 
      var $38=$2;
      var $39=$fld;
      var $40=(($39+68)|0);
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=HEAP32[((_code_globals_data)>>2)];
      var $44=(($43+($42<<2))|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=_code_globals_add($45);
      _ir_value_code_setaddr($38, $46);
      var $47=$2;
      var $48=(($47+20)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($49)|0)==3;
      if ($50) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $52=$fld;
      var $53=(($52+68)|0);
      var $54=(($53)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=HEAP32[((_code_globals_data)>>2)];
      var $57=(($56+($55<<2))|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=((($58)+(1))|0);
      var $60=_code_globals_add($59);
      var $61=$fld;
      var $62=(($61+68)|0);
      var $63=(($62)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=HEAP32[((_code_globals_data)>>2)];
      var $66=(($65+($64<<2))|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=((($67)+(2))|0);
      var $69=_code_globals_add($68);
      __label__ = 9; break;
    case 9: 
      __label__ = 13; break;
    case 10: 
      var $72=$2;
      var $73=_code_globals_add(0);
      _ir_value_code_setaddr($72, $73);
      var $74=$2;
      var $75=(($74+20)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=(($76)|0)==3;
      if ($77) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $79=_code_globals_add(0);
      var $80=_code_globals_add(0);
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $83=$2;
      var $84=(($83+68)|0);
      var $85=(($84)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=(($86)|0) < 0;
      if ($87) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      $1=0;
      __label__ = 16; break;
    case 15: 
      $1=1;
      __label__ = 16; break;
    case 16: 
      var $91=$1;
      STACKTOP = __stackBase__;
      return $91;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_global_field["X"]=1;

function _ir_op_read_write($op, $read, $write) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $1=$op;
      $2=$read;
      $3=$write;
      var $4=$1;
      if ((($4)|0) == 68 || (($4)|0) == 61) {
        __label__ = 3; break;
      }
      else if ((($4)|0) == 49 || (($4)|0) == 50 || (($4)|0) == 43 || (($4)|0) == 69) {
        __label__ = 4; break;
      }
      else if ((($4)|0) == 37 || (($4)|0) == 38 || (($4)|0) == 39 || (($4)|0) == 40 || (($4)|0) == 41 || (($4)|0) == 42) {
        __label__ = 5; break;
      }
      else {
      __label__ = 6; break;
      }
      
    case 3: 
      var $6=$3;
      HEAP32[(($6)>>2)]=0;
      var $7=$2;
      HEAP32[(($7)>>2)]=0;
      __label__ = 7; break;
    case 4: 
      var $9=$3;
      HEAP32[(($9)>>2)]=0;
      var $10=$2;
      HEAP32[(($10)>>2)]=1;
      __label__ = 7; break;
    case 5: 
      var $12=$3;
      HEAP32[(($12)>>2)]=0;
      var $13=$2;
      HEAP32[(($13)>>2)]=7;
      __label__ = 7; break;
    case 6: 
      var $15=$3;
      HEAP32[(($15)>>2)]=1;
      var $16=$2;
      HEAP32[(($16)>>2)]=6;
      __label__ = 7; break;
    case 7: 
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _gen_global_function($ir, $global) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $fun=__stackBase__;
      var $irfun;
      var $i;
      var $local_var_end;
      var $last;
      var $v;
      $2=$ir;
      $3=$global;
      var $4=$3;
      var $5=(($4+52)|0);
      var $6=HEAP8[($5)];
      var $7=(($6) & 1);
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$3;
      var $10=(($9+56)|0);
      var $11=$10;
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $15=$3;
      var $16=(($15+12)|0);
      var $17=$3;
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($16+4)|0);
      var $23=HEAP32[(($22)>>2)];
      _irerror($21, $23, ((STRING_TABLE.__str79293)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$19,tempInt));
      $1=0;
      __label__ = 32; break;
    case 5: 
      var $25=$3;
      var $26=(($25+56)|0);
      var $27=$26;
      var $28=HEAP32[(($27)>>2)];
      $irfun=$28;
      var $29=$3;
      var $30=(($29+68)|0);
      var $31=(($30+4)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=(($fun+16)|0);
      HEAP32[(($33)>>2)]=$32;
      var $34=$2;
      var $35=$3;
      var $36=(($35+12)|0);
      var $37=(($36)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=_ir_builder_filestring($34, $38);
      var $40=(($fun+20)|0);
      HEAP32[(($40)>>2)]=$39;
      var $41=(($fun+12)|0);
      HEAP32[(($41)>>2)]=0;
      var $42=$irfun;
      var $43=(($42+12)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($fun+24)|0);
      HEAP32[(($45)>>2)]=$44;
      $i=0;
      __label__ = 6; break;
    case 6: 
      var $47=$i;
      var $48=(($47)>>>0) < 8;
      if ($48) { __label__ = 7; break; } else { __label__ = 12; break; }
    case 7: 
      var $50=$i;
      var $51=(($fun+24)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=(($50)>>>0) >= (($52)>>>0);
      if ($53) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $55=$i;
      var $56=(($fun+28)|0);
      var $57=(($56+$55)|0);
      HEAP8[($57)]=0;
      __label__ = 10; break;
    case 9: 
      var $59=$i;
      var $60=$irfun;
      var $61=(($60+8)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62+($59<<2))|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=((_type_sizeof+($64<<2))|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=(($66) & 255);
      var $68=$i;
      var $69=(($fun+28)|0);
      var $70=(($69+$68)|0);
      HEAP8[($70)]=$67;
      __label__ = 10; break;
    case 10: 
      __label__ = 11; break;
    case 11: 
      var $73=$i;
      var $74=((($73)+(1))|0);
      $i=$74;
      __label__ = 6; break;
    case 12: 
      var $76=HEAP32[((_code_globals_elements)>>2)];
      var $77=(($fun+4)|0);
      HEAP32[(($77)>>2)]=$76;
      var $78=(($fun+4)|0);
      var $79=HEAP32[(($78)>>2)];
      $local_var_end=$79;
      $i=0;
      __label__ = 13; break;
    case 13: 
      var $81=$i;
      var $82=$irfun;
      var $83=(($82+56)|0);
      var $84=HEAP32[(($83)>>2)];
      var $85=(($81)>>>0) < (($84)>>>0);
      if ($85) { __label__ = 14; break; } else { __label__ = 18; break; }
    case 14: 
      var $87=$2;
      var $88=$i;
      var $89=$irfun;
      var $90=(($89+52)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=(($91+($88<<2))|0);
      var $93=HEAP32[(($92)>>2)];
      var $94=_ir_builder_gen_global($87, $93, 1);
      if ($94) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $96=$i;
      var $97=$irfun;
      var $98=(($97+52)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=(($99+($96<<2))|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=(($101+12)|0);
      var $103=$i;
      var $104=$irfun;
      var $105=(($104+52)|0);
      var $106=HEAP32[(($105)>>2)];
      var $107=(($106+($103<<2))|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($108)|0);
      var $110=HEAP32[(($109)>>2)];
      var $111=(($102)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($102+4)|0);
      var $114=HEAP32[(($113)>>2)];
      _irerror($112, $114, ((STRING_TABLE.__str80294)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$110,tempInt));
      $1=0;
      __label__ = 32; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $117=$i;
      var $118=((($117)+(1))|0);
      $i=$118;
      __label__ = 13; break;
    case 18: 
      var $120=$irfun;
      var $121=(($120+56)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=(($122)|0)!=0;
      if ($123) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $125=$irfun;
      var $126=(($125+56)|0);
      var $127=HEAP32[(($126)>>2)];
      var $128=((($127)-(1))|0);
      var $129=$irfun;
      var $130=(($129+52)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=(($131+($128<<2))|0);
      var $133=HEAP32[(($132)>>2)];
      $last=$133;
      var $134=$last;
      var $135=(($134+68)|0);
      var $136=(($135)|0);
      var $137=HEAP32[(($136)>>2)];
      $local_var_end=$137;
      var $138=$last;
      var $139=(($138+4)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=((_type_sizeof+($140<<2))|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=$local_var_end;
      var $144=((($143)+($142))|0);
      $local_var_end=$144;
      __label__ = 20; break;
    case 20: 
      $i=0;
      __label__ = 21; break;
    case 21: 
      var $147=$i;
      var $148=$irfun;
      var $149=(($148+44)|0);
      var $150=HEAP32[(($149)>>2)];
      var $151=(($147)>>>0) < (($150)>>>0);
      if ($151) { __label__ = 22; break; } else { __label__ = 24; break; }
    case 22: 
      var $153=$i;
      var $154=$irfun;
      var $155=(($154+40)|0);
      var $156=HEAP32[(($155)>>2)];
      var $157=(($156+($153<<2))|0);
      var $158=HEAP32[(($157)>>2)];
      $v=$158;
      var $159=$v;
      var $160=$local_var_end;
      var $161=$v;
      var $162=(($161+68)|0);
      var $163=(($162+8)|0);
      var $164=HEAP32[(($163)>>2)];
      var $165=((($160)+($164))|0);
      _ir_value_code_setaddr($159, $165);
      __label__ = 23; break;
    case 23: 
      var $167=$i;
      var $168=((($167)+(1))|0);
      $i=$168;
      __label__ = 21; break;
    case 24: 
      $i=0;
      __label__ = 25; break;
    case 25: 
      var $171=$i;
      var $172=$irfun;
      var $173=(($172+64)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=(($171)>>>0) < (($174)>>>0);
      if ($175) { __label__ = 26; break; } else { __label__ = 28; break; }
    case 26: 
      var $177=_code_globals_add(0);
      __label__ = 27; break;
    case 27: 
      var $179=$i;
      var $180=((($179)+(1))|0);
      $i=$180;
      __label__ = 25; break;
    case 28: 
      var $182=HEAP32[((_code_globals_elements)>>2)];
      var $183=(($fun+4)|0);
      var $184=HEAP32[(($183)>>2)];
      var $185=((($182)-($184))|0);
      var $186=(($fun+8)|0);
      HEAP32[(($186)>>2)]=$185;
      var $187=$irfun;
      var $188=(($187+32)|0);
      var $189=HEAP32[(($188)>>2)];
      var $190=(($189)|0)!=0;
      if ($190) { __label__ = 29; break; } else { __label__ = 30; break; }
    case 29: 
      var $192=$irfun;
      var $193=(($192+32)|0);
      var $194=HEAP32[(($193)>>2)];
      var $195=(($fun)|0);
      HEAP32[(($195)>>2)]=$194;
      __label__ = 31; break;
    case 30: 
      var $197=HEAP32[((_code_functions_elements)>>2)];
      var $198=$irfun;
      var $199=(($198+84)|0);
      HEAP32[(($199)>>2)]=$197;
      var $200=HEAP32[((_code_statements_elements)>>2)];
      var $201=(($fun)|0);
      HEAP32[(($201)>>2)]=$200;
      __label__ = 31; break;
    case 31: 
      var $203=_code_functions_add($fun);
      var $204=(($203)|0) >= 0;
      $1=$204;
      __label__ = 32; break;
    case 32: 
      var $206=$1;
      STACKTOP = __stackBase__;
      return $206;
    default: assert(0, "bad label: " + __label__);
  }
}
_gen_global_function["X"]=1;

function _ir_builder_filestring($ir, $filename) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $str;
      $2=$ir;
      $3=$filename;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+44)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+40)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<2))|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=$3;
      var $18=(($16)|0)==(($17)|0);
      if ($18) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $20=$i;
      var $21=$2;
      var $22=(($21+52)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+($20<<2))|0);
      var $25=HEAP32[(($24)>>2)];
      $1=$25;
      __label__ = 13; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $28=$i;
      var $29=((($28)+(1))|0);
      $i=$29;
      __label__ = 3; break;
    case 8: 
      var $31=$3;
      var $32=_code_genstring($31);
      $str=$32;
      var $33=$2;
      var $34=$3;
      var $35=_ir_builder_filenames_add($33, $34);
      if ($35) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 13; break;
    case 10: 
      var $38=$2;
      var $39=$str;
      var $40=_ir_builder_filestrings_add($38, $39);
      if ($40) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      var $42=$2;
      var $43=(($42+44)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44)-(1))|0);
      HEAP32[(($43)>>2)]=$45;
      __label__ = 12; break;
    case 12: 
      var $47=$str;
      $1=$47;
      __label__ = 13; break;
    case 13: 
      var $49=$1;
      ;
      return $49;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_builder_filestring["X"]=1;

function _ir_block_life_prop_previous($self, $prev, $changed) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      $2=$self;
      $3=$prev;
      $4=$changed;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $6=$i;
      var $7=$2;
      var $8=(($7+56)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)>>>0) < (($9)>>>0);
      if ($10) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      var $12=$3;
      var $13=$i;
      var $14=$2;
      var $15=(($14+52)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16+($13<<2))|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=_ir_block_living_find($12, $18, 0);
      if ($19) { __label__ = 8; break; } else { __label__ = 5; break; }
    case 5: 
      var $21=$2;
      var $22=$i;
      var $23=_ir_block_living_remove($21, $22);
      if ($23) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      $1=0;
      __label__ = 19; break;
    case 7: 
      var $26=$i;
      var $27=((($26)-(1))|0);
      $i=$27;
      __label__ = 8; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $30=$i;
      var $31=((($30)+(1))|0);
      $i=$31;
      __label__ = 3; break;
    case 10: 
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $34=$i;
      var $35=$3;
      var $36=(($35+56)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($34)>>>0) < (($37)>>>0);
      if ($38) { __label__ = 12; break; } else { __label__ = 18; break; }
    case 12: 
      var $40=$2;
      var $41=$i;
      var $42=$3;
      var $43=(($42+52)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=(($44+($41<<2))|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=_ir_block_living_find($40, $46, 0);
      if ($47) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      __label__ = 17; break;
    case 14: 
      var $50=$2;
      var $51=$i;
      var $52=$3;
      var $53=(($52+52)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=(($54+($51<<2))|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=_ir_block_living_add($50, $56);
      if ($57) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 19; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $61=$i;
      var $62=((($61)+(1))|0);
      $i=$62;
      __label__ = 11; break;
    case 18: 
      $1=1;
      __label__ = 19; break;
    case 19: 
      var $65=$1;
      ;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_life_prop_previous["X"]=1;

function _ir_block_living_add_instr($self, $eid) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $changed;
      var $tempbool;
      $1=$self;
      $2=$eid;
      $changed=0;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $4=$i;
      var $5=$1;
      var $6=(($5+56)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($4)|0)!=(($7)|0);
      if ($8) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $10=$i;
      var $11=$1;
      var $12=(($11+52)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13+($10<<2))|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$2;
      var $17=_ir_value_life_merge($15, $16);
      var $18=(($17)&1);
      $tempbool=$18;
      var $19=$changed;
      var $20=(($19) & 1);
      if ($20) { var $25 = 1;__label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $22=$tempbool;
      var $23=(($22) & 1);
      var $25 = $23;__label__ = 6; break;
    case 6: 
      var $25;
      var $26=(($25)&1);
      $changed=$26;
      __label__ = 7; break;
    case 7: 
      var $28=$i;
      var $29=((($28)+(1))|0);
      $i=$29;
      __label__ = 3; break;
    case 8: 
      var $31=$changed;
      var $32=(($31) & 1);
      ;
      return $32;
    default: assert(0, "bad label: " + __label__);
  }
}


function _ir_naive_phi_emit_store($block, $iid, $old, $what) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $instr;
      var $i;
      $2=$block;
      $3=$iid;
      $4=$old;
      $5=$what;
      var $6=$2;
      var $7=$4;
      var $8=$5;
      var $9=_ir_block_create_store($6, $7, $8);
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 9; break;
    case 4: 
      var $12=$2;
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=((($14)-(1))|0);
      var $16=$2;
      var $17=(($16+16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18+($15<<2))|0);
      var $20=HEAP32[(($19)>>2)];
      $instr=$20;
      var $21=$2;
      var $22=(($21+20)|0);
      var $23=HEAP32[(($22)>>2)];
      $i=$23;
      __label__ = 5; break;
    case 5: 
      var $25=$i;
      var $26=$3;
      var $27=(($25)>>>0) > (($26)>>>0);
      if ($27) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $29=$i;
      var $30=((($29)-(1))|0);
      var $31=$2;
      var $32=(($31+16)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33+($30<<2))|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$i;
      var $37=$2;
      var $38=(($37+16)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($39+($36<<2))|0);
      HEAP32[(($40)>>2)]=$35;
      __label__ = 7; break;
    case 7: 
      var $42=$i;
      var $43=((($42)-(1))|0);
      $i=$43;
      __label__ = 5; break;
    case 8: 
      var $45=$instr;
      var $46=$i;
      var $47=$2;
      var $48=(($47+16)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($49+($46<<2))|0);
      HEAP32[(($50)>>2)]=$45;
      $1=1;
      __label__ = 9; break;
    case 9: 
      var $52=$1;
      ;
      return $52;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_naive_phi_emit_store["X"]=1;

function _ir_block_delete_quick($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$self;
      var $2=$1;
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7)|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 545, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $12=$i;
      var $13=$1;
      var $14=(($13+20)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($12)|0)!=(($15)|0);
      if ($16) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $18=$i;
      var $19=$1;
      var $20=(($19+16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+($18<<2))|0);
      var $23=HEAP32[(($22)>>2)];
      _ir_instr_delete_quick($23);
      __label__ = 7; break;
    case 7: 
      var $25=$i;
      var $26=((($25)+(1))|0);
      $i=$26;
      __label__ = 5; break;
    case 8: 
      var $28=$1;
      var $29=(($28+16)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $33=$1;
      var $34=(($33+16)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=$35;
      _util_memory_d($36, 548, ((STRING_TABLE.__str9222)|0));
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      var $39=(($38+16)|0);
      HEAP32[(($39)>>2)]=0;
      var $40=$1;
      var $41=(($40+20)|0);
      HEAP32[(($41)>>2)]=0;
      var $42=$1;
      var $43=(($42+24)|0);
      HEAP32[(($43)>>2)]=0;
      var $44=$1;
      var $45=(($44+28)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($46)|0)!=0;
      if ($47) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $49=$1;
      var $50=(($49+28)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=$51;
      _util_memory_d($52, 549, ((STRING_TABLE.__str9222)|0));
      __label__ = 12; break;
    case 12: 
      var $54=$1;
      var $55=(($54+28)|0);
      HEAP32[(($55)>>2)]=0;
      var $56=$1;
      var $57=(($56+32)|0);
      HEAP32[(($57)>>2)]=0;
      var $58=$1;
      var $59=(($58+36)|0);
      HEAP32[(($59)>>2)]=0;
      var $60=$1;
      var $61=(($60+40)|0);
      var $62=HEAP32[(($61)>>2)];
      var $63=(($62)|0)!=0;
      if ($63) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $65=$1;
      var $66=(($65+40)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=$67;
      _util_memory_d($68, 550, ((STRING_TABLE.__str9222)|0));
      __label__ = 14; break;
    case 14: 
      var $70=$1;
      var $71=(($70+40)|0);
      HEAP32[(($71)>>2)]=0;
      var $72=$1;
      var $73=(($72+44)|0);
      HEAP32[(($73)>>2)]=0;
      var $74=$1;
      var $75=(($74+48)|0);
      HEAP32[(($75)>>2)]=0;
      var $76=$1;
      var $77=(($76+52)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($78)|0)!=0;
      if ($79) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $81=$1;
      var $82=(($81+52)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=$83;
      _util_memory_d($84, 551, ((STRING_TABLE.__str9222)|0));
      __label__ = 16; break;
    case 16: 
      var $86=$1;
      var $87=(($86+52)|0);
      HEAP32[(($87)>>2)]=0;
      var $88=$1;
      var $89=(($88+56)|0);
      HEAP32[(($89)>>2)]=0;
      var $90=$1;
      var $91=(($90+60)|0);
      HEAP32[(($91)>>2)]=0;
      var $92=$1;
      var $93=$92;
      _util_memory_d($93, 552, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_ir_block_delete_quick["X"]=1;

function _ir_instr_delete_quick($self) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$self;
      var $2=$1;
      var $3=(($2+32)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $7=$1;
      var $8=(($7+32)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=$9;
      _util_memory_d($10, 607, ((STRING_TABLE.__str9222)|0));
      __label__ = 4; break;
    case 4: 
      var $12=$1;
      var $13=(($12+32)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=$1;
      var $15=(($14+36)|0);
      HEAP32[(($15)>>2)]=0;
      var $16=$1;
      var $17=(($16+40)|0);
      HEAP32[(($17)>>2)]=0;
      var $18=$1;
      var $19=(($18+44)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20)|0)!=0;
      if ($21) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $23=$1;
      var $24=(($23+44)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=$25;
      _util_memory_d($26, 608, ((STRING_TABLE.__str9222)|0));
      __label__ = 6; break;
    case 6: 
      var $28=$1;
      var $29=(($28+44)|0);
      HEAP32[(($29)>>2)]=0;
      var $30=$1;
      var $31=(($30+48)|0);
      HEAP32[(($31)>>2)]=0;
      var $32=$1;
      var $33=(($32+52)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$1;
      var $35=$34;
      _util_memory_d($35, 609, ((STRING_TABLE.__str9222)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _token_value_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+8)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+12)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+12)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+12)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+12)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27)|0);
      var $29=_util_memory_a($28, 9, ((STRING_TABLE.__str385)|0));
      $reall=$29;
      var $30=$reall;
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $34=$reall;
      var $35=$2;
      var $36=(($35+4)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=$2;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40)|0);
      assert($41 % 1 === 0, 'memcpy given ' + $41 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($34, $37, $41, 1);
      var $42=$2;
      var $43=(($42+4)|0);
      var $44=HEAP32[(($43)>>2)];
      _util_memory_d($44, 9, ((STRING_TABLE.__str385)|0));
      var $45=$reall;
      var $46=$2;
      var $47=(($46+4)|0);
      HEAP32[(($47)>>2)]=$45;
      __label__ = 9; break;
    case 9: 
      var $49=$3;
      var $50=$2;
      var $51=(($50+8)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=((($52)+(1))|0);
      HEAP32[(($51)>>2)]=$53;
      var $54=$2;
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+$52)|0);
      HEAP8[($57)]=$49;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $59=$1;
      ;
      return $59;
    default: assert(0, "bad label: " + __label__);
  }
}
_token_value_add["X"]=1;

function _lex_file_frames_add($self, $f_0, $f_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $f=__stackBase__;
      var $reall;
      $2=$self;
      var $3=(($f)|0);
      HEAP32[(($3)>>2)]=$f_0;
      var $4=(($f+4)|0);
      HEAP32[(($4)>>2)]=$f_1;
      var $5=$2;
      var $6=(($5+340)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=(($8+344)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)|0)==(($10)|0);
      if ($11) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $13=$2;
      var $14=(($13+344)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $18=$2;
      var $19=(($18+344)|0);
      HEAP32[(($19)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $21=$2;
      var $22=(($21+344)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=((($23<<1))|0);
      HEAP32[(($22)>>2)]=$24;
      __label__ = 6; break;
    case 6: 
      var $26=$2;
      var $27=(($26+344)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=((($28<<3))|0);
      var $30=_util_memory_a($29, 10, ((STRING_TABLE.__str385)|0));
      var $31=$30;
      $reall=$31;
      var $32=$reall;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $36=$reall;
      var $37=$36;
      var $38=$2;
      var $39=(($38+336)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      var $42=$2;
      var $43=(($42+340)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44<<3))|0);
      assert($45 % 1 === 0, 'memcpy given ' + $45 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $41, $45, 4);
      var $46=$2;
      var $47=(($46+336)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      _util_memory_d($49, 10, ((STRING_TABLE.__str385)|0));
      var $50=$reall;
      var $51=$2;
      var $52=(($51+336)|0);
      HEAP32[(($52)>>2)]=$50;
      __label__ = 9; break;
    case 9: 
      var $54=$2;
      var $55=(($54+340)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+336)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<3))|0);
      var $62=$61;
      var $63=$f;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($62)>>2)]=HEAP32[(($63)>>2)];HEAP32[((($62)+(4))>>2)]=HEAP32[((($63)+(4))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_file_frames_add["X"]=1;

function _lex_filenames_add($element) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $temp;
      $2=$element;
      $temp=0;
      var $3=HEAP32[((_lex_filenames_elements)>>2)];
      var $4=HEAP32[((_lex_filenames_allocated)>>2)];
      var $5=(($3)|0)==(($4)|0);
      if ($5) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $7=HEAP32[((_lex_filenames_allocated)>>2)];
      var $8=(($7)|0)==0;
      if ($8) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_lex_filenames_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $11=HEAP32[((_lex_filenames_allocated)>>2)];
      var $12=((($11<<1))|0);
      HEAP32[((_lex_filenames_allocated)>>2)]=$12;
      __label__ = 6; break;
    case 6: 
      var $14=HEAP32[((_lex_filenames_allocated)>>2)];
      var $15=((($14<<2))|0);
      var $16=_util_memory_a($15, 12, ((STRING_TABLE.__str385)|0));
      $temp=$16;
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $19=$temp;
      _util_memory_d($19, 12, ((STRING_TABLE.__str385)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $21=$temp;
      var $22=HEAP32[((_lex_filenames_data)>>2)];
      var $23=$22;
      var $24=HEAP32[((_lex_filenames_elements)>>2)];
      var $25=((($24<<2))|0);
      assert($25 % 1 === 0, 'memcpy given ' + $25 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($21, $23, $25, 1);
      var $26=HEAP32[((_lex_filenames_data)>>2)];
      var $27=$26;
      _util_memory_d($27, 12, ((STRING_TABLE.__str385)|0));
      var $28=$temp;
      var $29=$28;
      HEAP32[((_lex_filenames_data)>>2)]=$29;
      __label__ = 9; break;
    case 9: 
      var $31=$2;
      var $32=HEAP32[((_lex_filenames_elements)>>2)];
      var $33=HEAP32[((_lex_filenames_data)>>2)];
      var $34=(($33+($32<<2))|0);
      HEAP32[(($34)>>2)]=$31;
      var $35=HEAP32[((_lex_filenames_elements)>>2)];
      var $36=((($35)+(1))|0);
      HEAP32[((_lex_filenames_elements)>>2)]=$36;
      $1=$35;
      __label__ = 10; break;
    case 10: 
      var $38=$1;
      ;
      return $38;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_filenames_add["X"]=1;

function _lexerror($lex, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  var $2;
  var $ap=__stackBase__;
  $1=$lex;
  $2=$fmt;
  var $3=$ap;
  HEAP32[(($3)>>2)]=arguments[_lexerror.length];
  var $4=$1;
  var $5=(($4+16)|0);
  var $6=HEAP32[(($5)>>2)];
  var $7=$1;
  var $8=(($7+24)|0);
  var $9=HEAP32[(($8)>>2)];
  var $10=$2;
  var $11=HEAP32[(($ap)>>2)];
  _vprintmsg(2, $6, $9, ((STRING_TABLE.__str1386)|0), $10, $11);
  var $12=$ap;
  ;
  STACKTOP = __stackBase__;
  return;
}


function _lexwarn($lex, $warntype, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ap=__stackBase__;
      var $lvl;
      $2=$lex;
      $3=$warntype;
      $4=$fmt;
      $lvl=1;
      var $5=$3;
      var $6=((((($5)|0))/(32))&-1);
      var $7=((_opts_warn+($6<<2))|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=$3;
      var $10=((($9)|0))%(32);
      var $11=1 << $10;
      var $12=$8 & $11;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $16=HEAP8[(_opts_werror)];
      var $17=(($16) & 1);
      if ($17) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $lvl=2;
      __label__ = 6; break;
    case 6: 
      var $20=$ap;
      HEAP32[(($20)>>2)]=arguments[_lexwarn.length];
      var $21=$lvl;
      var $22=$2;
      var $23=(($22+16)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=$2;
      var $26=(($25+24)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$4;
      var $29=HEAP32[(($ap)>>2)];
      _vprintmsg($21, $24, $27, ((STRING_TABLE.__str2387)|0), $28, $29);
      var $30=$ap;
      ;
      var $31=HEAP8[(_opts_werror)];
      var $32=(($31) & 1);
      $1=$32;
      __label__ = 7; break;
    case 7: 
      var $34=$1;
      STACKTOP = __stackBase__;
      return $34;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_open($file) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $lex;
      var $in;
      $2=$file;
      var $3=$2;
      var $4=_util_fopen($3, ((STRING_TABLE.__str3388)|0));
      $in=$4;
      var $5=$in;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $8=$2;
      _lexerror(0, ((STRING_TABLE.__str4389)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$8,tempInt));
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $10=_util_memory_a(352, 144, ((STRING_TABLE.__str385)|0));
      var $11=$10;
      $lex=$11;
      var $12=$lex;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $15=$in;
      var $16=_fclose($15);
      _lexerror(0, ((STRING_TABLE.__str5390)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $18=$lex;
      var $19=$18;
      for (var $$dest = $19>>2, $$stop = $$dest + 88; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      var $20=$in;
      var $21=$lex;
      var $22=(($21)|0);
      HEAP32[(($22)>>2)]=$20;
      var $23=$2;
      var $24=_util_strdup($23);
      var $25=$lex;
      var $26=(($25+16)|0);
      HEAP32[(($26)>>2)]=$24;
      var $27=$lex;
      var $28=(($27+20)|0);
      HEAP32[(($28)>>2)]=1;
      var $29=$lex;
      var $30=(($29+284)|0);
      HEAP32[(($30)>>2)]=0;
      var $31=$lex;
      var $32=(($31+288)|0);
      HEAP8[($32)]=0;
      var $33=$lex;
      var $34=(($33+16)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=_lex_filenames_add($35);
      var $37=$lex;
      $1=$37;
      __label__ = 7; break;
    case 7: 
      var $39=$1;
      STACKTOP = __stackBase__;
      return $39;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_open["X"]=1;

function _lex_open_string($str, $len, $name) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $lex;
      $2=$str;
      $3=$len;
      $4=$name;
      var $5=_util_memory_a(352, 169, ((STRING_TABLE.__str385)|0));
      var $6=$5;
      $lex=$6;
      var $7=$lex;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      _lexerror(0, ((STRING_TABLE.__str5390)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $11=$lex;
      var $12=$11;
      for (var $$dest = $12>>2, $$stop = $$dest + 88; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      var $13=$lex;
      var $14=(($13)|0);
      HEAP32[(($14)>>2)]=0;
      var $15=$2;
      var $16=$lex;
      var $17=(($16+4)|0);
      HEAP32[(($17)>>2)]=$15;
      var $18=$3;
      var $19=$lex;
      var $20=(($19+8)|0);
      HEAP32[(($20)>>2)]=$18;
      var $21=$lex;
      var $22=(($21+12)|0);
      HEAP32[(($22)>>2)]=0;
      var $23=$4;
      var $24=(($23)|0)!=0;
      if ($24) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $26=$4;
      var $29 = $26;__label__ = 7; break;
    case 6: 
      var $29 = ((STRING_TABLE.__str6391)|0);__label__ = 7; break;
    case 7: 
      var $29;
      var $30=_util_strdup($29);
      var $31=$lex;
      var $32=(($31+16)|0);
      HEAP32[(($32)>>2)]=$30;
      var $33=$lex;
      var $34=(($33+20)|0);
      HEAP32[(($34)>>2)]=1;
      var $35=$lex;
      var $36=(($35+284)|0);
      HEAP32[(($36)>>2)]=0;
      var $37=$lex;
      var $38=(($37+288)|0);
      HEAP8[($38)]=0;
      var $39=$lex;
      var $40=(($39+16)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=_lex_filenames_add($41);
      var $43=$lex;
      $1=$43;
      __label__ = 8; break;
    case 8: 
      var $45=$1;
      STACKTOP = __stackBase__;
      return $45;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_open_string["X"]=1;

function _lex_cleanup() {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $i;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $2=$i;
      var $3=HEAP32[((_lex_filenames_elements)>>2)];
      var $4=(($2)>>>0) < (($3)>>>0);
      if ($4) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $6=$i;
      var $7=HEAP32[((_lex_filenames_data)>>2)];
      var $8=(($7+($6<<2))|0);
      var $9=HEAP32[(($8)>>2)];
      _util_memory_d($9, 197, ((STRING_TABLE.__str385)|0));
      __label__ = 5; break;
    case 5: 
      var $11=$i;
      var $12=((($11)+(1))|0);
      $i=$12;
      __label__ = 3; break;
    case 6: 
      var $14=HEAP32[((_lex_filenames_data)>>2)];
      var $15=$14;
      _util_memory_d($15, 198, ((STRING_TABLE.__str385)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_close($lex) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$lex;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=$1;
      var $5=(($4+340)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($3)>>>0) < (($6)>>>0);
      if ($7) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $9=$i;
      var $10=$1;
      var $11=(($10+336)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12+($9<<3))|0);
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      _util_memory_d($15, 205, ((STRING_TABLE.__str385)|0));
      __label__ = 5; break;
    case 5: 
      var $17=$i;
      var $18=((($17)+(1))|0);
      $i=$18;
      __label__ = 3; break;
    case 6: 
      var $20=$1;
      var $21=(($20+336)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $25=$1;
      var $26=(($25+336)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$27;
      _util_memory_d($28, 206, ((STRING_TABLE.__str385)|0));
      __label__ = 8; break;
    case 8: 
      var $30=$1;
      var $31=(($30+336)|0);
      HEAP32[(($31)>>2)]=0;
      var $32=$1;
      var $33=(($32+340)|0);
      HEAP32[(($33)>>2)]=0;
      var $34=$1;
      var $35=(($34+344)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=$1;
      var $37=(($36+348)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=(($38)|0)!=0;
      if ($39) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $41=$1;
      var $42=(($41+348)|0);
      var $43=HEAP32[(($42)>>2)];
      _util_memory_d($43, 209, ((STRING_TABLE.__str385)|0));
      __label__ = 10; break;
    case 10: 
      var $45=$1;
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($47)|0)!=0;
      if ($48) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $50=$1;
      var $51=(($50)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=_fclose($52);
      __label__ = 12; break;
    case 12: 
      var $55=$1;
      var $56=(($55+292)|0);
      var $57=(($56+4)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58)|0)!=0;
      if ($59) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $61=$1;
      var $62=(($61+292)|0);
      var $63=(($62+4)|0);
      var $64=HEAP32[(($63)>>2)];
      _util_memory_d($64, 217, ((STRING_TABLE.__str385)|0));
      __label__ = 14; break;
    case 14: 
      var $66=$1;
      var $67=(($66+292)|0);
      var $68=(($67+4)|0);
      HEAP32[(($68)>>2)]=0;
      var $69=$1;
      var $70=(($69+292)|0);
      var $71=(($70+8)|0);
      HEAP32[(($71)>>2)]=0;
      var $72=$1;
      var $73=(($72+292)|0);
      var $74=(($73+12)|0);
      HEAP32[(($74)>>2)]=0;
      var $75=$1;
      var $76=$75;
      _util_memory_d($76, 220, ((STRING_TABLE.__str385)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_close["X"]=1;

function _lex_do($lex) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ch;
      var $nextch;
      var $v;
      var $frame;
      var $rc;
      var $rc1;
      var $m=__stackBase__;
      var $frame2;
      var $v3;
      $2=$lex;
      var $3=$2;
      _lex_token_new($3);
      var $4=$2;
      var $5=_lex_skipwhite($4);
      $ch=$5;
      var $6=$2;
      var $7=(($6+20)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=$2;
      var $10=(($9+24)|0);
      HEAP32[(($10)>>2)]=$8;
      var $11=$2;
      var $12=(($11+24)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$2;
      var $15=(($14+292)|0);
      var $16=(($15+28)|0);
      var $17=(($16+4)|0);
      HEAP32[(($17)>>2)]=$13;
      var $18=$2;
      var $19=(($18+16)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=$2;
      var $22=(($21+292)|0);
      var $23=(($22+28)|0);
      var $24=(($23)|0);
      HEAP32[(($24)>>2)]=$20;
      var $25=$2;
      var $26=(($25+328)|0);
      var $27=(($26+2)|0);
      var $28=HEAP8[($27)];
      var $29=(($28) & 1);
      if ($29) { __label__ = 3; break; } else { __label__ = 7; break; }
    case 3: 
      var $31=$ch;
      var $32=(($31)|0)==139;
      if ($32) { __label__ = 6; break; } else { __label__ = 4; break; }
    case 4: 
      var $34=$ch;
      var $35=(($34)|0)==140;
      if ($35) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $37=$ch;
      var $38=(($37)|0)==143;
      if ($38) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $40=$ch;
      var $41=$2;
      var $42=(($41+292)|0);
      var $43=(($42)|0);
      HEAP32[(($43)>>2)]=$40;
      $1=$40;
      __label__ = 256; break;
    case 7: 
      var $45=$2;
      var $46=(($45+288)|0);
      var $47=HEAP8[($46)];
      var $48=(($47) & 1);
      if ($48) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $50=$2;
      var $51=(($50+292)|0);
      var $52=(($51)|0);
      HEAP32[(($52)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 9: 
      var $54=$ch;
      var $55=(($54)|0)==-1;
      if ($55) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $57=$2;
      var $58=(($57+288)|0);
      HEAP8[($58)]=1;
      var $59=$2;
      var $60=(($59+292)|0);
      var $61=(($60)|0);
      HEAP32[(($61)>>2)]=141;
      $1=141;
      __label__ = 256; break;
    case 11: 
      var $63=$ch;
      var $64=(($63)|0)==36;
      if ($64) { __label__ = 12; break; } else { __label__ = 99; break; }
    case 12: 
      var $66=$2;
      var $67=_lex_getch($66);
      $ch=$67;
      var $68=$ch;
      var $69=_isident_start($68);
      if ($69) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      var $71=$2;
      _lexerror($71, ((STRING_TABLE.__str7392)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $72=$2;
      var $73=_lex_do($72);
      $1=$73;
      __label__ = 256; break;
    case 14: 
      var $75=$2;
      var $76=$ch;
      var $77=_lex_tokench($75, $76);
      if ($77) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $79=$2;
      var $80=(($79+292)|0);
      var $81=(($80)|0);
      HEAP32[(($81)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 16: 
      var $83=$2;
      var $84=_lex_finish_ident($83);
      if ($84) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $86=$2;
      var $87=(($86+292)|0);
      var $88=(($87)|0);
      HEAP32[(($88)>>2)]=142;
      $1=142;
      __label__ = 256; break;
    case 18: 
      var $90=$2;
      var $91=_lex_endtoken($90);
      if ($91) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      var $93=$2;
      var $94=(($93+292)|0);
      var $95=(($94)|0);
      HEAP32[(($95)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 20: 
      var $97=$2;
      var $98=(($97+292)|0);
      var $99=(($98+4)|0);
      var $100=HEAP32[(($99)>>2)];
      $v=$100;
      var $101=$v;
      var $102=_strcmp($101, ((STRING_TABLE.__str8393)|0));
      var $103=(($102)|0)!=0;
      if ($103) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $105=$v;
      var $106=_strcmp($105, ((STRING_TABLE.__str9394)|0));
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 25; break; } else { __label__ = 22; break; }
    case 22: 
      var $109=$2;
      var $110=_lex_finish_frames($109);
      if ($110) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $112=$2;
      var $113=(($112+292)|0);
      var $114=(($113)|0);
      HEAP32[(($114)>>2)]=142;
      $1=142;
      __label__ = 256; break;
    case 24: 
      var $116=$2;
      var $117=_lex_do($116);
      $1=$117;
      __label__ = 256; break;
    case 25: 
      var $119=$v;
      var $120=_strcmp($119, ((STRING_TABLE.__str10395)|0));
      var $121=(($120)|0)!=0;
      if ($121) { __label__ = 39; break; } else { __label__ = 26; break; }
    case 26: 
      var $123=$2;
      var $124=_lex_getch($123);
      $ch=$124;
      __label__ = 27; break;
    case 27: 
      var $126=$ch;
      var $127=(($126)|0)!=-1;
      if ($127) { __label__ = 28; break; } else { var $136 = 0;__label__ = 30; break; }
    case 28: 
      var $129=$ch;
      var $130=_isspace($129);
      var $131=(($130)|0)!=0;
      if ($131) { __label__ = 29; break; } else { var $136 = 0;__label__ = 30; break; }
    case 29: 
      var $133=$ch;
      var $134=(($133)|0)!=10;
      var $136 = $134;__label__ = 30; break;
    case 30: 
      var $136;
      if ($136) { __label__ = 31; break; } else { __label__ = 32; break; }
    case 31: 
      var $138=$2;
      var $139=_lex_getch($138);
      $ch=$139;
      __label__ = 27; break;
    case 32: 
      var $141=$ch;
      var $142=_isdigit($141);
      var $143=(($142)|0)!=0;
      if ($143) { __label__ = 34; break; } else { __label__ = 33; break; }
    case 33: 
      var $145=$2;
      _lexerror($145, ((STRING_TABLE.__str11396)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $146=$2;
      var $147=_lex_do($146);
      $1=$147;
      __label__ = 256; break;
    case 34: 
      var $149=$2;
      _lex_token_new($149);
      var $150=$2;
      var $151=$ch;
      var $152=_lex_finish_digit($150, $151);
      var $153=$2;
      var $154=(($153+292)|0);
      var $155=(($154)|0);
      HEAP32[(($155)>>2)]=$152;
      var $156=$2;
      var $157=_lex_endtoken($156);
      if ($157) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      var $159=$2;
      var $160=(($159+292)|0);
      var $161=(($160)|0);
      HEAP32[(($161)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 36: 
      var $163=$2;
      var $164=(($163+292)|0);
      var $165=(($164)|0);
      var $166=HEAP32[(($165)>>2)];
      var $167=(($166)|0)!=137;
      if ($167) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      var $169=$2;
      _lexerror($169, ((STRING_TABLE.__str11396)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $170=$2;
      var $171=_lex_do($170);
      $1=$171;
      __label__ = 256; break;
    case 38: 
      var $173=$2;
      var $174=(($173+292)|0);
      var $175=(($174+16)|0);
      var $176=$175;
      var $177=HEAP32[(($176)>>2)];
      var $178=$2;
      var $179=(($178+332)|0);
      HEAP32[(($179)>>2)]=$177;
      var $180=$2;
      var $181=_lex_do($180);
      $1=$181;
      __label__ = 256; break;
    case 39: 
      var $183=$v;
      var $184=_strcmp($183, ((STRING_TABLE.__str12397)|0));
      var $185=(($184)|0)!=0;
      if ($185) { __label__ = 51; break; } else { __label__ = 40; break; }
    case 40: 
      var $187=$2;
      _lex_token_new($187);
      var $188=$2;
      var $189=_lex_parse_frame($188);
      $rc=$189;
      var $190=$rc;
      var $191=(($190)|0) > 0;
      if ($191) { __label__ = 41; break; } else { __label__ = 42; break; }
    case 41: 
      var $193=$2;
      _lexerror($193, ((STRING_TABLE.__str13398)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $194=$2;
      var $195=_lex_do($194);
      $1=$195;
      __label__ = 256; break;
    case 42: 
      var $197=$rc;
      var $198=(($197)|0) < 0;
      if ($198) { __label__ = 43; break; } else { __label__ = 44; break; }
    case 43: 
      var $200=$2;
      var $201=(($200+292)|0);
      var $202=(($201)|0);
      HEAP32[(($202)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 44: 
      var $204=$2;
      var $205=(($204+292)|0);
      var $206=(($205+4)|0);
      var $207=HEAP32[(($206)>>2)];
      $v=$207;
      $frame=0;
      __label__ = 45; break;
    case 45: 
      var $209=$frame;
      var $210=$2;
      var $211=(($210+340)|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=(($209)>>>0) < (($212)>>>0);
      if ($213) { __label__ = 46; break; } else { __label__ = 50; break; }
    case 46: 
      var $215=$v;
      var $216=$frame;
      var $217=$2;
      var $218=(($217+336)|0);
      var $219=HEAP32[(($218)>>2)];
      var $220=(($219+($216<<3))|0);
      var $221=(($220)|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=_strcmp($215, $222);
      var $224=(($223)|0)!=0;
      if ($224) { __label__ = 48; break; } else { __label__ = 47; break; }
    case 47: 
      var $226=$frame;
      var $227=$2;
      var $228=(($227+336)|0);
      var $229=HEAP32[(($228)>>2)];
      var $230=(($229+($226<<3))|0);
      var $231=(($230+4)|0);
      var $232=HEAP32[(($231)>>2)];
      var $233=$2;
      var $234=(($233+332)|0);
      HEAP32[(($234)>>2)]=$232;
      var $235=$2;
      var $236=_lex_do($235);
      $1=$236;
      __label__ = 256; break;
    case 48: 
      __label__ = 49; break;
    case 49: 
      var $239=$frame;
      var $240=((($239)+(1))|0);
      $frame=$240;
      __label__ = 45; break;
    case 50: 
      var $242=$2;
      var $243=$v;
      _lexerror($242, ((STRING_TABLE.__str14399)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$243,tempInt));
      var $244=$2;
      var $245=_lex_do($244);
      $1=$245;
      __label__ = 256; break;
    case 51: 
      var $247=$v;
      var $248=_strcmp($247, ((STRING_TABLE.__str15400)|0));
      var $249=(($248)|0)!=0;
      if ($249) { __label__ = 67; break; } else { __label__ = 52; break; }
    case 52: 
      var $251=$2;
      _lex_token_new($251);
      var $252=$2;
      var $253=_lex_parse_frame($252);
      $rc1=$253;
      var $254=$rc1;
      var $255=(($254)|0) > 0;
      if ($255) { __label__ = 53; break; } else { __label__ = 54; break; }
    case 53: 
      var $257=$2;
      _lexerror($257, ((STRING_TABLE.__str13398)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $258=$2;
      var $259=_lex_do($258);
      $1=$259;
      __label__ = 256; break;
    case 54: 
      var $261=$rc1;
      var $262=(($261)|0) < 0;
      if ($262) { __label__ = 55; break; } else { __label__ = 56; break; }
    case 55: 
      var $264=$2;
      var $265=(($264+292)|0);
      var $266=(($265)|0);
      HEAP32[(($266)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 56: 
      var $268=$2;
      var $269=(($268+292)|0);
      var $270=(($269+4)|0);
      var $271=HEAP32[(($270)>>2)];
      $v=$271;
      var $272=$2;
      var $273=(($272+348)|0);
      var $274=HEAP32[(($273)>>2)];
      var $275=(($274)|0)!=0;
      if ($275) { __label__ = 57; break; } else { __label__ = 60; break; }
    case 57: 
      var $277=$2;
      var $278=(($277+332)|0);
      var $279=HEAP32[(($278)>>2)];
      var $280=(($m+4)|0);
      HEAP32[(($280)>>2)]=$279;
      var $281=$2;
      var $282=(($281+348)|0);
      var $283=HEAP32[(($282)>>2)];
      var $284=(($m)|0);
      HEAP32[(($284)>>2)]=$283;
      var $285=$2;
      var $286=(($285+348)|0);
      HEAP32[(($286)>>2)]=0;
      var $287=$2;
      var $288=(($m)|0);
      var $289=HEAP32[(($288)>>2)];
      var $290=(($m+4)|0);
      var $291=HEAP32[(($290)>>2)];
      var $292=_lex_file_frames_add($287, $289, $291);
      if ($292) { __label__ = 59; break; } else { __label__ = 58; break; }
    case 58: 
      var $294=$2;
      _lexerror($294, ((STRING_TABLE.__str16401)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $295=$2;
      var $296=(($295+292)|0);
      var $297=(($296)|0);
      HEAP32[(($297)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 59: 
      __label__ = 60; break;
    case 60: 
      var $300=$2;
      var $301=(($300+292)|0);
      var $302=(($301+4)|0);
      var $303=HEAP32[(($302)>>2)];
      var $304=$2;
      var $305=(($304+348)|0);
      HEAP32[(($305)>>2)]=$303;
      var $306=$2;
      var $307=(($306+292)|0);
      var $308=(($307+4)|0);
      HEAP32[(($308)>>2)]=0;
      var $309=$2;
      var $310=(($309+292)|0);
      var $311=(($310+8)|0);
      HEAP32[(($311)>>2)]=0;
      var $312=$2;
      var $313=(($312+292)|0);
      var $314=(($313+12)|0);
      HEAP32[(($314)>>2)]=0;
      $frame=0;
      __label__ = 61; break;
    case 61: 
      var $316=$frame;
      var $317=$2;
      var $318=(($317+340)|0);
      var $319=HEAP32[(($318)>>2)];
      var $320=(($316)>>>0) < (($319)>>>0);
      if ($320) { __label__ = 62; break; } else { __label__ = 66; break; }
    case 62: 
      var $322=$v;
      var $323=$frame;
      var $324=$2;
      var $325=(($324+336)|0);
      var $326=HEAP32[(($325)>>2)];
      var $327=(($326+($323<<3))|0);
      var $328=(($327)|0);
      var $329=HEAP32[(($328)>>2)];
      var $330=_strcmp($322, $329);
      var $331=(($330)|0)!=0;
      if ($331) { __label__ = 64; break; } else { __label__ = 63; break; }
    case 63: 
      var $333=$frame;
      var $334=$2;
      var $335=(($334+336)|0);
      var $336=HEAP32[(($335)>>2)];
      var $337=(($336+($333<<3))|0);
      var $338=(($337+4)|0);
      var $339=HEAP32[(($338)>>2)];
      var $340=$2;
      var $341=(($340+332)|0);
      HEAP32[(($341)>>2)]=$339;
      __label__ = 66; break;
    case 64: 
      __label__ = 65; break;
    case 65: 
      var $344=$frame;
      var $345=((($344)+(1))|0);
      $frame=$345;
      __label__ = 61; break;
    case 66: 
      var $347=$2;
      var $348=_lex_do($347);
      $1=$348;
      __label__ = 256; break;
    case 67: 
      var $350=$v;
      var $351=_strcmp($350, ((STRING_TABLE.__str17402)|0));
      var $352=(($351)|0)!=0;
      if ($352) { __label__ = 80; break; } else { __label__ = 68; break; }
    case 68: 
      $frame2=0;
      __label__ = 69; break;
    case 69: 
      var $355=$frame2;
      var $356=$2;
      var $357=(($356+340)|0);
      var $358=HEAP32[(($357)>>2)];
      var $359=(($355)>>>0) < (($358)>>>0);
      if ($359) { __label__ = 70; break; } else { __label__ = 72; break; }
    case 70: 
      var $361=$frame2;
      var $362=$2;
      var $363=(($362+336)|0);
      var $364=HEAP32[(($363)>>2)];
      var $365=(($364+($361<<3))|0);
      var $366=(($365)|0);
      var $367=HEAP32[(($366)>>2)];
      _util_memory_d($367, 858, ((STRING_TABLE.__str385)|0));
      __label__ = 71; break;
    case 71: 
      var $369=$frame2;
      var $370=((($369)+(1))|0);
      $frame2=$370;
      __label__ = 69; break;
    case 72: 
      var $372=$2;
      var $373=(($372+336)|0);
      var $374=HEAP32[(($373)>>2)];
      var $375=(($374)|0)!=0;
      if ($375) { __label__ = 73; break; } else { __label__ = 74; break; }
    case 73: 
      var $377=$2;
      var $378=(($377+336)|0);
      var $379=HEAP32[(($378)>>2)];
      var $380=$379;
      _util_memory_d($380, 859, ((STRING_TABLE.__str385)|0));
      __label__ = 74; break;
    case 74: 
      var $382=$2;
      var $383=(($382+336)|0);
      HEAP32[(($383)>>2)]=0;
      var $384=$2;
      var $385=(($384+340)|0);
      HEAP32[(($385)>>2)]=0;
      var $386=$2;
      var $387=(($386+344)|0);
      HEAP32[(($387)>>2)]=0;
      var $388=$2;
      var $389=_lex_getch($388);
      $ch=$389;
      __label__ = 75; break;
    case 75: 
      var $391=$ch;
      var $392=(($391)|0)!=-1;
      if ($392) { __label__ = 76; break; } else { var $397 = 0;__label__ = 77; break; }
    case 76: 
      var $394=$ch;
      var $395=(($394)|0)!=10;
      var $397 = $395;__label__ = 77; break;
    case 77: 
      var $397;
      if ($397) { __label__ = 78; break; } else { __label__ = 79; break; }
    case 78: 
      var $399=$2;
      var $400=_lex_getch($399);
      $ch=$400;
      __label__ = 75; break;
    case 79: 
      var $402=$2;
      var $403=_lex_do($402);
      $1=$403;
      __label__ = 256; break;
    case 80: 
      var $405=$v;
      var $406=_strcmp($405, ((STRING_TABLE.__str18403)|0));
      var $407=(($406)|0)!=0;
      if ($407) { __label__ = 81; break; } else { __label__ = 86; break; }
    case 81: 
      var $409=$v;
      var $410=_strcmp($409, ((STRING_TABLE.__str19404)|0));
      var $411=(($410)|0)!=0;
      if ($411) { __label__ = 82; break; } else { __label__ = 86; break; }
    case 82: 
      var $413=$v;
      var $414=_strcmp($413, ((STRING_TABLE.__str20405)|0));
      var $415=(($414)|0)!=0;
      if ($415) { __label__ = 83; break; } else { __label__ = 86; break; }
    case 83: 
      var $417=$v;
      var $418=_strcmp($417, ((STRING_TABLE.__str21406)|0));
      var $419=(($418)|0)!=0;
      if ($419) { __label__ = 84; break; } else { __label__ = 86; break; }
    case 84: 
      var $421=$v;
      var $422=_strcmp($421, ((STRING_TABLE.__str22407)|0));
      var $423=(($422)|0)!=0;
      if ($423) { __label__ = 85; break; } else { __label__ = 86; break; }
    case 85: 
      var $425=$v;
      var $426=_strcmp($425, ((STRING_TABLE.__str23408)|0));
      var $427=(($426)|0)!=0;
      if ($427) { __label__ = 92; break; } else { __label__ = 86; break; }
    case 86: 
      var $429=$2;
      var $430=_lex_getch($429);
      $ch=$430;
      __label__ = 87; break;
    case 87: 
      var $432=$ch;
      var $433=(($432)|0)!=-1;
      if ($433) { __label__ = 88; break; } else { var $438 = 0;__label__ = 89; break; }
    case 88: 
      var $435=$ch;
      var $436=(($435)|0)!=10;
      var $438 = $436;__label__ = 89; break;
    case 89: 
      var $438;
      if ($438) { __label__ = 90; break; } else { __label__ = 91; break; }
    case 90: 
      var $440=$2;
      var $441=_lex_getch($440);
      $ch=$441;
      __label__ = 87; break;
    case 91: 
      var $443=$2;
      var $444=_lex_do($443);
      $1=$444;
      __label__ = 256; break;
    case 92: 
      $frame=0;
      __label__ = 93; break;
    case 93: 
      var $447=$frame;
      var $448=$2;
      var $449=(($448+340)|0);
      var $450=HEAP32[(($449)>>2)];
      var $451=(($447)>>>0) < (($450)>>>0);
      if ($451) { __label__ = 94; break; } else { __label__ = 98; break; }
    case 94: 
      var $453=$v;
      var $454=$frame;
      var $455=$2;
      var $456=(($455+336)|0);
      var $457=HEAP32[(($456)>>2)];
      var $458=(($457+($454<<3))|0);
      var $459=(($458)|0);
      var $460=HEAP32[(($459)>>2)];
      var $461=_strcmp($453, $460);
      var $462=(($461)|0)!=0;
      if ($462) { __label__ = 96; break; } else { __label__ = 95; break; }
    case 95: 
      var $464=$frame;
      var $465=$2;
      var $466=(($465+336)|0);
      var $467=HEAP32[(($466)>>2)];
      var $468=(($467+($464<<3))|0);
      var $469=(($468+4)|0);
      var $470=HEAP32[(($469)>>2)];
      var $471=$2;
      var $472=(($471+292)|0);
      var $473=(($472+16)|0);
      var $474=$473;
      HEAP32[(($474)>>2)]=$470;
      var $475=$2;
      var $476=(($475+292)|0);
      var $477=(($476)|0);
      HEAP32[(($477)>>2)]=137;
      $1=137;
      __label__ = 256; break;
    case 96: 
      __label__ = 97; break;
    case 97: 
      var $480=$frame;
      var $481=((($480)+(1))|0);
      $frame=$481;
      __label__ = 93; break;
    case 98: 
      var $483=$2;
      _lexerror($483, ((STRING_TABLE.__str24409)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $484=$2;
      var $485=_lex_do($484);
      $1=$485;
      __label__ = 256; break;
    case 99: 
      var $487=$ch;
      if ((($487)|0) == 40) {
        __label__ = 100; break;
      }
      else if ((($487)|0) == 41 || (($487)|0) == 59 || (($487)|0) == 123 || (($487)|0) == 125 || (($487)|0) == 91 || (($487)|0) == 93 || (($487)|0) == 35) {
        __label__ = 106; break;
      }
      else {
      __label__ = 110; break;
      }
      
    case 100: 
      var $489=$2;
      var $490=$ch;
      var $491=_lex_tokench($489, $490);
      if ($491) { __label__ = 101; break; } else { __label__ = 102; break; }
    case 101: 
      var $493=$2;
      var $494=_lex_endtoken($493);
      if ($494) { __label__ = 103; break; } else { __label__ = 102; break; }
    case 102: 
      var $496=$2;
      var $497=(($496+292)|0);
      var $498=(($497)|0);
      HEAP32[(($498)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 103: 
      var $500=$2;
      var $501=(($500+328)|0);
      var $502=(($501)|0);
      var $503=HEAP8[($502)];
      var $504=(($503) & 1);
      if ($504) { __label__ = 104; break; } else { __label__ = 105; break; }
    case 104: 
      var $506=$ch;
      var $507=$2;
      var $508=(($507+292)|0);
      var $509=(($508)|0);
      HEAP32[(($509)>>2)]=$506;
      $1=$506;
      __label__ = 256; break;
    case 105: 
      var $511=$2;
      var $512=(($511+292)|0);
      var $513=(($512)|0);
      HEAP32[(($513)>>2)]=131;
      $1=131;
      __label__ = 256; break;
    case 106: 
      var $515=$2;
      var $516=$ch;
      var $517=_lex_tokench($515, $516);
      if ($517) { __label__ = 107; break; } else { __label__ = 108; break; }
    case 107: 
      var $519=$2;
      var $520=_lex_endtoken($519);
      if ($520) { __label__ = 109; break; } else { __label__ = 108; break; }
    case 108: 
      var $522=$2;
      var $523=(($522+292)|0);
      var $524=(($523)|0);
      HEAP32[(($524)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 109: 
      var $526=$ch;
      var $527=$2;
      var $528=(($527+292)|0);
      var $529=(($528)|0);
      HEAP32[(($529)>>2)]=$526;
      $1=$526;
      __label__ = 256; break;
    case 110: 
      __label__ = 111; break;
    case 111: 
      var $532=$2;
      var $533=(($532+328)|0);
      var $534=(($533)|0);
      var $535=HEAP8[($534)];
      var $536=(($535) & 1);
      if ($536) { __label__ = 112; break; } else { __label__ = 135; break; }
    case 112: 
      var $538=$ch;
      if ((($538)|0) == 43 || (($538)|0) == 45 || (($538)|0) == 42 || (($538)|0) == 47 || (($538)|0) == 60 || (($538)|0) == 62 || (($538)|0) == 61 || (($538)|0) == 38 || (($538)|0) == 124 || (($538)|0) == 94 || (($538)|0) == 126 || (($538)|0) == 44 || (($538)|0) == 33) {
        __label__ = 113; break;
      }
      else {
      __label__ = 117; break;
      }
      
    case 113: 
      var $540=$2;
      var $541=$ch;
      var $542=_lex_tokench($540, $541);
      if ($542) { __label__ = 114; break; } else { __label__ = 115; break; }
    case 114: 
      var $544=$2;
      var $545=_lex_endtoken($544);
      if ($545) { __label__ = 116; break; } else { __label__ = 115; break; }
    case 115: 
      var $547=$2;
      var $548=(($547+292)|0);
      var $549=(($548)|0);
      HEAP32[(($549)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 116: 
      var $551=$ch;
      var $552=$2;
      var $553=(($552+292)|0);
      var $554=(($553)|0);
      HEAP32[(($554)>>2)]=$551;
      $1=$551;
      __label__ = 256; break;
    case 117: 
      __label__ = 118; break;
    case 118: 
      var $557=$ch;
      var $558=(($557)|0)==46;
      if ($558) { __label__ = 119; break; } else { __label__ = 134; break; }
    case 119: 
      var $560=$2;
      var $561=$ch;
      var $562=_lex_tokench($560, $561);
      if ($562) { __label__ = 121; break; } else { __label__ = 120; break; }
    case 120: 
      var $564=$2;
      var $565=(($564+292)|0);
      var $566=(($565)|0);
      HEAP32[(($566)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 121: 
      var $568=$2;
      var $569=_lex_getch($568);
      $nextch=$569;
      var $570=$nextch;
      var $571=(($570)|0)!=46;
      if ($571) { __label__ = 122; break; } else { __label__ = 125; break; }
    case 122: 
      var $573=$2;
      var $574=$nextch;
      _lex_ungetch($573, $574);
      var $575=$2;
      var $576=_lex_endtoken($575);
      if ($576) { __label__ = 124; break; } else { __label__ = 123; break; }
    case 123: 
      var $578=$2;
      var $579=(($578+292)|0);
      var $580=(($579)|0);
      HEAP32[(($580)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 124: 
      var $582=$ch;
      var $583=$2;
      var $584=(($583+292)|0);
      var $585=(($584)|0);
      HEAP32[(($585)>>2)]=$582;
      $1=$582;
      __label__ = 256; break;
    case 125: 
      var $587=$2;
      var $588=_lex_getch($587);
      $nextch=$588;
      var $589=$nextch;
      var $590=(($589)|0)!=46;
      if ($590) { __label__ = 126; break; } else { __label__ = 129; break; }
    case 126: 
      var $592=$2;
      var $593=$nextch;
      _lex_ungetch($592, $593);
      var $594=$2;
      var $595=$nextch;
      _lex_ungetch($594, $595);
      var $596=$2;
      var $597=_lex_endtoken($596);
      if ($597) { __label__ = 128; break; } else { __label__ = 127; break; }
    case 127: 
      var $599=$2;
      var $600=(($599+292)|0);
      var $601=(($600)|0);
      HEAP32[(($601)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 128: 
      var $603=$ch;
      var $604=$2;
      var $605=(($604+292)|0);
      var $606=(($605)|0);
      HEAP32[(($606)>>2)]=$603;
      $1=$603;
      __label__ = 256; break;
    case 129: 
      var $608=$2;
      var $609=$ch;
      var $610=_lex_tokench($608, $609);
      if ($610) { __label__ = 130; break; } else { __label__ = 132; break; }
    case 130: 
      var $612=$2;
      var $613=$ch;
      var $614=_lex_tokench($612, $613);
      if ($614) { __label__ = 131; break; } else { __label__ = 132; break; }
    case 131: 
      var $616=$2;
      var $617=_lex_endtoken($616);
      if ($617) { __label__ = 133; break; } else { __label__ = 132; break; }
    case 132: 
      var $619=$2;
      var $620=(($619+292)|0);
      var $621=(($620)|0);
      HEAP32[(($621)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 133: 
      var $623=$2;
      var $624=(($623+292)|0);
      var $625=(($624)|0);
      HEAP32[(($625)>>2)]=133;
      $1=133;
      __label__ = 256; break;
    case 134: 
      __label__ = 135; break;
    case 135: 
      var $628=$ch;
      var $629=(($628)|0)==44;
      if ($629) { __label__ = 137; break; } else { __label__ = 136; break; }
    case 136: 
      var $631=$ch;
      var $632=(($631)|0)==46;
      if ($632) { __label__ = 137; break; } else { __label__ = 141; break; }
    case 137: 
      var $634=$2;
      var $635=$ch;
      var $636=_lex_tokench($634, $635);
      if ($636) { __label__ = 138; break; } else { __label__ = 139; break; }
    case 138: 
      var $638=$2;
      var $639=_lex_endtoken($638);
      if ($639) { __label__ = 140; break; } else { __label__ = 139; break; }
    case 139: 
      var $641=$2;
      var $642=(($641+292)|0);
      var $643=(($642)|0);
      HEAP32[(($643)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 140: 
      var $645=$2;
      var $646=(($645+292)|0);
      var $647=(($646)|0);
      HEAP32[(($647)>>2)]=131;
      $1=131;
      __label__ = 256; break;
    case 141: 
      var $649=$ch;
      var $650=(($649)|0)==43;
      if ($650) { __label__ = 149; break; } else { __label__ = 142; break; }
    case 142: 
      var $652=$ch;
      var $653=(($652)|0)==45;
      if ($653) { __label__ = 149; break; } else { __label__ = 143; break; }
    case 143: 
      var $655=$ch;
      var $656=(($655)|0)==62;
      if ($656) { __label__ = 149; break; } else { __label__ = 144; break; }
    case 144: 
      var $658=$ch;
      var $659=(($658)|0)==60;
      if ($659) { __label__ = 149; break; } else { __label__ = 145; break; }
    case 145: 
      var $661=$ch;
      var $662=(($661)|0)==61;
      if ($662) { __label__ = 149; break; } else { __label__ = 146; break; }
    case 146: 
      var $664=$ch;
      var $665=(($664)|0)==33;
      if ($665) { __label__ = 149; break; } else { __label__ = 147; break; }
    case 147: 
      var $667=$ch;
      var $668=(($667)|0)==38;
      if ($668) { __label__ = 149; break; } else { __label__ = 148; break; }
    case 148: 
      var $670=$ch;
      var $671=(($670)|0)==124;
      if ($671) { __label__ = 149; break; } else { __label__ = 166; break; }
    case 149: 
      var $673=$2;
      var $674=$ch;
      var $675=_lex_tokench($673, $674);
      if ($675) { __label__ = 151; break; } else { __label__ = 150; break; }
    case 150: 
      var $677=$2;
      var $678=(($677+292)|0);
      var $679=(($678)|0);
      HEAP32[(($679)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 151: 
      var $681=$2;
      var $682=_lex_getch($681);
      $nextch=$682;
      var $683=$nextch;
      var $684=$ch;
      var $685=(($683)|0)==(($684)|0);
      if ($685) { __label__ = 153; break; } else { __label__ = 152; break; }
    case 152: 
      var $687=$nextch;
      var $688=(($687)|0)==61;
      if ($688) { __label__ = 153; break; } else { __label__ = 156; break; }
    case 153: 
      var $690=$2;
      var $691=$nextch;
      var $692=_lex_tokench($690, $691);
      if ($692) { __label__ = 155; break; } else { __label__ = 154; break; }
    case 154: 
      var $694=$2;
      var $695=(($694+292)|0);
      var $696=(($695)|0);
      HEAP32[(($696)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 155: 
      __label__ = 163; break;
    case 156: 
      var $699=$ch;
      var $700=(($699)|0)==45;
      if ($700) { __label__ = 157; break; } else { __label__ = 161; break; }
    case 157: 
      var $702=$nextch;
      var $703=(($702)|0)==62;
      if ($703) { __label__ = 158; break; } else { __label__ = 161; break; }
    case 158: 
      var $705=$2;
      var $706=$nextch;
      var $707=_lex_tokench($705, $706);
      if ($707) { __label__ = 160; break; } else { __label__ = 159; break; }
    case 159: 
      var $709=$2;
      var $710=(($709+292)|0);
      var $711=(($710)|0);
      HEAP32[(($711)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 160: 
      __label__ = 162; break;
    case 161: 
      var $714=$2;
      var $715=$nextch;
      _lex_ungetch($714, $715);
      __label__ = 162; break;
    case 162: 
      __label__ = 163; break;
    case 163: 
      var $718=$2;
      var $719=_lex_endtoken($718);
      if ($719) { __label__ = 165; break; } else { __label__ = 164; break; }
    case 164: 
      var $721=$2;
      var $722=(($721+292)|0);
      var $723=(($722)|0);
      HEAP32[(($723)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 165: 
      var $725=$2;
      var $726=(($725+292)|0);
      var $727=(($726)|0);
      HEAP32[(($727)>>2)]=131;
      $1=131;
      __label__ = 256; break;
    case 166: 
      var $729=$ch;
      var $730=(($729)|0)==42;
      if ($730) { __label__ = 168; break; } else { __label__ = 167; break; }
    case 167: 
      var $732=$ch;
      var $733=(($732)|0)==47;
      if ($733) { __label__ = 168; break; } else { __label__ = 178; break; }
    case 168: 
      var $735=$2;
      var $736=$ch;
      var $737=_lex_tokench($735, $736);
      if ($737) { __label__ = 170; break; } else { __label__ = 169; break; }
    case 169: 
      var $739=$2;
      var $740=(($739+292)|0);
      var $741=(($740)|0);
      HEAP32[(($741)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 170: 
      var $743=$2;
      var $744=_lex_getch($743);
      $nextch=$744;
      var $745=$nextch;
      var $746=(($745)|0)==61;
      if ($746) { __label__ = 171; break; } else { __label__ = 174; break; }
    case 171: 
      var $748=$2;
      var $749=$nextch;
      var $750=_lex_tokench($748, $749);
      if ($750) { __label__ = 173; break; } else { __label__ = 172; break; }
    case 172: 
      var $752=$2;
      var $753=(($752+292)|0);
      var $754=(($753)|0);
      HEAP32[(($754)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 173: 
      __label__ = 175; break;
    case 174: 
      var $757=$2;
      var $758=$nextch;
      _lex_ungetch($757, $758);
      __label__ = 175; break;
    case 175: 
      var $760=$2;
      var $761=_lex_endtoken($760);
      if ($761) { __label__ = 177; break; } else { __label__ = 176; break; }
    case 176: 
      var $763=$2;
      var $764=(($763+292)|0);
      var $765=(($764)|0);
      HEAP32[(($765)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 177: 
      var $767=$2;
      var $768=(($767+292)|0);
      var $769=(($768)|0);
      HEAP32[(($769)>>2)]=131;
      $1=131;
      __label__ = 256; break;
    case 178: 
      var $771=$ch;
      var $772=_isident_start($771);
      if ($772) { __label__ = 179; break; } else { __label__ = 222; break; }
    case 179: 
      var $774=$2;
      var $775=$ch;
      var $776=_lex_tokench($774, $775);
      if ($776) { __label__ = 181; break; } else { __label__ = 180; break; }
    case 180: 
      var $778=$2;
      var $779=(($778+292)|0);
      var $780=(($779)|0);
      HEAP32[(($780)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 181: 
      var $782=$2;
      var $783=_lex_finish_ident($782);
      if ($783) { __label__ = 183; break; } else { __label__ = 182; break; }
    case 182: 
      var $785=$2;
      var $786=(($785+292)|0);
      var $787=(($786)|0);
      HEAP32[(($787)>>2)]=142;
      $1=142;
      __label__ = 256; break;
    case 183: 
      var $789=$2;
      var $790=_lex_endtoken($789);
      if ($790) { __label__ = 185; break; } else { __label__ = 184; break; }
    case 184: 
      var $792=$2;
      var $793=(($792+292)|0);
      var $794=(($793)|0);
      HEAP32[(($794)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 185: 
      var $796=$2;
      var $797=(($796+292)|0);
      var $798=(($797)|0);
      HEAP32[(($798)>>2)]=129;
      var $799=$2;
      var $800=(($799+292)|0);
      var $801=(($800+4)|0);
      var $802=HEAP32[(($801)>>2)];
      $v3=$802;
      var $803=$v3;
      var $804=_strcmp($803, ((STRING_TABLE.__str25410)|0));
      var $805=(($804)|0)!=0;
      if ($805) { __label__ = 187; break; } else { __label__ = 186; break; }
    case 186: 
      var $807=$2;
      var $808=(($807+292)|0);
      var $809=(($808)|0);
      HEAP32[(($809)>>2)]=130;
      var $810=$2;
      var $811=(($810+292)|0);
      var $812=(($811+16)|0);
      var $813=$812;
      HEAP32[(($813)>>2)]=0;
      __label__ = 221; break;
    case 187: 
      var $815=$v3;
      var $816=_strcmp($815, ((STRING_TABLE.__str26411)|0));
      var $817=(($816)|0)!=0;
      if ($817) { __label__ = 189; break; } else { __label__ = 188; break; }
    case 188: 
      var $819=$2;
      var $820=(($819+292)|0);
      var $821=(($820)|0);
      HEAP32[(($821)>>2)]=130;
      var $822=$2;
      var $823=(($822+292)|0);
      var $824=(($823+16)|0);
      var $825=$824;
      HEAP32[(($825)>>2)]=8;
      __label__ = 220; break;
    case 189: 
      var $827=$v3;
      var $828=_strcmp($827, ((STRING_TABLE.__str27412)|0));
      var $829=(($828)|0)!=0;
      if ($829) { __label__ = 191; break; } else { __label__ = 190; break; }
    case 190: 
      var $831=$2;
      var $832=(($831+292)|0);
      var $833=(($832)|0);
      HEAP32[(($833)>>2)]=130;
      var $834=$2;
      var $835=(($834+292)|0);
      var $836=(($835+16)|0);
      var $837=$836;
      HEAP32[(($837)>>2)]=2;
      __label__ = 219; break;
    case 191: 
      var $839=$v3;
      var $840=_strcmp($839, ((STRING_TABLE.__str28413)|0));
      var $841=(($840)|0)!=0;
      if ($841) { __label__ = 193; break; } else { __label__ = 192; break; }
    case 192: 
      var $843=$2;
      var $844=(($843+292)|0);
      var $845=(($844)|0);
      HEAP32[(($845)>>2)]=130;
      var $846=$2;
      var $847=(($846+292)|0);
      var $848=(($847+16)|0);
      var $849=$848;
      HEAP32[(($849)>>2)]=1;
      __label__ = 218; break;
    case 193: 
      var $851=$v3;
      var $852=_strcmp($851, ((STRING_TABLE.__str29414)|0));
      var $853=(($852)|0)!=0;
      if ($853) { __label__ = 195; break; } else { __label__ = 194; break; }
    case 194: 
      var $855=$2;
      var $856=(($855+292)|0);
      var $857=(($856)|0);
      HEAP32[(($857)>>2)]=130;
      var $858=$2;
      var $859=(($858+292)|0);
      var $860=(($859+16)|0);
      var $861=$860;
      HEAP32[(($861)>>2)]=4;
      __label__ = 217; break;
    case 195: 
      var $863=$v3;
      var $864=_strcmp($863, ((STRING_TABLE.__str30415)|0));
      var $865=(($864)|0)!=0;
      if ($865) { __label__ = 197; break; } else { __label__ = 196; break; }
    case 196: 
      var $867=$2;
      var $868=(($867+292)|0);
      var $869=(($868)|0);
      HEAP32[(($869)>>2)]=130;
      var $870=$2;
      var $871=(($870+292)|0);
      var $872=(($871+16)|0);
      var $873=$872;
      HEAP32[(($873)>>2)]=3;
      __label__ = 216; break;
    case 197: 
      var $875=$v3;
      var $876=_strcmp($875, ((STRING_TABLE.__str31416)|0));
      var $877=(($876)|0)!=0;
      if ($877) { __label__ = 198; break; } else { __label__ = 205; break; }
    case 198: 
      var $879=$v3;
      var $880=_strcmp($879, ((STRING_TABLE.__str32417)|0));
      var $881=(($880)|0)!=0;
      if ($881) { __label__ = 199; break; } else { __label__ = 205; break; }
    case 199: 
      var $883=$v3;
      var $884=_strcmp($883, ((STRING_TABLE.__str33418)|0));
      var $885=(($884)|0)!=0;
      if ($885) { __label__ = 200; break; } else { __label__ = 205; break; }
    case 200: 
      var $887=$v3;
      var $888=_strcmp($887, ((STRING_TABLE.__str34419)|0));
      var $889=(($888)|0)!=0;
      if ($889) { __label__ = 201; break; } else { __label__ = 205; break; }
    case 201: 
      var $891=$v3;
      var $892=_strcmp($891, ((STRING_TABLE.__str35420)|0));
      var $893=(($892)|0)!=0;
      if ($893) { __label__ = 202; break; } else { __label__ = 205; break; }
    case 202: 
      var $895=$v3;
      var $896=_strcmp($895, ((STRING_TABLE.__str36421)|0));
      var $897=(($896)|0)!=0;
      if ($897) { __label__ = 203; break; } else { __label__ = 205; break; }
    case 203: 
      var $899=$v3;
      var $900=_strcmp($899, ((STRING_TABLE.__str37422)|0));
      var $901=(($900)|0)!=0;
      if ($901) { __label__ = 204; break; } else { __label__ = 205; break; }
    case 204: 
      var $903=$v3;
      var $904=_strcmp($903, ((STRING_TABLE.__str38423)|0));
      var $905=(($904)|0)!=0;
      if ($905) { __label__ = 206; break; } else { __label__ = 205; break; }
    case 205: 
      var $907=$2;
      var $908=(($907+292)|0);
      var $909=(($908)|0);
      HEAP32[(($909)>>2)]=132;
      __label__ = 215; break;
    case 206: 
      var $911=HEAP32[((_opts_standard)>>2)];
      var $912=(($911)|0)!=0;
      if ($912) { __label__ = 207; break; } else { __label__ = 214; break; }
    case 207: 
      var $914=$v3;
      var $915=_strcmp($914, ((STRING_TABLE.__str39424)|0));
      var $916=(($915)|0)!=0;
      if ($916) { __label__ = 208; break; } else { __label__ = 212; break; }
    case 208: 
      var $918=$v3;
      var $919=_strcmp($918, ((STRING_TABLE.__str40425)|0));
      var $920=(($919)|0)!=0;
      if ($920) { __label__ = 209; break; } else { __label__ = 212; break; }
    case 209: 
      var $922=$v3;
      var $923=_strcmp($922, ((STRING_TABLE.__str41426)|0));
      var $924=(($923)|0)!=0;
      if ($924) { __label__ = 210; break; } else { __label__ = 212; break; }
    case 210: 
      var $926=$v3;
      var $927=_strcmp($926, ((STRING_TABLE.__str42427)|0));
      var $928=(($927)|0)!=0;
      if ($928) { __label__ = 211; break; } else { __label__ = 212; break; }
    case 211: 
      var $930=$v3;
      var $931=_strcmp($930, ((STRING_TABLE.__str43428)|0));
      var $932=(($931)|0)!=0;
      if ($932) { __label__ = 213; break; } else { __label__ = 212; break; }
    case 212: 
      var $934=$2;
      var $935=(($934+292)|0);
      var $936=(($935)|0);
      HEAP32[(($936)>>2)]=132;
      __label__ = 213; break;
    case 213: 
      __label__ = 214; break;
    case 214: 
      __label__ = 215; break;
    case 215: 
      __label__ = 216; break;
    case 216: 
      __label__ = 217; break;
    case 217: 
      __label__ = 218; break;
    case 218: 
      __label__ = 219; break;
    case 219: 
      __label__ = 220; break;
    case 220: 
      __label__ = 221; break;
    case 221: 
      var $946=$2;
      var $947=(($946+292)|0);
      var $948=(($947)|0);
      var $949=HEAP32[(($948)>>2)];
      $1=$949;
      __label__ = 256; break;
    case 222: 
      var $951=$ch;
      var $952=(($951)|0)==34;
      if ($952) { __label__ = 223; break; } else { __label__ = 239; break; }
    case 223: 
      var $954=$2;
      var $955=(($954+328)|0);
      var $956=(($955+1)|0);
      HEAP8[($956)]=1;
      var $957=$2;
      var $958=(($957+328)|0);
      var $959=(($958+2)|0);
      var $960=HEAP8[($959)];
      var $961=(($960) & 1);
      if ($961) { __label__ = 224; break; } else { __label__ = 226; break; }
    case 224: 
      var $963=$2;
      var $964=$ch;
      var $965=_lex_tokench($963, $964);
      if ($965) { __label__ = 226; break; } else { __label__ = 225; break; }
    case 225: 
      $1=143;
      __label__ = 256; break;
    case 226: 
      var $968=$2;
      var $969=_lex_finish_string($968, 34);
      var $970=$2;
      var $971=(($970+292)|0);
      var $972=(($971)|0);
      HEAP32[(($972)>>2)]=$969;
      var $973=$2;
      var $974=(($973+328)|0);
      var $975=(($974+2)|0);
      var $976=HEAP8[($975)];
      var $977=(($976) & 1);
      if ($977) { __label__ = 227; break; } else { __label__ = 229; break; }
    case 227: 
      var $979=$2;
      var $980=$ch;
      var $981=_lex_tokench($979, $980);
      if ($981) { __label__ = 229; break; } else { __label__ = 228; break; }
    case 228: 
      $1=143;
      __label__ = 256; break;
    case 229: 
      __label__ = 230; break;
    case 230: 
      var $985=$2;
      var $986=(($985+328)|0);
      var $987=(($986+2)|0);
      var $988=HEAP8[($987)];
      var $989=(($988) & 1);
      if ($989) { var $997 = 0;__label__ = 232; break; } else { __label__ = 231; break; }
    case 231: 
      var $991=$2;
      var $992=(($991+292)|0);
      var $993=(($992)|0);
      var $994=HEAP32[(($993)>>2)];
      var $995=(($994)|0)==134;
      var $997 = $995;__label__ = 232; break;
    case 232: 
      var $997;
      if ($997) { __label__ = 233; break; } else { __label__ = 236; break; }
    case 233: 
      var $999=$2;
      var $1000=_lex_skipwhite($999);
      $ch=$1000;
      var $1001=$ch;
      var $1002=(($1001)|0)!=34;
      if ($1002) { __label__ = 234; break; } else { __label__ = 235; break; }
    case 234: 
      var $1004=$2;
      var $1005=$ch;
      _lex_ungetch($1004, $1005);
      __label__ = 236; break;
    case 235: 
      var $1007=$2;
      var $1008=_lex_finish_string($1007, 34);
      var $1009=$2;
      var $1010=(($1009+292)|0);
      var $1011=(($1010)|0);
      HEAP32[(($1011)>>2)]=$1008;
      __label__ = 230; break;
    case 236: 
      var $1013=$2;
      var $1014=(($1013+328)|0);
      var $1015=(($1014+1)|0);
      HEAP8[($1015)]=0;
      var $1016=$2;
      var $1017=_lex_endtoken($1016);
      if ($1017) { __label__ = 238; break; } else { __label__ = 237; break; }
    case 237: 
      var $1019=$2;
      var $1020=(($1019+292)|0);
      var $1021=(($1020)|0);
      HEAP32[(($1021)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 238: 
      var $1023=$2;
      var $1024=(($1023+292)|0);
      var $1025=(($1024)|0);
      var $1026=HEAP32[(($1025)>>2)];
      $1=$1026;
      __label__ = 256; break;
    case 239: 
      var $1028=$ch;
      var $1029=(($1028)|0)==39;
      if ($1029) { __label__ = 240; break; } else { __label__ = 251; break; }
    case 240: 
      var $1031=$2;
      var $1032=(($1031+328)|0);
      var $1033=(($1032+2)|0);
      var $1034=HEAP8[($1033)];
      var $1035=(($1034) & 1);
      if ($1035) { __label__ = 241; break; } else { __label__ = 243; break; }
    case 241: 
      var $1037=$2;
      var $1038=$ch;
      var $1039=_lex_tokench($1037, $1038);
      if ($1039) { __label__ = 243; break; } else { __label__ = 242; break; }
    case 242: 
      $1=143;
      __label__ = 256; break;
    case 243: 
      var $1042=$2;
      var $1043=_lex_finish_string($1042, 39);
      var $1044=$2;
      var $1045=(($1044+292)|0);
      var $1046=(($1045)|0);
      HEAP32[(($1046)>>2)]=$1043;
      var $1047=$2;
      var $1048=(($1047+328)|0);
      var $1049=(($1048+2)|0);
      var $1050=HEAP8[($1049)];
      var $1051=(($1050) & 1);
      if ($1051) { __label__ = 244; break; } else { __label__ = 246; break; }
    case 244: 
      var $1053=$2;
      var $1054=$ch;
      var $1055=_lex_tokench($1053, $1054);
      if ($1055) { __label__ = 246; break; } else { __label__ = 245; break; }
    case 245: 
      $1=143;
      __label__ = 256; break;
    case 246: 
      var $1058=$2;
      var $1059=_lex_endtoken($1058);
      if ($1059) { __label__ = 248; break; } else { __label__ = 247; break; }
    case 247: 
      var $1061=$2;
      var $1062=(($1061+292)|0);
      var $1063=(($1062)|0);
      HEAP32[(($1063)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 248: 
      var $1065=$2;
      var $1066=(($1065+292)|0);
      var $1067=(($1066+4)|0);
      var $1068=HEAP32[(($1067)>>2)];
      var $1069=$2;
      var $1070=(($1069+292)|0);
      var $1071=(($1070+16)|0);
      var $1072=$1071;
      var $1073=(($1072)|0);
      var $1074=$2;
      var $1075=(($1074+292)|0);
      var $1076=(($1075+16)|0);
      var $1077=$1076;
      var $1078=(($1077+4)|0);
      var $1079=$2;
      var $1080=(($1079+292)|0);
      var $1081=(($1080+16)|0);
      var $1082=$1081;
      var $1083=(($1082+8)|0);
      var $1084=_sscanf($1068, ((STRING_TABLE.__str44429)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1073,HEAP32[(((tempInt)+(4))>>2)]=$1078,HEAP32[(((tempInt)+(8))>>2)]=$1083,tempInt));
      var $1085=(($1084)|0)==3;
      if ($1085) { __label__ = 249; break; } else { __label__ = 250; break; }
    case 249: 
      var $1087=$2;
      var $1088=(($1087+292)|0);
      var $1089=(($1088)|0);
      HEAP32[(($1089)>>2)]=136;
      __label__ = 250; break;
    case 250: 
      var $1091=$2;
      var $1092=(($1091+292)|0);
      var $1093=(($1092)|0);
      var $1094=HEAP32[(($1093)>>2)];
      $1=$1094;
      __label__ = 256; break;
    case 251: 
      var $1096=$ch;
      var $1097=_isdigit($1096);
      var $1098=(($1097)|0)!=0;
      if ($1098) { __label__ = 252; break; } else { __label__ = 255; break; }
    case 252: 
      var $1100=$2;
      var $1101=$ch;
      var $1102=_lex_finish_digit($1100, $1101);
      var $1103=$2;
      var $1104=(($1103+292)|0);
      var $1105=(($1104)|0);
      HEAP32[(($1105)>>2)]=$1102;
      var $1106=$2;
      var $1107=_lex_endtoken($1106);
      if ($1107) { __label__ = 254; break; } else { __label__ = 253; break; }
    case 253: 
      var $1109=$2;
      var $1110=(($1109+292)|0);
      var $1111=(($1110)|0);
      HEAP32[(($1111)>>2)]=143;
      $1=143;
      __label__ = 256; break;
    case 254: 
      var $1113=$2;
      var $1114=(($1113+292)|0);
      var $1115=(($1114)|0);
      var $1116=HEAP32[(($1115)>>2)];
      $1=$1116;
      __label__ = 256; break;
    case 255: 
      var $1118=$2;
      _lexerror($1118, ((STRING_TABLE.__str45430)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $1119=$2;
      var $1120=(($1119+292)|0);
      var $1121=(($1120)|0);
      HEAP32[(($1121)>>2)]=142;
      $1=142;
      __label__ = 256; break;
    case 256: 
      var $1123=$1;
      STACKTOP = __stackBase__;
      return $1123;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_do["X"]=1;

function _lex_token_new($lex) {
  ;
  var __label__;

  var $1;
  $1=$lex;
  var $2=$1;
  var $3=(($2+292)|0);
  var $4=(($3+8)|0);
  HEAP32[(($4)>>2)]=0;
  var $5=$1;
  var $6=(($5+292)|0);
  var $7=(($6+16)|0);
  var $8=$7;
  HEAP32[(($8)>>2)]=0;
  var $9=$1;
  var $10=(($9+24)|0);
  var $11=HEAP32[(($10)>>2)];
  var $12=$1;
  var $13=(($12+292)|0);
  var $14=(($13+28)|0);
  var $15=(($14+4)|0);
  HEAP32[(($15)>>2)]=$11;
  var $16=$1;
  var $17=(($16+16)|0);
  var $18=HEAP32[(($17)>>2)];
  var $19=$1;
  var $20=(($19+292)|0);
  var $21=(($20+28)|0);
  var $22=(($21)|0);
  HEAP32[(($22)>>2)]=$18;
  ;
  return;
}


function _lex_skipwhite($lex) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ch;
      var $haswhite;
      $2=$lex;
      $ch=0;
      $haswhite=0;
      __label__ = 3; break;
    case 3: 
      var $4=$2;
      var $5=_lex_getch($4);
      $ch=$5;
      __label__ = 4; break;
    case 4: 
      var $7=$ch;
      var $8=(($7)|0)!=-1;
      if ($8) { __label__ = 5; break; } else { var $14 = 0;__label__ = 6; break; }
    case 5: 
      var $10=$ch;
      var $11=_isspace($10);
      var $12=(($11)|0)!=0;
      var $14 = $12;__label__ = 6; break;
    case 6: 
      var $14;
      if ($14) { __label__ = 7; break; } else { __label__ = 18; break; }
    case 7: 
      var $16=$2;
      var $17=(($16+328)|0);
      var $18=(($17+2)|0);
      var $19=HEAP8[($18)];
      var $20=(($19) & 1);
      if ($20) { __label__ = 8; break; } else { __label__ = 17; break; }
    case 8: 
      var $22=$ch;
      var $23=(($22)|0)==10;
      if ($23) { __label__ = 9; break; } else { __label__ = 14; break; }
    case 9: 
      var $25=$haswhite;
      var $26=(($25) & 1);
      if ($26) { __label__ = 10; break; } else { __label__ = 13; break; }
    case 10: 
      var $28=$2;
      var $29=$ch;
      _lex_ungetch($28, $29);
      var $30=$2;
      var $31=_lex_endtoken($30);
      if ($31) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $1=143;
      __label__ = 71; break;
    case 12: 
      $1=139;
      __label__ = 71; break;
    case 13: 
      $1=140;
      __label__ = 71; break;
    case 14: 
      $haswhite=1;
      var $36=$2;
      var $37=$ch;
      var $38=_lex_tokench($36, $37);
      if ($38) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=143;
      __label__ = 71; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $42=$2;
      var $43=_lex_getch($42);
      $ch=$43;
      __label__ = 4; break;
    case 18: 
      var $45=$ch;
      var $46=(($45)|0)==47;
      if ($46) { __label__ = 19; break; } else { __label__ = 62; break; }
    case 19: 
      var $48=$2;
      var $49=_lex_getch($48);
      $ch=$49;
      var $50=$ch;
      var $51=(($50)|0)==47;
      if ($51) { __label__ = 20; break; } else { __label__ = 38; break; }
    case 20: 
      var $53=$2;
      var $54=_lex_getch($53);
      $ch=$54;
      var $55=$2;
      var $56=(($55+328)|0);
      var $57=(($56+2)|0);
      var $58=HEAP8[($57)];
      var $59=(($58) & 1);
      if ($59) { __label__ = 21; break; } else { __label__ = 25; break; }
    case 21: 
      $haswhite=1;
      var $61=$2;
      var $62=_lex_tokench($61, 47);
      if ($62) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $64=$2;
      var $65=_lex_tokench($64, 47);
      if ($65) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      $1=143;
      __label__ = 71; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      var $70=$ch;
      var $71=(($70)|0)!=-1;
      if ($71) { __label__ = 27; break; } else { var $76 = 0;__label__ = 28; break; }
    case 27: 
      var $73=$ch;
      var $74=(($73)|0)!=10;
      var $76 = $74;__label__ = 28; break;
    case 28: 
      var $76;
      if ($76) { __label__ = 29; break; } else { __label__ = 33; break; }
    case 29: 
      var $78=$2;
      var $79=(($78+328)|0);
      var $80=(($79+2)|0);
      var $81=HEAP8[($80)];
      var $82=(($81) & 1);
      if ($82) { __label__ = 30; break; } else { __label__ = 32; break; }
    case 30: 
      var $84=$2;
      var $85=$ch;
      var $86=_lex_tokench($84, $85);
      if ($86) { __label__ = 32; break; } else { __label__ = 31; break; }
    case 31: 
      $1=143;
      __label__ = 71; break;
    case 32: 
      var $89=$2;
      var $90=_lex_getch($89);
      $ch=$90;
      __label__ = 26; break;
    case 33: 
      var $92=$2;
      var $93=(($92+328)|0);
      var $94=(($93+2)|0);
      var $95=HEAP8[($94)];
      var $96=(($95) & 1);
      if ($96) { __label__ = 34; break; } else { __label__ = 37; break; }
    case 34: 
      var $98=$2;
      _lex_ungetch($98, 10);
      var $99=$2;
      var $100=_lex_endtoken($99);
      if ($100) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      $1=143;
      __label__ = 71; break;
    case 36: 
      $1=139;
      __label__ = 71; break;
    case 37: 
      __label__ = 63; break;
    case 38: 
      var $105=$ch;
      var $106=(($105)|0)==42;
      if ($106) { __label__ = 39; break; } else { __label__ = 61; break; }
    case 39: 
      var $108=$2;
      var $109=(($108+328)|0);
      var $110=(($109+2)|0);
      var $111=HEAP8[($110)];
      var $112=(($111) & 1);
      if ($112) { __label__ = 40; break; } else { __label__ = 44; break; }
    case 40: 
      $haswhite=1;
      var $114=$2;
      var $115=_lex_tokench($114, 47);
      if ($115) { __label__ = 41; break; } else { __label__ = 42; break; }
    case 41: 
      var $117=$2;
      var $118=_lex_tokench($117, 42);
      if ($118) { __label__ = 43; break; } else { __label__ = 42; break; }
    case 42: 
      $1=143;
      __label__ = 71; break;
    case 43: 
      __label__ = 44; break;
    case 44: 
      __label__ = 45; break;
    case 45: 
      var $123=$ch;
      var $124=(($123)|0)!=-1;
      if ($124) { __label__ = 46; break; } else { __label__ = 60; break; }
    case 46: 
      var $126=$2;
      var $127=_lex_getch($126);
      $ch=$127;
      var $128=$ch;
      var $129=(($128)|0)==42;
      if ($129) { __label__ = 47; break; } else { __label__ = 55; break; }
    case 47: 
      var $131=$2;
      var $132=_lex_getch($131);
      $ch=$132;
      var $133=$ch;
      var $134=(($133)|0)==47;
      if ($134) { __label__ = 48; break; } else { __label__ = 54; break; }
    case 48: 
      var $136=$2;
      var $137=(($136+328)|0);
      var $138=(($137+2)|0);
      var $139=HEAP8[($138)];
      var $140=(($139) & 1);
      if ($140) { __label__ = 49; break; } else { __label__ = 53; break; }
    case 49: 
      var $142=$2;
      var $143=_lex_tokench($142, 42);
      if ($143) { __label__ = 50; break; } else { __label__ = 51; break; }
    case 50: 
      var $145=$2;
      var $146=_lex_tokench($145, 47);
      if ($146) { __label__ = 52; break; } else { __label__ = 51; break; }
    case 51: 
      $1=143;
      __label__ = 71; break;
    case 52: 
      __label__ = 53; break;
    case 53: 
      __label__ = 60; break;
    case 54: 
      __label__ = 55; break;
    case 55: 
      var $152=$2;
      var $153=(($152+328)|0);
      var $154=(($153+2)|0);
      var $155=HEAP8[($154)];
      var $156=(($155) & 1);
      if ($156) { __label__ = 56; break; } else { __label__ = 59; break; }
    case 56: 
      var $158=$2;
      var $159=$ch;
      var $160=_lex_tokench($158, $159);
      if ($160) { __label__ = 58; break; } else { __label__ = 57; break; }
    case 57: 
      $1=143;
      __label__ = 71; break;
    case 58: 
      __label__ = 59; break;
    case 59: 
      __label__ = 45; break;
    case 60: 
      $ch=32;
      __label__ = 63; break;
    case 61: 
      var $166=$2;
      var $167=$ch;
      _lex_ungetch($166, $167);
      $ch=47;
      __label__ = 66; break;
    case 62: 
      __label__ = 63; break;
    case 63: 
      var $170=$ch;
      var $171=(($170)|0)!=-1;
      if ($171) { __label__ = 64; break; } else { var $177 = 0;__label__ = 65; break; }
    case 64: 
      var $173=$ch;
      var $174=_isspace($173);
      var $175=(($174)|0)!=0;
      var $177 = $175;__label__ = 65; break;
    case 65: 
      var $177;
      if ($177) { __label__ = 3; break; } else { __label__ = 66; break; }
    case 66: 
      var $179=$haswhite;
      var $180=(($179) & 1);
      if ($180) { __label__ = 67; break; } else { __label__ = 70; break; }
    case 67: 
      var $182=$2;
      var $183=_lex_endtoken($182);
      if ($183) { __label__ = 69; break; } else { __label__ = 68; break; }
    case 68: 
      $1=143;
      __label__ = 71; break;
    case 69: 
      var $186=$2;
      var $187=$ch;
      _lex_ungetch($186, $187);
      $1=139;
      __label__ = 71; break;
    case 70: 
      var $189=$ch;
      $1=$189;
      __label__ = 71; break;
    case 71: 
      var $191=$1;
      ;
      return $191;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_skipwhite["X"]=1;

function _lex_getch($lex) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ch;
      $2=$lex;
      var $3=$2;
      var $4=(($3+284)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+284)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=((($10)-(1))|0);
      HEAP32[(($9)>>2)]=$11;
      var $12=$2;
      var $13=(($12+284)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=$2;
      var $16=(($15+28)|0);
      var $17=(($16+$14)|0);
      var $18=HEAP8[($17)];
      var $19=(($18 << 24) >> 24);
      var $20=(($19)|0)==10;
      if ($20) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $22=$2;
      var $23=(($22+20)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=((($24)+(1))|0);
      HEAP32[(($23)>>2)]=$25;
      __label__ = 5; break;
    case 5: 
      var $27=$2;
      var $28=(($27+284)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=$2;
      var $31=(($30+28)|0);
      var $32=(($31+$29)|0);
      var $33=HEAP8[($32)];
      var $34=(($33 << 24) >> 24);
      $1=$34;
      __label__ = 18; break;
    case 6: 
      var $36=$2;
      var $37=_lex_fgetc($36);
      $ch=$37;
      var $38=$ch;
      var $39=(($38)|0)==10;
      if ($39) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $41=$2;
      var $42=(($41+20)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43)+(1))|0);
      HEAP32[(($42)>>2)]=$44;
      __label__ = 17; break;
    case 8: 
      var $46=$ch;
      var $47=(($46)|0)==63;
      if ($47) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $49=$2;
      var $50=$ch;
      var $51=_lex_try_trigraph($49, $50);
      $1=$51;
      __label__ = 18; break;
    case 10: 
      var $53=$2;
      var $54=(($53+328)|0);
      var $55=(($54+1)|0);
      var $56=HEAP8[($55)];
      var $57=(($56) & 1);
      if ($57) { __label__ = 15; break; } else { __label__ = 11; break; }
    case 11: 
      var $59=$ch;
      var $60=(($59)|0)==60;
      if ($60) { __label__ = 14; break; } else { __label__ = 12; break; }
    case 12: 
      var $62=$ch;
      var $63=(($62)|0)==58;
      if ($63) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      var $65=$ch;
      var $66=(($65)|0)==37;
      if ($66) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      var $68=$2;
      var $69=$ch;
      var $70=_lex_try_digraph($68, $69);
      $1=$70;
      __label__ = 18; break;
    case 15: 
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $74=$ch;
      $1=$74;
      __label__ = 18; break;
    case 18: 
      var $76=$1;
      ;
      return $76;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_getch["X"]=1;

function _isident_start($ch) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$ch;
      var $2=$1;
      var $3=_isalpha($2);
      var $4=(($3)|0)!=0;
      if ($4) { var $9 = 1;__label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $6=$1;
      var $7=(($6)|0)==95;
      var $9 = $7;__label__ = 4; break;
    case 4: 
      var $9;
      ;
      return $9;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_tokench($lex, $ch) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$lex;
      $3=$ch;
      var $4=$2;
      var $5=(($4+292)|0);
      var $6=$3;
      var $7=(($6) & 255);
      var $8=_token_value_add($5, $7);
      if ($8) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $10=$2;
      _lexerror($10, ((STRING_TABLE.__str16401)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 5; break;
    case 4: 
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $13=$1;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_finish_ident($lex) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ch;
      $2=$lex;
      var $3=$2;
      var $4=_lex_getch($3);
      $ch=$4;
      __label__ = 3; break;
    case 3: 
      var $6=$ch;
      var $7=(($6)|0)!=-1;
      if ($7) { __label__ = 4; break; } else { var $12 = 0;__label__ = 5; break; }
    case 4: 
      var $9=$ch;
      var $10=_isident($9);
      var $12 = $10;__label__ = 5; break;
    case 5: 
      var $12;
      if ($12) { __label__ = 6; break; } else { __label__ = 9; break; }
    case 6: 
      var $14=$2;
      var $15=$ch;
      var $16=_lex_tokench($14, $15);
      if ($16) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $18=$2;
      var $19=(($18+292)|0);
      var $20=(($19)|0);
      HEAP32[(($20)>>2)]=143;
      $1=1;
      __label__ = 10; break;
    case 8: 
      var $22=$2;
      var $23=_lex_getch($22);
      $ch=$23;
      __label__ = 3; break;
    case 9: 
      var $25=$2;
      var $26=$ch;
      _lex_ungetch($25, $26);
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $28=$1;
      ;
      return $28;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_endtoken($lex) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$lex;
      var $3=$2;
      var $4=(($3+292)|0);
      var $5=_token_value_add($4, 0);
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $7=$2;
      _lexerror($7, ((STRING_TABLE.__str16401)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $9=$2;
      var $10=(($9+292)|0);
      var $11=(($10+8)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=((($12)-(1))|0);
      HEAP32[(($11)>>2)]=$13;
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $15=$1;
      STACKTOP = __stackBase__;
      return $15;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_finish_frames($lex) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $rc;
      var $m=__stackBase__;
      $2=$lex;
      __label__ = 3; break;
    case 3: 
      var $4=$2;
      var $5=_lex_parse_frame($4);
      $rc=$5;
      var $6=$rc;
      var $7=(($6)|0) > 0;
      if ($7) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      $1=1;
      __label__ = 21; break;
    case 5: 
      var $10=$rc;
      var $11=(($10)|0) < 0;
      if ($11) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      $1=0;
      __label__ = 21; break;
    case 7: 
      $i=0;
      __label__ = 8; break;
    case 8: 
      var $15=$i;
      var $16=$2;
      var $17=(($16+340)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($15)>>>0) < (($18)>>>0);
      if ($19) { __label__ = 9; break; } else { __label__ = 15; break; }
    case 9: 
      var $21=$2;
      var $22=(($21+292)|0);
      var $23=(($22+4)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=$i;
      var $26=$2;
      var $27=(($26+336)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28+($25<<3))|0);
      var $30=(($29)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=_strcmp($24, $31);
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 13; break; } else { __label__ = 10; break; }
    case 10: 
      var $35=$2;
      var $36=(($35+332)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=((($37)+(1))|0);
      HEAP32[(($36)>>2)]=$38;
      var $39=$i;
      var $40=$2;
      var $41=(($40+336)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=(($42+($39<<3))|0);
      var $44=(($43+4)|0);
      HEAP32[(($44)>>2)]=$37;
      var $45=$2;
      var $46=$2;
      var $47=(($46+292)|0);
      var $48=(($47+4)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=_lexwarn($45, 13, ((STRING_TABLE.__str51436)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$49,tempInt));
      if ($50) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      $1=0;
      __label__ = 21; break;
    case 12: 
      __label__ = 15; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $55=$i;
      var $56=((($55)+(1))|0);
      $i=$56;
      __label__ = 8; break;
    case 15: 
      var $58=$i;
      var $59=$2;
      var $60=(($59+340)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($58)>>>0) < (($61)>>>0);
      if ($62) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      __label__ = 20; break;
    case 17: 
      var $65=$2;
      var $66=(($65+332)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=((($67)+(1))|0);
      HEAP32[(($66)>>2)]=$68;
      var $69=(($m+4)|0);
      HEAP32[(($69)>>2)]=$67;
      var $70=$2;
      var $71=(($70+292)|0);
      var $72=(($71+4)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=(($m)|0);
      HEAP32[(($74)>>2)]=$73;
      var $75=$2;
      var $76=(($75+292)|0);
      var $77=(($76+4)|0);
      HEAP32[(($77)>>2)]=0;
      var $78=$2;
      var $79=(($78+292)|0);
      var $80=(($79+8)|0);
      HEAP32[(($80)>>2)]=0;
      var $81=$2;
      var $82=(($81+292)|0);
      var $83=(($82+12)|0);
      HEAP32[(($83)>>2)]=0;
      var $84=$2;
      var $85=(($m)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=(($m+4)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=_lex_file_frames_add($84, $86, $88);
      if ($89) { __label__ = 19; break; } else { __label__ = 18; break; }
    case 18: 
      var $91=$2;
      _lexerror($91, ((STRING_TABLE.__str16401)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 21; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      if (1) { __label__ = 3; break; } else { __label__ = 21; break; }
    case 21: 
      var $95=$1;
      STACKTOP = __stackBase__;
      return $95;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_finish_frames["X"]=1;

function _isxdigit_only($ch) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$ch;
      var $2=$1;
      var $3=(($2)|0) >= 97;
      if ($3) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $5=$1;
      var $6=(($5)|0) <= 102;
      if ($6) { var $16 = 1;__label__ = 7; break; } else { __label__ = 4; break; }
    case 4: 
      var $8=$1;
      var $9=(($8)|0) >= 65;
      if ($9) { __label__ = 5; break; } else { var $14 = 0;__label__ = 6; break; }
    case 5: 
      var $11=$1;
      var $12=(($11)|0) <= 70;
      var $14 = $12;__label__ = 6; break;
    case 6: 
      var $14;
      var $16 = $14;__label__ = 7; break;
    case 7: 
      var $16;
      ;
      return $16;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_ungetch($lex, $ch) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $1=$lex;
      $2=$ch;
      var $3=$2;
      var $4=(($3) & 255);
      var $5=$1;
      var $6=(($5+284)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=((($7)+(1))|0);
      HEAP32[(($6)>>2)]=$8;
      var $9=$1;
      var $10=(($9+28)|0);
      var $11=(($10+$7)|0);
      HEAP8[($11)]=$4;
      var $12=$2;
      var $13=(($12)|0)==10;
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$1;
      var $16=(($15+20)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=((($17)-(1))|0);
      HEAP32[(($16)>>2)]=$18;
      __label__ = 4; break;
    case 4: 
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_finish_digit($lex, $lastch) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $ishex;
      var $ch;
      $2=$lex;
      $3=$lastch;
      $ishex=0;
      var $4=$3;
      $ch=$4;
      var $5=$2;
      var $6=(($5+292)|0);
      var $7=(($6)|0);
      HEAP32[(($7)>>2)]=137;
      var $8=$2;
      var $9=$ch;
      var $10=_lex_tokench($8, $9);
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+292)|0);
      var $14=(($13)|0);
      HEAP32[(($14)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 4: 
      var $16=$2;
      var $17=_lex_getch($16);
      $ch=$17;
      var $18=$ch;
      var $19=(($18)|0)!=46;
      if ($19) { __label__ = 5; break; } else { __label__ = 12; break; }
    case 5: 
      var $21=$ch;
      var $22=_isdigit($21);
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 12; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$3;
      var $26=(($25)|0)!=48;
      if ($26) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $28=$ch;
      var $29=(($28)|0)!=120;
      if ($29) { __label__ = 8; break; } else { __label__ = 11; break; }
    case 8: 
      var $31=$2;
      var $32=$ch;
      _lex_ungetch($31, $32);
      var $33=$2;
      var $34=_lex_endtoken($33);
      if ($34) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $36=$2;
      var $37=(($36+292)|0);
      var $38=(($37)|0);
      HEAP32[(($38)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 10: 
      var $40=$3;
      var $41=((($40)-(48))|0);
      var $42=$2;
      var $43=(($42+292)|0);
      var $44=(($43+16)|0);
      var $45=$44;
      HEAP32[(($45)>>2)]=$41;
      var $46=$2;
      var $47=(($46+292)|0);
      var $48=(($47)|0);
      var $49=HEAP32[(($48)>>2)];
      $1=$49;
      __label__ = 46; break;
    case 11: 
      $ishex=1;
      __label__ = 12; break;
    case 12: 
      var $52=$ch;
      var $53=(($52)|0)!=46;
      if ($53) { __label__ = 13; break; } else { __label__ = 25; break; }
    case 13: 
      var $55=$2;
      var $56=$ch;
      var $57=_lex_tokench($55, $56);
      if ($57) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      var $59=$2;
      var $60=(($59+292)|0);
      var $61=(($60)|0);
      HEAP32[(($61)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 15: 
      var $63=$2;
      var $64=_lex_getch($63);
      $ch=$64;
      __label__ = 16; break;
    case 16: 
      var $66=$ch;
      var $67=_isdigit($66);
      var $68=(($67)|0)!=0;
      if ($68) { var $78 = 1;__label__ = 20; break; } else { __label__ = 17; break; }
    case 17: 
      var $70=$ishex;
      var $71=(($70) & 1);
      if ($71) { __label__ = 18; break; } else { var $76 = 0;__label__ = 19; break; }
    case 18: 
      var $73=$ch;
      var $74=_isxdigit_only($73);
      var $76 = $74;__label__ = 19; break;
    case 19: 
      var $76;
      var $78 = $76;__label__ = 20; break;
    case 20: 
      var $78;
      if ($78) { __label__ = 21; break; } else { __label__ = 24; break; }
    case 21: 
      var $80=$2;
      var $81=$ch;
      var $82=_lex_tokench($80, $81);
      if ($82) { __label__ = 23; break; } else { __label__ = 22; break; }
    case 22: 
      var $84=$2;
      var $85=(($84+292)|0);
      var $86=(($85)|0);
      HEAP32[(($86)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 23: 
      var $88=$2;
      var $89=_lex_getch($88);
      $ch=$89;
      __label__ = 16; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $92=$ch;
      var $93=(($92)|0)==46;
      if ($93) { __label__ = 26; break; } else { __label__ = 35; break; }
    case 26: 
      var $95=$ishex;
      var $96=(($95) & 1);
      if ($96) { __label__ = 35; break; } else { __label__ = 27; break; }
    case 27: 
      var $98=$2;
      var $99=(($98+292)|0);
      var $100=(($99)|0);
      HEAP32[(($100)>>2)]=138;
      var $101=$2;
      var $102=$ch;
      var $103=_lex_tokench($101, $102);
      if ($103) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      var $105=$2;
      var $106=(($105+292)|0);
      var $107=(($106)|0);
      HEAP32[(($107)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 29: 
      var $109=$2;
      var $110=_lex_getch($109);
      $ch=$110;
      __label__ = 30; break;
    case 30: 
      var $112=$ch;
      var $113=_isdigit($112);
      var $114=(($113)|0)!=0;
      if ($114) { __label__ = 31; break; } else { __label__ = 34; break; }
    case 31: 
      var $116=$2;
      var $117=$ch;
      var $118=_lex_tokench($116, $117);
      if ($118) { __label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      var $120=$2;
      var $121=(($120+292)|0);
      var $122=(($121)|0);
      HEAP32[(($122)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 33: 
      var $124=$2;
      var $125=_lex_getch($124);
      $ch=$125;
      __label__ = 30; break;
    case 34: 
      __label__ = 35; break;
    case 35: 
      var $128=$2;
      var $129=(($128+292)|0);
      var $130=(($129)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=(($131)|0)==138;
      if ($132) { __label__ = 36; break; } else { __label__ = 38; break; }
    case 36: 
      var $134=$ch;
      var $135=(($134)|0)==102;
      if ($135) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      var $137=$2;
      var $138=_lex_getch($137);
      $ch=$138;
      __label__ = 38; break;
    case 38: 
      var $140=$ch;
      var $141=_isident($140);
      if ($141) { __label__ = 39; break; } else { __label__ = 40; break; }
    case 39: 
      var $143=$2;
      _lexerror($143, ((STRING_TABLE.__str50435)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $144=$2;
      var $145=(($144+292)|0);
      var $146=(($145)|0);
      HEAP32[(($146)>>2)]=142;
      $1=142;
      __label__ = 46; break;
    case 40: 
      var $148=$2;
      var $149=$ch;
      _lex_ungetch($148, $149);
      var $150=$2;
      var $151=_lex_endtoken($150);
      if ($151) { __label__ = 42; break; } else { __label__ = 41; break; }
    case 41: 
      var $153=$2;
      var $154=(($153+292)|0);
      var $155=(($154)|0);
      HEAP32[(($155)>>2)]=143;
      $1=143;
      __label__ = 46; break;
    case 42: 
      var $157=$2;
      var $158=(($157+292)|0);
      var $159=(($158)|0);
      var $160=HEAP32[(($159)>>2)];
      var $161=(($160)|0)==138;
      if ($161) { __label__ = 43; break; } else { __label__ = 44; break; }
    case 43: 
      var $163=$2;
      var $164=(($163+292)|0);
      var $165=(($164+4)|0);
      var $166=HEAP32[(($165)>>2)];
      var $167=_strtod($166, 0);
      var $168=$2;
      var $169=(($168+292)|0);
      var $170=(($169+16)|0);
      var $171=$170;
      (tempDoubleF64[0]=$167,HEAP32[(($171)>>2)]=tempDoubleI32[0],HEAP32[((($171)+(4))>>2)]=tempDoubleI32[1]);
      __label__ = 45; break;
    case 44: 
      var $173=$2;
      var $174=(($173+292)|0);
      var $175=(($174+4)|0);
      var $176=HEAP32[(($175)>>2)];
      var $177=_strtol($176, 0, 0);
      var $178=$2;
      var $179=(($178+292)|0);
      var $180=(($179+16)|0);
      var $181=$180;
      HEAP32[(($181)>>2)]=$177;
      __label__ = 45; break;
    case 45: 
      var $183=$2;
      var $184=(($183+292)|0);
      var $185=(($184)|0);
      var $186=HEAP32[(($185)>>2)];
      $1=$186;
      __label__ = 46; break;
    case 46: 
      var $188=$1;
      STACKTOP = __stackBase__;
      return $188;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_finish_digit["X"]=1;

function _lex_parse_frame($lex) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ch;
      $2=$lex;
      var $3=$2;
      _lex_token_new($3);
      var $4=$2;
      var $5=_lex_getch($4);
      $ch=$5;
      __label__ = 3; break;
    case 3: 
      var $7=$ch;
      var $8=(($7)|0)!=-1;
      if ($8) { __label__ = 4; break; } else { var $17 = 0;__label__ = 6; break; }
    case 4: 
      var $10=$ch;
      var $11=(($10)|0)!=10;
      if ($11) { __label__ = 5; break; } else { var $17 = 0;__label__ = 6; break; }
    case 5: 
      var $13=$ch;
      var $14=_isspace($13);
      var $15=(($14)|0)!=0;
      var $17 = $15;__label__ = 6; break;
    case 6: 
      var $17;
      if ($17) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $19=$2;
      var $20=_lex_getch($19);
      $ch=$20;
      __label__ = 3; break;
    case 8: 
      var $22=$ch;
      var $23=(($22)|0)==10;
      if ($23) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      $1=1;
      __label__ = 19; break;
    case 10: 
      var $26=$ch;
      var $27=_isident_start($26);
      if ($27) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      var $29=$2;
      var $30=$ch;
      _lexerror($29, ((STRING_TABLE.__str49434)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$30,tempInt));
      $1=-1;
      __label__ = 19; break;
    case 12: 
      var $32=$2;
      var $33=$ch;
      var $34=_lex_tokench($32, $33);
      if ($34) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      $1=-1;
      __label__ = 19; break;
    case 14: 
      var $37=$2;
      var $38=_lex_finish_ident($37);
      if ($38) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=-1;
      __label__ = 19; break;
    case 16: 
      var $41=$2;
      var $42=_lex_endtoken($41);
      if ($42) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      $1=-1;
      __label__ = 19; break;
    case 18: 
      $1=0;
      __label__ = 19; break;
    case 19: 
      var $46=$1;
      STACKTOP = __stackBase__;
      return $46;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_parse_frame["X"]=1;

function _lex_finish_string($lex, $quote) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $ch;
      $2=$lex;
      $3=$quote;
      $ch=0;
      __label__ = 3; break;
    case 3: 
      var $5=$ch;
      var $6=(($5)|0)!=-1;
      if ($6) { __label__ = 4; break; } else { __label__ = 29; break; }
    case 4: 
      var $8=$2;
      var $9=_lex_getch($8);
      $ch=$9;
      var $10=$ch;
      var $11=$3;
      var $12=(($10)|0)==(($11)|0);
      if ($12) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=134;
      __label__ = 30; break;
    case 6: 
      var $15=$2;
      var $16=(($15+328)|0);
      var $17=(($16+2)|0);
      var $18=HEAP8[($17)];
      var $19=(($18) & 1);
      if ($19) { __label__ = 25; break; } else { __label__ = 7; break; }
    case 7: 
      var $21=$ch;
      var $22=(($21)|0)==92;
      if ($22) { __label__ = 8; break; } else { __label__ = 25; break; }
    case 8: 
      var $24=$2;
      var $25=_lex_getch($24);
      $ch=$25;
      var $26=$ch;
      var $27=(($26)|0)==-1;
      if ($27) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $29=$2;
      _lexerror($29, ((STRING_TABLE.__str46431)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $30=$2;
      _lex_ungetch($30, -1);
      var $31=$2;
      var $32=(($31+292)|0);
      var $33=(($32)|0);
      HEAP32[(($33)>>2)]=142;
      $1=142;
      __label__ = 30; break;
    case 10: 
      var $35=$ch;
      if ((($35)|0) == 92) {
        __label__ = 11; break;
      }
      else if ((($35)|0) == 97) {
        __label__ = 12; break;
      }
      else if ((($35)|0) == 98) {
        __label__ = 13; break;
      }
      else if ((($35)|0) == 114) {
        __label__ = 14; break;
      }
      else if ((($35)|0) == 110) {
        __label__ = 15; break;
      }
      else if ((($35)|0) == 116) {
        __label__ = 16; break;
      }
      else if ((($35)|0) == 102) {
        __label__ = 17; break;
      }
      else if ((($35)|0) == 118) {
        __label__ = 18; break;
      }
      else {
      __label__ = 19; break;
      }
      
    case 11: 
      __label__ = 22; break;
    case 12: 
      $ch=7;
      __label__ = 22; break;
    case 13: 
      $ch=8;
      __label__ = 22; break;
    case 14: 
      $ch=13;
      __label__ = 22; break;
    case 15: 
      $ch=10;
      __label__ = 22; break;
    case 16: 
      $ch=9;
      __label__ = 22; break;
    case 17: 
      $ch=12;
      __label__ = 22; break;
    case 18: 
      $ch=11;
      __label__ = 22; break;
    case 19: 
      var $45=$2;
      var $46=$ch;
      var $47=_lexwarn($45, 3, ((STRING_TABLE.__str47432)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$46,tempInt));
      var $48=$2;
      var $49=_lex_tokench($48, 92);
      if ($49) { __label__ = 21; break; } else { __label__ = 20; break; }
    case 20: 
      var $51=$2;
      var $52=(($51+292)|0);
      var $53=(($52)|0);
      HEAP32[(($53)>>2)]=143;
      $1=143;
      __label__ = 30; break;
    case 21: 
      __label__ = 22; break;
    case 22: 
      var $56=$2;
      var $57=$ch;
      var $58=_lex_tokench($56, $57);
      if ($58) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $60=$2;
      var $61=(($60+292)|0);
      var $62=(($61)|0);
      HEAP32[(($62)>>2)]=143;
      $1=143;
      __label__ = 30; break;
    case 24: 
      __label__ = 28; break;
    case 25: 
      var $65=$2;
      var $66=$ch;
      var $67=_lex_tokench($65, $66);
      if ($67) { __label__ = 27; break; } else { __label__ = 26; break; }
    case 26: 
      var $69=$2;
      var $70=(($69+292)|0);
      var $71=(($70)|0);
      HEAP32[(($71)>>2)]=143;
      $1=143;
      __label__ = 30; break;
    case 27: 
      __label__ = 28; break;
    case 28: 
      __label__ = 3; break;
    case 29: 
      var $75=$2;
      _lexerror($75, ((STRING_TABLE.__str48433)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $76=$2;
      _lex_ungetch($76, -1);
      var $77=$2;
      var $78=(($77+292)|0);
      var $79=(($78)|0);
      HEAP32[(($79)>>2)]=142;
      $1=142;
      __label__ = 30; break;
    case 30: 
      var $81=$1;
      STACKTOP = __stackBase__;
      return $81;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_finish_string["X"]=1;

function _isident($ch) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$ch;
      var $2=$1;
      var $3=_isident_start($2);
      if ($3) { var $9 = 1;__label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $5=$1;
      var $6=_isdigit($5);
      var $7=(($6)|0)!=0;
      var $9 = $7;__label__ = 4; break;
    case 4: 
      var $9;
      ;
      return $9;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_fgetc($lex) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$lex;
      var $3=$2;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$2;
      var $9=(($8)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=_fgetc($10);
      $1=$11;
      __label__ = 9; break;
    case 4: 
      var $13=$2;
      var $14=(($13+4)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 8; break; }
    case 5: 
      var $18=$2;
      var $19=(($18+12)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=$2;
      var $22=(($21+8)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($20)>>>0) >= (($23)>>>0);
      if ($24) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      $1=-1;
      __label__ = 9; break;
    case 7: 
      var $27=$2;
      var $28=(($27+12)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=((($29)+(1))|0);
      HEAP32[(($28)>>2)]=$30;
      var $31=$2;
      var $32=(($31+4)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33+$29)|0);
      var $35=HEAP8[($34)];
      var $36=(($35 << 24) >> 24);
      $1=$36;
      __label__ = 9; break;
    case 8: 
      $1=-1;
      __label__ = 9; break;
    case 9: 
      var $39=$1;
      ;
      return $39;
    default: assert(0, "bad label: " + __label__);
  }
}


function _lex_try_trigraph($lex, $old) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $c2;
      var $c3;
      $2=$lex;
      $3=$old;
      var $4=$2;
      var $5=_lex_fgetc($4);
      $c2=$5;
      var $6=$c2;
      var $7=(($6)|0)!=63;
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$2;
      var $10=$c2;
      _lex_ungetch($9, $10);
      var $11=$3;
      $1=$11;
      __label__ = 15; break;
    case 4: 
      var $13=$2;
      var $14=_lex_fgetc($13);
      $c3=$14;
      var $15=$c3;
      if ((($15)|0) == 61) {
        __label__ = 5; break;
      }
      else if ((($15)|0) == 47) {
        __label__ = 6; break;
      }
      else if ((($15)|0) == 39) {
        __label__ = 7; break;
      }
      else if ((($15)|0) == 40) {
        __label__ = 8; break;
      }
      else if ((($15)|0) == 41) {
        __label__ = 9; break;
      }
      else if ((($15)|0) == 33) {
        __label__ = 10; break;
      }
      else if ((($15)|0) == 60) {
        __label__ = 11; break;
      }
      else if ((($15)|0) == 62) {
        __label__ = 12; break;
      }
      else if ((($15)|0) == 45) {
        __label__ = 13; break;
      }
      else {
      __label__ = 14; break;
      }
      
    case 5: 
      $1=35;
      __label__ = 15; break;
    case 6: 
      $1=92;
      __label__ = 15; break;
    case 7: 
      $1=94;
      __label__ = 15; break;
    case 8: 
      $1=91;
      __label__ = 15; break;
    case 9: 
      $1=93;
      __label__ = 15; break;
    case 10: 
      $1=124;
      __label__ = 15; break;
    case 11: 
      $1=123;
      __label__ = 15; break;
    case 12: 
      $1=125;
      __label__ = 15; break;
    case 13: 
      $1=126;
      __label__ = 15; break;
    case 14: 
      var $26=$2;
      var $27=$c3;
      _lex_ungetch($26, $27);
      var $28=$2;
      var $29=$c2;
      _lex_ungetch($28, $29);
      var $30=$3;
      $1=$30;
      __label__ = 15; break;
    case 15: 
      var $32=$1;
      ;
      return $32;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_try_trigraph["X"]=1;

function _lex_try_digraph($lex, $ch) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $c2;
      $2=$lex;
      $3=$ch;
      var $4=$2;
      var $5=_lex_fgetc($4);
      $c2=$5;
      var $6=$3;
      var $7=(($6)|0)==60;
      if ($7) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $9=$c2;
      var $10=(($9)|0)==58;
      if ($10) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      $1=91;
      __label__ = 22; break;
    case 5: 
      var $13=$3;
      var $14=(($13)|0)==58;
      if ($14) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $16=$c2;
      var $17=(($16)|0)==62;
      if ($17) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      $1=93;
      __label__ = 22; break;
    case 8: 
      var $20=$3;
      var $21=(($20)|0)==60;
      if ($21) { __label__ = 9; break; } else { __label__ = 11; break; }
    case 9: 
      var $23=$c2;
      var $24=(($23)|0)==37;
      if ($24) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      $1=123;
      __label__ = 22; break;
    case 11: 
      var $27=$3;
      var $28=(($27)|0)==37;
      if ($28) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $30=$c2;
      var $31=(($30)|0)==62;
      if ($31) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      $1=125;
      __label__ = 22; break;
    case 14: 
      var $34=$3;
      var $35=(($34)|0)==37;
      if ($35) { __label__ = 15; break; } else { __label__ = 17; break; }
    case 15: 
      var $37=$c2;
      var $38=(($37)|0)==58;
      if ($38) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      $1=35;
      __label__ = 22; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $45=$2;
      var $46=$c2;
      _lex_ungetch($45, $46);
      var $47=$3;
      $1=$47;
      __label__ = 22; break;
    case 22: 
      var $49=$1;
      ;
      return $49;
    default: assert(0, "bad label: " + __label__);
  }
}
_lex_try_digraph["X"]=1;

function _items_add($element_0, $element_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $element=__stackBase__;
      var $temp;
      var $2=(($element)|0);
      HEAP32[(($2)>>2)]=$element_0;
      var $3=(($element+4)|0);
      HEAP32[(($3)>>2)]=$element_1;
      $temp=0;
      var $4=HEAP32[((_items_elements)>>2)];
      var $5=HEAP32[((_items_allocated)>>2)];
      var $6=(($4)|0)==(($5)|0);
      if ($6) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $8=HEAP32[((_items_allocated)>>2)];
      var $9=(($8)|0)==0;
      if ($9) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      HEAP32[((_items_allocated)>>2)]=12;
      __label__ = 6; break;
    case 5: 
      var $12=HEAP32[((_items_allocated)>>2)];
      var $13=((($12<<1))|0);
      HEAP32[((_items_allocated)>>2)]=$13;
      __label__ = 6; break;
    case 6: 
      var $15=HEAP32[((_items_allocated)>>2)];
      var $16=((($15<<3))|0);
      var $17=_util_memory_a($16, 48, ((STRING_TABLE.__str1448)|0));
      $temp=$17;
      var $18=(($17)|0)!=0;
      if ($18) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $20=$temp;
      _util_memory_d($20, 48, ((STRING_TABLE.__str1448)|0));
      $1=-1;
      __label__ = 10; break;
    case 8: 
      var $22=$temp;
      var $23=HEAP32[((_items_data)>>2)];
      var $24=$23;
      var $25=HEAP32[((_items_elements)>>2)];
      var $26=((($25<<3))|0);
      assert($26 % 1 === 0, 'memcpy given ' + $26 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($22, $24, $26, 1);
      var $27=HEAP32[((_items_data)>>2)];
      var $28=$27;
      _util_memory_d($28, 48, ((STRING_TABLE.__str1448)|0));
      var $29=$temp;
      var $30=$29;
      HEAP32[((_items_data)>>2)]=$30;
      __label__ = 9; break;
    case 9: 
      var $32=HEAP32[((_items_elements)>>2)];
      var $33=HEAP32[((_items_data)>>2)];
      var $34=(($33+($32<<3))|0);
      var $35=$34;
      var $36=$element;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($35)>>2)]=HEAP32[(($36)>>2)];HEAP32[((($35)+(4))>>2)]=HEAP32[((($36)+(4))>>2)];
      var $37=HEAP32[((_items_elements)>>2)];
      var $38=((($37)+(1))|0);
      HEAP32[((_items_elements)>>2)]=$38;
      $1=$37;
      __label__ = 10; break;
    case 10: 
      var $40=$1;
      STACKTOP = __stackBase__;
      return $40;
    default: assert(0, "bad label: " + __label__);
  }
}
_items_add["X"]=1;

function _options_set($flags, $idx, $on) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $lb;
      $1=$flags;
      $2=$idx;
      var $4=(($on)&1);
      $3=$4;
      var $5=$2;
      $lb=$5;
      var $6=$3;
      var $7=(($6) & 1);
      if ($7) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $9=$lb;
      var $10=1 << $9;
      var $11=$1;
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$13 | $10;
      HEAP32[(($12)>>2)]=$14;
      __label__ = 5; break;
    case 4: 
      var $16=$lb;
      var $17=1 << $16;
      var $18=$17 ^ -1;
      var $19=$1;
      var $20=(($19)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=$21 & $18;
      HEAP32[(($20)>>2)]=$22;
      __label__ = 5; break;
    case 5: 
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _main($argc, $argv) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $itr;
      var $retval;
      var $opts_output_free;
      var $src;
      var $line=__stackBase__;
      var $linelen=(__stackBase__)+(4);
      $1=0;
      $2=$argc;
      $3=$argv;
      $retval=0;
      $opts_output_free=0;
      var $4=$3;
      var $5=(($4)|0);
      var $6=HEAP32[(($5)>>2)];
      HEAP32[((_app_name)>>2)]=$6;
      _options_set(((_opts_warn)|0), 3, 1);
      _options_set(((_opts_warn)|0), 4, 1);
      _options_set(((_opts_warn)|0), 5, 1);
      _options_set(((_opts_warn)|0), 7, 1);
      _options_set(((_opts_warn)|0), 6, 1);
      _options_set(((_opts_warn)|0), 2, 1);
      _options_set(((_opts_warn)|0), 9, 1);
      _options_set(((_opts_warn)|0), 10, 1);
      _options_set(((_opts_warn)|0), 11, 1);
      _options_set(((_opts_warn)|0), 12, 1);
      _options_set(((_opts_warn)|0), 13, 1);
      _options_set(((_opts_warn)|0), 1, 1);
      _options_set(((_opts_warn)|0), 14, 1);
      _options_set(((_opts_warn)|0), 15, 1);
      _options_set(((_opts_warn)|0), 16, 1);
      var $7=$2;
      var $8=$3;
      var $9=_options_parse($7, $8);
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $11=_usage();
      $1=$11;
      __label__ = 51; break;
    case 4: 
      var $13=HEAP32[((_opts_standard)>>2)];
      var $14=(($13)|0)==3;
      if ($14) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      HEAP32[((_operators)>>2)]=((_c_operators)|0);
      HEAP32[((_operator_count)>>2)]=42;
      __label__ = 7; break;
    case 6: 
      HEAP32[((_operators)>>2)]=((_qcc_operators)|0);
      HEAP32[((_operator_count)>>2)]=29;
      __label__ = 7; break;
    case 7: 
      var $18=HEAP8[(_opts_dump)];
      var $19=(($18) & 1);
      if ($19) { __label__ = 8; break; } else { __label__ = 17; break; }
    case 8: 
      $itr=0;
      __label__ = 9; break;
    case 9: 
      var $22=$itr;
      var $23=(($22)>>>0) < 4;
      if ($23) { __label__ = 10; break; } else { __label__ = 12; break; }
    case 10: 
      var $25=$itr;
      var $26=((_opts_flag_list+($25<<3))|0);
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$itr;
      var $30=Math.floor(((($29)>>>0))/(32));
      var $31=((_opts_flags+($30<<2))|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$itr;
      var $34=((($33)>>>0))%(32);
      var $35=1 << $34;
      var $36=$32 & $35;
      var $37=(($36)|0)!=0;
      var $38=$37 ^ 1;
      var $39=$38 ^ 1;
      var $40=(($39)&1);
      var $41=_printf(((STRING_TABLE.__str2451)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$28,HEAP32[(((tempInt)+(4))>>2)]=$40,tempInt));
      __label__ = 11; break;
    case 11: 
      var $43=$itr;
      var $44=((($43)+(1))|0);
      $itr=$44;
      __label__ = 9; break;
    case 12: 
      $itr=0;
      __label__ = 13; break;
    case 13: 
      var $47=$itr;
      var $48=(($47)>>>0) < 17;
      if ($48) { __label__ = 14; break; } else { __label__ = 16; break; }
    case 14: 
      var $50=$itr;
      var $51=((_opts_warn_list+($50<<3))|0);
      var $52=(($51)|0);
      var $53=HEAP32[(($52)>>2)];
      var $54=$itr;
      var $55=Math.floor(((($54)>>>0))/(32));
      var $56=((_opts_warn+($55<<2))|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=$itr;
      var $59=((($58)>>>0))%(32);
      var $60=1 << $59;
      var $61=$57 & $60;
      var $62=(($61)|0)!=0;
      var $63=$62 ^ 1;
      var $64=$63 ^ 1;
      var $65=(($64)&1);
      var $66=_printf(((STRING_TABLE.__str3454)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$53,HEAP32[(((tempInt)+(4))>>2)]=$65,tempInt));
      __label__ = 15; break;
    case 15: 
      var $68=$itr;
      var $69=((($68)+(1))|0);
      $itr=$69;
      __label__ = 13; break;
    case 16: 
      var $71=HEAP32[((_opts_output)>>2)];
      var $72=_printf(((STRING_TABLE.__str4455)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$71,tempInt));
      var $73=HEAP32[((_opts_O)>>2)];
      var $74=_printf(((STRING_TABLE.__str5456)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$73,tempInt));
      var $75=HEAP32[((_opts_standard)>>2)];
      var $76=_printf(((STRING_TABLE.__str6457)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$75,tempInt));
      __label__ = 17; break;
    case 17: 
      var $78=_parser_init();
      if ($78) { __label__ = 19; break; } else { __label__ = 18; break; }
    case 18: 
      var $80=_printf(((STRING_TABLE.__str7458)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=1;
      __label__ = 48; break;
    case 19: 
      _util_debug(((STRING_TABLE.__str8459)|0), ((STRING_TABLE.__str9460)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $82=HEAP32[((_items_elements)>>2)];
      var $83=(($82)|0)!=0;
      if ($83) { __label__ = 20; break; } else { __label__ = 29; break; }
    case 20: 
      var $85=_printf(((STRING_TABLE.__str10461)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $86=HEAP32[((_items_elements)>>2)];
      var $87=_printf(((STRING_TABLE.__str11462)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$86,tempInt));
      $itr=0;
      __label__ = 21; break;
    case 21: 
      var $89=$itr;
      var $90=HEAP32[((_items_elements)>>2)];
      var $91=(($89)>>>0) < (($90)>>>0);
      if ($91) { __label__ = 22; break; } else { __label__ = 26; break; }
    case 22: 
      var $93=$itr;
      var $94=HEAP32[((_items_data)>>2)];
      var $95=(($94+($93<<3))|0);
      var $96=(($95)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=_parser_compile_string(((STRING_TABLE.__str12463)|0), $97);
      if ($98) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      $retval=1;
      __label__ = 48; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $102=$itr;
      var $103=((($102)+(1))|0);
      $itr=$103;
      __label__ = 21; break;
    case 26: 
      var $105=HEAP32[((_opts_output)>>2)];
      var $106=_parser_finish($105);
      if ($106) { __label__ = 28; break; } else { __label__ = 27; break; }
    case 27: 
      $retval=1;
      __label__ = 48; break;
    case 28: 
      __label__ = 47; break;
    case 29: 
      HEAP32[(($linelen)>>2)]=0;
      var $110=_printf(((STRING_TABLE.__str13464)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $111=_util_fopen(((STRING_TABLE.__str14465)|0), ((STRING_TABLE.__str15466)|0));
      $src=$111;
      var $112=$src;
      var $113=(($112)|0)!=0;
      if ($113) { __label__ = 31; break; } else { __label__ = 30; break; }
    case 30: 
      var $115=_printf(((STRING_TABLE.__str16467)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=1;
      __label__ = 48; break;
    case 31: 
      HEAP32[(($line)>>2)]=0;
      var $117=$src;
      var $118=_progs_nextline($line, $linelen, $117);
      if ($118) { __label__ = 32; break; } else { __label__ = 33; break; }
    case 32: 
      var $120=HEAP32[(($line)>>2)];
      var $121=(($120)|0);
      var $122=HEAP8[($121)];
      var $123=(($122 << 24) >> 24)!=0;
      if ($123) { __label__ = 34; break; } else { __label__ = 33; break; }
    case 33: 
      var $125=_printf(((STRING_TABLE.__str17468)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=1;
      __label__ = 46; break;
    case 34: 
      var $127=HEAP8[(_opts_output_wasset)];
      var $128=(($127) & 1);
      if ($128) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      var $130=HEAP32[(($line)>>2)];
      var $131=_util_strdup($130);
      HEAP32[((_opts_output)>>2)]=$131;
      $opts_output_free=1;
      __label__ = 36; break;
    case 36: 
      __label__ = 37; break;
    case 37: 
      var $134=$src;
      var $135=_progs_nextline($line, $linelen, $134);
      if ($135) { __label__ = 38; break; } else { __label__ = 45; break; }
    case 38: 
      var $137=HEAP32[(($line)>>2)];
      var $138=(($137)|0);
      var $139=HEAP8[($138)];
      var $140=(($139 << 24) >> 24)!=0;
      if ($140) { __label__ = 39; break; } else { __label__ = 41; break; }
    case 39: 
      var $142=HEAP32[(($line)>>2)];
      var $143=(($142)|0);
      var $144=HEAP8[($143)];
      var $145=(($144 << 24) >> 24);
      var $146=(($145)|0)==47;
      if ($146) { __label__ = 40; break; } else { __label__ = 42; break; }
    case 40: 
      var $148=HEAP32[(($line)>>2)];
      var $149=(($148+1)|0);
      var $150=HEAP8[($149)];
      var $151=(($150 << 24) >> 24);
      var $152=(($151)|0)==47;
      if ($152) { __label__ = 41; break; } else { __label__ = 42; break; }
    case 41: 
      __label__ = 37; break;
    case 42: 
      var $155=HEAP32[(($line)>>2)];
      var $156=_printf(((STRING_TABLE.__str18469)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$155,tempInt));
      var $157=HEAP32[(($line)>>2)];
      var $158=_parser_compile_file($157);
      if ($158) { __label__ = 44; break; } else { __label__ = 43; break; }
    case 43: 
      $retval=1;
      __label__ = 46; break;
    case 44: 
      __label__ = 37; break;
    case 45: 
      var $162=HEAP32[((_opts_output)>>2)];
      var $163=_parser_finish($162);
      __label__ = 46; break;
    case 46: 
      var $165=$src;
      var $166=_fclose($165);
      var $167=HEAP32[(($line)>>2)];
      _util_memory_d($167, 520, ((STRING_TABLE.__str1448)|0));
      __label__ = 47; break;
    case 47: 
      __label__ = 48; break;
    case 48: 
      _util_debug(((STRING_TABLE.__str8459)|0), ((STRING_TABLE.__str19470)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $170=HEAP32[((_items_data)>>2)];
      var $171=$170;
      _util_memory_d($171, 528, ((STRING_TABLE.__str1448)|0));
      _parser_cleanup();
      var $172=$opts_output_free;
      var $173=(($172) & 1);
      if ($173) { __label__ = 49; break; } else { __label__ = 50; break; }
    case 49: 
      var $175=HEAP32[((_opts_output)>>2)];
      _util_memory_d($175, 532, ((STRING_TABLE.__str1448)|0));
      __label__ = 50; break;
    case 50: 
      _lex_cleanup();
      _util_meminfo();
      var $177=$retval;
      $1=$177;
      __label__ = 51; break;
    case 51: 
      var $179=$1;
      STACKTOP = __stackBase__;
      return $179;
    default: assert(0, "bad label: " + __label__);
  }
}
Module["_main"] = _main;_main["X"]=1;

function _options_witharg($argc_, $argv_, $out) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $argc;
      var $argv;
      $2=$argc_;
      $3=$argv_;
      $4=$out;
      var $5=$2;
      var $6=HEAP32[(($5)>>2)];
      $argc=$6;
      var $7=$3;
      var $8=HEAP32[(($7)>>2)];
      $argv=$8;
      var $9=$argv;
      var $10=(($9)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($11+2)|0);
      var $13=HEAP8[($12)];
      var $14=(($13 << 24) >> 24)!=0;
      if ($14) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $16=$argv;
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18+2)|0);
      var $20=$4;
      HEAP32[(($20)>>2)]=$19;
      $1=1;
      __label__ = 7; break;
    case 4: 
      var $22=$argc;
      var $23=(($22)|0) < 2;
      if ($23) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $26=$argv;
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=$4;
      HEAP32[(($29)>>2)]=$28;
      var $30=$2;
      var $31=HEAP32[(($30)>>2)];
      var $32=((($31)-(1))|0);
      HEAP32[(($30)>>2)]=$32;
      var $33=$3;
      var $34=HEAP32[(($33)>>2)];
      var $35=(($34+4)|0);
      HEAP32[(($33)>>2)]=$35;
      $1=1;
      __label__ = 7; break;
    case 7: 
      var $37=$1;
      ;
      return $37;
    default: assert(0, "bad label: " + __label__);
  }
}
_options_witharg["X"]=1;

function _progs_nextline($out, $alen, $src) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $len;
      var $line=__stackBase__;
      var $start;
      var $end;
      $2=$out;
      $3=$alen;
      $4=$src;
      var $5=$2;
      var $6=HEAP32[(($5)>>2)];
      HEAP32[(($line)>>2)]=$6;
      var $7=$3;
      var $8=$4;
      var $9=_util_getline($line, $7, $8);
      $len=$9;
      var $10=$len;
      var $11=(($10)|0)==-1;
      if ($11) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 18; break;
    case 4: 
      var $14=HEAP32[(($line)>>2)];
      $start=$14;
      __label__ = 5; break;
    case 5: 
      var $16=$start;
      var $17=HEAP8[($16)];
      var $18=(($17 << 24) >> 24);
      var $19=_isspace($18);
      var $20=(($19)|0)!=0;
      if ($20) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $23=$start;
      var $24=(($23+1)|0);
      $start=$24;
      __label__ = 5; break;
    case 8: 
      var $26=$start;
      $end=$26;
      __label__ = 9; break;
    case 9: 
      var $28=$end;
      var $29=HEAP8[($28)];
      var $30=(($29 << 24) >> 24);
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 10; break; } else { var $40 = 0;__label__ = 11; break; }
    case 10: 
      var $33=$end;
      var $34=HEAP8[($33)];
      var $35=(($34 << 24) >> 24);
      var $36=_isspace($35);
      var $37=(($36)|0)!=0;
      var $38=$37 ^ 1;
      var $40 = $38;__label__ = 11; break;
    case 11: 
      var $40;
      if ($40) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $43=$end;
      var $44=(($43+1)|0);
      $end=$44;
      __label__ = 9; break;
    case 14: 
      var $46=HEAP32[(($line)>>2)];
      var $47=$2;
      HEAP32[(($47)>>2)]=$46;
      __label__ = 15; break;
    case 15: 
      var $49=$start;
      var $50=$end;
      var $51=(($49)|0)!=(($50)|0);
      if ($51) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      var $53=$start;
      var $54=(($53+1)|0);
      $start=$54;
      var $55=HEAP8[($53)];
      var $56=HEAP32[(($line)>>2)];
      var $57=(($56+1)|0);
      HEAP32[(($line)>>2)]=$57;
      HEAP8[($56)]=$55;
      __label__ = 15; break;
    case 17: 
      var $59=HEAP32[(($line)>>2)];
      HEAP8[($59)]=0;
      $1=1;
      __label__ = 18; break;
    case 18: 
      var $61=$1;
      STACKTOP = __stackBase__;
      return $61;
    default: assert(0, "bad label: " + __label__);
  }
}
_progs_nextline["X"]=1;

function _usage() {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1=HEAP32[((_app_name)>>2)];
  var $2=_printf(((STRING_TABLE.__str78531)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1,tempInt));
  var $3=_printf(((STRING_TABLE.__str79532)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $4=_printf(((STRING_TABLE.__str80533)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $5=_printf(((STRING_TABLE.__str81534)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $6=_printf(((STRING_TABLE.__str82535)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $7=_printf(((STRING_TABLE.__str83536)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $8=_printf(((STRING_TABLE.__str84537)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $9=_printf(((STRING_TABLE.__str85538)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  var $10=_printf(((STRING_TABLE.__str86539)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
  STACKTOP = __stackBase__;
  return -1;
}


function _options_long_gcc($optname, $argc_, $argv_, $out) {
  ;
  var __label__;

  var $1;
  var $2;
  var $3;
  var $4;
  $1=$optname;
  $2=$argc_;
  $3=$argv_;
  $4=$out;
  var $5=$1;
  var $6=$2;
  var $7=$3;
  var $8=$4;
  var $9=_options_long_witharg_all($5, $6, $7, $8, 1, 0);
  ;
  return $9;
}


function _options_setflag($name, $on) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$name;
  var $3=(($on)&1);
  $2=$3;
  var $4=$1;
  var $5=$2;
  var $6=(($5) & 1);
  var $7=_options_setflag_all($4, $6, ((_opts_flags)|0), ((_opts_flag_list)|0), 4);
  ;
  return $7;
}


function _options_setwarn($name, $on) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$name;
  var $3=(($on)&1);
  $2=$3;
  var $4=$1;
  var $5=$2;
  var $6=(($5) & 1);
  var $7=_options_setflag_all($4, $6, ((_opts_warn)|0), ((_opts_warn_list)|0), 17);
  ;
  return $7;
}


function _options_long_witharg($optname, $argc_, $argv_, $out) {
  ;
  var __label__;

  var $1;
  var $2;
  var $3;
  var $4;
  $1=$optname;
  $2=$argc_;
  $3=$argv_;
  $4=$out;
  var $5=$1;
  var $6=$2;
  var $7=$3;
  var $8=$4;
  var $9=_options_long_witharg_all($5, $6, $7, $8, 2, 1);
  ;
  return $9;
}


function _options_parse($argc, $argv) {
  var __stackBase__  = STACKTOP; STACKTOP += 1052; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2=__stackBase__;
      var $3=(__stackBase__)+(4);
      var $argend;
      var $itr;
      var $buffer=(__stackBase__)+(8);
      var $argarg=(__stackBase__)+(1032);
      var $item=(__stackBase__)+(1036);
      var $item1=(__stackBase__)+(1044);
      HEAP32[(($2)>>2)]=$argc;
      HEAP32[(($3)>>2)]=$argv;
      $argend=0;
      __label__ = 3; break;
    case 3: 
      var $5=$argend;
      var $6=(($5) & 1);
      if ($6) { var $11 = 0;__label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $8=HEAP32[(($2)>>2)];
      var $9=(($8)|0) > 1;
      var $11 = $9;__label__ = 5; break;
    case 5: 
      var $11;
      if ($11) { __label__ = 6; break; } else { __label__ = 106; break; }
    case 6: 
      var $13=HEAP32[(($3)>>2)];
      var $14=(($13+4)|0);
      HEAP32[(($3)>>2)]=$14;
      var $15=HEAP32[(($2)>>2)];
      var $16=((($15)-(1))|0);
      HEAP32[(($2)>>2)]=$16;
      var $17=HEAP32[(($3)>>2)];
      var $18=(($17)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($19)|0);
      var $21=HEAP8[($20)];
      var $22=(($21 << 24) >> 24);
      var $23=(($22)|0)==45;
      if ($23) { __label__ = 7; break; } else { __label__ = 104; break; }
    case 7: 
      var $25=_options_long_gcc(((STRING_TABLE.__str87540)|0), $2, $3, $argarg);
      if ($25) { __label__ = 8; break; } else { __label__ = 23; break; }
    case 8: 
      var $27=HEAP32[(($argarg)>>2)];
      var $28=_strcmp($27, ((STRING_TABLE.__str88541)|0));
      var $29=(($28)|0)!=0;
      if ($29) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $31=HEAP32[(($argarg)>>2)];
      var $32=_strcmp($31, ((STRING_TABLE.__str89542)|0));
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      HEAP32[((_opts_standard)>>2)]=3;
      __label__ = 22; break;
    case 11: 
      var $36=HEAP32[(($argarg)>>2)];
      var $37=_strcmp($36, ((STRING_TABLE.__str90543)|0));
      var $38=(($37)|0)!=0;
      if ($38) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      HEAP32[((_opts_standard)>>2)]=0;
      __label__ = 21; break;
    case 13: 
      var $41=HEAP32[(($argarg)>>2)];
      var $42=_strcmp($41, ((STRING_TABLE.__str91544)|0));
      var $43=(($42)|0)!=0;
      if ($43) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      var $45=HEAP32[(($argarg)>>2)];
      var $46=_strcmp($45, ((STRING_TABLE.__str92545)|0));
      var $47=(($46)|0)!=0;
      if ($47) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      HEAP32[((_opts_standard)>>2)]=1;
      __label__ = 20; break;
    case 16: 
      var $50=HEAP32[(($argarg)>>2)];
      var $51=_strcmp($50, ((STRING_TABLE.__str93546)|0));
      var $52=(($51)|0)!=0;
      if ($52) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      HEAP32[((_opts_standard)>>2)]=2;
      __label__ = 19; break;
    case 18: 
      var $55=HEAP32[(($argarg)>>2)];
      var $56=_printf(((STRING_TABLE.__str94547)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$55,tempInt));
      $1=0;
      __label__ = 107; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      __label__ = 22; break;
    case 22: 
      __label__ = 3; break;
    case 23: 
      var $62=_options_long_gcc(((STRING_TABLE.__str95548)|0), $2, $3, $argarg);
      if ($62) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      HEAP8[(_opts_forcecrc)]=1;
      var $64=HEAP32[(($argarg)>>2)];
      var $65=_strtol($64, 0, 0);
      var $66=(($65) & 65535);
      HEAP16[((_opts_forced_crc)>>1)]=$66;
      __label__ = 3; break;
    case 25: 
      var $68=HEAP32[(($3)>>2)];
      var $69=(($68)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=(($70+1)|0);
      var $72=_strcmp($71, ((STRING_TABLE.__str96549)|0));
      var $73=(($72)|0)!=0;
      if ($73) { __label__ = 27; break; } else { __label__ = 26; break; }
    case 26: 
      HEAP8[(_opts_debug)]=1;
      __label__ = 3; break;
    case 27: 
      var $76=HEAP32[(($3)>>2)];
      var $77=(($76)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($78+1)|0);
      var $80=_strcmp($79, ((STRING_TABLE.__str97550)|0));
      var $81=(($80)|0)!=0;
      if ($81) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      HEAP8[(_opts_dump)]=1;
      __label__ = 3; break;
    case 29: 
      var $84=HEAP32[(($3)>>2)];
      var $85=(($84)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=(($86+1)|0);
      var $88=_strcmp($87, ((STRING_TABLE.__str98551)|0));
      var $89=(($88)|0)!=0;
      if ($89) { __label__ = 31; break; } else { __label__ = 30; break; }
    case 30: 
      HEAP8[(_opts_memchk)]=1;
      __label__ = 3; break;
    case 31: 
      var $92=HEAP32[(($3)>>2)];
      var $93=(($92)|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=(($94+1)|0);
      var $96=HEAP8[($95)];
      var $97=(($96 << 24) >> 24);
      if ((($97)|0) == 104) {
        __label__ = 32; break;
      }
      else if ((($97)|0) == 69) {
        __label__ = 33; break;
      }
      else if ((($97)|0) == 102) {
        __label__ = 34; break;
      }
      else if ((($97)|0) == 87) {
        __label__ = 49; break;
      }
      else if ((($97)|0) == 79) {
        __label__ = 83; break;
      }
      else if ((($97)|0) == 111) {
        __label__ = 86; break;
      }
      else if ((($97)|0) == 97 || (($97)|0) == 115) {
        __label__ = 89; break;
      }
      else if ((($97)|0) == 45) {
        __label__ = 92; break;
      }
      else {
      __label__ = 102; break;
      }
      
    case 32: 
      var $99=_usage();
      _exit(0);
      throw "Reached an unreachable!"
    case 33: 
      HEAP8[(_opts_pp_only)]=1;
      __label__ = 103; break;
    case 34: 
      var $102=HEAP32[(($3)>>2)];
      var $103=(($102)|0);
      var $104=HEAP32[(($103)>>2)];
      var $105=(($104+2)|0);
      var $106=HEAP32[(($3)>>2)];
      var $107=(($106)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=(($108+2)|0);
      var $110=HEAP32[(($3)>>2)];
      var $111=(($110)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($112+2)|0);
      var $114=_strlen($113);
      var $115=((($114)+(1))|0);
      var $116=_util_strtocmd($105, $109, $115);
      var $117=HEAP32[(($3)>>2)];
      var $118=(($117)|0);
      var $119=HEAP32[(($118)>>2)];
      var $120=(($119+2)|0);
      var $121=_strcmp($120, ((STRING_TABLE.__str99552)|0));
      var $122=(($121)|0)!=0;
      if ($122) { __label__ = 40; break; } else { __label__ = 35; break; }
    case 35: 
      var $124=_printf(((STRING_TABLE.__str100553)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $itr=0;
      __label__ = 36; break;
    case 36: 
      var $126=$itr;
      var $127=(($126)>>>0) < 4;
      if ($127) { __label__ = 37; break; } else { __label__ = 39; break; }
    case 37: 
      var $129=$itr;
      var $130=((_opts_flag_list+($129<<3))|0);
      var $131=(($130)|0);
      var $132=HEAP32[(($131)>>2)];
      var $133=(($buffer)|0);
      var $134=_util_strtononcmd($132, $133, 1024);
      var $135=(($buffer)|0);
      var $136=_printf(((STRING_TABLE.__str101554)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$135,tempInt));
      __label__ = 38; break;
    case 38: 
      var $138=$itr;
      var $139=((($138)+(1))|0);
      $itr=$139;
      __label__ = 36; break;
    case 39: 
      _exit(0);
      throw "Reached an unreachable!"
    case 40: 
      var $142=HEAP32[(($3)>>2)];
      var $143=(($142)|0);
      var $144=HEAP32[(($143)>>2)];
      var $145=(($144+2)|0);
      var $146=_strncmp($145, ((STRING_TABLE.__str102555)|0), 3);
      var $147=(($146)|0)!=0;
      if ($147) { __label__ = 44; break; } else { __label__ = 41; break; }
    case 41: 
      var $149=HEAP32[(($3)>>2)];
      var $150=(($149)|0);
      var $151=HEAP32[(($150)>>2)];
      var $152=(($151+5)|0);
      var $153=_options_setflag($152, 0);
      if ($153) { __label__ = 43; break; } else { __label__ = 42; break; }
    case 42: 
      var $155=HEAP32[(($3)>>2)];
      var $156=(($155)|0);
      var $157=HEAP32[(($156)>>2)];
      var $158=(($157+2)|0);
      var $159=_printf(((STRING_TABLE.__str103556)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$158,tempInt));
      $1=0;
      __label__ = 107; break;
    case 43: 
      __label__ = 47; break;
    case 44: 
      var $162=HEAP32[(($3)>>2)];
      var $163=(($162)|0);
      var $164=HEAP32[(($163)>>2)];
      var $165=(($164+2)|0);
      var $166=_options_setflag($165, 1);
      if ($166) { __label__ = 46; break; } else { __label__ = 45; break; }
    case 45: 
      var $168=HEAP32[(($3)>>2)];
      var $169=(($168)|0);
      var $170=HEAP32[(($169)>>2)];
      var $171=(($170+2)|0);
      var $172=_printf(((STRING_TABLE.__str103556)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$171,tempInt));
      $1=0;
      __label__ = 107; break;
    case 46: 
      __label__ = 47; break;
    case 47: 
      __label__ = 48; break;
    case 48: 
      __label__ = 103; break;
    case 49: 
      var $177=HEAP32[(($3)>>2)];
      var $178=(($177)|0);
      var $179=HEAP32[(($178)>>2)];
      var $180=(($179+2)|0);
      var $181=HEAP32[(($3)>>2)];
      var $182=(($181)|0);
      var $183=HEAP32[(($182)>>2)];
      var $184=(($183+2)|0);
      var $185=HEAP32[(($3)>>2)];
      var $186=(($185)|0);
      var $187=HEAP32[(($186)>>2)];
      var $188=(($187+2)|0);
      var $189=_strlen($188);
      var $190=((($189)+(1))|0);
      var $191=_util_strtocmd($180, $184, $190);
      var $192=HEAP32[(($3)>>2)];
      var $193=(($192)|0);
      var $194=HEAP32[(($193)>>2)];
      var $195=(($194+2)|0);
      var $196=_strcmp($195, ((STRING_TABLE.__str99552)|0));
      var $197=(($196)|0)!=0;
      if ($197) { __label__ = 55; break; } else { __label__ = 50; break; }
    case 50: 
      var $199=_printf(((STRING_TABLE.__str104557)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $itr=0;
      __label__ = 51; break;
    case 51: 
      var $201=$itr;
      var $202=(($201)>>>0) < 17;
      if ($202) { __label__ = 52; break; } else { __label__ = 54; break; }
    case 52: 
      var $204=$itr;
      var $205=((_opts_warn_list+($204<<3))|0);
      var $206=(($205)|0);
      var $207=HEAP32[(($206)>>2)];
      var $208=(($buffer)|0);
      var $209=_util_strtononcmd($207, $208, 1024);
      var $210=(($buffer)|0);
      var $211=_printf(((STRING_TABLE.__str105558)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$210,tempInt));
      __label__ = 53; break;
    case 53: 
      var $213=$itr;
      var $214=((($213)+(1))|0);
      $itr=$214;
      __label__ = 51; break;
    case 54: 
      _exit(0);
      throw "Reached an unreachable!"
    case 55: 
      var $217=HEAP32[(($3)>>2)];
      var $218=(($217)|0);
      var $219=HEAP32[(($218)>>2)];
      var $220=(($219+2)|0);
      var $221=_strcmp($220, ((STRING_TABLE.__str106559)|0));
      var $222=(($221)|0)!=0;
      if ($222) { __label__ = 57; break; } else { __label__ = 56; break; }
    case 56: 
      HEAP8[(_opts_werror)]=0;
      __label__ = 103; break;
    case 57: 
      var $225=HEAP32[(($3)>>2)];
      var $226=(($225)|0);
      var $227=HEAP32[(($226)>>2)];
      var $228=(($227+2)|0);
      var $229=_strcmp($228, ((STRING_TABLE.__str107560)|0));
      var $230=(($229)|0)!=0;
      if ($230) { __label__ = 59; break; } else { __label__ = 58; break; }
    case 58: 
      HEAP8[(_opts_werror)]=1;
      __label__ = 103; break;
    case 59: 
      var $233=HEAP32[(($3)>>2)];
      var $234=(($233)|0);
      var $235=HEAP32[(($234)>>2)];
      var $236=(($235+2)|0);
      var $237=_strcmp($236, ((STRING_TABLE.__str108561)|0));
      var $238=(($237)|0)!=0;
      if ($238) { __label__ = 65; break; } else { __label__ = 60; break; }
    case 60: 
      $itr=0;
      __label__ = 61; break;
    case 61: 
      var $241=$itr;
      var $242=(($241)>>>0) < 1;
      if ($242) { __label__ = 62; break; } else { __label__ = 64; break; }
    case 62: 
      var $244=$itr;
      var $245=((_opts_warn+($244<<2))|0);
      HEAP32[(($245)>>2)]=0;
      __label__ = 63; break;
    case 63: 
      var $247=$itr;
      var $248=((($247)+(1))|0);
      $itr=$248;
      __label__ = 61; break;
    case 64: 
      __label__ = 103; break;
    case 65: 
      var $251=HEAP32[(($3)>>2)];
      var $252=(($251)|0);
      var $253=HEAP32[(($252)>>2)];
      var $254=(($253+2)|0);
      var $255=_strcmp($254, ((STRING_TABLE.__str109562)|0));
      var $256=(($255)|0)!=0;
      if ($256) { __label__ = 71; break; } else { __label__ = 66; break; }
    case 66: 
      $itr=0;
      __label__ = 67; break;
    case 67: 
      var $259=$itr;
      var $260=(($259)>>>0) < 1;
      if ($260) { __label__ = 68; break; } else { __label__ = 70; break; }
    case 68: 
      var $262=$itr;
      var $263=((_opts_warn+($262<<2))|0);
      HEAP32[(($263)>>2)]=-1;
      __label__ = 69; break;
    case 69: 
      var $265=$itr;
      var $266=((($265)+(1))|0);
      $itr=$266;
      __label__ = 67; break;
    case 70: 
      __label__ = 103; break;
    case 71: 
      __label__ = 72; break;
    case 72: 
      __label__ = 73; break;
    case 73: 
      __label__ = 74; break;
    case 74: 
      __label__ = 75; break;
    case 75: 
      var $273=HEAP32[(($3)>>2)];
      var $274=(($273)|0);
      var $275=HEAP32[(($274)>>2)];
      var $276=(($275+2)|0);
      var $277=_strncmp($276, ((STRING_TABLE.__str102555)|0), 3);
      var $278=(($277)|0)!=0;
      if ($278) { __label__ = 79; break; } else { __label__ = 76; break; }
    case 76: 
      var $280=HEAP32[(($3)>>2)];
      var $281=(($280)|0);
      var $282=HEAP32[(($281)>>2)];
      var $283=(($282+5)|0);
      var $284=_options_setwarn($283, 0);
      if ($284) { __label__ = 78; break; } else { __label__ = 77; break; }
    case 77: 
      var $286=HEAP32[(($3)>>2)];
      var $287=(($286)|0);
      var $288=HEAP32[(($287)>>2)];
      var $289=(($288+2)|0);
      var $290=_printf(((STRING_TABLE.__str110563)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$289,tempInt));
      $1=0;
      __label__ = 107; break;
    case 78: 
      __label__ = 82; break;
    case 79: 
      var $293=HEAP32[(($3)>>2)];
      var $294=(($293)|0);
      var $295=HEAP32[(($294)>>2)];
      var $296=(($295+2)|0);
      var $297=_options_setwarn($296, 1);
      if ($297) { __label__ = 81; break; } else { __label__ = 80; break; }
    case 80: 
      var $299=HEAP32[(($3)>>2)];
      var $300=(($299)|0);
      var $301=HEAP32[(($300)>>2)];
      var $302=(($301+2)|0);
      var $303=_printf(((STRING_TABLE.__str110563)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$302,tempInt));
      $1=0;
      __label__ = 107; break;
    case 81: 
      __label__ = 82; break;
    case 82: 
      __label__ = 103; break;
    case 83: 
      var $307=_options_witharg($2, $3, $argarg);
      if ($307) { __label__ = 85; break; } else { __label__ = 84; break; }
    case 84: 
      var $309=_printf(((STRING_TABLE.__str111564)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 107; break;
    case 85: 
      var $311=HEAP32[(($argarg)>>2)];
      var $312=_atoi($311);
      HEAP32[((_opts_O)>>2)]=$312;
      __label__ = 103; break;
    case 86: 
      var $314=_options_witharg($2, $3, $argarg);
      if ($314) { __label__ = 88; break; } else { __label__ = 87; break; }
    case 87: 
      var $316=_printf(((STRING_TABLE.__str112565)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 107; break;
    case 88: 
      var $318=HEAP32[(($argarg)>>2)];
      HEAP32[((_opts_output)>>2)]=$318;
      HEAP8[(_opts_output_wasset)]=1;
      __label__ = 103; break;
    case 89: 
      var $320=HEAP32[(($3)>>2)];
      var $321=(($320)|0);
      var $322=HEAP32[(($321)>>2)];
      var $323=(($322+1)|0);
      var $324=HEAP8[($323)];
      var $325=(($324 << 24) >> 24);
      var $326=(($325)|0)==97;
      var $327=$326 ? 1 : 2;
      var $328=(($item+4)|0);
      HEAP32[(($328)>>2)]=$327;
      var $329=_options_witharg($2, $3, $argarg);
      if ($329) { __label__ = 91; break; } else { __label__ = 90; break; }
    case 90: 
      var $331=HEAP32[(($3)>>2)];
      var $332=(($331)|0);
      var $333=HEAP32[(($332)>>2)];
      var $334=(($333+1)|0);
      var $335=HEAP8[($334)];
      var $336=(($335 << 24) >> 24);
      var $337=(($336)|0)==97;
      var $338=$337 ? (((STRING_TABLE.__str114567)|0)) : (((STRING_TABLE.__str115568)|0));
      var $339=_printf(((STRING_TABLE.__str113566)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$338,tempInt));
      $1=0;
      __label__ = 107; break;
    case 91: 
      var $341=HEAP32[(($argarg)>>2)];
      var $342=(($item)|0);
      HEAP32[(($342)>>2)]=$341;
      var $343=(($item)|0);
      var $344=HEAP32[(($343)>>2)];
      var $345=(($item+4)|0);
      var $346=HEAP32[(($345)>>2)];
      var $347=_items_add($344, $346);
      __label__ = 103; break;
    case 92: 
      var $349=HEAP32[(($3)>>2)];
      var $350=(($349)|0);
      var $351=HEAP32[(($350)>>2)];
      var $352=(($351+2)|0);
      var $353=HEAP8[($352)];
      var $354=(($353 << 24) >> 24)!=0;
      if ($354) { __label__ = 94; break; } else { __label__ = 93; break; }
    case 93: 
      $argend=1;
      __label__ = 103; break;
    case 94: 
      var $357=HEAP32[(($3)>>2)];
      var $358=(($357)|0);
      var $359=HEAP32[(($358)>>2)];
      var $360=(($359+2)|0);
      var $361=_strcmp($360, ((STRING_TABLE.__str116569)|0));
      var $362=(($361)|0)!=0;
      if ($362) { __label__ = 96; break; } else { __label__ = 95; break; }
    case 95: 
      var $364=_usage();
      _exit(0);
      throw "Reached an unreachable!"
    case 96: 
      var $366=_options_long_witharg(((STRING_TABLE.__str117570)|0), $2, $3, $argarg);
      if ($366) { __label__ = 97; break; } else { __label__ = 98; break; }
    case 97: 
      var $368=HEAP32[(($argarg)>>2)];
      HEAP32[((_opts_output)>>2)]=$368;
      HEAP8[(_opts_output_wasset)]=1;
      __label__ = 99; break;
    case 98: 
      var $370=HEAP32[(($3)>>2)];
      var $371=(($370)|0);
      var $372=HEAP32[(($371)>>2)];
      var $373=_printf(((STRING_TABLE.__str118571)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$372,tempInt));
      $1=0;
      __label__ = 107; break;
    case 99: 
      __label__ = 100; break;
    case 100: 
      __label__ = 101; break;
    case 101: 
      __label__ = 103; break;
    case 102: 
      var $378=HEAP32[(($3)>>2)];
      var $379=(($378)|0);
      var $380=HEAP32[(($379)>>2)];
      var $381=_printf(((STRING_TABLE.__str118571)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$380,tempInt));
      $1=0;
      __label__ = 107; break;
    case 103: 
      __label__ = 105; break;
    case 104: 
      var $384=HEAP32[(($3)>>2)];
      var $385=(($384)|0);
      var $386=HEAP32[(($385)>>2)];
      var $387=(($item1)|0);
      HEAP32[(($387)>>2)]=$386;
      var $388=(($item1+4)|0);
      HEAP32[(($388)>>2)]=0;
      var $389=(($item1)|0);
      var $390=HEAP32[(($389)>>2)];
      var $391=(($item1+4)|0);
      var $392=HEAP32[(($391)>>2)];
      var $393=_items_add($390, $392);
      __label__ = 105; break;
    case 105: 
      __label__ = 3; break;
    case 106: 
      $1=1;
      __label__ = 107; break;
    case 107: 
      var $397=$1;
      STACKTOP = __stackBase__;
      return $397;
    default: assert(0, "bad label: " + __label__);
  }
}
_options_parse["X"]=1;

function _vec3_mulvv($a_0, $a_1, $a_2, $b_0, $b_1, $b_2) {
  var __stackBase__  = STACKTOP; STACKTOP += 24; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $a=__stackBase__;
  var $b=(__stackBase__)+(12);
  var $1=(($a)|0);
  HEAPF32[(($1)>>2)]=$a_0;
  var $2=(($a+4)|0);
  HEAPF32[(($2)>>2)]=$a_1;
  var $3=(($a+8)|0);
  HEAPF32[(($3)>>2)]=$a_2;
  var $4=(($b)|0);
  HEAPF32[(($4)>>2)]=$b_0;
  var $5=(($b+4)|0);
  HEAPF32[(($5)>>2)]=$b_1;
  var $6=(($b+8)|0);
  HEAPF32[(($6)>>2)]=$b_2;
  var $7=(($a)|0);
  var $8=HEAPF32[(($7)>>2)];
  var $9=(($b)|0);
  var $10=HEAPF32[(($9)>>2)];
  var $11=($8)*($10);
  var $12=(($a+4)|0);
  var $13=HEAPF32[(($12)>>2)];
  var $14=(($b+4)|0);
  var $15=HEAPF32[(($14)>>2)];
  var $16=($13)*($15);
  var $17=($11)+($16);
  var $18=(($a+8)|0);
  var $19=HEAPF32[(($18)>>2)];
  var $20=(($b+8)|0);
  var $21=HEAPF32[(($20)>>2)];
  var $22=($19)*($21);
  var $23=($17)+($22);
  STACKTOP = __stackBase__;
  return $23;
}


function _options_long_witharg_all($optname, $argc_, $argv_, $out, $ds, $split) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $7;
      var $argc;
      var $argv;
      var $len;
      $2=$optname;
      $3=$argc_;
      $4=$argv_;
      $5=$out;
      $6=$ds;
      var $8=(($split)&1);
      $7=$8;
      var $9=$3;
      var $10=HEAP32[(($9)>>2)];
      $argc=$10;
      var $11=$4;
      var $12=HEAP32[(($11)>>2)];
      $argv=$12;
      var $13=$2;
      var $14=_strlen($13);
      $len=$14;
      var $15=$argv;
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$6;
      var $19=(($17+$18)|0);
      var $20=$2;
      var $21=$len;
      var $22=_strncmp($19, $20, $21);
      var $23=(($22)|0)!=0;
      if ($23) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=0;
      __label__ = 10; break;
    case 4: 
      var $26=$6;
      var $27=$len;
      var $28=((($26)+($27))|0);
      var $29=$argv;
      var $30=(($29)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($31+$28)|0);
      var $33=HEAP8[($32)];
      var $34=(($33 << 24) >> 24);
      var $35=(($34)|0)==61;
      if ($35) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $37=$argv;
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$6;
      var $41=(($39+$40)|0);
      var $42=$len;
      var $43=(($41+$42)|0);
      var $44=(($43+1)|0);
      var $45=$5;
      HEAP32[(($45)>>2)]=$44;
      $1=1;
      __label__ = 10; break;
    case 6: 
      var $47=$7;
      var $48=(($47) & 1);
      if ($48) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $50=$argc;
      var $51=$6;
      var $52=(($50)|0) < (($51)|0);
      if ($52) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      $1=0;
      __label__ = 10; break;
    case 9: 
      var $55=$argv;
      var $56=(($55+4)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=$5;
      HEAP32[(($58)>>2)]=$57;
      var $59=$3;
      var $60=HEAP32[(($59)>>2)];
      var $61=((($60)-(1))|0);
      HEAP32[(($59)>>2)]=$61;
      var $62=$4;
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63+4)|0);
      HEAP32[(($62)>>2)]=$64;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $66=$1;
      ;
      return $66;
    default: assert(0, "bad label: " + __label__);
  }
}
_options_long_witharg_all["X"]=1;

function _options_setflag_all($name, $on, $flags, $list, $listsize) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $6;
      var $i;
      var $lb;
      $2=$name;
      var $7=(($on)&1);
      $3=$7;
      $4=$flags;
      $5=$list;
      $6=$listsize;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $9=$i;
      var $10=$6;
      var $11=(($9)>>>0) < (($10)>>>0);
      if ($11) { __label__ = 4; break; } else { __label__ = 11; break; }
    case 4: 
      var $13=$2;
      var $14=$i;
      var $15=$5;
      var $16=(($15+($14<<3))|0);
      var $17=(($16)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=_strcmp($13, $18);
      var $20=(($19)|0)!=0;
      if ($20) { __label__ = 9; break; } else { __label__ = 5; break; }
    case 5: 
      var $22=$i;
      var $23=$5;
      var $24=(($23+($22<<3))|0);
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      $lb=$26;
      var $27=$3;
      var $28=(($27) & 1);
      if ($28) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $30=$lb;
      var $31=1 << $30;
      var $32=$4;
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=$34 | $31;
      HEAP32[(($33)>>2)]=$35;
      __label__ = 8; break;
    case 7: 
      var $37=$lb;
      var $38=1 << $37;
      var $39=$38 ^ -1;
      var $40=$4;
      var $41=(($40)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$42 & $39;
      HEAP32[(($41)>>2)]=$43;
      __label__ = 8; break;
    case 8: 
      $1=1;
      __label__ = 12; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $47=$i;
      var $48=((($47)+(1))|0);
      $i=$48;
      __label__ = 3; break;
    case 11: 
      $1=0;
      __label__ = 12; break;
    case 12: 
      var $51=$1;
      ;
      return $51;
    default: assert(0, "bad label: " + __label__);
  }
}
_options_setflag_all["X"]=1;

function _parser_t_globals_add($self, $f_0, $f_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $f=__stackBase__;
      var $reall;
      $2=$self;
      var $3=(($f)|0);
      HEAP32[(($3)>>2)]=$f_0;
      var $4=(($f+4)|0);
      HEAP32[(($4)>>2)]=$f_1;
      var $5=$2;
      var $6=(($5+12)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=(($8+16)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)|0)==(($10)|0);
      if ($11) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $13=$2;
      var $14=(($13+16)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $18=$2;
      var $19=(($18+16)|0);
      HEAP32[(($19)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $21=$2;
      var $22=(($21+16)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=((($23<<1))|0);
      HEAP32[(($22)>>2)]=$24;
      __label__ = 6; break;
    case 6: 
      var $26=$2;
      var $27=(($26+16)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=((($28<<3))|0);
      var $30=_util_memory_a($29, 42, ((STRING_TABLE.__str572)|0));
      var $31=$30;
      $reall=$31;
      var $32=$reall;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $36=$reall;
      var $37=$36;
      var $38=$2;
      var $39=(($38+8)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      var $42=$2;
      var $43=(($42+12)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44<<3))|0);
      assert($45 % 1 === 0, 'memcpy given ' + $45 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $41, $45, 4);
      var $46=$2;
      var $47=(($46+8)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      _util_memory_d($49, 42, ((STRING_TABLE.__str572)|0));
      var $50=$reall;
      var $51=$2;
      var $52=(($51+8)|0);
      HEAP32[(($52)>>2)]=$50;
      __label__ = 9; break;
    case 9: 
      var $54=$2;
      var $55=(($54+12)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+8)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<3))|0);
      var $62=$61;
      var $63=$f;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($62)>>2)]=HEAP32[(($63)>>2)];HEAP32[((($62)+(4))>>2)]=HEAP32[((($63)+(4))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_globals_add["X"]=1;

function _parser_t_fields_add($self, $f_0, $f_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $f=__stackBase__;
      var $reall;
      $2=$self;
      var $3=(($f)|0);
      HEAP32[(($3)>>2)]=$f_0;
      var $4=(($f+4)|0);
      HEAP32[(($4)>>2)]=$f_1;
      var $5=$2;
      var $6=(($5+24)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=(($8+28)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)|0)==(($10)|0);
      if ($11) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $13=$2;
      var $14=(($13+28)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $18=$2;
      var $19=(($18+28)|0);
      HEAP32[(($19)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $21=$2;
      var $22=(($21+28)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=((($23<<1))|0);
      HEAP32[(($22)>>2)]=$24;
      __label__ = 6; break;
    case 6: 
      var $26=$2;
      var $27=(($26+28)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=((($28<<3))|0);
      var $30=_util_memory_a($29, 43, ((STRING_TABLE.__str572)|0));
      var $31=$30;
      $reall=$31;
      var $32=$reall;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $36=$reall;
      var $37=$36;
      var $38=$2;
      var $39=(($38+20)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      var $42=$2;
      var $43=(($42+24)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44<<3))|0);
      assert($45 % 1 === 0, 'memcpy given ' + $45 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $41, $45, 4);
      var $46=$2;
      var $47=(($46+20)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      _util_memory_d($49, 43, ((STRING_TABLE.__str572)|0));
      var $50=$reall;
      var $51=$2;
      var $52=(($51+20)|0);
      HEAP32[(($52)>>2)]=$50;
      __label__ = 9; break;
    case 9: 
      var $54=$2;
      var $55=(($54+24)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+20)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<3))|0);
      var $62=$61;
      var $63=$f;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($62)>>2)]=HEAP32[(($63)>>2)];HEAP32[((($62)+(4))>>2)]=HEAP32[((($63)+(4))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_fields_add["X"]=1;

function _parser_t_imm_float_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+48)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+52)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+52)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+52)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+52)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+52)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 44, ((STRING_TABLE.__str572)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+44)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+48)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+44)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 44, ((STRING_TABLE.__str572)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+44)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+48)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+44)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_imm_float_add["X"]=1;

function _parser_t_imm_string_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+60)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+64)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+64)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+64)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+64)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+64)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 45, ((STRING_TABLE.__str572)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+56)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+60)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+56)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 45, ((STRING_TABLE.__str572)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+56)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+60)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+56)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_imm_string_add["X"]=1;

function _parser_t_imm_vector_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+72)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+76)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+76)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+76)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+76)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+76)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 46, ((STRING_TABLE.__str572)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+68)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+72)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+68)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 46, ((STRING_TABLE.__str572)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+68)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+72)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+68)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_imm_vector_add["X"]=1;

function _parser_t_locals_add($self, $f_0, $f_1) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $f=__stackBase__;
      var $reall;
      $2=$self;
      var $3=(($f)|0);
      HEAP32[(($3)>>2)]=$f_0;
      var $4=(($f+4)|0);
      HEAP32[(($4)>>2)]=$f_1;
      var $5=$2;
      var $6=(($5+104)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=$2;
      var $9=(($8+108)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)|0)==(($10)|0);
      if ($11) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $13=$2;
      var $14=(($13+108)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $18=$2;
      var $19=(($18+108)|0);
      HEAP32[(($19)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $21=$2;
      var $22=(($21+108)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=((($23<<1))|0);
      HEAP32[(($22)>>2)]=$24;
      __label__ = 6; break;
    case 6: 
      var $26=$2;
      var $27=(($26+108)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=((($28<<3))|0);
      var $30=_util_memory_a($29, 47, ((STRING_TABLE.__str572)|0));
      var $31=$30;
      $reall=$31;
      var $32=$reall;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $36=$reall;
      var $37=$36;
      var $38=$2;
      var $39=(($38+100)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      var $42=$2;
      var $43=(($42+104)|0);
      var $44=HEAP32[(($43)>>2)];
      var $45=((($44<<3))|0);
      assert($45 % 1 === 0, 'memcpy given ' + $45 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($37, $41, $45, 4);
      var $46=$2;
      var $47=(($46+100)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=$48;
      _util_memory_d($49, 47, ((STRING_TABLE.__str572)|0));
      var $50=$reall;
      var $51=$2;
      var $52=(($51+100)|0);
      HEAP32[(($52)>>2)]=$50;
      __label__ = 9; break;
    case 9: 
      var $54=$2;
      var $55=(($54+104)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+100)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<3))|0);
      var $62=$61;
      var $63=$f;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($62)>>2)]=HEAP32[(($63)>>2)];HEAP32[((($62)+(4))>>2)]=HEAP32[((($63)+(4))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $65=$1;
      STACKTOP = __stackBase__;
      return $65;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_locals_add["X"]=1;

function _parser_t_functions_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+36)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+40)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+40)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+40)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+40)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+40)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 48, ((STRING_TABLE.__str572)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37+32)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+36)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45+32)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 48, ((STRING_TABLE.__str572)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50+32)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+36)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58+32)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_t_functions_add["X"]=1;

function _vec3_add($agg_result, $a_0, $a_1, $a_2, $b_0, $b_1, $b_2) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $a=__stackBase__;
  var $b=(__stackBase__)+(12);
  var $out=(__stackBase__)+(24);
  var $1=(($a)|0);
  HEAPF32[(($1)>>2)]=$a_0;
  var $2=(($a+4)|0);
  HEAPF32[(($2)>>2)]=$a_1;
  var $3=(($a+8)|0);
  HEAPF32[(($3)>>2)]=$a_2;
  var $4=(($b)|0);
  HEAPF32[(($4)>>2)]=$b_0;
  var $5=(($b+4)|0);
  HEAPF32[(($5)>>2)]=$b_1;
  var $6=(($b+8)|0);
  HEAPF32[(($6)>>2)]=$b_2;
  var $7=(($a)|0);
  var $8=HEAPF32[(($7)>>2)];
  var $9=(($b)|0);
  var $10=HEAPF32[(($9)>>2)];
  var $11=($8)+($10);
  var $12=(($out)|0);
  HEAPF32[(($12)>>2)]=$11;
  var $13=(($a+4)|0);
  var $14=HEAPF32[(($13)>>2)];
  var $15=(($b+4)|0);
  var $16=HEAPF32[(($15)>>2)];
  var $17=($14)+($16);
  var $18=(($out+4)|0);
  HEAPF32[(($18)>>2)]=$17;
  var $19=(($a+8)|0);
  var $20=HEAPF32[(($19)>>2)];
  var $21=(($b+8)|0);
  var $22=HEAPF32[(($21)>>2)];
  var $23=($20)+($22);
  var $24=(($out+8)|0);
  HEAPF32[(($24)>>2)]=$23;
  var $25=$agg_result;
  var $26=$out;
  assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($25)>>2)]=HEAP32[(($26)>>2)];HEAP32[((($25)+(4))>>2)]=HEAP32[((($26)+(4))>>2)];HEAP32[((($25)+(8))>>2)]=HEAP32[((($26)+(8))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _vec3_sub($agg_result, $a_0, $a_1, $a_2, $b_0, $b_1, $b_2) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $a=__stackBase__;
  var $b=(__stackBase__)+(12);
  var $out=(__stackBase__)+(24);
  var $1=(($a)|0);
  HEAPF32[(($1)>>2)]=$a_0;
  var $2=(($a+4)|0);
  HEAPF32[(($2)>>2)]=$a_1;
  var $3=(($a+8)|0);
  HEAPF32[(($3)>>2)]=$a_2;
  var $4=(($b)|0);
  HEAPF32[(($4)>>2)]=$b_0;
  var $5=(($b+4)|0);
  HEAPF32[(($5)>>2)]=$b_1;
  var $6=(($b+8)|0);
  HEAPF32[(($6)>>2)]=$b_2;
  var $7=(($a)|0);
  var $8=HEAPF32[(($7)>>2)];
  var $9=(($b)|0);
  var $10=HEAPF32[(($9)>>2)];
  var $11=($8)-($10);
  var $12=(($out)|0);
  HEAPF32[(($12)>>2)]=$11;
  var $13=(($a+4)|0);
  var $14=HEAPF32[(($13)>>2)];
  var $15=(($b+4)|0);
  var $16=HEAPF32[(($15)>>2)];
  var $17=($14)-($16);
  var $18=(($out+4)|0);
  HEAPF32[(($18)>>2)]=$17;
  var $19=(($a+8)|0);
  var $20=HEAPF32[(($19)>>2)];
  var $21=(($b+8)|0);
  var $22=HEAPF32[(($21)>>2)];
  var $23=($20)-($22);
  var $24=(($out+8)|0);
  HEAPF32[(($24)>>2)]=$23;
  var $25=$agg_result;
  var $26=$out;
  assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($25)>>2)]=HEAP32[(($26)>>2)];HEAP32[((($25)+(4))>>2)]=HEAP32[((($26)+(4))>>2)];HEAP32[((($25)+(8))>>2)]=HEAP32[((($26)+(8))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _vec3_mulvf($agg_result, $a_0, $a_1, $a_2, $b) {
  var __stackBase__  = STACKTOP; STACKTOP += 24; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $a=__stackBase__;
  var $1;
  var $out=(__stackBase__)+(12);
  var $2=(($a)|0);
  HEAPF32[(($2)>>2)]=$a_0;
  var $3=(($a+4)|0);
  HEAPF32[(($3)>>2)]=$a_1;
  var $4=(($a+8)|0);
  HEAPF32[(($4)>>2)]=$a_2;
  $1=$b;
  var $5=(($a)|0);
  var $6=HEAPF32[(($5)>>2)];
  var $7=$1;
  var $8=($6)*($7);
  var $9=(($out)|0);
  HEAPF32[(($9)>>2)]=$8;
  var $10=(($a+4)|0);
  var $11=HEAPF32[(($10)>>2)];
  var $12=$1;
  var $13=($11)*($12);
  var $14=(($out+4)|0);
  HEAPF32[(($14)>>2)]=$13;
  var $15=(($a+8)|0);
  var $16=HEAPF32[(($15)>>2)];
  var $17=$1;
  var $18=($16)*($17);
  var $19=(($out+8)|0);
  HEAPF32[(($19)>>2)]=$18;
  var $20=$agg_result;
  var $21=$out;
  assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($20)>>2)]=HEAP32[(($21)>>2)];HEAP32[((($20)+(4))>>2)]=HEAP32[((($21)+(4))>>2)];HEAP32[((($20)+(8))>>2)]=HEAP32[((($21)+(8))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _parser_next($parser) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$parser;
      var $3=$2;
      var $4=(($3)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=_lex_do($5);
      var $7=$2;
      var $8=(($7+4)|0);
      HEAP32[(($8)>>2)]=$6;
      var $9=$2;
      var $10=(($9+4)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($11)|0)==141;
      if ($12) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      $1=1;
      __label__ = 7; break;
    case 4: 
      var $15=$2;
      var $16=(($15+4)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17)|0) >= 142;
      if ($18) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $20=$2;
      _parseerror($20, ((STRING_TABLE.__str1573)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 7; break;
    case 6: 
      $1=1;
      __label__ = 7; break;
    case 7: 
      var $23=$1;
      STACKTOP = __stackBase__;
      return $23;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parseerror($parser, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  var $2;
  var $ap=__stackBase__;
  $1=$parser;
  $2=$fmt;
  var $3=$1;
  var $4=(($3+116)|0);
  var $5=HEAP32[(($4)>>2)];
  var $6=((($5)+(1))|0);
  HEAP32[(($4)>>2)]=$6;
  var $7=$ap;
  HEAP32[(($7)>>2)]=arguments[_parseerror.length];
  var $8=$1;
  var $9=(($8)|0);
  var $10=HEAP32[(($9)>>2)];
  var $11=(($10+292)|0);
  var $12=(($11+28)|0);
  var $13=(($12)|0);
  var $14=HEAP32[(($13)>>2)];
  var $15=$1;
  var $16=(($15)|0);
  var $17=HEAP32[(($16)>>2)];
  var $18=(($17+292)|0);
  var $19=(($18+28)|0);
  var $20=(($19+4)|0);
  var $21=HEAP32[(($20)>>2)];
  var $22=$2;
  var $23=HEAP32[(($ap)>>2)];
  _vprintmsg(2, $14, $21, ((STRING_TABLE.__str4576)|0), $22, $23);
  var $24=$ap;
  ;
  STACKTOP = __stackBase__;
  return;
}


function _paramlist_t_p_add($self, $f) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $reall;
      $2=$self;
      $3=$f;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=$2;
      var $8=(($7+8)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($6)|0)==(($9)|0);
      if ($10) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $12=$2;
      var $13=(($12+8)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14)|0)!=0;
      if ($15) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $17=$2;
      var $18=(($17+8)|0);
      HEAP32[(($18)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $20=$2;
      var $21=(($20+8)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=((($22<<1))|0);
      HEAP32[(($21)>>2)]=$23;
      __label__ = 6; break;
    case 6: 
      var $25=$2;
      var $26=(($25+8)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=((($27<<2))|0);
      var $29=_util_memory_a($28, 312, ((STRING_TABLE.__str572)|0));
      var $30=$29;
      $reall=$30;
      var $31=$reall;
      var $32=(($31)|0)!=0;
      if ($32) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $35=$reall;
      var $36=$35;
      var $37=$2;
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$39;
      var $41=$2;
      var $42=(($41+4)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=((($43<<2))|0);
      assert($44 % 1 === 0, 'memcpy given ' + $44 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($36, $40, $44, 4);
      var $45=$2;
      var $46=(($45)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=$47;
      _util_memory_d($48, 312, ((STRING_TABLE.__str572)|0));
      var $49=$reall;
      var $50=$2;
      var $51=(($50)|0);
      HEAP32[(($51)>>2)]=$49;
      __label__ = 9; break;
    case 9: 
      var $53=$3;
      var $54=$2;
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=((($56)+(1))|0);
      HEAP32[(($55)>>2)]=$57;
      var $58=$2;
      var $59=(($58)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($60+($56<<2))|0);
      HEAP32[(($61)>>2)]=$53;
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      ;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_paramlist_t_p_add["X"]=1;

function _shunt_out_add($self, $f) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $f; $f = STACKTOP;STACKTOP += 28;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");HEAP32[(($f)>>2)]=HEAP32[((tempParam)>>2)];HEAP32[((($f)+(4))>>2)]=HEAP32[(((tempParam)+(4))>>2)];HEAP32[((($f)+(8))>>2)]=HEAP32[(((tempParam)+(8))>>2)];HEAP32[((($f)+(12))>>2)]=HEAP32[(((tempParam)+(12))>>2)];HEAP32[((($f)+(16))>>2)]=HEAP32[(((tempParam)+(16))>>2)];HEAP32[((($f)+(20))>>2)]=HEAP32[(((tempParam)+(20))>>2)];HEAP32[((($f)+(24))>>2)]=HEAP32[(((tempParam)+(24))>>2)];
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $reall;
      $2=$self;
      var $3=$2;
      var $4=(($3+4)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$2;
      var $7=(($6+8)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)|0)==(($8)|0);
      if ($9) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $11=$2;
      var $12=(($11+8)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $16=$2;
      var $17=(($16+8)|0);
      HEAP32[(($17)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $19=$2;
      var $20=(($19+8)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=((($21<<1))|0);
      HEAP32[(($20)>>2)]=$22;
      __label__ = 6; break;
    case 6: 
      var $24=$2;
      var $25=(($24+8)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=((($26)*(28))|0);
      var $28=_util_memory_a($27, 448, ((STRING_TABLE.__str572)|0));
      var $29=$28;
      $reall=$29;
      var $30=$reall;
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $34=$reall;
      var $35=$34;
      var $36=$2;
      var $37=(($36)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=$38;
      var $40=$2;
      var $41=(($40+4)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=((($42)*(28))|0);
      assert($43 % 1 === 0, 'memcpy given ' + $43 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($35, $39, $43, 4);
      var $44=$2;
      var $45=(($44)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$46;
      _util_memory_d($47, 448, ((STRING_TABLE.__str572)|0));
      var $48=$reall;
      var $49=$2;
      var $50=(($49)|0);
      HEAP32[(($50)>>2)]=$48;
      __label__ = 9; break;
    case 9: 
      var $52=$2;
      var $53=(($52+4)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=((($54)+(1))|0);
      HEAP32[(($53)>>2)]=$55;
      var $56=$2;
      var $57=(($56)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58+($54)*(28))|0);
      var $60=$59;
      var $61=$f;
      assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($60)>>2)]=HEAP32[(($61)>>2)];HEAP32[((($60)+(4))>>2)]=HEAP32[((($61)+(4))>>2)];HEAP32[((($60)+(8))>>2)]=HEAP32[((($61)+(8))>>2)];HEAP32[((($60)+(12))>>2)]=HEAP32[((($61)+(12))>>2)];HEAP32[((($60)+(16))>>2)]=HEAP32[((($61)+(16))>>2)];HEAP32[((($60)+(20))>>2)]=HEAP32[((($61)+(20))>>2)];HEAP32[((($60)+(24))>>2)]=HEAP32[((($61)+(24))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      STACKTOP = __stackBase__;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_shunt_out_add["X"]=1;

function _shunt_ops_add($self, $f) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var tempParam = $f; $f = STACKTOP;STACKTOP += 28;assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack");HEAP32[(($f)>>2)]=HEAP32[((tempParam)>>2)];HEAP32[((($f)+(4))>>2)]=HEAP32[(((tempParam)+(4))>>2)];HEAP32[((($f)+(8))>>2)]=HEAP32[(((tempParam)+(8))>>2)];HEAP32[((($f)+(12))>>2)]=HEAP32[(((tempParam)+(12))>>2)];HEAP32[((($f)+(16))>>2)]=HEAP32[(((tempParam)+(16))>>2)];HEAP32[((($f)+(20))>>2)]=HEAP32[(((tempParam)+(20))>>2)];HEAP32[((($f)+(24))>>2)]=HEAP32[(((tempParam)+(24))>>2)];
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $reall;
      $2=$self;
      var $3=$2;
      var $4=(($3+16)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=$2;
      var $7=(($6+20)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)|0)==(($8)|0);
      if ($9) { __label__ = 3; break; } else { __label__ = 9; break; }
    case 3: 
      var $11=$2;
      var $12=(($11+20)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $16=$2;
      var $17=(($16+20)|0);
      HEAP32[(($17)>>2)]=16;
      __label__ = 6; break;
    case 5: 
      var $19=$2;
      var $20=(($19+20)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=((($21<<1))|0);
      HEAP32[(($20)>>2)]=$22;
      __label__ = 6; break;
    case 6: 
      var $24=$2;
      var $25=(($24+20)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=((($26)*(28))|0);
      var $28=_util_memory_a($27, 449, ((STRING_TABLE.__str572)|0));
      var $29=$28;
      $reall=$29;
      var $30=$reall;
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      $1=0;
      __label__ = 10; break;
    case 8: 
      var $34=$reall;
      var $35=$34;
      var $36=$2;
      var $37=(($36+12)|0);
      var $38=HEAP32[(($37)>>2)];
      var $39=$38;
      var $40=$2;
      var $41=(($40+16)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=((($42)*(28))|0);
      assert($43 % 1 === 0, 'memcpy given ' + $43 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($35, $39, $43, 4);
      var $44=$2;
      var $45=(($44+12)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=$46;
      _util_memory_d($47, 449, ((STRING_TABLE.__str572)|0));
      var $48=$reall;
      var $49=$2;
      var $50=(($49+12)|0);
      HEAP32[(($50)>>2)]=$48;
      __label__ = 9; break;
    case 9: 
      var $52=$2;
      var $53=(($52+16)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=((($54)+(1))|0);
      HEAP32[(($53)>>2)]=$55;
      var $56=$2;
      var $57=(($56+12)|0);
      var $58=HEAP32[(($57)>>2)];
      var $59=(($58+($54)*(28))|0);
      var $60=$59;
      var $61=$f;
      assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($60)>>2)]=HEAP32[(($61)>>2)];HEAP32[((($60)+(4))>>2)]=HEAP32[((($61)+(4))>>2)];HEAP32[((($60)+(8))>>2)]=HEAP32[((($61)+(8))>>2)];HEAP32[((($60)+(12))>>2)]=HEAP32[((($61)+(12))>>2)];HEAP32[((($60)+(16))>>2)]=HEAP32[((($61)+(16))>>2)];HEAP32[((($60)+(20))>>2)]=HEAP32[((($61)+(20))>>2)];HEAP32[((($60)+(24))>>2)]=HEAP32[((($61)+(24))>>2)];
      $1=1;
      __label__ = 10; break;
    case 10: 
      var $63=$1;
      STACKTOP = __stackBase__;
      return $63;
    default: assert(0, "bad label: " + __label__);
  }
}
_shunt_ops_add["X"]=1;

function _parser_init() {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2=_util_memory_a(124, 2835, ((STRING_TABLE.__str572)|0));
      var $3=$2;
      HEAP32[((_parser)>>2)]=$3;
      var $4=HEAP32[((_parser)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $8=HEAP32[((_parser)>>2)];
      var $9=$8;
      for (var $$dest = $9>>2, $$stop = $$dest + 31; $$dest < $$stop; $$dest++) {
        HEAP32[$$dest] = 0
      };
      $1=1;
      __label__ = 5; break;
    case 5: 
      var $11=$1;
      ;
      return $11;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_compile() {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2=HEAP32[((_parser)>>2)];
      var $3=(($2)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4+328)|0);
      var $6=(($5)|0);
      HEAP8[($6)]=1;
      var $7=HEAP32[((_parser)>>2)];
      var $8=_parser_next($7);
      if ($8) { __label__ = 3; break; } else { __label__ = 16; break; }
    case 3: 
      __label__ = 4; break;
    case 4: 
      var $11=HEAP32[((_parser)>>2)];
      var $12=(($11+4)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=141;
      if ($14) { __label__ = 5; break; } else { var $21 = 0;__label__ = 6; break; }
    case 5: 
      var $16=HEAP32[((_parser)>>2)];
      var $17=(($16+4)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0) < 142;
      var $21 = $19;__label__ = 6; break;
    case 6: 
      var $21;
      if ($21) { __label__ = 7; break; } else { __label__ = 15; break; }
    case 7: 
      var $23=HEAP32[((_parser)>>2)];
      var $24=_parser_global_statement($23);
      if ($24) { __label__ = 14; break; } else { __label__ = 8; break; }
    case 8: 
      var $26=HEAP32[((_parser)>>2)];
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)==141;
      if ($29) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $31=HEAP32[((_parser)>>2)];
      _parseerror($31, ((STRING_TABLE.__str2574)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 13; break;
    case 10: 
      var $33=HEAP32[((_parser)>>2)];
      var $34=(($33+116)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)!=0;
      if ($36) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      var $38=HEAP32[((_parser)>>2)];
      _parseerror($38, ((STRING_TABLE.__str3575)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $41=HEAP32[((_parser)>>2)];
      var $42=(($41)|0);
      var $43=HEAP32[(($42)>>2)];
      _lex_close($43);
      var $44=HEAP32[((_parser)>>2)];
      var $45=(($44)|0);
      HEAP32[(($45)>>2)]=0;
      $1=0;
      __label__ = 18; break;
    case 14: 
      __label__ = 4; break;
    case 15: 
      __label__ = 17; break;
    case 16: 
      var $49=HEAP32[((_parser)>>2)];
      _parseerror($49, ((STRING_TABLE.__str4576)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $50=HEAP32[((_parser)>>2)];
      var $51=(($50)|0);
      var $52=HEAP32[(($51)>>2)];
      _lex_close($52);
      var $53=HEAP32[((_parser)>>2)];
      var $54=(($53)|0);
      HEAP32[(($54)>>2)]=0;
      $1=0;
      __label__ = 18; break;
    case 17: 
      var $56=HEAP32[((_parser)>>2)];
      var $57=(($56)|0);
      var $58=HEAP32[(($57)>>2)];
      _lex_close($58);
      var $59=HEAP32[((_parser)>>2)];
      var $60=(($59)|0);
      HEAP32[(($60)>>2)]=0;
      var $61=HEAP32[((_parser)>>2)];
      var $62=(($61+116)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63)|0)!=0;
      var $65=$64 ^ 1;
      $1=$65;
      __label__ = 18; break;
    case 18: 
      var $67=$1;
      STACKTOP = __stackBase__;
      return $67;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_compile["X"]=1;

function _parser_global_statement($parser) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$parser;
      var $3=$2;
      var $4=(($3+4)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)==130;
      if ($6) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $8=$2;
      var $9=(($8+4)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($10)|0)==46;
      if ($11) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $13=$2;
      var $14=_parse_variable($13, 0);
      $1=$14;
      __label__ = 15; break;
    case 5: 
      var $16=$2;
      var $17=(($16+4)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18)|0)==132;
      if ($19) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      $1=0;
      __label__ = 15; break;
    case 7: 
      var $22=$2;
      var $23=(($22+4)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24)|0)==36;
      if ($25) { __label__ = 8; break; } else { __label__ = 11; break; }
    case 8: 
      var $27=$2;
      var $28=_parser_next($27);
      if ($28) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $30=$2;
      _parseerror($30, ((STRING_TABLE.__str4576)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 15; break;
    case 10: 
      __label__ = 12; break;
    case 11: 
      var $33=$2;
      var $34=$2;
      var $35=(($34)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36+292)|0);
      var $38=(($37+4)|0);
      var $39=HEAP32[(($38)>>2)];
      _parseerror($33, ((STRING_TABLE.__str29601)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$39,tempInt));
      $1=0;
      __label__ = 15; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      $1=1;
      __label__ = 15; break;
    case 15: 
      var $44=$1;
      STACKTOP = __stackBase__;
      return $44;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_global_statement["X"]=1;

function _parser_compile_file($filename) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      $2=$filename;
      var $3=$2;
      var $4=_lex_open($3);
      var $5=HEAP32[((_parser)>>2)];
      var $6=(($5)|0);
      HEAP32[(($6)>>2)]=$4;
      var $7=HEAP32[((_parser)>>2)];
      var $8=(($7)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $12=$2;
      var $13=_printf(((STRING_TABLE.__str5577)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$12,tempInt));
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $15=_parser_compile();
      $1=$15;
      __label__ = 5; break;
    case 5: 
      var $17=$1;
      STACKTOP = __stackBase__;
      return $17;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_compile_string($name, $str) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      $2=$name;
      $3=$str;
      var $4=$3;
      var $5=$3;
      var $6=_strlen($5);
      var $7=$2;
      var $8=_lex_open_string($4, $6, $7);
      var $9=HEAP32[((_parser)>>2)];
      var $10=(($9)|0);
      HEAP32[(($10)>>2)]=$8;
      var $11=HEAP32[((_parser)>>2)];
      var $12=(($11)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $16=$2;
      var $17=_printf(((STRING_TABLE.__str6578)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$16,tempInt));
      $1=0;
      __label__ = 5; break;
    case 4: 
      var $19=_parser_compile();
      $1=$19;
      __label__ = 5; break;
    case 5: 
      var $21=$1;
      STACKTOP = __stackBase__;
      return $21;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_cleanup() {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $i;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $2=$i;
      var $3=HEAP32[((_parser)>>2)];
      var $4=(($3+36)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($2)>>>0) < (($5)>>>0);
      if ($6) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $8=$i;
      var $9=HEAP32[((_parser)>>2)];
      var $10=(($9+32)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($11+($8<<2))|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$13;
      var $15=$14;
      var $16=(($15+8)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$i;
      var $19=HEAP32[((_parser)>>2)];
      var $20=(($19+32)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+($18<<2))|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$23;
      FUNCTION_TABLE[$17]($24);
      __label__ = 5; break;
    case 5: 
      var $26=$i;
      var $27=((($26)+(1))|0);
      $i=$27;
      __label__ = 3; break;
    case 6: 
      $i=0;
      __label__ = 7; break;
    case 7: 
      var $30=$i;
      var $31=HEAP32[((_parser)>>2)];
      var $32=(($31+72)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($30)>>>0) < (($33)>>>0);
      if ($34) { __label__ = 8; break; } else { __label__ = 10; break; }
    case 8: 
      var $36=$i;
      var $37=HEAP32[((_parser)>>2)];
      var $38=(($37+68)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($39+($36<<2))|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=$41;
      var $43=$42;
      var $44=(($43+8)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$i;
      var $47=HEAP32[((_parser)>>2)];
      var $48=(($47+68)|0);
      var $49=HEAP32[(($48)>>2)];
      var $50=(($49+($46<<2))|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=$51;
      FUNCTION_TABLE[$45]($52);
      __label__ = 9; break;
    case 9: 
      var $54=$i;
      var $55=((($54)+(1))|0);
      $i=$55;
      __label__ = 7; break;
    case 10: 
      $i=0;
      __label__ = 11; break;
    case 11: 
      var $58=$i;
      var $59=HEAP32[((_parser)>>2)];
      var $60=(($59+60)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($58)>>>0) < (($61)>>>0);
      if ($62) { __label__ = 12; break; } else { __label__ = 14; break; }
    case 12: 
      var $64=$i;
      var $65=HEAP32[((_parser)>>2)];
      var $66=(($65+56)|0);
      var $67=HEAP32[(($66)>>2)];
      var $68=(($67+($64<<2))|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=$69;
      var $71=$70;
      var $72=(($71+8)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=$i;
      var $75=HEAP32[((_parser)>>2)];
      var $76=(($75+56)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=(($77+($74<<2))|0);
      var $79=HEAP32[(($78)>>2)];
      var $80=$79;
      FUNCTION_TABLE[$73]($80);
      __label__ = 13; break;
    case 13: 
      var $82=$i;
      var $83=((($82)+(1))|0);
      $i=$83;
      __label__ = 11; break;
    case 14: 
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $86=$i;
      var $87=HEAP32[((_parser)>>2)];
      var $88=(($87+48)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($86)>>>0) < (($89)>>>0);
      if ($90) { __label__ = 16; break; } else { __label__ = 18; break; }
    case 16: 
      var $92=$i;
      var $93=HEAP32[((_parser)>>2)];
      var $94=(($93+44)|0);
      var $95=HEAP32[(($94)>>2)];
      var $96=(($95+($92<<2))|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=$97;
      var $99=$98;
      var $100=(($99+8)|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=$i;
      var $103=HEAP32[((_parser)>>2)];
      var $104=(($103+44)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=(($105+($102<<2))|0);
      var $107=HEAP32[(($106)>>2)];
      var $108=$107;
      FUNCTION_TABLE[$101]($108);
      __label__ = 17; break;
    case 17: 
      var $110=$i;
      var $111=((($110)+(1))|0);
      $i=$111;
      __label__ = 15; break;
    case 18: 
      $i=0;
      __label__ = 19; break;
    case 19: 
      var $114=$i;
      var $115=HEAP32[((_parser)>>2)];
      var $116=(($115+24)|0);
      var $117=HEAP32[(($116)>>2)];
      var $118=(($114)>>>0) < (($117)>>>0);
      if ($118) { __label__ = 20; break; } else { __label__ = 22; break; }
    case 20: 
      var $120=$i;
      var $121=HEAP32[((_parser)>>2)];
      var $122=(($121+20)|0);
      var $123=HEAP32[(($122)>>2)];
      var $124=(($123+($120<<3))|0);
      var $125=(($124+4)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=$126;
      var $128=$127;
      var $129=(($128+8)|0);
      var $130=HEAP32[(($129)>>2)];
      var $131=$i;
      var $132=HEAP32[((_parser)>>2)];
      var $133=(($132+20)|0);
      var $134=HEAP32[(($133)>>2)];
      var $135=(($134+($131<<3))|0);
      var $136=(($135+4)|0);
      var $137=HEAP32[(($136)>>2)];
      var $138=$137;
      FUNCTION_TABLE[$130]($138);
      var $139=$i;
      var $140=HEAP32[((_parser)>>2)];
      var $141=(($140+20)|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=(($142+($139<<3))|0);
      var $144=(($143)|0);
      var $145=HEAP32[(($144)>>2)];
      _util_memory_d($145, 2912, ((STRING_TABLE.__str572)|0));
      __label__ = 21; break;
    case 21: 
      var $147=$i;
      var $148=((($147)+(1))|0);
      $i=$148;
      __label__ = 19; break;
    case 22: 
      $i=0;
      __label__ = 23; break;
    case 23: 
      var $151=$i;
      var $152=HEAP32[((_parser)>>2)];
      var $153=(($152+12)|0);
      var $154=HEAP32[(($153)>>2)];
      var $155=(($151)>>>0) < (($154)>>>0);
      if ($155) { __label__ = 24; break; } else { __label__ = 26; break; }
    case 24: 
      var $157=$i;
      var $158=HEAP32[((_parser)>>2)];
      var $159=(($158+8)|0);
      var $160=HEAP32[(($159)>>2)];
      var $161=(($160+($157<<3))|0);
      var $162=(($161+4)|0);
      var $163=HEAP32[(($162)>>2)];
      var $164=$163;
      var $165=$164;
      var $166=(($165+8)|0);
      var $167=HEAP32[(($166)>>2)];
      var $168=$i;
      var $169=HEAP32[((_parser)>>2)];
      var $170=(($169+8)|0);
      var $171=HEAP32[(($170)>>2)];
      var $172=(($171+($168<<3))|0);
      var $173=(($172+4)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=$174;
      FUNCTION_TABLE[$167]($175);
      var $176=$i;
      var $177=HEAP32[((_parser)>>2)];
      var $178=(($177+8)|0);
      var $179=HEAP32[(($178)>>2)];
      var $180=(($179+($176<<3))|0);
      var $181=(($180)|0);
      var $182=HEAP32[(($181)>>2)];
      _util_memory_d($182, 2916, ((STRING_TABLE.__str572)|0));
      __label__ = 25; break;
    case 25: 
      var $184=$i;
      var $185=((($184)+(1))|0);
      $i=$185;
      __label__ = 23; break;
    case 26: 
      var $187=HEAP32[((_parser)>>2)];
      var $188=(($187+32)|0);
      var $189=HEAP32[(($188)>>2)];
      var $190=(($189)|0)!=0;
      if ($190) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      var $192=HEAP32[((_parser)>>2)];
      var $193=(($192+32)|0);
      var $194=HEAP32[(($193)>>2)];
      var $195=$194;
      _util_memory_d($195, 2918, ((STRING_TABLE.__str572)|0));
      __label__ = 28; break;
    case 28: 
      var $197=HEAP32[((_parser)>>2)];
      var $198=(($197+32)|0);
      HEAP32[(($198)>>2)]=0;
      var $199=HEAP32[((_parser)>>2)];
      var $200=(($199+36)|0);
      HEAP32[(($200)>>2)]=0;
      var $201=HEAP32[((_parser)>>2)];
      var $202=(($201+40)|0);
      HEAP32[(($202)>>2)]=0;
      var $203=HEAP32[((_parser)>>2)];
      var $204=(($203+68)|0);
      var $205=HEAP32[(($204)>>2)];
      var $206=(($205)|0)!=0;
      if ($206) { __label__ = 29; break; } else { __label__ = 30; break; }
    case 29: 
      var $208=HEAP32[((_parser)>>2)];
      var $209=(($208+68)|0);
      var $210=HEAP32[(($209)>>2)];
      var $211=$210;
      _util_memory_d($211, 2919, ((STRING_TABLE.__str572)|0));
      __label__ = 30; break;
    case 30: 
      var $213=HEAP32[((_parser)>>2)];
      var $214=(($213+68)|0);
      HEAP32[(($214)>>2)]=0;
      var $215=HEAP32[((_parser)>>2)];
      var $216=(($215+72)|0);
      HEAP32[(($216)>>2)]=0;
      var $217=HEAP32[((_parser)>>2)];
      var $218=(($217+76)|0);
      HEAP32[(($218)>>2)]=0;
      var $219=HEAP32[((_parser)>>2)];
      var $220=(($219+56)|0);
      var $221=HEAP32[(($220)>>2)];
      var $222=(($221)|0)!=0;
      if ($222) { __label__ = 31; break; } else { __label__ = 32; break; }
    case 31: 
      var $224=HEAP32[((_parser)>>2)];
      var $225=(($224+56)|0);
      var $226=HEAP32[(($225)>>2)];
      var $227=$226;
      _util_memory_d($227, 2920, ((STRING_TABLE.__str572)|0));
      __label__ = 32; break;
    case 32: 
      var $229=HEAP32[((_parser)>>2)];
      var $230=(($229+56)|0);
      HEAP32[(($230)>>2)]=0;
      var $231=HEAP32[((_parser)>>2)];
      var $232=(($231+60)|0);
      HEAP32[(($232)>>2)]=0;
      var $233=HEAP32[((_parser)>>2)];
      var $234=(($233+64)|0);
      HEAP32[(($234)>>2)]=0;
      var $235=HEAP32[((_parser)>>2)];
      var $236=(($235+44)|0);
      var $237=HEAP32[(($236)>>2)];
      var $238=(($237)|0)!=0;
      if ($238) { __label__ = 33; break; } else { __label__ = 34; break; }
    case 33: 
      var $240=HEAP32[((_parser)>>2)];
      var $241=(($240+44)|0);
      var $242=HEAP32[(($241)>>2)];
      var $243=$242;
      _util_memory_d($243, 2921, ((STRING_TABLE.__str572)|0));
      __label__ = 34; break;
    case 34: 
      var $245=HEAP32[((_parser)>>2)];
      var $246=(($245+44)|0);
      HEAP32[(($246)>>2)]=0;
      var $247=HEAP32[((_parser)>>2)];
      var $248=(($247+48)|0);
      HEAP32[(($248)>>2)]=0;
      var $249=HEAP32[((_parser)>>2)];
      var $250=(($249+52)|0);
      HEAP32[(($250)>>2)]=0;
      var $251=HEAP32[((_parser)>>2)];
      var $252=(($251+8)|0);
      var $253=HEAP32[(($252)>>2)];
      var $254=(($253)|0)!=0;
      if ($254) { __label__ = 35; break; } else { __label__ = 36; break; }
    case 35: 
      var $256=HEAP32[((_parser)>>2)];
      var $257=(($256+8)|0);
      var $258=HEAP32[(($257)>>2)];
      var $259=$258;
      _util_memory_d($259, 2922, ((STRING_TABLE.__str572)|0));
      __label__ = 36; break;
    case 36: 
      var $261=HEAP32[((_parser)>>2)];
      var $262=(($261+8)|0);
      HEAP32[(($262)>>2)]=0;
      var $263=HEAP32[((_parser)>>2)];
      var $264=(($263+12)|0);
      HEAP32[(($264)>>2)]=0;
      var $265=HEAP32[((_parser)>>2)];
      var $266=(($265+16)|0);
      HEAP32[(($266)>>2)]=0;
      var $267=HEAP32[((_parser)>>2)];
      var $268=(($267+20)|0);
      var $269=HEAP32[(($268)>>2)];
      var $270=(($269)|0)!=0;
      if ($270) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      var $272=HEAP32[((_parser)>>2)];
      var $273=(($272+20)|0);
      var $274=HEAP32[(($273)>>2)];
      var $275=$274;
      _util_memory_d($275, 2923, ((STRING_TABLE.__str572)|0));
      __label__ = 38; break;
    case 38: 
      var $277=HEAP32[((_parser)>>2)];
      var $278=(($277+20)|0);
      HEAP32[(($278)>>2)]=0;
      var $279=HEAP32[((_parser)>>2)];
      var $280=(($279+24)|0);
      HEAP32[(($280)>>2)]=0;
      var $281=HEAP32[((_parser)>>2)];
      var $282=(($281+28)|0);
      HEAP32[(($282)>>2)]=0;
      var $283=HEAP32[((_parser)>>2)];
      var $284=(($283+100)|0);
      var $285=HEAP32[(($284)>>2)];
      var $286=(($285)|0)!=0;
      if ($286) { __label__ = 39; break; } else { __label__ = 40; break; }
    case 39: 
      var $288=HEAP32[((_parser)>>2)];
      var $289=(($288+100)|0);
      var $290=HEAP32[(($289)>>2)];
      var $291=$290;
      _util_memory_d($291, 2924, ((STRING_TABLE.__str572)|0));
      __label__ = 40; break;
    case 40: 
      var $293=HEAP32[((_parser)>>2)];
      var $294=(($293+100)|0);
      HEAP32[(($294)>>2)]=0;
      var $295=HEAP32[((_parser)>>2)];
      var $296=(($295+104)|0);
      HEAP32[(($296)>>2)]=0;
      var $297=HEAP32[((_parser)>>2)];
      var $298=(($297+108)|0);
      HEAP32[(($298)>>2)]=0;
      var $299=HEAP32[((_parser)>>2)];
      var $300=$299;
      _util_memory_d($300, 2926, ((STRING_TABLE.__str572)|0));
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_cleanup["X"]=1;

function _progdefs_crc_file($str) {
  ;
  var __label__;

  var $1;
  $1=$str;
  ;
  return;
}


function _parser_finish($output) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $i;
      var $ir;
      var $retval;
      var $field;
      var $isconst;
      var $ifld;
      var $subtype;
      var $asvalue;
      $2=$output;
      $retval=1;
      var $3=HEAP32[((_parser)>>2)];
      var $4=(($3+116)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 70; break; } else { __label__ = 3; break; }
    case 3: 
      var $8=_ir_builder_new(((STRING_TABLE.__str7579)|0));
      $ir=$8;
      var $9=$ir;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=_printf(((STRING_TABLE.__str8580)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 71; break;
    case 5: 
      $i=0;
      __label__ = 6; break;
    case 6: 
      var $15=$i;
      var $16=HEAP32[((_parser)>>2)];
      var $17=(($16+24)|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($15)>>>0) < (($18)>>>0);
      if ($19) { __label__ = 7; break; } else { __label__ = 20; break; }
    case 7: 
      var $21=$i;
      var $22=HEAP32[((_parser)>>2)];
      var $23=(($22+20)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($24+($21<<3))|0);
      var $26=(($25+4)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=$27;
      var $29=(($28+12)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)==2;
      if ($31) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      __label__ = 19; break;
    case 9: 
      var $34=$i;
      var $35=HEAP32[((_parser)>>2)];
      var $36=(($35+20)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37+($34<<3))|0);
      var $39=(($38+4)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$40;
      $field=$41;
      var $42=$field;
      var $43=(($42+60)|0);
      var $44=HEAP8[($43)];
      var $45=(($44) & 1);
      var $46=(($45)&1);
      $isconst=$46;
      var $47=$field;
      var $48=(($47+60)|0);
      HEAP8[($48)]=0;
      var $49=$field;
      var $50=$ir;
      var $51=_ast_global_codegen($49, $50);
      if ($51) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $53=$field;
      var $54=(($53+56)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=_printf(((STRING_TABLE.__str9581)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$55,tempInt));
      var $57=$ir;
      _ir_builder_delete($57);
      $1=0;
      __label__ = 71; break;
    case 11: 
      var $59=$isconst;
      var $60=(($59) & 1);
      if ($60) { __label__ = 12; break; } else { __label__ = 18; break; }
    case 12: 
      var $62=$field;
      var $63=(($62+60)|0);
      HEAP8[($63)]=1;
      var $64=$field;
      var $65=(($64)|0);
      var $66=(($65+28)|0);
      var $67=HEAP32[(($66)>>2)];
      $subtype=$67;
      var $68=$ir;
      var $69=$field;
      var $70=(($69+56)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$subtype;
      var $73=$72;
      var $74=(($73+24)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=_ir_builder_create_field($68, $71, $75);
      $ifld=$76;
      var $77=$subtype;
      var $78=$77;
      var $79=(($78+24)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=(($80)|0)==5;
      if ($81) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $83=$subtype;
      var $84=$83;
      var $85=(($84+28)|0);
      var $86=HEAP32[(($85)>>2)];
      var $87=$86;
      var $88=(($87+24)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$ifld;
      var $91=(($90+20)|0);
      HEAP32[(($91)>>2)]=$89;
      __label__ = 17; break;
    case 14: 
      var $93=$subtype;
      var $94=$93;
      var $95=(($94+24)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=(($96)|0)==6;
      if ($97) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $99=$subtype;
      var $100=$99;
      var $101=(($100+28)|0);
      var $102=HEAP32[(($101)>>2)];
      var $103=$102;
      var $104=(($103+24)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=$ifld;
      var $107=(($106+24)|0);
      HEAP32[(($107)>>2)]=$105;
      __label__ = 16; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      var $110=$field;
      var $111=(($110+80)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=$ifld;
      var $114=_ir_value_set_field($112, $113);
      var $115=$114 ^ 1;
      var $116=(($115)&1);
      __label__ = 18; break;
    case 18: 
      __label__ = 19; break;
    case 19: 
      var $119=$i;
      var $120=((($119)+(1))|0);
      $i=$120;
      __label__ = 6; break;
    case 20: 
      $i=0;
      __label__ = 21; break;
    case 21: 
      var $123=$i;
      var $124=HEAP32[((_parser)>>2)];
      var $125=(($124+12)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=(($123)>>>0) < (($126)>>>0);
      if ($127) { __label__ = 22; break; } else { __label__ = 37; break; }
    case 22: 
      var $129=$i;
      var $130=HEAP32[((_parser)>>2)];
      var $131=(($130+8)|0);
      var $132=HEAP32[(($131)>>2)];
      var $133=(($132+($129<<3))|0);
      var $134=(($133+4)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=$135;
      var $137=(($136+12)|0);
      var $138=HEAP32[(($137)>>2)];
      var $139=(($138)|0)==2;
      if ($139) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      __label__ = 36; break;
    case 24: 
      var $142=$i;
      var $143=HEAP32[((_parser)>>2)];
      var $144=(($143+8)|0);
      var $145=HEAP32[(($144)>>2)];
      var $146=(($145+($142<<3))|0);
      var $147=(($146+4)|0);
      var $148=HEAP32[(($147)>>2)];
      var $149=$148;
      $asvalue=$149;
      var $150=$asvalue;
      var $151=(($150+76)|0);
      var $152=HEAP32[(($151)>>2)];
      var $153=(($152)|0)!=0;
      if ($153) { __label__ = 33; break; } else { __label__ = 25; break; }
    case 25: 
      var $155=$asvalue;
      var $156=(($155+60)|0);
      var $157=HEAP8[($156)];
      var $158=(($157) & 1);
      if ($158) { __label__ = 33; break; } else { __label__ = 26; break; }
    case 26: 
      var $160=$asvalue;
      var $161=(($160)|0);
      var $162=(($161+24)|0);
      var $163=HEAP32[(($162)>>2)];
      var $164=(($163)|0)!=6;
      if ($164) { __label__ = 27; break; } else { __label__ = 33; break; }
    case 27: 
      var $166=$asvalue;
      var $167=(($166+56)|0);
      var $168=HEAP32[(($167)>>2)];
      var $169=_strcmp($168, ((STRING_TABLE.__str10582)|0));
      var $170=(($169)|0)!=0;
      if ($170) { __label__ = 28; break; } else { __label__ = 32; break; }
    case 28: 
      var $172=$asvalue;
      var $173=(($172+56)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=_strcmp($174, ((STRING_TABLE.__str11583)|0));
      var $176=(($175)|0)!=0;
      if ($176) { __label__ = 29; break; } else { __label__ = 32; break; }
    case 29: 
      var $178=$retval;
      var $179=(($178) & 1);
      if ($179) { __label__ = 30; break; } else { var $194 = 0;__label__ = 31; break; }
    case 30: 
      var $181=$asvalue;
      var $182=$181;
      var $183=(($182)|0);
      var $184=$asvalue;
      var $185=(($184+56)|0);
      var $186=HEAP32[(($185)>>2)];
      var $187=(($183)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=(($183+4)|0);
      var $190=HEAP32[(($189)>>2)];
      var $191=_genwarning($188, $190, 1, ((STRING_TABLE.__str12584)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$186,tempInt));
      var $192=$191 ^ 1;
      var $194 = $192;__label__ = 31; break;
    case 31: 
      var $194;
      var $195=(($194)&1);
      $retval=$195;
      __label__ = 32; break;
    case 32: 
      __label__ = 33; break;
    case 33: 
      var $198=$asvalue;
      var $199=$ir;
      var $200=_ast_global_codegen($198, $199);
      if ($200) { __label__ = 35; break; } else { __label__ = 34; break; }
    case 34: 
      var $202=$i;
      var $203=HEAP32[((_parser)>>2)];
      var $204=(($203+8)|0);
      var $205=HEAP32[(($204)>>2)];
      var $206=(($205+($202<<3))|0);
      var $207=(($206)|0);
      var $208=HEAP32[(($207)>>2)];
      var $209=_printf(((STRING_TABLE.__str13585)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$208,tempInt));
      var $210=$ir;
      _ir_builder_delete($210);
      $1=0;
      __label__ = 71; break;
    case 35: 
      __label__ = 36; break;
    case 36: 
      var $213=$i;
      var $214=((($213)+(1))|0);
      $i=$214;
      __label__ = 21; break;
    case 37: 
      $i=0;
      __label__ = 38; break;
    case 38: 
      var $217=$i;
      var $218=HEAP32[((_parser)>>2)];
      var $219=(($218+48)|0);
      var $220=HEAP32[(($219)>>2)];
      var $221=(($217)>>>0) < (($220)>>>0);
      if ($221) { __label__ = 39; break; } else { __label__ = 43; break; }
    case 39: 
      var $223=$i;
      var $224=HEAP32[((_parser)>>2)];
      var $225=(($224+44)|0);
      var $226=HEAP32[(($225)>>2)];
      var $227=(($226+($223<<2))|0);
      var $228=HEAP32[(($227)>>2)];
      var $229=$ir;
      var $230=_ast_global_codegen($228, $229);
      if ($230) { __label__ = 41; break; } else { __label__ = 40; break; }
    case 40: 
      var $232=$i;
      var $233=HEAP32[((_parser)>>2)];
      var $234=(($233+44)|0);
      var $235=HEAP32[(($234)>>2)];
      var $236=(($235+($232<<2))|0);
      var $237=HEAP32[(($236)>>2)];
      var $238=(($237+56)|0);
      var $239=HEAP32[(($238)>>2)];
      var $240=_printf(((STRING_TABLE.__str13585)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$239,tempInt));
      var $241=$ir;
      _ir_builder_delete($241);
      $1=0;
      __label__ = 71; break;
    case 41: 
      __label__ = 42; break;
    case 42: 
      var $244=$i;
      var $245=((($244)+(1))|0);
      $i=$245;
      __label__ = 38; break;
    case 43: 
      $i=0;
      __label__ = 44; break;
    case 44: 
      var $248=$i;
      var $249=HEAP32[((_parser)>>2)];
      var $250=(($249+60)|0);
      var $251=HEAP32[(($250)>>2)];
      var $252=(($248)>>>0) < (($251)>>>0);
      if ($252) { __label__ = 45; break; } else { __label__ = 49; break; }
    case 45: 
      var $254=$i;
      var $255=HEAP32[((_parser)>>2)];
      var $256=(($255+56)|0);
      var $257=HEAP32[(($256)>>2)];
      var $258=(($257+($254<<2))|0);
      var $259=HEAP32[(($258)>>2)];
      var $260=$ir;
      var $261=_ast_global_codegen($259, $260);
      if ($261) { __label__ = 47; break; } else { __label__ = 46; break; }
    case 46: 
      var $263=$i;
      var $264=HEAP32[((_parser)>>2)];
      var $265=(($264+56)|0);
      var $266=HEAP32[(($265)>>2)];
      var $267=(($266+($263<<2))|0);
      var $268=HEAP32[(($267)>>2)];
      var $269=(($268+56)|0);
      var $270=HEAP32[(($269)>>2)];
      var $271=_printf(((STRING_TABLE.__str13585)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$270,tempInt));
      var $272=$ir;
      _ir_builder_delete($272);
      $1=0;
      __label__ = 71; break;
    case 47: 
      __label__ = 48; break;
    case 48: 
      var $275=$i;
      var $276=((($275)+(1))|0);
      $i=$276;
      __label__ = 44; break;
    case 49: 
      $i=0;
      __label__ = 50; break;
    case 50: 
      var $279=$i;
      var $280=HEAP32[((_parser)>>2)];
      var $281=(($280+72)|0);
      var $282=HEAP32[(($281)>>2)];
      var $283=(($279)>>>0) < (($282)>>>0);
      if ($283) { __label__ = 51; break; } else { __label__ = 55; break; }
    case 51: 
      var $285=$i;
      var $286=HEAP32[((_parser)>>2)];
      var $287=(($286+68)|0);
      var $288=HEAP32[(($287)>>2)];
      var $289=(($288+($285<<2))|0);
      var $290=HEAP32[(($289)>>2)];
      var $291=$ir;
      var $292=_ast_global_codegen($290, $291);
      if ($292) { __label__ = 53; break; } else { __label__ = 52; break; }
    case 52: 
      var $294=$i;
      var $295=HEAP32[((_parser)>>2)];
      var $296=(($295+68)|0);
      var $297=HEAP32[(($296)>>2)];
      var $298=(($297+($294<<2))|0);
      var $299=HEAP32[(($298)>>2)];
      var $300=(($299+56)|0);
      var $301=HEAP32[(($300)>>2)];
      var $302=_printf(((STRING_TABLE.__str13585)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$301,tempInt));
      var $303=$ir;
      _ir_builder_delete($303);
      $1=0;
      __label__ = 71; break;
    case 53: 
      __label__ = 54; break;
    case 54: 
      var $306=$i;
      var $307=((($306)+(1))|0);
      $i=$307;
      __label__ = 50; break;
    case 55: 
      $i=0;
      __label__ = 56; break;
    case 56: 
      var $310=$i;
      var $311=HEAP32[((_parser)>>2)];
      var $312=(($311+36)|0);
      var $313=HEAP32[(($312)>>2)];
      var $314=(($310)>>>0) < (($313)>>>0);
      if ($314) { __label__ = 57; break; } else { __label__ = 63; break; }
    case 57: 
      var $316=$i;
      var $317=HEAP32[((_parser)>>2)];
      var $318=(($317+32)|0);
      var $319=HEAP32[(($318)>>2)];
      var $320=(($319+($316<<2))|0);
      var $321=HEAP32[(($320)>>2)];
      var $322=$ir;
      var $323=_ast_function_codegen($321, $322);
      if ($323) { __label__ = 59; break; } else { __label__ = 58; break; }
    case 58: 
      var $325=$i;
      var $326=HEAP32[((_parser)>>2)];
      var $327=(($326+32)|0);
      var $328=HEAP32[(($327)>>2)];
      var $329=(($328+($325<<2))|0);
      var $330=HEAP32[(($329)>>2)];
      var $331=(($330+24)|0);
      var $332=HEAP32[(($331)>>2)];
      var $333=_printf(((STRING_TABLE.__str14586)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$332,tempInt));
      var $334=$ir;
      _ir_builder_delete($334);
      $1=0;
      __label__ = 71; break;
    case 59: 
      var $336=$i;
      var $337=HEAP32[((_parser)>>2)];
      var $338=(($337+32)|0);
      var $339=HEAP32[(($338)>>2)];
      var $340=(($339+($336<<2))|0);
      var $341=HEAP32[(($340)>>2)];
      var $342=(($341+32)|0);
      var $343=HEAP32[(($342)>>2)];
      var $344=_ir_function_finalize($343);
      if ($344) { __label__ = 61; break; } else { __label__ = 60; break; }
    case 60: 
      var $346=$i;
      var $347=HEAP32[((_parser)>>2)];
      var $348=(($347+32)|0);
      var $349=HEAP32[(($348)>>2)];
      var $350=(($349+($346<<2))|0);
      var $351=HEAP32[(($350)>>2)];
      var $352=(($351+24)|0);
      var $353=HEAP32[(($352)>>2)];
      var $354=_printf(((STRING_TABLE.__str15587)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$353,tempInt));
      var $355=$ir;
      _ir_builder_delete($355);
      $1=0;
      __label__ = 71; break;
    case 61: 
      __label__ = 62; break;
    case 62: 
      var $358=$i;
      var $359=((($358)+(1))|0);
      $i=$359;
      __label__ = 56; break;
    case 63: 
      var $361=$retval;
      var $362=(($361) & 1);
      if ($362) { __label__ = 64; break; } else { __label__ = 69; break; }
    case 64: 
      var $364=HEAP8[(_opts_dump)];
      var $365=(($364) & 1);
      if ($365) { __label__ = 65; break; } else { __label__ = 66; break; }
    case 65: 
      var $367=$ir;
      _ir_builder_dump($367, 34);
      __label__ = 66; break;
    case 66: 
      var $369=HEAP32[((_parser)>>2)];
      _generate_checksum($369);
      var $370=$ir;
      var $371=$2;
      var $372=_ir_builder_generate($370, $371);
      if ($372) { __label__ = 68; break; } else { __label__ = 67; break; }
    case 67: 
      var $374=_printf(((STRING_TABLE.__str16588)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $375=$ir;
      _ir_builder_delete($375);
      $1=0;
      __label__ = 71; break;
    case 68: 
      __label__ = 69; break;
    case 69: 
      var $378=$ir;
      _ir_builder_delete($378);
      var $379=$retval;
      var $380=(($379) & 1);
      $1=$380;
      __label__ = 71; break;
    case 70: 
      var $382=_printf(((STRING_TABLE.__str17589)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 71; break;
    case 71: 
      var $384=$1;
      STACKTOP = __stackBase__;
      return $384;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_finish["X"]=1;

function _genwarning($ctx_0, $ctx_1, $warntype, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $ctx=__stackBase__;
      var $2;
      var $3;
      var $ap=(__stackBase__)+(8);
      var $lvl;
      var $4=(($ctx)|0);
      HEAP32[(($4)>>2)]=$ctx_0;
      var $5=(($ctx+4)|0);
      HEAP32[(($5)>>2)]=$ctx_1;
      $2=$warntype;
      $3=$fmt;
      $lvl=1;
      var $6=$2;
      var $7=((((($6)|0))/(32))&-1);
      var $8=((_opts_warn+($7<<2))|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=$2;
      var $11=((($10)|0))%(32);
      var $12=1 << $11;
      var $13=$9 & $12;
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $17=HEAP8[(_opts_werror)];
      var $18=(($17) & 1);
      if ($18) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $lvl=2;
      __label__ = 6; break;
    case 6: 
      var $21=$ap;
      HEAP32[(($21)>>2)]=arguments[_genwarning.length];
      var $22=$lvl;
      var $23=(($ctx)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=(($ctx+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=$3;
      var $28=HEAP32[(($ap)>>2)];
      _vprintmsg($22, $24, $26, ((STRING_TABLE.__str28600)|0), $27, $28);
      var $29=$ap;
      ;
      var $30=HEAP8[(_opts_werror)];
      var $31=(($30) & 1);
      $1=$31;
      __label__ = 7; break;
    case 7: 
      var $33=$1;
      STACKTOP = __stackBase__;
      return $33;
    default: assert(0, "bad label: " + __label__);
  }
}


function _generate_checksum($parser) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $crc;
      var $i;
      $1=$parser;
      $crc=-1;
      var $2=$crc;
      var $3=_progdefs_crc_both($2, ((STRING_TABLE.__str18590)|0));
      $crc=$3;
      var $4=$crc;
      var $5=_progdefs_crc_sum($4, ((STRING_TABLE.__str19591)|0));
      $crc=$5;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $7=$i;
      var $8=$1;
      var $9=(($8+88)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)>>>0) < (($10)>>>0);
      if ($11) { __label__ = 4; break; } else { __label__ = 14; break; }
    case 4: 
      var $13=$i;
      var $14=$1;
      var $15=(($14+8)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16+($13<<3))|0);
      var $18=(($17+4)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=$19;
      var $21=(($20+12)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=(($22)|0)==2;
      if ($23) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      __label__ = 13; break;
    case 6: 
      var $26=$i;
      var $27=$1;
      var $28=(($27+8)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+($26<<3))|0);
      var $31=(($30+4)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$32;
      var $34=(($33+24)|0);
      var $35=HEAP32[(($34)>>2)];
      if ((($35)|0) == 2) {
        __label__ = 7; break;
      }
      else if ((($35)|0) == 3) {
        __label__ = 8; break;
      }
      else if ((($35)|0) == 1) {
        __label__ = 9; break;
      }
      else if ((($35)|0) == 6) {
        __label__ = 10; break;
      }
      else {
      __label__ = 11; break;
      }
      
    case 7: 
      var $37=$crc;
      var $38=_progdefs_crc_both($37, ((STRING_TABLE.__str20592)|0));
      $crc=$38;
      __label__ = 12; break;
    case 8: 
      var $40=$crc;
      var $41=_progdefs_crc_both($40, ((STRING_TABLE.__str21593)|0));
      $crc=$41;
      __label__ = 12; break;
    case 9: 
      var $43=$crc;
      var $44=_progdefs_crc_both($43, ((STRING_TABLE.__str22594)|0));
      $crc=$44;
      __label__ = 12; break;
    case 10: 
      var $46=$crc;
      var $47=_progdefs_crc_both($46, ((STRING_TABLE.__str23595)|0));
      $crc=$47;
      __label__ = 12; break;
    case 11: 
      var $49=$crc;
      var $50=_progdefs_crc_both($49, ((STRING_TABLE.__str24596)|0));
      $crc=$50;
      __label__ = 12; break;
    case 12: 
      var $52=$crc;
      var $53=$i;
      var $54=$1;
      var $55=(($54+8)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56+($53<<3))|0);
      var $58=(($57)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=_progdefs_crc_both($52, $59);
      $crc=$60;
      var $61=$crc;
      var $62=_progdefs_crc_both($61, ((STRING_TABLE.__str25597)|0));
      $crc=$62;
      __label__ = 13; break;
    case 13: 
      var $64=$i;
      var $65=((($64)+(1))|0);
      $i=$65;
      __label__ = 3; break;
    case 14: 
      var $67=$crc;
      var $68=_progdefs_crc_both($67, ((STRING_TABLE.__str26598)|0));
      $crc=$68;
      $i=0;
      __label__ = 15; break;
    case 15: 
      var $70=$i;
      var $71=$1;
      var $72=(($71+92)|0);
      var $73=HEAP32[(($72)>>2)];
      var $74=(($70)>>>0) < (($73)>>>0);
      if ($74) { __label__ = 16; break; } else { __label__ = 26; break; }
    case 16: 
      var $76=$i;
      var $77=$1;
      var $78=(($77+20)|0);
      var $79=HEAP32[(($78)>>2)];
      var $80=(($79+($76<<3))|0);
      var $81=(($80+4)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=$82;
      var $84=(($83+12)|0);
      var $85=HEAP32[(($84)>>2)];
      var $86=(($85)|0)==2;
      if ($86) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      __label__ = 25; break;
    case 18: 
      var $89=$i;
      var $90=$1;
      var $91=(($90+20)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=(($92+($89<<3))|0);
      var $94=(($93+4)|0);
      var $95=HEAP32[(($94)>>2)];
      var $96=$95;
      var $97=(($96+28)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=$98;
      var $100=(($99+24)|0);
      var $101=HEAP32[(($100)>>2)];
      if ((($101)|0) == 2) {
        __label__ = 19; break;
      }
      else if ((($101)|0) == 3) {
        __label__ = 20; break;
      }
      else if ((($101)|0) == 1) {
        __label__ = 21; break;
      }
      else if ((($101)|0) == 6) {
        __label__ = 22; break;
      }
      else {
      __label__ = 23; break;
      }
      
    case 19: 
      var $103=$crc;
      var $104=_progdefs_crc_both($103, ((STRING_TABLE.__str20592)|0));
      $crc=$104;
      __label__ = 24; break;
    case 20: 
      var $106=$crc;
      var $107=_progdefs_crc_both($106, ((STRING_TABLE.__str21593)|0));
      $crc=$107;
      __label__ = 24; break;
    case 21: 
      var $109=$crc;
      var $110=_progdefs_crc_both($109, ((STRING_TABLE.__str22594)|0));
      $crc=$110;
      __label__ = 24; break;
    case 22: 
      var $112=$crc;
      var $113=_progdefs_crc_both($112, ((STRING_TABLE.__str23595)|0));
      $crc=$113;
      __label__ = 24; break;
    case 23: 
      var $115=$crc;
      var $116=_progdefs_crc_both($115, ((STRING_TABLE.__str24596)|0));
      $crc=$116;
      __label__ = 24; break;
    case 24: 
      var $118=$crc;
      var $119=$i;
      var $120=$1;
      var $121=(($120+20)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=(($122+($119<<3))|0);
      var $124=(($123)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=_progdefs_crc_both($118, $125);
      $crc=$126;
      var $127=$crc;
      var $128=_progdefs_crc_both($127, ((STRING_TABLE.__str25597)|0));
      $crc=$128;
      __label__ = 25; break;
    case 25: 
      var $130=$i;
      var $131=((($130)+(1))|0);
      $i=$131;
      __label__ = 15; break;
    case 26: 
      var $133=$crc;
      var $134=_progdefs_crc_both($133, ((STRING_TABLE.__str27599)|0));
      $crc=$134;
      var $135=$crc;
      HEAP16[((_code_crc)>>1)]=$135;
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_generate_checksum["X"]=1;

function _progdefs_crc_both($old, $str) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$old;
  $2=$str;
  var $3=$1;
  var $4=$2;
  var $5=_progdefs_crc_sum($3, $4);
  $1=$5;
  var $6=$2;
  _progdefs_crc_file($6);
  var $7=$1;
  ;
  return $7;
}


function _progdefs_crc_sum($old, $str) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$old;
  $2=$str;
  var $3=$1;
  var $4=$2;
  var $5=$2;
  var $6=_strlen($5);
  var $7=_util_crc16($3, $4, $6);
  ;
  return $7;
}


function _parse_variable($parser, $localblock) {
  var __stackBase__  = STACKTOP; STACKTOP += 52; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $isfunc=__stackBase__;
      var $ctx=(__stackBase__)+(4);
      var $var;
      var $fld;
      var $cleanvar;
      var $varent=(__stackBase__)+(12);
      var $ve=(__stackBase__)+(20);
      var $olddecl;
      var $typevar;
      var $hadproto;
      var $isparam=(__stackBase__)+(44);
      var $retval;
      var $isfield;
      var $basetype;
      var $was_end;
      var $fval;
      var $proto;
      var $dummy=(__stackBase__)+(48);
      var $param;
      var $tmp;
      var $e;
      var $func;
      var $cexp;
      var $cval;
      $2=$parser;
      $3=$localblock;
      HEAP8[($isfunc)]=0;
      $var=0;
      $fld=0;
      $cleanvar=0;
      $retval=1;
      $isfield=0;
      var $4=$2;
      var $5=(($4+4)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)==46;
      if ($7) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      $isfield=1;
      var $9=$2;
      var $10=_parser_next($9);
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $12=$2;
      _parseerror($12, ((STRING_TABLE.__str30602)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 229; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $15=$2;
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17+292)|0);
      var $19=(($18+16)|0);
      var $20=$19;
      var $21=HEAP32[(($20)>>2)];
      $basetype=$21;
      var $22=$2;
      var $23=_parser_next($22);
      if ($23) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $25=$2;
      _parseerror($25, ((STRING_TABLE.__str31603)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 229; break;
    case 8: 
      var $27=$2;
      var $28=$basetype;
      var $29=_parse_type($27, $28, $isfunc);
      $typevar=$29;
      var $30=$typevar;
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      $1=0;
      __label__ = 229; break;
    case 10: 
      __label__ = 11; break;
    case 11: 
      $hadproto=0;
      $olddecl=0;
      HEAP8[($isparam)]=0;
      var $35=(($varent)|0);
      HEAP32[(($35)>>2)]=0;
      var $36=(($ve+16)|0);
      var $37=(($36)|0);
      HEAP32[(($37)>>2)]=0;
      var $38=(($ve+8)|0);
      var $39=(($38)|0);
      HEAP32[(($39)>>2)]=0;
      var $40=(($ve)|0);
      var $41=(($40)|0);
      HEAP32[(($41)>>2)]=0;
      var $42=(($ve+16)|0);
      var $43=(($42+4)|0);
      HEAP32[(($43)>>2)]=0;
      var $44=(($ve+8)|0);
      var $45=(($44+4)|0);
      HEAP32[(($45)>>2)]=0;
      var $46=(($ve)|0);
      var $47=(($46+4)|0);
      HEAP32[(($47)>>2)]=0;
      var $48=$2;
      var $49=(($48)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($50+292)|0);
      var $52=(($51+28)|0);
      var $53=$ctx;
      var $54=$52;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($53)>>2)]=HEAP32[(($54)>>2)];HEAP32[((($53)+(4))>>2)]=HEAP32[((($54)+(4))>>2)];
      var $55=$typevar;
      var $56=_ast_value_copy($55);
      $var=$56;
      $cleanvar=1;
      var $57=$var;
      var $58=(($57)|0)!=0;
      if ($58) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      var $60=$2;
      _parseerror($60, ((STRING_TABLE.__str32604)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 13: 
      var $62=$2;
      var $63=(($62+4)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=(($64)|0)!=129;
      if ($65) { __label__ = 14; break; } else { __label__ = 15; break; }
    case 14: 
      var $67=$2;
      _parseerror($67, ((STRING_TABLE.__str33605)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 15: 
      var $69=$3;
      var $70=(($69)|0)!=0;
      if ($70) { __label__ = 27; break; } else { __label__ = 16; break; }
    case 16: 
      $was_end=0;
      var $72=$2;
      var $73=(($72)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=(($74+292)|0);
      var $76=(($75+4)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=_strcmp($77, ((STRING_TABLE.__str10582)|0));
      var $79=(($78)|0)!=0;
      if ($79) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $81=$2;
      var $82=(($81+12)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=$2;
      var $85=(($84+88)|0);
      HEAP32[(($85)>>2)]=$83;
      $was_end=1;
      __label__ = 21; break;
    case 18: 
      var $87=$2;
      var $88=(($87)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($89+292)|0);
      var $91=(($90+4)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=_strcmp($92, ((STRING_TABLE.__str11583)|0));
      var $94=(($93)|0)!=0;
      if ($94) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      var $96=$2;
      var $97=(($96+24)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=$2;
      var $100=(($99+92)|0);
      HEAP32[(($100)>>2)]=$98;
      $was_end=1;
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $103=$isfield;
      var $104=(($103) & 1);
      if ($104) { __label__ = 22; break; } else { __label__ = 26; break; }
    case 22: 
      var $106=$was_end;
      var $107=(($106) & 1);
      if ($107) { __label__ = 23; break; } else { __label__ = 26; break; }
    case 23: 
      var $109=$2;
      var $110=$2;
      var $111=(($110)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($112+292)|0);
      var $114=(($113+4)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=_parsewarning($109, 15, ((STRING_TABLE.__str34606)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$115,tempInt));
      if ($116) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      $retval=0;
      __label__ = 211; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $121=$var;
      var $122=$2;
      var $123=(($122)|0);
      var $124=HEAP32[(($123)>>2)];
      var $125=(($124+292)|0);
      var $126=(($125+4)|0);
      var $127=HEAP32[(($126)>>2)];
      var $128=_ast_value_set_name($121, $127);
      if ($128) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      var $130=$2;
      _parseerror($130, ((STRING_TABLE.__str35607)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 29: 
      var $132=HEAP8[($isfunc)];
      var $133=(($132) & 1);
      if ($133) { __label__ = 30; break; } else { __label__ = 48; break; }
    case 30: 
      $proto=0;
      var $135=$3;
      var $136=(($135)|0)!=0;
      if ($136) { __label__ = 32; break; } else { __label__ = 31; break; }
    case 31: 
      var $138=$2;
      var $139=$2;
      var $140=(($139)|0);
      var $141=HEAP32[(($140)>>2)];
      var $142=(($141+292)|0);
      var $143=(($142+4)|0);
      var $144=HEAP32[(($143)>>2)];
      var $145=_parser_find_global($138, $144);
      $olddecl=$145;
      __label__ = 33; break;
    case 32: 
      var $147=$2;
      var $148=$2;
      var $149=(($148)|0);
      var $150=HEAP32[(($149)>>2)];
      var $151=(($150+292)|0);
      var $152=(($151+4)|0);
      var $153=HEAP32[(($152)>>2)];
      var $154=$2;
      var $155=(($154+112)|0);
      var $156=HEAP32[(($155)>>2)];
      var $157=_parser_find_local($147, $153, $156, $dummy);
      $olddecl=$157;
      __label__ = 33; break;
    case 33: 
      var $159=$olddecl;
      var $160=(($159)|0)!=0;
      if ($160) { __label__ = 34; break; } else { __label__ = 37; break; }
    case 34: 
      var $162=$olddecl;
      var $163=$162;
      var $164=(($163+12)|0);
      var $165=HEAP32[(($164)>>2)];
      var $166=(($165)|0)==2;
      if ($166) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      var $168=$2;
      var $169=$2;
      var $170=(($169)|0);
      var $171=HEAP32[(($170)>>2)];
      var $172=(($171+292)|0);
      var $173=(($172+4)|0);
      var $174=HEAP32[(($173)>>2)];
      _parseerror($168, ((STRING_TABLE.__str36608)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$174,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 36: 
      var $176=$olddecl;
      var $177=$176;
      $proto=$177;
      __label__ = 37; break;
    case 37: 
      var $179=$var;
      var $180=(($179+56)|0);
      var $181=HEAP32[(($180)>>2)];
      var $182=(($ctx)|0);
      var $183=HEAP32[(($182)>>2)];
      var $184=(($ctx+4)|0);
      var $185=HEAP32[(($184)>>2)];
      var $186=_ast_value_new($183, $185, $181, 6);
      $fval=$186;
      var $187=$fval;
      var $188=(($187)|0)!=0;
      if ($188) { __label__ = 39; break; } else { __label__ = 38; break; }
    case 38: 
      $retval=0;
      __label__ = 211; break;
    case 39: 
      var $191=$var;
      var $192=$191;
      var $193=$fval;
      var $194=(($193)|0);
      var $195=(($194+28)|0);
      HEAP32[(($195)>>2)]=$192;
      var $196=$var;
      var $197=(($196)|0);
      var $198=(($197+32)|0);
      var $199=HEAP32[(($198)>>2)];
      var $200=$fval;
      var $201=(($200)|0);
      var $202=(($201+32)|0);
      HEAP32[(($202)>>2)]=$199;
      var $203=$var;
      var $204=(($203)|0);
      var $205=(($204+36)|0);
      var $206=HEAP32[(($205)>>2)];
      var $207=$fval;
      var $208=(($207)|0);
      var $209=(($208+36)|0);
      HEAP32[(($209)>>2)]=$206;
      var $210=$var;
      var $211=(($210)|0);
      var $212=(($211+40)|0);
      var $213=HEAP32[(($212)>>2)];
      var $214=$fval;
      var $215=(($214)|0);
      var $216=(($215+40)|0);
      HEAP32[(($216)>>2)]=$213;
      var $217=$var;
      var $218=(($217)|0);
      var $219=(($218+32)|0);
      HEAP32[(($219)>>2)]=0;
      var $220=$var;
      var $221=(($220)|0);
      var $222=(($221+36)|0);
      HEAP32[(($222)>>2)]=0;
      var $223=$var;
      var $224=(($223)|0);
      var $225=(($224+40)|0);
      HEAP32[(($225)>>2)]=0;
      var $226=$var;
      var $227=(($226)|0);
      var $228=(($227+44)|0);
      var $229=HEAP8[($228)];
      var $230=(($229) & 1);
      var $231=$fval;
      var $232=(($231)|0);
      var $233=(($232+44)|0);
      var $234=(($230)&1);
      HEAP8[($233)]=$234;
      $var=0;
      var $235=$proto;
      var $236=(($235)|0)!=0;
      if ($236) { __label__ = 40; break; } else { __label__ = 47; break; }
    case 40: 
      var $238=$proto;
      var $239=$238;
      var $240=$fval;
      var $241=$240;
      var $242=_ast_compare_type($239, $241);
      if ($242) { __label__ = 42; break; } else { __label__ = 41; break; }
    case 41: 
      var $244=$2;
      var $245=$proto;
      var $246=(($245+56)|0);
      var $247=HEAP32[(($246)>>2)];
      var $248=$proto;
      var $249=$248;
      var $250=(($249)|0);
      var $251=(($250)|0);
      var $252=HEAP32[(($251)>>2)];
      var $253=$proto;
      var $254=$253;
      var $255=(($254)|0);
      var $256=(($255+4)|0);
      var $257=HEAP32[(($256)>>2)];
      _parseerror($244, ((STRING_TABLE.__str37609)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$247,HEAP32[(((tempInt)+(4))>>2)]=$252,HEAP32[(((tempInt)+(8))>>2)]=$257,tempInt));
      var $258=$fval;
      _ast_value_delete($258);
      $retval=0;
      __label__ = 211; break;
    case 42: 
      $param=0;
      __label__ = 43; break;
    case 43: 
      var $261=$param;
      var $262=$fval;
      var $263=(($262)|0);
      var $264=(($263+36)|0);
      var $265=HEAP32[(($264)>>2)];
      var $266=(($261)>>>0) < (($265)>>>0);
      if ($266) { __label__ = 44; break; } else { __label__ = 46; break; }
    case 44: 
      var $268=$param;
      var $269=$proto;
      var $270=(($269)|0);
      var $271=(($270+32)|0);
      var $272=HEAP32[(($271)>>2)];
      var $273=(($272+($268<<2))|0);
      var $274=HEAP32[(($273)>>2)];
      var $275=$param;
      var $276=$fval;
      var $277=(($276)|0);
      var $278=(($277+32)|0);
      var $279=HEAP32[(($278)>>2)];
      var $280=(($279+($275<<2))|0);
      var $281=HEAP32[(($280)>>2)];
      var $282=(($281+56)|0);
      var $283=HEAP32[(($282)>>2)];
      var $284=_ast_value_set_name($274, $283);
      __label__ = 45; break;
    case 45: 
      var $286=$param;
      var $287=((($286)+(1))|0);
      $param=$287;
      __label__ = 43; break;
    case 46: 
      var $289=$proto;
      var $290=$289;
      var $291=(($290)|0);
      var $292=$fval;
      var $293=$292;
      var $294=(($293)|0);
      var $295=$291;
      var $296=$294;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($295)>>2)]=HEAP32[(($296)>>2)];HEAP32[((($295)+(4))>>2)]=HEAP32[((($296)+(4))>>2)];
      var $297=$fval;
      _ast_value_delete($297);
      var $298=$proto;
      $fval=$298;
      $hadproto=1;
      __label__ = 47; break;
    case 47: 
      var $300=$fval;
      $var=$300;
      __label__ = 48; break;
    case 48: 
      var $302=$isfield;
      var $303=(($302) & 1);
      if ($303) { __label__ = 49; break; } else { __label__ = 50; break; }
    case 49: 
      var $305=$var;
      var $306=(($305+56)|0);
      var $307=HEAP32[(($306)>>2)];
      var $308=(($ctx)|0);
      var $309=HEAP32[(($308)>>2)];
      var $310=(($ctx+4)|0);
      var $311=HEAP32[(($310)>>2)];
      var $312=_ast_value_new($309, $311, $307, 5);
      $fld=$312;
      var $313=$var;
      var $314=$313;
      var $315=$fld;
      var $316=(($315)|0);
      var $317=(($316+28)|0);
      HEAP32[(($317)>>2)]=$314;
      var $318=$var;
      $tmp=$318;
      var $319=$fld;
      $var=$319;
      var $320=$tmp;
      $fld=$320;
      __label__ = 51; break;
    case 50: 
      var $322=$var;
      $fld=$322;
      __label__ = 51; break;
    case 51: 
      var $324=HEAP8[($isfunc)];
      var $325=(($324) & 1);
      if ($325) { __label__ = 96; break; } else { __label__ = 52; break; }
    case 52: 
      var $327=$3;
      var $328=(($327)|0)!=0;
      if ($328) { __label__ = 73; break; } else { __label__ = 53; break; }
    case 53: 
      var $330=$2;
      var $331=$var;
      var $332=(($331+56)|0);
      var $333=HEAP32[(($332)>>2)];
      var $334=_parser_find_global($330, $333);
      $olddecl=$334;
      var $335=$olddecl;
      var $336=(($335)|0)!=0;
      if ($336) { __label__ = 54; break; } else { __label__ = 60; break; }
    case 54: 
      var $338=$isfield;
      var $339=(($338) & 1);
      if ($339) { __label__ = 56; break; } else { __label__ = 55; break; }
    case 55: 
      var $341=$2;
      var $342=$var;
      var $343=(($342+56)|0);
      var $344=HEAP32[(($343)>>2)];
      var $345=$olddecl;
      var $346=$345;
      var $347=(($346)|0);
      var $348=(($347)|0);
      var $349=HEAP32[(($348)>>2)];
      var $350=$olddecl;
      var $351=$350;
      var $352=(($351)|0);
      var $353=(($352+4)|0);
      var $354=HEAP32[(($353)>>2)];
      _parseerror($341, ((STRING_TABLE.__str38610)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$344,HEAP32[(((tempInt)+(4))>>2)]=$349,HEAP32[(((tempInt)+(8))>>2)]=$354,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 56: 
      var $356=HEAP32[((_opts_standard)>>2)];
      var $357=(($356)|0)==0;
      if ($357) { __label__ = 57; break; } else { __label__ = 58; break; }
    case 57: 
      var $359=$2;
      _parseerror($359, ((STRING_TABLE.__str39611)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $360=$2;
      var $361=$var;
      var $362=(($361+56)|0);
      var $363=HEAP32[(($362)>>2)];
      var $364=$olddecl;
      var $365=$364;
      var $366=(($365)|0);
      var $367=(($366)|0);
      var $368=HEAP32[(($367)>>2)];
      var $369=$olddecl;
      var $370=$369;
      var $371=(($370)|0);
      var $372=(($371+4)|0);
      var $373=HEAP32[(($372)>>2)];
      _parseerror($360, ((STRING_TABLE.__str38610)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$363,HEAP32[(((tempInt)+(4))>>2)]=$368,HEAP32[(((tempInt)+(8))>>2)]=$373,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 58: 
      __label__ = 59; break;
    case 59: 
      __label__ = 60; break;
    case 60: 
      var $377=$2;
      var $378=$var;
      var $379=(($378+56)|0);
      var $380=HEAP32[(($379)>>2)];
      var $381=_parser_find_field($377, $380);
      $olddecl=$381;
      var $382=$olddecl;
      var $383=(($382)|0)!=0;
      if ($383) { __label__ = 61; break; } else { __label__ = 69; break; }
    case 61: 
      var $385=HEAP32[((_opts_standard)>>2)];
      var $386=(($385)|0)==0;
      if ($386) { __label__ = 62; break; } else { __label__ = 69; break; }
    case 62: 
      var $388=$isfield;
      var $389=(($388) & 1);
      if ($389) { __label__ = 64; break; } else { __label__ = 63; break; }
    case 63: 
      var $391=$2;
      _parseerror($391, ((STRING_TABLE.__str39611)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $392=$2;
      var $393=$var;
      var $394=(($393+56)|0);
      var $395=HEAP32[(($394)>>2)];
      var $396=$olddecl;
      var $397=$396;
      var $398=(($397)|0);
      var $399=(($398)|0);
      var $400=HEAP32[(($399)>>2)];
      var $401=$olddecl;
      var $402=$401;
      var $403=(($402)|0);
      var $404=(($403+4)|0);
      var $405=HEAP32[(($404)>>2)];
      _parseerror($392, ((STRING_TABLE.__str40612)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$395,HEAP32[(((tempInt)+(4))>>2)]=$400,HEAP32[(((tempInt)+(8))>>2)]=$405,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 64: 
      var $407=$2;
      var $408=$var;
      var $409=(($408+56)|0);
      var $410=HEAP32[(($409)>>2)];
      var $411=$olddecl;
      var $412=$411;
      var $413=(($412)|0);
      var $414=(($413)|0);
      var $415=HEAP32[(($414)>>2)];
      var $416=$olddecl;
      var $417=$416;
      var $418=(($417)|0);
      var $419=(($418+4)|0);
      var $420=HEAP32[(($419)>>2)];
      var $421=_parsewarning($407, 5, ((STRING_TABLE.__str40612)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$410,HEAP32[(((tempInt)+(4))>>2)]=$415,HEAP32[(((tempInt)+(8))>>2)]=$420,tempInt));
      if ($421) { __label__ = 65; break; } else { __label__ = 66; break; }
    case 65: 
      $retval=0;
      __label__ = 211; break;
    case 66: 
      var $424=$olddecl;
      var $425=$var;
      var $426=$425;
      var $427=_ast_compare_type($424, $426);
      if ($427) { __label__ = 68; break; } else { __label__ = 67; break; }
    case 67: 
      var $429=$2;
      var $430=$var;
      var $431=(($430+56)|0);
      var $432=HEAP32[(($431)>>2)];
      var $433=$olddecl;
      var $434=$433;
      var $435=(($434)|0);
      var $436=(($435)|0);
      var $437=HEAP32[(($436)>>2)];
      var $438=$olddecl;
      var $439=$438;
      var $440=(($439)|0);
      var $441=(($440+4)|0);
      var $442=HEAP32[(($441)>>2)];
      _parseerror($429, ((STRING_TABLE.__str41613)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$432,HEAP32[(((tempInt)+(4))>>2)]=$437,HEAP32[(((tempInt)+(8))>>2)]=$442,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 68: 
      var $444=$var;
      var $445=$444;
      var $446=$445;
      var $447=(($446+8)|0);
      var $448=HEAP32[(($447)>>2)];
      var $449=$var;
      var $450=$449;
      FUNCTION_TABLE[$448]($450);
      $var=0;
      __label__ = 143; break;
    case 69: 
      var $452=$olddecl;
      var $453=(($452)|0)!=0;
      if ($453) { __label__ = 70; break; } else { __label__ = 71; break; }
    case 70: 
      var $455=$2;
      var $456=$var;
      var $457=(($456+56)|0);
      var $458=HEAP32[(($457)>>2)];
      var $459=$olddecl;
      var $460=$459;
      var $461=(($460)|0);
      var $462=(($461)|0);
      var $463=HEAP32[(($462)>>2)];
      var $464=$olddecl;
      var $465=$464;
      var $466=(($465)|0);
      var $467=(($466+4)|0);
      var $468=HEAP32[(($467)>>2)];
      _parseerror($455, ((STRING_TABLE.__str40612)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$458,HEAP32[(((tempInt)+(4))>>2)]=$463,HEAP32[(((tempInt)+(8))>>2)]=$468,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 71: 
      __label__ = 72; break;
    case 72: 
      __label__ = 95; break;
    case 73: 
      var $472=$2;
      var $473=$var;
      var $474=(($473+56)|0);
      var $475=HEAP32[(($474)>>2)];
      var $476=$2;
      var $477=(($476+112)|0);
      var $478=HEAP32[(($477)>>2)];
      var $479=_parser_find_local($472, $475, $478, $isparam);
      $olddecl=$479;
      var $480=HEAP32[((_opts_standard)>>2)];
      var $481=(($480)|0)==3;
      if ($481) { __label__ = 74; break; } else { __label__ = 85; break; }
    case 74: 
      var $483=$olddecl;
      var $484=(($483)|0)!=0;
      if ($484) { __label__ = 75; break; } else { __label__ = 78; break; }
    case 75: 
      var $486=HEAP8[($isparam)];
      var $487=(($486) & 1);
      if ($487) { __label__ = 77; break; } else { __label__ = 76; break; }
    case 76: 
      var $489=$2;
      var $490=$var;
      var $491=(($490+56)|0);
      var $492=HEAP32[(($491)>>2)];
      var $493=$olddecl;
      var $494=$493;
      var $495=(($494)|0);
      var $496=(($495)|0);
      var $497=HEAP32[(($496)>>2)];
      var $498=$olddecl;
      var $499=$498;
      var $500=(($499)|0);
      var $501=(($500+4)|0);
      var $502=HEAP32[(($501)>>2)];
      _parseerror($489, ((STRING_TABLE.__str42614)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$492,HEAP32[(((tempInt)+(4))>>2)]=$497,HEAP32[(((tempInt)+(8))>>2)]=$502,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 77: 
      __label__ = 78; break;
    case 78: 
      var $505=HEAP8[($isparam)];
      var $506=(($505) & 1);
      if ($506) { __label__ = 80; break; } else { __label__ = 79; break; }
    case 79: 
      var $508=$olddecl;
      var $509=(($508)|0)!=0;
      if ($509) { __label__ = 81; break; } else { __label__ = 80; break; }
    case 80: 
      var $511=$2;
      var $512=$var;
      var $513=(($512+56)|0);
      var $514=HEAP32[(($513)>>2)];
      var $515=_parser_find_local($511, $514, 0, $isparam);
      $olddecl=$515;
      var $516=(($515)|0)!=0;
      if ($516) { __label__ = 81; break; } else { __label__ = 84; break; }
    case 81: 
      var $518=$2;
      var $519=$var;
      var $520=(($519+56)|0);
      var $521=HEAP32[(($520)>>2)];
      var $522=_parsewarning($518, 8, ((STRING_TABLE.__str43615)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$521,tempInt));
      if ($522) { __label__ = 82; break; } else { __label__ = 83; break; }
    case 82: 
      var $524=$2;
      var $525=$var;
      var $526=(($525+56)|0);
      var $527=HEAP32[(($526)>>2)];
      var $528=$olddecl;
      var $529=$528;
      var $530=(($529)|0);
      var $531=(($530)|0);
      var $532=HEAP32[(($531)>>2)];
      var $533=$olddecl;
      var $534=$533;
      var $535=(($534)|0);
      var $536=(($535+4)|0);
      var $537=HEAP32[(($536)>>2)];
      _parseerror($524, ((STRING_TABLE.__str42614)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$527,HEAP32[(((tempInt)+(4))>>2)]=$532,HEAP32[(((tempInt)+(8))>>2)]=$537,tempInt));
      $retval=0;
      __label__ = 211; break;
    case 83: 
      __label__ = 84; break;
    case 84: 
      __label__ = 94; break;
    case 85: 
      var $541=$olddecl;
      var $542=(($541)|0)!=0;
      if ($542) { __label__ = 86; break; } else { __label__ = 93; break; }
    case 86: 
      var $544=HEAP8[($isparam)];
      var $545=(($544) & 1);
      if ($545) { __label__ = 87; break; } else { __label__ = 89; break; }
    case 87: 
      var $547=$2;
      var $548=$var;
      var $549=(($548+56)|0);
      var $550=HEAP32[(($549)>>2)];
      var $551=_parsewarning($547, 8, ((STRING_TABLE.__str44616)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$550,tempInt));
      if ($551) { __label__ = 88; break; } else { __label__ = 89; break; }
    case 88: 
      var $553=$var;
      _ast_value_delete($553);
      $var=0;
      $retval=0;
      __label__ = 211; break;
    case 89: 
      var $555=HEAP8[($isparam)];
      var $556=(($555) & 1);
      if ($556) { __label__ = 91; break; } else { __label__ = 90; break; }
    case 90: 
      var $558=$2;
      var $559=$var;
      var $560=(($559+56)|0);
      var $561=HEAP32[(($560)>>2)];
      var $562=$olddecl;
      var $563=$562;
      var $564=(($563)|0);
      var $565=(($564)|0);
      var $566=HEAP32[(($565)>>2)];
      var $567=$olddecl;
      var $568=$567;
      var $569=(($568)|0);
      var $570=(($569+4)|0);
      var $571=HEAP32[(($570)>>2)];
      _parseerror($558, ((STRING_TABLE.__str42614)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$561,HEAP32[(((tempInt)+(4))>>2)]=$566,HEAP32[(((tempInt)+(8))>>2)]=$571,tempInt));
      var $572=$var;
      _ast_value_delete($572);
      $var=0;
      $retval=0;
      __label__ = 211; break;
    case 91: 
      __label__ = 92; break;
    case 92: 
      var $575=$var;
      _ast_value_delete($575);
      $var=0;
      __label__ = 143; break;
    case 93: 
      __label__ = 94; break;
    case 94: 
      __label__ = 95; break;
    case 95: 
      __label__ = 96; break;
    case 96: 
      var $580=$hadproto;
      var $581=(($580) & 1);
      if ($581) { __label__ = 142; break; } else { __label__ = 97; break; }
    case 97: 
      var $583=$var;
      var $584=(($583+56)|0);
      var $585=HEAP32[(($584)>>2)];
      var $586=_util_strdup($585);
      var $587=(($varent)|0);
      HEAP32[(($587)>>2)]=$586;
      var $588=$var;
      var $589=$588;
      var $590=(($varent+4)|0);
      HEAP32[(($590)>>2)]=$589;
      var $591=$3;
      var $592=(($591)|0)!=0;
      if ($592) { __label__ = 106; break; } else { __label__ = 98; break; }
    case 98: 
      var $594=$isfield;
      var $595=(($594) & 1);
      if ($595) { __label__ = 102; break; } else { __label__ = 99; break; }
    case 99: 
      var $597=$2;
      var $598=(($varent)|0);
      var $599=HEAP32[(($598)>>2)];
      var $600=(($varent+4)|0);
      var $601=HEAP32[(($600)>>2)];
      var $602=_parser_t_globals_add($597, $599, $601);
      var $603=(($602)&1);
      $retval=$603;
      if ($602) { __label__ = 101; break; } else { __label__ = 100; break; }
    case 100: 
      __label__ = 211; break;
    case 101: 
      __label__ = 105; break;
    case 102: 
      var $607=$2;
      var $608=(($varent)|0);
      var $609=HEAP32[(($608)>>2)];
      var $610=(($varent+4)|0);
      var $611=HEAP32[(($610)>>2)];
      var $612=_parser_t_fields_add($607, $609, $611);
      var $613=(($612)&1);
      $retval=$613;
      if ($612) { __label__ = 104; break; } else { __label__ = 103; break; }
    case 103: 
      __label__ = 211; break;
    case 104: 
      __label__ = 105; break;
    case 105: 
      __label__ = 111; break;
    case 106: 
      var $618=$2;
      var $619=(($varent)|0);
      var $620=HEAP32[(($619)>>2)];
      var $621=(($varent+4)|0);
      var $622=HEAP32[(($621)>>2)];
      var $623=_parser_t_locals_add($618, $620, $622);
      var $624=(($623)&1);
      $retval=$624;
      if ($623) { __label__ = 108; break; } else { __label__ = 107; break; }
    case 107: 
      __label__ = 211; break;
    case 108: 
      var $627=$3;
      var $628=$var;
      var $629=_ast_block_locals_add($627, $628);
      var $630=(($629)&1);
      $retval=$630;
      if ($629) { __label__ = 110; break; } else { __label__ = 109; break; }
    case 109: 
      var $632=$2;
      var $633=(($632+104)|0);
      var $634=HEAP32[(($633)>>2)];
      var $635=((($634)-(1))|0);
      HEAP32[(($633)>>2)]=$635;
      __label__ = 211; break;
    case 110: 
      __label__ = 111; break;
    case 111: 
      var $638=$fld;
      var $639=(($638)|0);
      var $640=(($639+24)|0);
      var $641=HEAP32[(($640)>>2)];
      var $642=(($641)|0)==3;
      if ($642) { __label__ = 112; break; } else { __label__ = 141; break; }
    case 112: 
      var $644=$2;
      var $645=$var;
      var $646=(($ve)|0);
      var $647=_create_vector_members($644, $645, $646);
      if ($647) { __label__ = 114; break; } else { __label__ = 113; break; }
    case 113: 
      $retval=0;
      __label__ = 211; break;
    case 114: 
      var $650=$3;
      var $651=(($650)|0)!=0;
      if ($651) { __label__ = 129; break; } else { __label__ = 115; break; }
    case 115: 
      $e=0;
      __label__ = 116; break;
    case 116: 
      var $654=$e;
      var $655=(($654)>>>0) < 3;
      if ($655) { __label__ = 117; break; } else { __label__ = 126; break; }
    case 117: 
      var $657=$isfield;
      var $658=(($657) & 1);
      if ($658) { __label__ = 121; break; } else { __label__ = 118; break; }
    case 118: 
      var $660=$2;
      var $661=$e;
      var $662=(($ve+($661<<3))|0);
      var $663=(($662)|0);
      var $664=HEAP32[(($663)>>2)];
      var $665=(($662+4)|0);
      var $666=HEAP32[(($665)>>2)];
      var $667=_parser_t_globals_add($660, $664, $666);
      var $668=(($667)&1);
      $retval=$668;
      if ($667) { __label__ = 120; break; } else { __label__ = 119; break; }
    case 119: 
      __label__ = 126; break;
    case 120: 
      __label__ = 124; break;
    case 121: 
      var $672=$2;
      var $673=$e;
      var $674=(($ve+($673<<3))|0);
      var $675=(($674)|0);
      var $676=HEAP32[(($675)>>2)];
      var $677=(($674+4)|0);
      var $678=HEAP32[(($677)>>2)];
      var $679=_parser_t_fields_add($672, $676, $678);
      var $680=(($679)&1);
      $retval=$680;
      if ($679) { __label__ = 123; break; } else { __label__ = 122; break; }
    case 122: 
      __label__ = 126; break;
    case 123: 
      __label__ = 124; break;
    case 124: 
      __label__ = 125; break;
    case 125: 
      var $685=$e;
      var $686=((($685)+(1))|0);
      $e=$686;
      __label__ = 116; break;
    case 126: 
      var $688=$retval;
      var $689=(($688) & 1);
      if ($689) { __label__ = 128; break; } else { __label__ = 127; break; }
    case 127: 
      var $691=$e;
      var $692=((($691)+(1))|0);
      var $693=$2;
      var $694=(($693+12)|0);
      var $695=HEAP32[(($694)>>2)];
      var $696=((($695)-($692))|0);
      HEAP32[(($694)>>2)]=$696;
      __label__ = 211; break;
    case 128: 
      __label__ = 140; break;
    case 129: 
      $e=0;
      __label__ = 130; break;
    case 130: 
      var $700=$e;
      var $701=(($700)>>>0) < 3;
      if ($701) { __label__ = 131; break; } else { __label__ = 137; break; }
    case 131: 
      var $703=$2;
      var $704=$e;
      var $705=(($ve+($704<<3))|0);
      var $706=(($705)|0);
      var $707=HEAP32[(($706)>>2)];
      var $708=(($705+4)|0);
      var $709=HEAP32[(($708)>>2)];
      var $710=_parser_t_locals_add($703, $707, $709);
      var $711=(($710)&1);
      $retval=$711;
      if ($710) { __label__ = 133; break; } else { __label__ = 132; break; }
    case 132: 
      __label__ = 137; break;
    case 133: 
      var $714=$3;
      var $715=$e;
      var $716=(($ve+($715<<3))|0);
      var $717=(($716+4)|0);
      var $718=HEAP32[(($717)>>2)];
      var $719=_ast_block_collect($714, $718);
      var $720=(($719)&1);
      $retval=$720;
      if ($719) { __label__ = 135; break; } else { __label__ = 134; break; }
    case 134: 
      __label__ = 137; break;
    case 135: 
      var $723=$e;
      var $724=(($ve+($723<<3))|0);
      var $725=(($724+4)|0);
      HEAP32[(($725)>>2)]=0;
      __label__ = 136; break;
    case 136: 
      var $727=$e;
      var $728=((($727)+(1))|0);
      $e=$728;
      __label__ = 130; break;
    case 137: 
      var $730=$retval;
      var $731=(($730) & 1);
      if ($731) { __label__ = 139; break; } else { __label__ = 138; break; }
    case 138: 
      var $733=$e;
      var $734=((($733)+(1))|0);
      var $735=$2;
      var $736=(($735+104)|0);
      var $737=HEAP32[(($736)>>2)];
      var $738=((($737)-($734))|0);
      HEAP32[(($736)>>2)]=$738;
      var $739=$3;
      var $740=(($739+60)|0);
      var $741=HEAP32[(($740)>>2)];
      var $742=((($741)-(1))|0);
      HEAP32[(($740)>>2)]=$742;
      __label__ = 211; break;
    case 139: 
      __label__ = 140; break;
    case 140: 
      var $745=(($ve+16)|0);
      var $746=(($745)|0);
      HEAP32[(($746)>>2)]=0;
      var $747=(($ve+8)|0);
      var $748=(($747)|0);
      HEAP32[(($748)>>2)]=0;
      var $749=(($ve)|0);
      var $750=(($749)|0);
      HEAP32[(($750)>>2)]=0;
      var $751=(($ve+16)|0);
      var $752=(($751+4)|0);
      HEAP32[(($752)>>2)]=0;
      var $753=(($ve+8)|0);
      var $754=(($753+4)|0);
      HEAP32[(($754)>>2)]=0;
      var $755=(($ve)|0);
      var $756=(($755+4)|0);
      HEAP32[(($756)>>2)]=0;
      __label__ = 141; break;
    case 141: 
      $cleanvar=0;
      var $758=(($varent)|0);
      HEAP32[(($758)>>2)]=0;
      __label__ = 142; break;
    case 142: 
      __label__ = 143; break;
    case 143: 
      var $761=$2;
      var $762=_parser_next($761);
      var $763=(($762)&1);
      $retval=$763;
      if ($762) { __label__ = 145; break; } else { __label__ = 144; break; }
    case 144: 
      __label__ = 211; break;
    case 145: 
      var $766=$2;
      var $767=(($766+4)|0);
      var $768=HEAP32[(($767)>>2)];
      var $769=(($768)|0)==59;
      if ($769) { __label__ = 146; break; } else { __label__ = 147; break; }
    case 146: 
      var $771=$typevar;
      _ast_value_delete($771);
      var $772=$2;
      var $773=_parser_next($772);
      $1=$773;
      __label__ = 229; break;
    case 147: 
      var $775=$2;
      var $776=(($775+4)|0);
      var $777=HEAP32[(($776)>>2)];
      var $778=(($777)|0)==44;
      if ($778) { __label__ = 148; break; } else { __label__ = 151; break; }
    case 148: 
      var $780=$2;
      var $781=_parser_next($780);
      var $782=(($781)&1);
      $retval=$782;
      if ($781) { __label__ = 150; break; } else { __label__ = 149; break; }
    case 149: 
      __label__ = 211; break;
    case 150: 
      __label__ = 11; break;
    case 151: 
      var $786=$3;
      var $787=(($786)|0)!=0;
      if ($787) { __label__ = 154; break; } else { __label__ = 152; break; }
    case 152: 
      var $789=$isfield;
      var $790=(($789) & 1);
      if ($790) { __label__ = 153; break; } else { __label__ = 154; break; }
    case 153: 
      var $792=$2;
      _parseerror($792, ((STRING_TABLE.__str45617)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $793=$typevar;
      _ast_value_delete($793);
      $1=0;
      __label__ = 229; break;
    case 154: 
      var $795=$3;
      var $796=(($795)|0)!=0;
      if ($796) { __label__ = 155; break; } else { __label__ = 159; break; }
    case 155: 
      var $798=HEAP32[((_opts_standard)>>2)];
      var $799=(($798)|0)==0;
      if ($799) { __label__ = 156; break; } else { __label__ = 159; break; }
    case 156: 
      var $801=$2;
      var $802=$var;
      var $803=(($802+56)|0);
      var $804=HEAP32[(($803)>>2)];
      var $805=_parsewarning($801, 9, ((STRING_TABLE.__str46618)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$804,tempInt));
      if ($805) { __label__ = 157; break; } else { __label__ = 158; break; }
    case 157: 
      var $807=$typevar;
      _ast_value_delete($807);
      $1=0;
      __label__ = 229; break;
    case 158: 
      __label__ = 159; break;
    case 159: 
      var $810=$2;
      var $811=(($810+4)|0);
      var $812=HEAP32[(($811)>>2)];
      var $813=(($812)|0)!=61;
      if ($813) { __label__ = 160; break; } else { __label__ = 164; break; }
    case 160: 
      var $815=HEAP32[((_opts_standard)>>2)];
      var $816=(($815)|0)==0;
      if ($816) { __label__ = 161; break; } else { __label__ = 162; break; }
    case 161: 
      var $818=$2;
      _parseerror($818, ((STRING_TABLE.__str45617)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 163; break;
    case 162: 
      var $820=$2;
      _parseerror($820, ((STRING_TABLE.__str47619)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 163; break;
    case 163: 
      var $822=$typevar;
      _ast_value_delete($822);
      $1=0;
      __label__ = 229; break;
    case 164: 
      var $824=$2;
      var $825=_parser_next($824);
      if ($825) { __label__ = 166; break; } else { __label__ = 165; break; }
    case 165: 
      var $827=$typevar;
      _ast_value_delete($827);
      $1=0;
      __label__ = 229; break;
    case 166: 
      var $829=$2;
      var $830=(($829+4)|0);
      var $831=HEAP32[(($830)>>2)];
      var $832=(($831)|0)==35;
      if ($832) { __label__ = 167; break; } else { __label__ = 184; break; }
    case 167: 
      var $834=$3;
      var $835=(($834)|0)!=0;
      if ($835) { __label__ = 168; break; } else { __label__ = 169; break; }
    case 168: 
      var $837=$2;
      _parseerror($837, ((STRING_TABLE.__str48620)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $838=$typevar;
      _ast_value_delete($838);
      $1=0;
      __label__ = 229; break;
    case 169: 
      var $840=HEAP8[($isfunc)];
      var $841=(($840) & 1);
      if ($841) { __label__ = 171; break; } else { __label__ = 170; break; }
    case 170: 
      var $843=$2;
      var $844=$var;
      var $845=(($844+56)|0);
      var $846=HEAP32[(($845)>>2)];
      _parseerror($843, ((STRING_TABLE.__str49621)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$846,tempInt));
      var $847=$typevar;
      _ast_value_delete($847);
      $1=0;
      __label__ = 229; break;
    case 171: 
      var $849=$2;
      var $850=_parser_next($849);
      if ($850) { __label__ = 173; break; } else { __label__ = 172; break; }
    case 172: 
      var $852=$2;
      _parseerror($852, ((STRING_TABLE.__str50622)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $853=$typevar;
      _ast_value_delete($853);
      $1=0;
      __label__ = 229; break;
    case 173: 
      var $855=$2;
      var $856=(($855+4)|0);
      var $857=HEAP32[(($856)>>2)];
      var $858=(($857)|0)!=137;
      if ($858) { __label__ = 174; break; } else { __label__ = 175; break; }
    case 174: 
      var $860=$2;
      _parseerror($860, ((STRING_TABLE.__str51623)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $861=$typevar;
      _ast_value_delete($861);
      $1=0;
      __label__ = 229; break;
    case 175: 
      var $863=$2;
      var $864=(($863)|0);
      var $865=HEAP32[(($864)>>2)];
      var $866=(($865+292)|0);
      var $867=(($866+16)|0);
      var $868=$867;
      var $869=HEAP32[(($868)>>2)];
      var $870=(($869)|0) <= 0;
      if ($870) { __label__ = 176; break; } else { __label__ = 177; break; }
    case 176: 
      var $872=$2;
      _parseerror($872, ((STRING_TABLE.__str52624)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $873=$typevar;
      _ast_value_delete($873);
      $1=0;
      __label__ = 229; break;
    case 177: 
      var $875=$var;
      var $876=$875;
      var $877=(($876)|0);
      var $878=$var;
      var $879=(($878+56)|0);
      var $880=HEAP32[(($879)>>2)];
      var $881=$var;
      var $882=(($877)|0);
      var $883=HEAP32[(($882)>>2)];
      var $884=(($877+4)|0);
      var $885=HEAP32[(($884)>>2)];
      var $886=_ast_function_new($883, $885, $880, $881);
      $func=$886;
      var $887=$func;
      var $888=(($887)|0)!=0;
      if ($888) { __label__ = 179; break; } else { __label__ = 178; break; }
    case 178: 
      var $890=$2;
      var $891=$var;
      var $892=(($891+56)|0);
      var $893=HEAP32[(($892)>>2)];
      _parseerror($890, ((STRING_TABLE.__str53625)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$893,tempInt));
      var $894=$typevar;
      _ast_value_delete($894);
      $1=0;
      __label__ = 229; break;
    case 179: 
      var $896=$2;
      var $897=$func;
      var $898=_parser_t_functions_add($896, $897);
      if ($898) { __label__ = 181; break; } else { __label__ = 180; break; }
    case 180: 
      var $900=$2;
      var $901=$var;
      var $902=(($901+56)|0);
      var $903=HEAP32[(($902)>>2)];
      _parseerror($900, ((STRING_TABLE.__str54626)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$903,tempInt));
      var $904=$func;
      _ast_function_delete($904);
      var $905=$var;
      var $906=(($905+64)|0);
      var $907=$906;
      HEAP32[(($907)>>2)]=0;
      var $908=$typevar;
      _ast_value_delete($908);
      $1=0;
      __label__ = 229; break;
    case 181: 
      var $910=$2;
      var $911=(($910)|0);
      var $912=HEAP32[(($911)>>2)];
      var $913=(($912+292)|0);
      var $914=(($913+16)|0);
      var $915=$914;
      var $916=HEAP32[(($915)>>2)];
      var $917=(((-$916))|0);
      var $918=$func;
      var $919=(($918+28)|0);
      HEAP32[(($919)>>2)]=$917;
      var $920=$2;
      var $921=_parser_next($920);
      if ($921) { __label__ = 183; break; } else { __label__ = 182; break; }
    case 182: 
      var $923=$typevar;
      _ast_value_delete($923);
      $1=0;
      __label__ = 229; break;
    case 183: 
      __label__ = 206; break;
    case 184: 
      var $926=$2;
      var $927=(($926+4)|0);
      var $928=HEAP32[(($927)>>2)];
      var $929=(($928)|0)==123;
      if ($929) { __label__ = 186; break; } else { __label__ = 185; break; }
    case 185: 
      var $931=$2;
      var $932=(($931+4)|0);
      var $933=HEAP32[(($932)>>2)];
      var $934=(($933)|0)==91;
      if ($934) { __label__ = 186; break; } else { __label__ = 191; break; }
    case 186: 
      var $936=$typevar;
      _ast_value_delete($936);
      var $937=$3;
      var $938=(($937)|0)!=0;
      if ($938) { __label__ = 187; break; } else { __label__ = 188; break; }
    case 187: 
      var $940=$2;
      _parseerror($940, ((STRING_TABLE.__str55627)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 229; break;
    case 188: 
      var $942=$2;
      var $943=$var;
      var $944=_parse_function_body($942, $943);
      if ($944) { __label__ = 190; break; } else { __label__ = 189; break; }
    case 189: 
      $1=0;
      __label__ = 229; break;
    case 190: 
      $1=1;
      __label__ = 229; break;
    case 191: 
      var $948=$2;
      var $949=_parse_expression_leave($948, 1);
      $cexp=$949;
      var $950=$cexp;
      var $951=(($950)|0)!=0;
      if ($951) { __label__ = 193; break; } else { __label__ = 192; break; }
    case 192: 
      var $953=$typevar;
      _ast_value_delete($953);
      $1=0;
      __label__ = 229; break;
    case 193: 
      var $955=$cexp;
      var $956=$955;
      $cval=$956;
      var $957=$cval;
      var $958=$957;
      var $959=(($958+12)|0);
      var $960=HEAP32[(($959)>>2)];
      var $961=(($960)|0)==2;
      if ($961) { __label__ = 194; break; } else { __label__ = 195; break; }
    case 194: 
      var $963=$cval;
      var $964=(($963+60)|0);
      var $965=HEAP8[($964)];
      var $966=(($965) & 1);
      if ($966) { __label__ = 196; break; } else { __label__ = 195; break; }
    case 195: 
      var $968=$2;
      _parseerror($968, ((STRING_TABLE.__str56628)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 204; break;
    case 196: 
      var $970=$var;
      var $971=(($970+60)|0);
      HEAP8[($971)]=1;
      var $972=$cval;
      var $973=(($972)|0);
      var $974=(($973+24)|0);
      var $975=HEAP32[(($974)>>2)];
      var $976=(($975)|0)==1;
      if ($976) { __label__ = 197; break; } else { __label__ = 198; break; }
    case 197: 
      var $978=$cval;
      var $979=(($978+64)|0);
      var $980=$979;
      var $981=HEAP32[(($980)>>2)];
      var $982=_parser_strdup($981);
      var $983=$var;
      var $984=(($983+64)|0);
      var $985=$984;
      HEAP32[(($985)>>2)]=$982;
      __label__ = 199; break;
    case 198: 
      var $987=$var;
      var $988=(($987+64)|0);
      var $989=$988;
      var $990=$cval;
      var $991=(($990+64)|0);
      var $992=$991;
      assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($989)>>2)]=HEAP32[(($992)>>2)];HEAP32[((($989)+(4))>>2)]=HEAP32[((($992)+(4))>>2)];HEAP32[((($989)+(8))>>2)]=HEAP32[((($992)+(8))>>2)];
      __label__ = 199; break;
    case 199: 
      __label__ = 200; break;
    case 200: 
      var $995=$cval;
      var $996=$995;
      var $997=$996;
      var $998=(($997+16)|0);
      var $999=HEAP8[($998)];
      var $1000=(($999) & 1);
      if ($1000) { __label__ = 202; break; } else { __label__ = 201; break; }
    case 201: 
      var $1002=$cval;
      var $1003=$1002;
      var $1004=$1003;
      var $1005=(($1004+8)|0);
      var $1006=HEAP32[(($1005)>>2)];
      var $1007=$cval;
      var $1008=$1007;
      FUNCTION_TABLE[$1006]($1008);
      __label__ = 202; break;
    case 202: 
      __label__ = 203; break;
    case 203: 
      __label__ = 204; break;
    case 204: 
      __label__ = 205; break;
    case 205: 
      __label__ = 206; break;
    case 206: 
      var $1014=$2;
      var $1015=(($1014+4)|0);
      var $1016=HEAP32[(($1015)>>2)];
      var $1017=(($1016)|0)==44;
      if ($1017) { __label__ = 207; break; } else { __label__ = 208; break; }
    case 207: 
      __label__ = 11; break;
    case 208: 
      var $1020=$2;
      var $1021=(($1020+4)|0);
      var $1022=HEAP32[(($1021)>>2)];
      var $1023=(($1022)|0)!=59;
      if ($1023) { __label__ = 209; break; } else { __label__ = 210; break; }
    case 209: 
      var $1025=$2;
      _parseerror($1025, ((STRING_TABLE.__str45617)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $1026=$typevar;
      _ast_value_delete($1026);
      $1=0;
      __label__ = 229; break;
    case 210: 
      var $1028=$2;
      var $1029=_parser_next($1028);
      var $1030=$typevar;
      _ast_value_delete($1030);
      $1=1;
      __label__ = 229; break;
    case 211: 
      var $1032=$typevar;
      var $1033=$1032;
      var $1034=$1033;
      var $1035=(($1034+8)|0);
      var $1036=HEAP32[(($1035)>>2)];
      var $1037=$typevar;
      var $1038=$1037;
      FUNCTION_TABLE[$1036]($1038);
      var $1039=$var;
      var $1040=(($1039)|0)!=0;
      if ($1040) { __label__ = 212; break; } else { __label__ = 214; break; }
    case 212: 
      var $1042=$cleanvar;
      var $1043=(($1042) & 1);
      if ($1043) { __label__ = 213; break; } else { __label__ = 214; break; }
    case 213: 
      var $1045=$var;
      var $1046=$1045;
      var $1047=$1046;
      var $1048=(($1047+8)|0);
      var $1049=HEAP32[(($1048)>>2)];
      var $1050=$var;
      var $1051=$1050;
      FUNCTION_TABLE[$1049]($1051);
      __label__ = 214; break;
    case 214: 
      var $1053=(($varent)|0);
      var $1054=HEAP32[(($1053)>>2)];
      var $1055=(($1054)|0)!=0;
      if ($1055) { __label__ = 215; break; } else { __label__ = 216; break; }
    case 215: 
      var $1057=(($varent)|0);
      var $1058=HEAP32[(($1057)>>2)];
      _util_memory_d($1058, 2794, ((STRING_TABLE.__str572)|0));
      __label__ = 216; break;
    case 216: 
      var $1060=(($ve)|0);
      var $1061=(($1060)|0);
      var $1062=HEAP32[(($1061)>>2)];
      var $1063=(($1062)|0)!=0;
      if ($1063) { __label__ = 217; break; } else { __label__ = 218; break; }
    case 217: 
      var $1065=(($ve)|0);
      var $1066=(($1065)|0);
      var $1067=HEAP32[(($1066)>>2)];
      _util_memory_d($1067, 2795, ((STRING_TABLE.__str572)|0));
      __label__ = 218; break;
    case 218: 
      var $1069=(($ve+8)|0);
      var $1070=(($1069)|0);
      var $1071=HEAP32[(($1070)>>2)];
      var $1072=(($1071)|0)!=0;
      if ($1072) { __label__ = 219; break; } else { __label__ = 220; break; }
    case 219: 
      var $1074=(($ve+8)|0);
      var $1075=(($1074)|0);
      var $1076=HEAP32[(($1075)>>2)];
      _util_memory_d($1076, 2796, ((STRING_TABLE.__str572)|0));
      __label__ = 220; break;
    case 220: 
      var $1078=(($ve+16)|0);
      var $1079=(($1078)|0);
      var $1080=HEAP32[(($1079)>>2)];
      var $1081=(($1080)|0)!=0;
      if ($1081) { __label__ = 221; break; } else { __label__ = 222; break; }
    case 221: 
      var $1083=(($ve+16)|0);
      var $1084=(($1083)|0);
      var $1085=HEAP32[(($1084)>>2)];
      _util_memory_d($1085, 2797, ((STRING_TABLE.__str572)|0));
      __label__ = 222; break;
    case 222: 
      var $1087=(($ve)|0);
      var $1088=(($1087+4)|0);
      var $1089=HEAP32[(($1088)>>2)];
      var $1090=(($1089)|0)!=0;
      if ($1090) { __label__ = 223; break; } else { __label__ = 224; break; }
    case 223: 
      var $1092=(($ve)|0);
      var $1093=(($1092+4)|0);
      var $1094=HEAP32[(($1093)>>2)];
      var $1095=$1094;
      _util_memory_d($1095, 2798, ((STRING_TABLE.__str572)|0));
      __label__ = 224; break;
    case 224: 
      var $1097=(($ve+8)|0);
      var $1098=(($1097+4)|0);
      var $1099=HEAP32[(($1098)>>2)];
      var $1100=(($1099)|0)!=0;
      if ($1100) { __label__ = 225; break; } else { __label__ = 226; break; }
    case 225: 
      var $1102=(($ve+8)|0);
      var $1103=(($1102+4)|0);
      var $1104=HEAP32[(($1103)>>2)];
      var $1105=$1104;
      _util_memory_d($1105, 2799, ((STRING_TABLE.__str572)|0));
      __label__ = 226; break;
    case 226: 
      var $1107=(($ve+16)|0);
      var $1108=(($1107+4)|0);
      var $1109=HEAP32[(($1108)>>2)];
      var $1110=(($1109)|0)!=0;
      if ($1110) { __label__ = 227; break; } else { __label__ = 228; break; }
    case 227: 
      var $1112=(($ve+16)|0);
      var $1113=(($1112+4)|0);
      var $1114=HEAP32[(($1113)>>2)];
      var $1115=$1114;
      _util_memory_d($1115, 2800, ((STRING_TABLE.__str572)|0));
      __label__ = 228; break;
    case 228: 
      var $1117=$retval;
      var $1118=(($1117) & 1);
      $1=$1118;
      __label__ = 229; break;
    case 229: 
      var $1120=$1;
      STACKTOP = __stackBase__;
      return $1120;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_variable["X"]=1;

function _parse_type($parser, $basetype, $isfunc) {
  var __stackBase__  = STACKTOP; STACKTOP += 24; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $params=__stackBase__;
      var $var;
      var $ctx=(__stackBase__)+(12);
      var $vtype;
      var $temptype;
      var $i;
      var $variadic;
      var $param;
      var $fld;
      var $isfield;
      var $isfuncparam=(__stackBase__)+(20);
      var $fval;
      $2=$parser;
      $3=$basetype;
      $4=$isfunc;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=$ctx;
      var $11=$9;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$3;
      $vtype=$12;
      $variadic=0;
      var $13=(($params)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=(($params+4)|0);
      HEAP32[(($14)>>2)]=0;
      var $15=(($params+8)|0);
      HEAP32[(($15)>>2)]=0;
      var $16=$4;
      HEAP8[($16)]=0;
      var $17=$2;
      var $18=(($17+4)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($19)|0)==40;
      if ($20) { __label__ = 3; break; } else { __label__ = 48; break; }
    case 3: 
      var $22=$4;
      HEAP8[($22)]=1;
      __label__ = 4; break;
    case 4: 
      $isfield=0;
      HEAP8[($isfuncparam)]=0;
      var $24=$2;
      var $25=_parser_next($24);
      if ($25) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      __label__ = 53; break;
    case 6: 
      var $28=$2;
      var $29=(($28+4)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30)|0)==41;
      if ($31) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      __label__ = 45; break;
    case 8: 
      var $34=$2;
      var $35=(($34+4)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36)|0)==46;
      if ($37) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      $isfield=1;
      var $39=$2;
      var $40=_parser_next($39);
      if ($40) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $42=$2;
      _parseerror($42, ((STRING_TABLE.__str165)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 53; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $45=$2;
      var $46=(($45+4)|0);
      var $47=HEAP32[(($46)>>2)];
      var $48=(($47)|0)==133;
      if ($48) { __label__ = 13; break; } else { __label__ = 22; break; }
    case 13: 
      $variadic=1;
      var $50=$2;
      var $51=_parser_next($50);
      if ($51) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      __label__ = 53; break;
    case 15: 
      var $54=$2;
      var $55=(($54+4)|0);
      var $56=HEAP32[(($55)>>2)];
      var $57=(($56)|0)!=41;
      if ($57) { __label__ = 16; break; } else { __label__ = 17; break; }
    case 16: 
      var $59=$2;
      _parseerror($59, ((STRING_TABLE.__str166)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 53; break;
    case 17: 
      var $61=HEAP32[((_opts_standard)>>2)];
      var $62=(($61)|0)==0;
      if ($62) { __label__ = 18; break; } else { __label__ = 21; break; }
    case 18: 
      var $64=$2;
      var $65=_parsewarning($64, 4, ((STRING_TABLE.__str167)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($65) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      __label__ = 53; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      __label__ = 45; break;
    case 22: 
      var $70=$2;
      var $71=(($70)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=(($72+292)|0);
      var $74=(($73+16)|0);
      var $75=$74;
      var $76=HEAP32[(($75)>>2)];
      $temptype=$76;
      var $77=$2;
      var $78=_parser_next($77);
      if ($78) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      __label__ = 53; break;
    case 24: 
      var $81=$2;
      var $82=$temptype;
      var $83=_parse_type($81, $82, $isfuncparam);
      $param=$83;
      var $84=$param;
      var $85=(($84)|0)!=0;
      if ($85) { __label__ = 26; break; } else { __label__ = 25; break; }
    case 25: 
      __label__ = 53; break;
    case 26: 
      var $88=$2;
      var $89=(($88+4)|0);
      var $90=HEAP32[(($89)>>2)];
      var $91=(($90)|0)==129;
      if ($91) { __label__ = 27; break; } else { __label__ = 32; break; }
    case 27: 
      var $93=$param;
      var $94=$2;
      var $95=(($94)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=(($96+292)|0);
      var $98=(($97+4)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=_ast_value_set_name($93, $99);
      if ($100) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      __label__ = 53; break;
    case 29: 
      var $103=$2;
      var $104=_parser_next($103);
      if ($104) { __label__ = 31; break; } else { __label__ = 30; break; }
    case 30: 
      __label__ = 53; break;
    case 31: 
      __label__ = 32; break;
    case 32: 
      var $108=HEAP8[($isfuncparam)];
      var $109=(($108) & 1);
      if ($109) { __label__ = 33; break; } else { __label__ = 36; break; }
    case 33: 
      var $111=$param;
      var $112=$111;
      var $113=(($112)|0);
      var $114=$param;
      var $115=(($114+56)|0);
      var $116=HEAP32[(($115)>>2)];
      var $117=(($113)|0);
      var $118=HEAP32[(($117)>>2)];
      var $119=(($113+4)|0);
      var $120=HEAP32[(($119)>>2)];
      var $121=_ast_value_new($118, $120, $116, 6);
      $fval=$121;
      var $122=$fval;
      var $123=(($122)|0)!=0;
      if ($123) { __label__ = 35; break; } else { __label__ = 34; break; }
    case 34: 
      var $125=$param;
      var $126=$125;
      var $127=$126;
      var $128=(($127+8)|0);
      var $129=HEAP32[(($128)>>2)];
      var $130=$param;
      var $131=$130;
      FUNCTION_TABLE[$129]($131);
      __label__ = 53; break;
    case 35: 
      var $133=$param;
      var $134=$133;
      var $135=$fval;
      var $136=(($135)|0);
      var $137=(($136+28)|0);
      HEAP32[(($137)>>2)]=$134;
      var $138=$param;
      var $139=(($138)|0);
      var $140=(($139+32)|0);
      var $141=HEAP32[(($140)>>2)];
      var $142=$fval;
      var $143=(($142)|0);
      var $144=(($143+32)|0);
      HEAP32[(($144)>>2)]=$141;
      var $145=$param;
      var $146=(($145)|0);
      var $147=(($146+36)|0);
      var $148=HEAP32[(($147)>>2)];
      var $149=$fval;
      var $150=(($149)|0);
      var $151=(($150+36)|0);
      HEAP32[(($151)>>2)]=$148;
      var $152=$param;
      var $153=(($152)|0);
      var $154=(($153+40)|0);
      var $155=HEAP32[(($154)>>2)];
      var $156=$fval;
      var $157=(($156)|0);
      var $158=(($157+40)|0);
      HEAP32[(($158)>>2)]=$155;
      var $159=$param;
      var $160=(($159)|0);
      var $161=(($160+32)|0);
      HEAP32[(($161)>>2)]=0;
      var $162=$param;
      var $163=(($162)|0);
      var $164=(($163+36)|0);
      HEAP32[(($164)>>2)]=0;
      var $165=$param;
      var $166=(($165)|0);
      var $167=(($166+40)|0);
      HEAP32[(($167)>>2)]=0;
      var $168=$param;
      var $169=(($168)|0);
      var $170=(($169+44)|0);
      var $171=HEAP8[($170)];
      var $172=(($171) & 1);
      var $173=$fval;
      var $174=(($173)|0);
      var $175=(($174+44)|0);
      var $176=(($172)&1);
      HEAP8[($175)]=$176;
      var $177=$fval;
      $param=$177;
      __label__ = 36; break;
    case 36: 
      var $179=$isfield;
      var $180=(($179) & 1);
      if ($180) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      var $182=$param;
      var $183=(($182+56)|0);
      var $184=HEAP32[(($183)>>2)];
      var $185=(($ctx)|0);
      var $186=HEAP32[(($185)>>2)];
      var $187=(($ctx+4)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=_ast_value_new($186, $188, $184, 5);
      $fld=$189;
      var $190=$param;
      var $191=$190;
      var $192=$fld;
      var $193=(($192)|0);
      var $194=(($193+28)|0);
      HEAP32[(($194)>>2)]=$191;
      var $195=$fld;
      $param=$195;
      __label__ = 38; break;
    case 38: 
      var $197=$param;
      var $198=_paramlist_t_p_add($params, $197);
      if ($198) { __label__ = 40; break; } else { __label__ = 39; break; }
    case 39: 
      var $200=$2;
      _parseerror($200, ((STRING_TABLE.__str168)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 53; break;
    case 40: 
      var $202=$2;
      var $203=(($202+4)|0);
      var $204=HEAP32[(($203)>>2)];
      var $205=(($204)|0)==44;
      if ($205) { __label__ = 41; break; } else { __label__ = 42; break; }
    case 41: 
      __label__ = 4; break;
    case 42: 
      var $208=$2;
      var $209=(($208+4)|0);
      var $210=HEAP32[(($209)>>2)];
      var $211=(($210)|0)==41;
      if ($211) { __label__ = 43; break; } else { __label__ = 44; break; }
    case 43: 
      __label__ = 45; break;
    case 44: 
      var $214=$2;
      _parseerror($214, ((STRING_TABLE.__str169)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 53; break;
    case 45: 
      var $216=$2;
      var $217=_parser_next($216);
      if ($217) { __label__ = 47; break; } else { __label__ = 46; break; }
    case 46: 
      __label__ = 53; break;
    case 47: 
      __label__ = 48; break;
    case 48: 
      var $221=(($params+4)|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=(($222)>>>0) > 8;
      if ($223) { __label__ = 49; break; } else { __label__ = 50; break; }
    case 49: 
      var $225=$2;
      _parseerror($225, ((STRING_TABLE.__str170)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 50; break;
    case 50: 
      var $227=$vtype;
      var $228=(($ctx)|0);
      var $229=HEAP32[(($228)>>2)];
      var $230=(($ctx+4)|0);
      var $231=HEAP32[(($230)>>2)];
      var $232=_ast_value_new($229, $231, ((STRING_TABLE.__str171)|0), $227);
      $var=$232;
      var $233=$var;
      var $234=(($233)|0)!=0;
      if ($234) { __label__ = 52; break; } else { __label__ = 51; break; }
    case 51: 
      __label__ = 53; break;
    case 52: 
      var $237=$variadic;
      var $238=(($237) & 1);
      var $239=$var;
      var $240=(($239)|0);
      var $241=(($240+44)|0);
      var $242=(($238)&1);
      HEAP8[($241)]=$242;
      var $243=(($params)|0);
      var $244=HEAP32[(($243)>>2)];
      var $245=$var;
      var $246=(($245)|0);
      var $247=(($246+32)|0);
      HEAP32[(($247)>>2)]=$244;
      var $248=(($params+4)|0);
      var $249=HEAP32[(($248)>>2)];
      var $250=$var;
      var $251=(($250)|0);
      var $252=(($251+36)|0);
      HEAP32[(($252)>>2)]=$249;
      var $253=(($params+8)|0);
      var $254=HEAP32[(($253)>>2)];
      var $255=$var;
      var $256=(($255)|0);
      var $257=(($256+40)|0);
      HEAP32[(($257)>>2)]=$254;
      var $258=(($params)|0);
      HEAP32[(($258)>>2)]=0;
      var $259=(($params+4)|0);
      HEAP32[(($259)>>2)]=0;
      var $260=(($params+8)|0);
      HEAP32[(($260)>>2)]=0;
      var $261=$var;
      $1=$261;
      __label__ = 60; break;
    case 53: 
      $i=0;
      __label__ = 54; break;
    case 54: 
      var $264=$i;
      var $265=(($params+4)|0);
      var $266=HEAP32[(($265)>>2)];
      var $267=(($264)>>>0) < (($266)>>>0);
      if ($267) { __label__ = 55; break; } else { __label__ = 57; break; }
    case 55: 
      var $269=$i;
      var $270=(($params)|0);
      var $271=HEAP32[(($270)>>2)];
      var $272=(($271+($269<<2))|0);
      var $273=HEAP32[(($272)>>2)];
      _ast_value_delete($273);
      __label__ = 56; break;
    case 56: 
      var $275=$i;
      var $276=((($275)+(1))|0);
      $i=$276;
      __label__ = 54; break;
    case 57: 
      var $278=(($params)|0);
      var $279=HEAP32[(($278)>>2)];
      var $280=(($279)|0)!=0;
      if ($280) { __label__ = 58; break; } else { __label__ = 59; break; }
    case 58: 
      var $282=(($params)|0);
      var $283=HEAP32[(($282)>>2)];
      var $284=$283;
      _util_memory_d($284, 430, ((STRING_TABLE.__str572)|0));
      __label__ = 59; break;
    case 59: 
      var $286=(($params)|0);
      HEAP32[(($286)>>2)]=0;
      var $287=(($params+4)|0);
      HEAP32[(($287)>>2)]=0;
      var $288=(($params+8)|0);
      HEAP32[(($288)>>2)]=0;
      $1=0;
      __label__ = 60; break;
    case 60: 
      var $290=$1;
      STACKTOP = __stackBase__;
      return $290;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_type["X"]=1;

function _parsewarning($parser, $warntype, $fmt) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ap=__stackBase__;
      var $lvl;
      $2=$parser;
      $3=$warntype;
      $4=$fmt;
      $lvl=1;
      var $5=$3;
      var $6=((((($5)|0))/(32))&-1);
      var $7=((_opts_warn+($6<<2))|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=$3;
      var $10=((($9)|0))%(32);
      var $11=1 << $10;
      var $12=$8 & $11;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $16=HEAP8[(_opts_werror)];
      var $17=(($16) & 1);
      if ($17) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $19=$2;
      var $20=(($19+116)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=((($21)+(1))|0);
      HEAP32[(($20)>>2)]=$22;
      $lvl=2;
      __label__ = 6; break;
    case 6: 
      var $24=$ap;
      HEAP32[(($24)>>2)]=arguments[_parsewarning.length];
      var $25=$lvl;
      var $26=$2;
      var $27=(($26)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28+292)|0);
      var $30=(($29+28)|0);
      var $31=(($30)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$2;
      var $34=(($33)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+292)|0);
      var $37=(($36+28)|0);
      var $38=(($37+4)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=$4;
      var $41=HEAP32[(($ap)>>2)];
      _vprintmsg($25, $32, $39, ((STRING_TABLE.__str28600)|0), $40, $41);
      var $42=$ap;
      ;
      var $43=HEAP8[(_opts_werror)];
      var $44=(($43) & 1);
      $1=$44;
      __label__ = 7; break;
    case 7: 
      var $46=$1;
      STACKTOP = __stackBase__;
      return $46;
    default: assert(0, "bad label: " + __label__);
  }
}
_parsewarning["X"]=1;

function _parser_find_global($parser, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$parser;
      $3=$name;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+12)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+8)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<3))|0);
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$3;
      var $19=_strcmp($17, $18);
      var $20=(($19)|0)!=0;
      if ($20) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $22=$i;
      var $23=$2;
      var $24=(($23+8)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+($22<<3))|0);
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      $1=0;
      __label__ = 9; break;
    case 9: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_find_local($parser, $name, $upto, $isparam) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $5;
      var $i;
      $2=$parser;
      $3=$name;
      $4=$upto;
      $5=$isparam;
      var $6=$5;
      HEAP8[($6)]=0;
      var $7=$2;
      var $8=(($7+104)|0);
      var $9=HEAP32[(($8)>>2)];
      $i=$9;
      __label__ = 3; break;
    case 3: 
      var $11=$i;
      var $12=$4;
      var $13=(($11)>>>0) > (($12)>>>0);
      if ($13) { __label__ = 4; break; } else { __label__ = 7; break; }
    case 4: 
      var $15=$i;
      var $16=((($15)-(1))|0);
      $i=$16;
      var $17=$i;
      var $18=$2;
      var $19=(($18+100)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20+($17<<3))|0);
      var $22=(($21)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=$3;
      var $25=_strcmp($23, $24);
      var $26=(($25)|0)!=0;
      if ($26) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $28=$i;
      var $29=$2;
      var $30=(($29+100)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=(($31+($28<<3))|0);
      var $33=(($32+4)|0);
      var $34=HEAP32[(($33)>>2)];
      $1=$34;
      __label__ = 8; break;
    case 6: 
      __label__ = 3; break;
    case 7: 
      var $37=$5;
      HEAP8[($37)]=1;
      var $38=$2;
      var $39=$3;
      var $40=_parser_find_param($38, $39);
      $1=$40;
      __label__ = 8; break;
    case 8: 
      var $42=$1;
      ;
      return $42;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_find_local["X"]=1;

function _parser_find_field($parser, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      $2=$parser;
      $3=$name;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+24)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<3))|0);
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$3;
      var $19=_strcmp($17, $18);
      var $20=(($19)|0)!=0;
      if ($20) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $22=$i;
      var $23=$2;
      var $24=(($23+20)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+($22<<3))|0);
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 9; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      $1=0;
      __label__ = 9; break;
    case 9: 
      var $35=$1;
      ;
      return $35;
    default: assert(0, "bad label: " + __label__);
  }
}


function _create_vector_members($parser, $var, $ve) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $i;
      var $len;
      $2=$parser;
      $3=$var;
      $4=$ve;
      var $5=$3;
      var $6=(($5+56)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=_strlen($7);
      $len=$8;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $10=$i;
      var $11=(($10)>>>0) < 3;
      if ($11) { __label__ = 4; break; } else { __label__ = 10; break; }
    case 4: 
      var $13=$3;
      var $14=$13;
      var $15=(($14)|0);
      var $16=$3;
      var $17=$16;
      var $18=$i;
      var $19=(($15)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($15+4)|0);
      var $22=HEAP32[(($21)>>2)];
      var $23=_ast_member_new($20, $22, $17, $18);
      var $24=$23;
      var $25=$i;
      var $26=$4;
      var $27=(($26+($25<<3))|0);
      var $28=(($27+4)|0);
      HEAP32[(($28)>>2)]=$24;
      var $29=$i;
      var $30=$4;
      var $31=(($30+($29<<3))|0);
      var $32=(($31+4)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33)|0)!=0;
      if ($34) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      __label__ = 10; break;
    case 6: 
      var $37=$len;
      var $38=((($37)+(3))|0);
      var $39=_util_memory_a($38, 1937, ((STRING_TABLE.__str572)|0));
      var $40=$i;
      var $41=$4;
      var $42=(($41+($40<<3))|0);
      var $43=(($42)|0);
      HEAP32[(($43)>>2)]=$39;
      var $44=$i;
      var $45=$4;
      var $46=(($45+($44<<3))|0);
      var $47=(($46)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48)|0)!=0;
      if ($49) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $51=$i;
      var $52=$4;
      var $53=(($52+($51<<3))|0);
      var $54=(($53+4)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$55;
      var $57=$56;
      var $58=(($57+8)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=$i;
      var $61=$4;
      var $62=(($61+($60<<3))|0);
      var $63=(($62+4)|0);
      var $64=HEAP32[(($63)>>2)];
      var $65=$64;
      FUNCTION_TABLE[$59]($65);
      __label__ = 10; break;
    case 8: 
      var $67=$i;
      var $68=$4;
      var $69=(($68+($67<<3))|0);
      var $70=(($69)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$3;
      var $73=(($72+56)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=$len;
      assert($75 % 1 === 0, 'memcpy given ' + $75 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($71, $74, $75, 1);
      var $76=$len;
      var $77=$i;
      var $78=$4;
      var $79=(($78+($77<<3))|0);
      var $80=(($79)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81+$76)|0);
      HEAP8[($82)]=95;
      var $83=$i;
      var $84=((($83)+(120))|0);
      var $85=(($84) & 255);
      var $86=$len;
      var $87=((($86)+(1))|0);
      var $88=$i;
      var $89=$4;
      var $90=(($89+($88<<3))|0);
      var $91=(($90)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=(($92+$87)|0);
      HEAP8[($93)]=$85;
      var $94=$len;
      var $95=((($94)+(2))|0);
      var $96=$i;
      var $97=$4;
      var $98=(($97+($96<<3))|0);
      var $99=(($98)|0);
      var $100=HEAP32[(($99)>>2)];
      var $101=(($100+$95)|0);
      HEAP8[($101)]=0;
      __label__ = 9; break;
    case 9: 
      var $103=$i;
      var $104=((($103)+(1))|0);
      $i=$104;
      __label__ = 3; break;
    case 10: 
      var $106=$i;
      var $107=(($106)|0)==3;
      if ($107) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      $1=1;
      __label__ = 16; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $111=$i;
      var $112=((($111)-(1))|0);
      $i=$112;
      var $113=$i;
      var $114=$4;
      var $115=(($114+($113<<3))|0);
      var $116=(($115)|0);
      var $117=HEAP32[(($116)>>2)];
      _util_memory_d($117, 1954, ((STRING_TABLE.__str572)|0));
      var $118=$i;
      var $119=$4;
      var $120=(($119+($118<<3))|0);
      var $121=(($120+4)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=$122;
      var $124=$123;
      var $125=(($124+8)|0);
      var $126=HEAP32[(($125)>>2)];
      var $127=$i;
      var $128=$4;
      var $129=(($128+($127<<3))|0);
      var $130=(($129+4)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=$131;
      FUNCTION_TABLE[$126]($132);
      var $133=$i;
      var $134=$4;
      var $135=(($134+($133<<3))|0);
      var $136=(($135)|0);
      HEAP32[(($136)>>2)]=0;
      var $137=$i;
      var $138=$4;
      var $139=(($138+($137<<3))|0);
      var $140=(($139+4)|0);
      HEAP32[(($140)>>2)]=0;
      __label__ = 14; break;
    case 14: 
      var $142=$i;
      var $143=(($142)|0)!=0;
      if ($143) { __label__ = 13; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 16; break;
    case 16: 
      var $146=$1;
      ;
      return $146;
    default: assert(0, "bad label: " + __label__);
  }
}
_create_vector_members["X"]=1;

// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.

function _parse_function_body($parser, $var) {
  var __stackBase__  = STACKTOP; STACKTOP += 40; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $block;
      var $func;
      var $old;
      var $parami;
      var $framenum;
      var $nextthink;
      var $fld_think;
      var $fld_nextthink;
      var $fld_frame;
      var $gbl_time;
      var $gbl_self;
      var $has_frame_think;
      var $retval;
      var $varent=__stackBase__;
      var $thinkfunc;
      var $functype;
      var $ctx=(__stackBase__)+(8);
      var $self_frame;
      var $self_nextthink;
      var $self_think;
      var $time_plus_1;
      var $store_frame;
      var $store_nextthink;
      var $store_think;
      var $e;
      var $ve=(__stackBase__)+(16);
      var $param;
      $2=$parser;
      $3=$var;
      $block=0;
      $framenum=0;
      $nextthink=0;
      $fld_think=0;
      $fld_nextthink=0;
      $fld_frame=0;
      $gbl_time=0;
      $gbl_self=0;
      $retval=1;
      $has_frame_think=0;
      var $4=$2;
      var $5=(($4+96)|0);
      var $6=HEAP32[(($5)>>2)];
      $old=$6;
      var $7=$3;
      var $8=(($7)|0);
      var $9=(($8+44)|0);
      var $10=HEAP8[($9)];
      var $11=(($10) & 1);
      if ($11) { __label__ = 3; break; } else { __label__ = 6; break; }
    case 3: 
      var $13=$2;
      var $14=_parsewarning($13, 12, ((STRING_TABLE.__str103675)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($14) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      $1=0;
      __label__ = 198; break;
    case 5: 
      __label__ = 6; break;
    case 6: 
      var $18=$2;
      var $19=(($18+4)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20)|0)==91;
      if ($21) { __label__ = 7; break; } else { __label__ = 88; break; }
    case 7: 
      $nextthink=0;
      var $23=$2;
      var $24=_parser_find_field($23, ((STRING_TABLE.__str104676)|0));
      $fld_think=$24;
      var $25=$2;
      var $26=_parser_find_field($25, ((STRING_TABLE.__str105677)|0));
      $fld_nextthink=$26;
      var $27=$2;
      var $28=_parser_find_field($27, ((STRING_TABLE.__str106678)|0));
      $fld_frame=$28;
      var $29=$fld_think;
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 8; break; } else { __label__ = 10; break; }
    case 8: 
      var $32=$fld_nextthink;
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $35=$fld_frame;
      var $36=(($35)|0)!=0;
      if ($36) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $38=$2;
      _parseerror($38, ((STRING_TABLE.__str107679)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $39=$2;
      _parseerror($39, ((STRING_TABLE.__str108680)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 198; break;
    case 11: 
      var $41=$2;
      var $42=_parser_find_global($41, ((STRING_TABLE.__str109681)|0));
      $gbl_time=$42;
      var $43=$2;
      var $44=_parser_find_global($43, ((STRING_TABLE.__str110682)|0));
      $gbl_self=$44;
      var $45=$gbl_time;
      var $46=(($45)|0)!=0;
      if ($46) { __label__ = 12; break; } else { __label__ = 13; break; }
    case 12: 
      var $48=$gbl_self;
      var $49=(($48)|0)!=0;
      if ($49) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      var $51=$2;
      _parseerror($51, ((STRING_TABLE.__str111683)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $52=$2;
      _parseerror($52, ((STRING_TABLE.__str112684)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 198; break;
    case 14: 
      var $54=$2;
      var $55=_parser_next($54);
      if ($55) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 198; break;
    case 16: 
      var $58=$2;
      var $59=_parse_expression_leave($58, 1);
      $framenum=$59;
      var $60=$framenum;
      var $61=(($60)|0)!=0;
      if ($61) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $63=$2;
      _parseerror($63, ((STRING_TABLE.__str113685)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 198; break;
    case 18: 
      var $65=$framenum;
      var $66=$65;
      var $67=(($66+12)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=(($68)|0)==2;
      if ($69) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $71=$framenum;
      var $72=$71;
      var $73=(($72+60)|0);
      var $74=HEAP8[($73)];
      var $75=(($74) & 1);
      if ($75) { __label__ = 25; break; } else { __label__ = 20; break; }
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $78=$framenum;
      var $79=$78;
      var $80=$79;
      var $81=(($80+16)|0);
      var $82=HEAP8[($81)];
      var $83=(($82) & 1);
      if ($83) { __label__ = 23; break; } else { __label__ = 22; break; }
    case 22: 
      var $85=$framenum;
      var $86=$85;
      var $87=$86;
      var $88=(($87+8)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$framenum;
      var $91=$90;
      FUNCTION_TABLE[$89]($91);
      __label__ = 23; break;
    case 23: 
      __label__ = 24; break;
    case 24: 
      var $94=$2;
      _parseerror($94, ((STRING_TABLE.__str114686)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 198; break;
    case 25: 
      var $96=$2;
      var $97=(($96+4)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=(($98)|0)!=44;
      if ($99) { __label__ = 26; break; } else { __label__ = 31; break; }
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $102=$framenum;
      var $103=$102;
      var $104=$103;
      var $105=(($104+16)|0);
      var $106=HEAP8[($105)];
      var $107=(($106) & 1);
      if ($107) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      var $109=$framenum;
      var $110=$109;
      var $111=$110;
      var $112=(($111+8)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$framenum;
      var $115=$114;
      FUNCTION_TABLE[$113]($115);
      __label__ = 29; break;
    case 29: 
      __label__ = 30; break;
    case 30: 
      var $118=$2;
      _parseerror($118, ((STRING_TABLE.__str115687)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $119=$2;
      var $120=$2;
      var $121=(($120+4)|0);
      var $122=HEAP32[(($121)>>2)];
      _parseerror($119, ((STRING_TABLE.__str116688)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$122,tempInt));
      $1=0;
      __label__ = 198; break;
    case 31: 
      var $124=$2;
      var $125=_parser_next($124);
      if ($125) { __label__ = 37; break; } else { __label__ = 32; break; }
    case 32: 
      __label__ = 33; break;
    case 33: 
      var $128=$framenum;
      var $129=$128;
      var $130=$129;
      var $131=(($130+16)|0);
      var $132=HEAP8[($131)];
      var $133=(($132) & 1);
      if ($133) { __label__ = 35; break; } else { __label__ = 34; break; }
    case 34: 
      var $135=$framenum;
      var $136=$135;
      var $137=$136;
      var $138=(($137+8)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=$framenum;
      var $141=$140;
      FUNCTION_TABLE[$139]($141);
      __label__ = 35; break;
    case 35: 
      __label__ = 36; break;
    case 36: 
      $1=0;
      __label__ = 198; break;
    case 37: 
      var $145=$2;
      var $146=(($145+4)|0);
      var $147=HEAP32[(($146)>>2)];
      var $148=(($147)|0)==129;
      if ($148) { __label__ = 38; break; } else { __label__ = 59; break; }
    case 38: 
      var $150=$2;
      var $151=$2;
      var $152=(($151)|0);
      var $153=HEAP32[(($152)>>2)];
      var $154=(($153+292)|0);
      var $155=(($154+4)|0);
      var $156=HEAP32[(($155)>>2)];
      var $157=_parser_find_var($150, $156);
      var $158=(($157)|0)!=0;
      if ($158) { __label__ = 59; break; } else { __label__ = 39; break; }
    case 39: 
      var $160=$fld_think;
      var $161=$160;
      var $162=(($161+28)|0);
      var $163=HEAP32[(($162)>>2)];
      $functype=$163;
      var $164=$2;
      var $165=(($164)|0);
      var $166=HEAP32[(($165)>>2)];
      var $167=(($166+292)|0);
      var $168=(($167+28)|0);
      var $169=$2;
      var $170=(($169)|0);
      var $171=HEAP32[(($170)>>2)];
      var $172=(($171+292)|0);
      var $173=(($172+4)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=$functype;
      var $176=$175;
      var $177=(($176+24)|0);
      var $178=HEAP32[(($177)>>2)];
      var $179=(($168)|0);
      var $180=HEAP32[(($179)>>2)];
      var $181=(($168+4)|0);
      var $182=HEAP32[(($181)>>2)];
      var $183=_ast_value_new($180, $182, $174, $178);
      $thinkfunc=$183;
      var $184=$thinkfunc;
      var $185=(($184)|0)!=0;
      if ($185) { __label__ = 40; break; } else { __label__ = 41; break; }
    case 40: 
      var $187=$thinkfunc;
      var $188=$187;
      var $189=$functype;
      var $190=_ast_type_adopt_impl($188, $189);
      if ($190) { __label__ = 46; break; } else { __label__ = 41; break; }
    case 41: 
      __label__ = 42; break;
    case 42: 
      var $193=$framenum;
      var $194=$193;
      var $195=$194;
      var $196=(($195+16)|0);
      var $197=HEAP8[($196)];
      var $198=(($197) & 1);
      if ($198) { __label__ = 44; break; } else { __label__ = 43; break; }
    case 43: 
      var $200=$framenum;
      var $201=$200;
      var $202=$201;
      var $203=(($202+8)|0);
      var $204=HEAP32[(($203)>>2)];
      var $205=$framenum;
      var $206=$205;
      FUNCTION_TABLE[$204]($206);
      __label__ = 44; break;
    case 44: 
      __label__ = 45; break;
    case 45: 
      var $209=$2;
      var $210=$2;
      var $211=(($210)|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=(($212+292)|0);
      var $214=(($213+4)|0);
      var $215=HEAP32[(($214)>>2)];
      _parseerror($209, ((STRING_TABLE.__str117689)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$215,tempInt));
      $1=0;
      __label__ = 198; break;
    case 46: 
      var $217=$2;
      var $218=_parser_next($217);
      if ($218) { __label__ = 52; break; } else { __label__ = 47; break; }
    case 47: 
      __label__ = 48; break;
    case 48: 
      var $221=$framenum;
      var $222=$221;
      var $223=$222;
      var $224=(($223+16)|0);
      var $225=HEAP8[($224)];
      var $226=(($225) & 1);
      if ($226) { __label__ = 50; break; } else { __label__ = 49; break; }
    case 49: 
      var $228=$framenum;
      var $229=$228;
      var $230=$229;
      var $231=(($230+8)|0);
      var $232=HEAP32[(($231)>>2)];
      var $233=$framenum;
      var $234=$233;
      FUNCTION_TABLE[$232]($234);
      __label__ = 50; break;
    case 50: 
      __label__ = 51; break;
    case 51: 
      var $237=$thinkfunc;
      var $238=$237;
      var $239=$238;
      var $240=(($239+8)|0);
      var $241=HEAP32[(($240)>>2)];
      var $242=$thinkfunc;
      var $243=$242;
      FUNCTION_TABLE[$241]($243);
      $1=0;
      __label__ = 198; break;
    case 52: 
      var $245=$thinkfunc;
      var $246=$245;
      var $247=(($varent+4)|0);
      HEAP32[(($247)>>2)]=$246;
      var $248=$thinkfunc;
      var $249=(($248+56)|0);
      var $250=HEAP32[(($249)>>2)];
      var $251=_util_strdup($250);
      var $252=(($varent)|0);
      HEAP32[(($252)>>2)]=$251;
      var $253=$2;
      var $254=(($varent)|0);
      var $255=HEAP32[(($254)>>2)];
      var $256=(($varent+4)|0);
      var $257=HEAP32[(($256)>>2)];
      var $258=_parser_t_globals_add($253, $255, $257);
      if ($258) { __label__ = 58; break; } else { __label__ = 53; break; }
    case 53: 
      __label__ = 54; break;
    case 54: 
      var $261=$framenum;
      var $262=$261;
      var $263=$262;
      var $264=(($263+16)|0);
      var $265=HEAP8[($264)];
      var $266=(($265) & 1);
      if ($266) { __label__ = 56; break; } else { __label__ = 55; break; }
    case 55: 
      var $268=$framenum;
      var $269=$268;
      var $270=$269;
      var $271=(($270+8)|0);
      var $272=HEAP32[(($271)>>2)];
      var $273=$framenum;
      var $274=$273;
      FUNCTION_TABLE[$272]($274);
      __label__ = 56; break;
    case 56: 
      __label__ = 57; break;
    case 57: 
      var $277=$thinkfunc;
      var $278=$277;
      var $279=$278;
      var $280=(($279+8)|0);
      var $281=HEAP32[(($280)>>2)];
      var $282=$thinkfunc;
      var $283=$282;
      FUNCTION_TABLE[$281]($283);
      $1=0;
      __label__ = 198; break;
    case 58: 
      var $285=$thinkfunc;
      var $286=$285;
      $nextthink=$286;
      __label__ = 66; break;
    case 59: 
      var $288=$2;
      var $289=_parse_expression_leave($288, 1);
      $nextthink=$289;
      var $290=$nextthink;
      var $291=(($290)|0)!=0;
      if ($291) { __label__ = 65; break; } else { __label__ = 60; break; }
    case 60: 
      __label__ = 61; break;
    case 61: 
      var $294=$framenum;
      var $295=$294;
      var $296=$295;
      var $297=(($296+16)|0);
      var $298=HEAP8[($297)];
      var $299=(($298) & 1);
      if ($299) { __label__ = 63; break; } else { __label__ = 62; break; }
    case 62: 
      var $301=$framenum;
      var $302=$301;
      var $303=$302;
      var $304=(($303+8)|0);
      var $305=HEAP32[(($304)>>2)];
      var $306=$framenum;
      var $307=$306;
      FUNCTION_TABLE[$305]($307);
      __label__ = 63; break;
    case 63: 
      __label__ = 64; break;
    case 64: 
      var $310=$2;
      _parseerror($310, ((STRING_TABLE.__str118690)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 198; break;
    case 65: 
      __label__ = 66; break;
    case 66: 
      var $313=$nextthink;
      var $314=$313;
      var $315=(($314+12)|0);
      var $316=HEAP32[(($315)>>2)];
      var $317=(($316)|0)==2;
      if ($317) { __label__ = 68; break; } else { __label__ = 67; break; }
    case 67: 
      var $319=$2;
      _parseerror($319, ((STRING_TABLE.__str119691)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 68; break;
    case 68: 
      var $321=$retval;
      var $322=(($321) & 1);
      if ($322) { __label__ = 69; break; } else { __label__ = 71; break; }
    case 69: 
      var $324=$2;
      var $325=(($324+4)|0);
      var $326=HEAP32[(($325)>>2)];
      var $327=(($326)|0)!=93;
      if ($327) { __label__ = 70; break; } else { __label__ = 71; break; }
    case 70: 
      var $329=$2;
      _parseerror($329, ((STRING_TABLE.__str120692)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 71; break;
    case 71: 
      var $331=$retval;
      var $332=(($331) & 1);
      if ($332) { __label__ = 72; break; } else { __label__ = 74; break; }
    case 72: 
      var $334=$2;
      var $335=_parser_next($334);
      if ($335) { __label__ = 74; break; } else { __label__ = 73; break; }
    case 73: 
      $retval=0;
      __label__ = 74; break;
    case 74: 
      var $338=$retval;
      var $339=(($338) & 1);
      if ($339) { __label__ = 75; break; } else { __label__ = 77; break; }
    case 75: 
      var $341=$2;
      var $342=(($341+4)|0);
      var $343=HEAP32[(($342)>>2)];
      var $344=(($343)|0)!=123;
      if ($344) { __label__ = 76; break; } else { __label__ = 77; break; }
    case 76: 
      var $346=$2;
      _parseerror($346, ((STRING_TABLE.__str121693)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $retval=0;
      __label__ = 77; break;
    case 77: 
      var $348=$retval;
      var $349=(($348) & 1);
      if ($349) { __label__ = 87; break; } else { __label__ = 78; break; }
    case 78: 
      __label__ = 79; break;
    case 79: 
      var $352=$nextthink;
      var $353=$352;
      var $354=$353;
      var $355=(($354+16)|0);
      var $356=HEAP8[($355)];
      var $357=(($356) & 1);
      if ($357) { __label__ = 81; break; } else { __label__ = 80; break; }
    case 80: 
      var $359=$nextthink;
      var $360=$359;
      var $361=$360;
      var $362=(($361+8)|0);
      var $363=HEAP32[(($362)>>2)];
      var $364=$nextthink;
      var $365=$364;
      FUNCTION_TABLE[$363]($365);
      __label__ = 81; break;
    case 81: 
      __label__ = 82; break;
    case 82: 
      __label__ = 83; break;
    case 83: 
      var $369=$framenum;
      var $370=$369;
      var $371=$370;
      var $372=(($371+16)|0);
      var $373=HEAP8[($372)];
      var $374=(($373) & 1);
      if ($374) { __label__ = 85; break; } else { __label__ = 84; break; }
    case 84: 
      var $376=$framenum;
      var $377=$376;
      var $378=$377;
      var $379=(($378+8)|0);
      var $380=HEAP32[(($379)>>2)];
      var $381=$framenum;
      var $382=$381;
      FUNCTION_TABLE[$380]($382);
      __label__ = 85; break;
    case 85: 
      __label__ = 86; break;
    case 86: 
      $1=0;
      __label__ = 198; break;
    case 87: 
      $has_frame_think=1;
      __label__ = 88; break;
    case 88: 
      var $387=$2;
      var $388=(($387)|0);
      var $389=HEAP32[(($388)>>2)];
      var $390=(($389+292)|0);
      var $391=(($390+28)|0);
      var $392=(($391)|0);
      var $393=HEAP32[(($392)>>2)];
      var $394=(($391+4)|0);
      var $395=HEAP32[(($394)>>2)];
      var $396=_ast_block_new($393, $395);
      $block=$396;
      var $397=$block;
      var $398=(($397)|0)!=0;
      if ($398) { __label__ = 100; break; } else { __label__ = 89; break; }
    case 89: 
      var $400=$2;
      _parseerror($400, ((STRING_TABLE.__str122694)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $401=$has_frame_think;
      var $402=(($401) & 1);
      if ($402) { __label__ = 90; break; } else { __label__ = 99; break; }
    case 90: 
      __label__ = 91; break;
    case 91: 
      var $405=$nextthink;
      var $406=$405;
      var $407=$406;
      var $408=(($407+16)|0);
      var $409=HEAP8[($408)];
      var $410=(($409) & 1);
      if ($410) { __label__ = 93; break; } else { __label__ = 92; break; }
    case 92: 
      var $412=$nextthink;
      var $413=$412;
      var $414=$413;
      var $415=(($414+8)|0);
      var $416=HEAP32[(($415)>>2)];
      var $417=$nextthink;
      var $418=$417;
      FUNCTION_TABLE[$416]($418);
      __label__ = 93; break;
    case 93: 
      __label__ = 94; break;
    case 94: 
      __label__ = 95; break;
    case 95: 
      var $422=$framenum;
      var $423=$422;
      var $424=$423;
      var $425=(($424+16)|0);
      var $426=HEAP8[($425)];
      var $427=(($426) & 1);
      if ($427) { __label__ = 97; break; } else { __label__ = 96; break; }
    case 96: 
      var $429=$framenum;
      var $430=$429;
      var $431=$430;
      var $432=(($431+8)|0);
      var $433=HEAP32[(($432)>>2)];
      var $434=$framenum;
      var $435=$434;
      FUNCTION_TABLE[$433]($435);
      __label__ = 97; break;
    case 97: 
      __label__ = 98; break;
    case 98: 
      __label__ = 99; break;
    case 99: 
      $1=0;
      __label__ = 198; break;
    case 100: 
      var $440=$has_frame_think;
      var $441=(($440) & 1);
      if ($441) { __label__ = 101; break; } else { __label__ = 150; break; }
    case 101: 
      var $443=$2;
      var $444=(($443)|0);
      var $445=HEAP32[(($444)>>2)];
      var $446=(($445+292)|0);
      var $447=(($446+28)|0);
      var $448=$ctx;
      var $449=$447;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($448)>>2)]=HEAP32[(($449)>>2)];HEAP32[((($448)+(4))>>2)]=HEAP32[((($449)+(4))>>2)];
      var $450=$gbl_self;
      var $451=$fld_frame;
      var $452=(($ctx)|0);
      var $453=HEAP32[(($452)>>2)];
      var $454=(($ctx+4)|0);
      var $455=HEAP32[(($454)>>2)];
      var $456=_ast_entfield_new($453, $455, $450, $451);
      var $457=$456;
      $self_frame=$457;
      var $458=$gbl_self;
      var $459=$fld_nextthink;
      var $460=(($ctx)|0);
      var $461=HEAP32[(($460)>>2)];
      var $462=(($ctx+4)|0);
      var $463=HEAP32[(($462)>>2)];
      var $464=_ast_entfield_new($461, $463, $458, $459);
      var $465=$464;
      $self_nextthink=$465;
      var $466=$gbl_self;
      var $467=$fld_think;
      var $468=(($ctx)|0);
      var $469=HEAP32[(($468)>>2)];
      var $470=(($ctx+4)|0);
      var $471=HEAP32[(($470)>>2)];
      var $472=_ast_entfield_new($469, $471, $466, $467);
      var $473=$472;
      $self_think=$473;
      var $474=$gbl_time;
      var $475=$2;
      var $476=_parser_const_float($475, 0.1);
      var $477=$476;
      var $478=(($ctx)|0);
      var $479=HEAP32[(($478)>>2)];
      var $480=(($ctx+4)|0);
      var $481=HEAP32[(($480)>>2)];
      var $482=_ast_binary_new($479, $481, 6, $474, $477);
      var $483=$482;
      $time_plus_1=$483;
      var $484=$self_frame;
      var $485=(($484)|0)!=0;
      if ($485) { __label__ = 102; break; } else { __label__ = 105; break; }
    case 102: 
      var $487=$self_nextthink;
      var $488=(($487)|0)!=0;
      if ($488) { __label__ = 103; break; } else { __label__ = 105; break; }
    case 103: 
      var $490=$self_think;
      var $491=(($490)|0)!=0;
      if ($491) { __label__ = 104; break; } else { __label__ = 105; break; }
    case 104: 
      var $493=$time_plus_1;
      var $494=(($493)|0)!=0;
      if ($494) { __label__ = 114; break; } else { __label__ = 105; break; }
    case 105: 
      var $496=$self_frame;
      var $497=(($496)|0)!=0;
      if ($497) { __label__ = 106; break; } else { __label__ = 107; break; }
    case 106: 
      var $499=$self_frame;
      var $500=$499;
      var $501=$500;
      var $502=(($501+8)|0);
      var $503=HEAP32[(($502)>>2)];
      var $504=$self_frame;
      var $505=$504;
      FUNCTION_TABLE[$503]($505);
      __label__ = 107; break;
    case 107: 
      var $507=$self_nextthink;
      var $508=(($507)|0)!=0;
      if ($508) { __label__ = 108; break; } else { __label__ = 109; break; }
    case 108: 
      var $510=$self_nextthink;
      var $511=$510;
      var $512=$511;
      var $513=(($512+8)|0);
      var $514=HEAP32[(($513)>>2)];
      var $515=$self_nextthink;
      var $516=$515;
      FUNCTION_TABLE[$514]($516);
      __label__ = 109; break;
    case 109: 
      var $518=$self_think;
      var $519=(($518)|0)!=0;
      if ($519) { __label__ = 110; break; } else { __label__ = 111; break; }
    case 110: 
      var $521=$self_think;
      var $522=$521;
      var $523=$522;
      var $524=(($523+8)|0);
      var $525=HEAP32[(($524)>>2)];
      var $526=$self_think;
      var $527=$526;
      FUNCTION_TABLE[$525]($527);
      __label__ = 111; break;
    case 111: 
      var $529=$time_plus_1;
      var $530=(($529)|0)!=0;
      if ($530) { __label__ = 112; break; } else { __label__ = 113; break; }
    case 112: 
      var $532=$time_plus_1;
      var $533=$532;
      var $534=$533;
      var $535=(($534+8)|0);
      var $536=HEAP32[(($535)>>2)];
      var $537=$time_plus_1;
      var $538=$537;
      FUNCTION_TABLE[$536]($538);
      __label__ = 113; break;
    case 113: 
      $retval=0;
      __label__ = 114; break;
    case 114: 
      var $541=$retval;
      var $542=(($541) & 1);
      if ($542) { __label__ = 115; break; } else { __label__ = 139; break; }
    case 115: 
      var $544=$self_frame;
      var $545=$framenum;
      var $546=(($ctx)|0);
      var $547=HEAP32[(($546)>>2)];
      var $548=(($ctx+4)|0);
      var $549=HEAP32[(($548)>>2)];
      var $550=_ast_store_new($547, $549, 37, $544, $545);
      $store_frame=$550;
      var $551=$self_nextthink;
      var $552=$time_plus_1;
      var $553=(($ctx)|0);
      var $554=HEAP32[(($553)>>2)];
      var $555=(($ctx+4)|0);
      var $556=HEAP32[(($555)>>2)];
      var $557=_ast_store_new($554, $556, 37, $551, $552);
      $store_nextthink=$557;
      var $558=$self_think;
      var $559=$nextthink;
      var $560=(($ctx)|0);
      var $561=HEAP32[(($560)>>2)];
      var $562=(($ctx+4)|0);
      var $563=HEAP32[(($562)>>2)];
      var $564=_ast_store_new($561, $563, 42, $558, $559);
      $store_think=$564;
      var $565=$store_frame;
      var $566=(($565)|0)!=0;
      if ($566) { __label__ = 117; break; } else { __label__ = 116; break; }
    case 116: 
      var $568=$self_frame;
      var $569=$568;
      var $570=$569;
      var $571=(($570+8)|0);
      var $572=HEAP32[(($571)>>2)];
      var $573=$self_frame;
      var $574=$573;
      FUNCTION_TABLE[$572]($574);
      $retval=0;
      __label__ = 117; break;
    case 117: 
      var $576=$store_nextthink;
      var $577=(($576)|0)!=0;
      if ($577) { __label__ = 119; break; } else { __label__ = 118; break; }
    case 118: 
      var $579=$self_nextthink;
      var $580=$579;
      var $581=$580;
      var $582=(($581+8)|0);
      var $583=HEAP32[(($582)>>2)];
      var $584=$self_nextthink;
      var $585=$584;
      FUNCTION_TABLE[$583]($585);
      $retval=0;
      __label__ = 119; break;
    case 119: 
      var $587=$store_think;
      var $588=(($587)|0)!=0;
      if ($588) { __label__ = 121; break; } else { __label__ = 120; break; }
    case 120: 
      var $590=$self_think;
      var $591=$590;
      var $592=$591;
      var $593=(($592+8)|0);
      var $594=HEAP32[(($593)>>2)];
      var $595=$self_think;
      var $596=$595;
      FUNCTION_TABLE[$594]($596);
      $retval=0;
      __label__ = 121; break;
    case 121: 
      var $598=$retval;
      var $599=(($598) & 1);
      if ($599) { __label__ = 129; break; } else { __label__ = 122; break; }
    case 122: 
      var $601=$store_frame;
      var $602=(($601)|0)!=0;
      if ($602) { __label__ = 123; break; } else { __label__ = 124; break; }
    case 123: 
      var $604=$store_frame;
      var $605=$604;
      var $606=$605;
      var $607=(($606+8)|0);
      var $608=HEAP32[(($607)>>2)];
      var $609=$store_frame;
      var $610=$609;
      FUNCTION_TABLE[$608]($610);
      __label__ = 124; break;
    case 124: 
      var $612=$store_nextthink;
      var $613=(($612)|0)!=0;
      if ($613) { __label__ = 125; break; } else { __label__ = 126; break; }
    case 125: 
      var $615=$store_nextthink;
      var $616=$615;
      var $617=$616;
      var $618=(($617+8)|0);
      var $619=HEAP32[(($618)>>2)];
      var $620=$store_nextthink;
      var $621=$620;
      FUNCTION_TABLE[$619]($621);
      __label__ = 126; break;
    case 126: 
      var $623=$store_think;
      var $624=(($623)|0)!=0;
      if ($624) { __label__ = 127; break; } else { __label__ = 128; break; }
    case 127: 
      var $626=$store_think;
      var $627=$626;
      var $628=$627;
      var $629=(($628+8)|0);
      var $630=HEAP32[(($629)>>2)];
      var $631=$store_think;
      var $632=$631;
      FUNCTION_TABLE[$630]($632);
      __label__ = 128; break;
    case 128: 
      $retval=0;
      __label__ = 129; break;
    case 129: 
      var $635=$retval;
      var $636=(($635) & 1);
      if ($636) { __label__ = 130; break; } else { __label__ = 132; break; }
    case 130: 
      var $638=$block;
      var $639=$store_frame;
      var $640=$639;
      var $641=_ast_block_exprs_add($638, $640);
      if ($641) { __label__ = 132; break; } else { __label__ = 131; break; }
    case 131: 
      var $643=$store_frame;
      var $644=$643;
      var $645=$644;
      var $646=(($645+8)|0);
      var $647=HEAP32[(($646)>>2)];
      var $648=$store_frame;
      var $649=$648;
      FUNCTION_TABLE[$647]($649);
      var $650=$store_nextthink;
      var $651=$650;
      var $652=$651;
      var $653=(($652+8)|0);
      var $654=HEAP32[(($653)>>2)];
      var $655=$store_nextthink;
      var $656=$655;
      FUNCTION_TABLE[$654]($656);
      var $657=$store_think;
      var $658=$657;
      var $659=$658;
      var $660=(($659+8)|0);
      var $661=HEAP32[(($660)>>2)];
      var $662=$store_think;
      var $663=$662;
      FUNCTION_TABLE[$661]($663);
      $retval=0;
      __label__ = 132; break;
    case 132: 
      var $665=$retval;
      var $666=(($665) & 1);
      if ($666) { __label__ = 133; break; } else { __label__ = 135; break; }
    case 133: 
      var $668=$block;
      var $669=$store_nextthink;
      var $670=$669;
      var $671=_ast_block_exprs_add($668, $670);
      if ($671) { __label__ = 135; break; } else { __label__ = 134; break; }
    case 134: 
      var $673=$store_nextthink;
      var $674=$673;
      var $675=$674;
      var $676=(($675+8)|0);
      var $677=HEAP32[(($676)>>2)];
      var $678=$store_nextthink;
      var $679=$678;
      FUNCTION_TABLE[$677]($679);
      var $680=$store_think;
      var $681=$680;
      var $682=$681;
      var $683=(($682+8)|0);
      var $684=HEAP32[(($683)>>2)];
      var $685=$store_think;
      var $686=$685;
      FUNCTION_TABLE[$684]($686);
      $retval=0;
      __label__ = 135; break;
    case 135: 
      var $688=$retval;
      var $689=(($688) & 1);
      if ($689) { __label__ = 136; break; } else { __label__ = 138; break; }
    case 136: 
      var $691=$block;
      var $692=$store_think;
      var $693=$692;
      var $694=_ast_block_exprs_add($691, $693);
      if ($694) { __label__ = 138; break; } else { __label__ = 137; break; }
    case 137: 
      var $696=$store_think;
      var $697=$696;
      var $698=$697;
      var $699=(($698+8)|0);
      var $700=HEAP32[(($699)>>2)];
      var $701=$store_think;
      var $702=$701;
      FUNCTION_TABLE[$700]($702);
      $retval=0;
      __label__ = 138; break;
    case 138: 
      __label__ = 139; break;
    case 139: 
      var $705=$retval;
      var $706=(($705) & 1);
      if ($706) { __label__ = 149; break; } else { __label__ = 140; break; }
    case 140: 
      var $708=$2;
      _parseerror($708, ((STRING_TABLE.__str123695)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 141; break;
    case 141: 
      var $710=$nextthink;
      var $711=$710;
      var $712=$711;
      var $713=(($712+16)|0);
      var $714=HEAP8[($713)];
      var $715=(($714) & 1);
      if ($715) { __label__ = 143; break; } else { __label__ = 142; break; }
    case 142: 
      var $717=$nextthink;
      var $718=$717;
      var $719=$718;
      var $720=(($719+8)|0);
      var $721=HEAP32[(($720)>>2)];
      var $722=$nextthink;
      var $723=$722;
      FUNCTION_TABLE[$721]($723);
      __label__ = 143; break;
    case 143: 
      __label__ = 144; break;
    case 144: 
      __label__ = 145; break;
    case 145: 
      var $727=$framenum;
      var $728=$727;
      var $729=$728;
      var $730=(($729+16)|0);
      var $731=HEAP8[($730)];
      var $732=(($731) & 1);
      if ($732) { __label__ = 147; break; } else { __label__ = 146; break; }
    case 146: 
      var $734=$framenum;
      var $735=$734;
      var $736=$735;
      var $737=(($736+8)|0);
      var $738=HEAP32[(($737)>>2)];
      var $739=$framenum;
      var $740=$739;
      FUNCTION_TABLE[$738]($740);
      __label__ = 147; break;
    case 147: 
      __label__ = 148; break;
    case 148: 
      var $743=$block;
      var $744=$743;
      var $745=$744;
      var $746=(($745+8)|0);
      var $747=HEAP32[(($746)>>2)];
      var $748=$block;
      var $749=$748;
      FUNCTION_TABLE[$747]($749);
      $1=0;
      __label__ = 198; break;
    case 149: 
      __label__ = 150; break;
    case 150: 
      $parami=0;
      __label__ = 151; break;
    case 151: 
      var $753=$parami;
      var $754=$3;
      var $755=(($754)|0);
      var $756=(($755+36)|0);
      var $757=HEAP32[(($756)>>2)];
      var $758=(($753)>>>0) < (($757)>>>0);
      if ($758) { __label__ = 152; break; } else { __label__ = 173; break; }
    case 152: 
      var $760=$parami;
      var $761=$3;
      var $762=(($761)|0);
      var $763=(($762+32)|0);
      var $764=HEAP32[(($763)>>2)];
      var $765=(($764+($760<<2))|0);
      var $766=HEAP32[(($765)>>2)];
      $param=$766;
      var $767=$param;
      var $768=(($767)|0);
      var $769=(($768+24)|0);
      var $770=HEAP32[(($769)>>2)];
      var $771=(($770)|0)!=3;
      if ($771) { __label__ = 153; break; } else { __label__ = 156; break; }
    case 153: 
      var $773=$param;
      var $774=(($773)|0);
      var $775=(($774+24)|0);
      var $776=HEAP32[(($775)>>2)];
      var $777=(($776)|0)!=5;
      if ($777) { __label__ = 155; break; } else { __label__ = 154; break; }
    case 154: 
      var $779=$param;
      var $780=(($779)|0);
      var $781=(($780+28)|0);
      var $782=HEAP32[(($781)>>2)];
      var $783=$782;
      var $784=(($783+24)|0);
      var $785=HEAP32[(($784)>>2)];
      var $786=(($785)|0)!=3;
      if ($786) { __label__ = 155; break; } else { __label__ = 156; break; }
    case 155: 
      __label__ = 172; break;
    case 156: 
      var $789=$2;
      var $790=$param;
      var $791=(($ve)|0);
      var $792=_create_vector_members($789, $790, $791);
      if ($792) { __label__ = 158; break; } else { __label__ = 157; break; }
    case 157: 
      var $794=$block;
      _ast_block_delete($794);
      $1=0;
      __label__ = 198; break;
    case 158: 
      $e=0;
      __label__ = 159; break;
    case 159: 
      var $797=$e;
      var $798=(($797)>>>0) < 3;
      if ($798) { __label__ = 160; break; } else { __label__ = 166; break; }
    case 160: 
      var $800=$2;
      var $801=$e;
      var $802=(($ve+($801<<3))|0);
      var $803=(($802)|0);
      var $804=HEAP32[(($803)>>2)];
      var $805=(($802+4)|0);
      var $806=HEAP32[(($805)>>2)];
      var $807=_parser_t_locals_add($800, $804, $806);
      if ($807) { __label__ = 162; break; } else { __label__ = 161; break; }
    case 161: 
      __label__ = 166; break;
    case 162: 
      var $810=$block;
      var $811=$e;
      var $812=(($ve+($811<<3))|0);
      var $813=(($812+4)|0);
      var $814=HEAP32[(($813)>>2)];
      var $815=_ast_block_collect($810, $814);
      if ($815) { __label__ = 164; break; } else { __label__ = 163; break; }
    case 163: 
      var $817=$2;
      var $818=(($817+104)|0);
      var $819=HEAP32[(($818)>>2)];
      var $820=((($819)-(1))|0);
      HEAP32[(($818)>>2)]=$820;
      __label__ = 166; break;
    case 164: 
      var $822=$e;
      var $823=(($ve+($822<<3))|0);
      var $824=(($823+4)|0);
      HEAP32[(($824)>>2)]=0;
      __label__ = 165; break;
    case 165: 
      var $826=$e;
      var $827=((($826)+(1))|0);
      $e=$827;
      __label__ = 159; break;
    case 166: 
      var $829=$e;
      var $830=(($829)|0)!=3;
      if ($830) { __label__ = 167; break; } else { __label__ = 171; break; }
    case 167: 
      var $832=$e;
      var $833=$2;
      var $834=(($833+100)|0);
      var $835=HEAP32[(($834)>>2)];
      var $836=(((-$832))|0);
      var $837=(($835+($836<<3))|0);
      HEAP32[(($834)>>2)]=$837;
      __label__ = 168; break;
    case 168: 
      var $839=$e;
      var $840=(($ve+($839<<3))|0);
      var $841=(($840)|0);
      var $842=HEAP32[(($841)>>2)];
      _util_memory_d($842, 2225, ((STRING_TABLE.__str572)|0));
      var $843=$e;
      var $844=((($843)-(1))|0);
      $e=$844;
      __label__ = 169; break;
    case 169: 
      var $846=$e;
      var $847=(($846)|0)!=0;
      if ($847) { __label__ = 168; break; } else { __label__ = 170; break; }
    case 170: 
      var $849=$block;
      _ast_block_delete($849);
      $1=0;
      __label__ = 198; break;
    case 171: 
      __label__ = 172; break;
    case 172: 
      var $852=$parami;
      var $853=((($852)+(1))|0);
      $parami=$853;
      __label__ = 151; break;
    case 173: 
      var $855=$3;
      var $856=$855;
      var $857=(($856)|0);
      var $858=$3;
      var $859=(($858+56)|0);
      var $860=HEAP32[(($859)>>2)];
      var $861=$3;
      var $862=(($857)|0);
      var $863=HEAP32[(($862)>>2)];
      var $864=(($857+4)|0);
      var $865=HEAP32[(($864)>>2)];
      var $866=_ast_function_new($863, $865, $860, $861);
      $func=$866;
      var $867=$func;
      var $868=(($867)|0)!=0;
      if ($868) { __label__ = 175; break; } else { __label__ = 174; break; }
    case 174: 
      var $870=$2;
      var $871=$3;
      var $872=(($871+56)|0);
      var $873=HEAP32[(($872)>>2)];
      _parseerror($870, ((STRING_TABLE.__str53625)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$873,tempInt));
      var $874=$block;
      _ast_block_delete($874);
      __label__ = 194; break;
    case 175: 
      var $876=$2;
      var $877=$func;
      var $878=_parser_t_functions_add($876, $877);
      if ($878) { __label__ = 177; break; } else { __label__ = 176; break; }
    case 176: 
      var $880=$2;
      var $881=$3;
      var $882=(($881+56)|0);
      var $883=HEAP32[(($882)>>2)];
      _parseerror($880, ((STRING_TABLE.__str54626)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$883,tempInt));
      var $884=$block;
      _ast_block_delete($884);
      __label__ = 193; break;
    case 177: 
      var $886=$func;
      var $887=$2;
      var $888=(($887+96)|0);
      HEAP32[(($888)>>2)]=$886;
      var $889=$2;
      var $890=$block;
      var $891=_parse_block_into($889, $890, 1);
      if ($891) { __label__ = 179; break; } else { __label__ = 178; break; }
    case 178: 
      var $893=$block;
      _ast_block_delete($893);
      __label__ = 192; break;
    case 179: 
      var $895=$func;
      var $896=$block;
      var $897=_ast_function_blocks_add($895, $896);
      if ($897) { __label__ = 181; break; } else { __label__ = 180; break; }
    case 180: 
      var $899=$block;
      _ast_block_delete($899);
      __label__ = 192; break;
    case 181: 
      var $901=$old;
      var $902=$2;
      var $903=(($902+96)|0);
      HEAP32[(($903)>>2)]=$901;
      __label__ = 182; break;
    case 182: 
      var $905=$2;
      var $906=(($905+104)|0);
      var $907=HEAP32[(($906)>>2)];
      var $908=(($907)|0)!=0;
      if ($908) { __label__ = 183; break; } else { __label__ = 186; break; }
    case 183: 
      var $910=$retval;
      var $911=(($910) & 1);
      if ($911) { __label__ = 184; break; } else { var $916 = 0;__label__ = 185; break; }
    case 184: 
      var $913=$2;
      var $914=_parser_pop_local($913);
      var $916 = $914;__label__ = 185; break;
    case 185: 
      var $916;
      var $917=(($916)&1);
      $retval=$917;
      __label__ = 182; break;
    case 186: 
      var $919=$2;
      var $920=(($919+4)|0);
      var $921=HEAP32[(($920)>>2)];
      var $922=(($921)|0)==59;
      if ($922) { __label__ = 187; break; } else { __label__ = 188; break; }
    case 187: 
      var $924=$2;
      var $925=_parser_next($924);
      $1=$925;
      __label__ = 198; break;
    case 188: 
      var $927=HEAP32[((_opts_standard)>>2)];
      var $928=(($927)|0)==0;
      if ($928) { __label__ = 189; break; } else { __label__ = 190; break; }
    case 189: 
      var $930=$2;
      _parseerror($930, ((STRING_TABLE.__str124696)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 190; break;
    case 190: 
      __label__ = 191; break;
    case 191: 
      var $933=$retval;
      var $934=(($933) & 1);
      $1=$934;
      __label__ = 198; break;
    case 192: 
      var $936=$2;
      var $937=(($936+36)|0);
      var $938=HEAP32[(($937)>>2)];
      var $939=((($938)-(1))|0);
      HEAP32[(($937)>>2)]=$939;
      __label__ = 193; break;
    case 193: 
      var $941=$func;
      _ast_function_delete($941);
      var $942=$3;
      var $943=(($942+64)|0);
      var $944=$943;
      HEAP32[(($944)>>2)]=0;
      __label__ = 194; break;
    case 194: 
      __label__ = 195; break;
    case 195: 
      var $947=$2;
      var $948=(($947+104)|0);
      var $949=HEAP32[(($948)>>2)];
      var $950=(($949)|0)!=0;
      if ($950) { __label__ = 196; break; } else { __label__ = 197; break; }
    case 196: 
      var $952=$2;
      var $953=(($952+104)|0);
      var $954=HEAP32[(($953)>>2)];
      var $955=((($954)-(1))|0);
      HEAP32[(($953)>>2)]=$955;
      var $956=$2;
      var $957=(($956+104)|0);
      var $958=HEAP32[(($957)>>2)];
      var $959=$2;
      var $960=(($959+100)|0);
      var $961=HEAP32[(($960)>>2)];
      var $962=(($961+($958<<3))|0);
      var $963=(($962)|0);
      var $964=HEAP32[(($963)>>2)];
      _util_memory_d($964, 2275, ((STRING_TABLE.__str572)|0));
      __label__ = 195; break;
    case 197: 
      var $966=$old;
      var $967=$2;
      var $968=(($967+96)|0);
      HEAP32[(($968)>>2)]=$966;
      $1=0;
      __label__ = 198; break;
    case 198: 
      var $970=$1;
      STACKTOP = __stackBase__;
      return $970;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_function_body["X"]=1;

function _parse_expression_leave($parser, $stopatcomma) {
  var __stackBase__  = STACKTOP; STACKTOP += 248; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $expr;
      var $sy=__stackBase__;
      var $wantop;
      var $gotmemberof;
      var $parens;
      var $var;
      var $4=(__stackBase__)+(24);
      var $val;
      var $5=(__stackBase__)+(52);
      var $val1;
      var $6=(__stackBase__)+(80);
      var $val2;
      var $7=(__stackBase__)+(108);
      var $val3;
      var $8=(__stackBase__)+(136);
      var $op;
      var $olast;
      var $o;
      var $prevex;
      var $9=(__stackBase__)+(164);
      var $10=(__stackBase__)+(192);
      var $11=(__stackBase__)+(220);
      $2=$parser;
      var $12=(($stopatcomma)&1);
      $3=$12;
      $expr=0;
      $wantop=0;
      $gotmemberof=0;
      $parens=0;
      var $13=(($sy)|0);
      HEAP32[(($13)>>2)]=0;
      var $14=(($sy+4)|0);
      HEAP32[(($14)>>2)]=0;
      var $15=(($sy+8)|0);
      HEAP32[(($15)>>2)]=0;
      var $16=(($sy+12)|0);
      HEAP32[(($16)>>2)]=0;
      var $17=(($sy+16)|0);
      HEAP32[(($17)>>2)]=0;
      var $18=(($sy+20)|0);
      HEAP32[(($18)>>2)]=0;
      var $19=$2;
      var $20=(($19)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21+328)|0);
      var $23=(($22)|0);
      HEAP8[($23)]=0;
      var $24=$2;
      _parser_reclassify_token($24);
      __label__ = 3; break;
    case 3: 
      var $26=$gotmemberof;
      var $27=(($26) & 1);
      if ($27) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      $gotmemberof=0;
      __label__ = 6; break;
    case 5: 
      var $30=$2;
      var $31=(($30+120)|0);
      HEAP32[(($31)>>2)]=0;
      __label__ = 6; break;
    case 6: 
      var $33=$2;
      var $34=(($33+4)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)==129;
      if ($36) { __label__ = 7; break; } else { __label__ = 32; break; }
    case 7: 
      var $38=$wantop;
      var $39=(($38) & 1);
      if ($39) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $41=$2;
      _parseerror($41, ((STRING_TABLE.__str57629)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 9: 
      $wantop=1;
      var $43=HEAP32[((_opts_standard)>>2)];
      var $44=(($43)|0)==3;
      if ($44) { __label__ = 10; break; } else { __label__ = 22; break; }
    case 10: 
      var $46=$2;
      var $47=(($46+120)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48)|0)==4;
      if ($49) { __label__ = 11; break; } else { __label__ = 14; break; }
    case 11: 
      var $51=$2;
      var $52=$2;
      var $53=(($52)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=(($54+292)|0);
      var $56=(($55+4)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=_parser_find_var($51, $57);
      $var=$58;
      var $59=$var;
      var $60=(($59)|0)!=0;
      if ($60) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      var $62=$2;
      var $63=$2;
      var $64=(($63)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($65+292)|0);
      var $67=(($66+4)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=_parser_find_field($62, $68);
      $var=$69;
      __label__ = 13; break;
    case 13: 
      __label__ = 21; break;
    case 14: 
      var $72=$2;
      var $73=(($72+120)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=(($74)|0)==3;
      if ($75) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $77=$2;
      _parseerror($77, ((STRING_TABLE.__str58630)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 16: 
      var $79=$2;
      var $80=(($79+120)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81)|0)!=0;
      if ($82) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      var $84=$2;
      _parseerror($84, ((STRING_TABLE.__str59631)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 18: 
      var $86=$2;
      var $87=$2;
      var $88=(($87)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($89+292)|0);
      var $91=(($90+4)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=_parser_find_var($86, $92);
      $var=$93;
      __label__ = 19; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      __label__ = 25; break;
    case 22: 
      var $98=$2;
      var $99=$2;
      var $100=(($99)|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=(($101+292)|0);
      var $103=(($102+4)|0);
      var $104=HEAP32[(($103)>>2)];
      var $105=_parser_find_var($98, $104);
      $var=$105;
      var $106=$var;
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $109=$2;
      var $110=$2;
      var $111=(($110)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($112+292)|0);
      var $114=(($113+4)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=_parser_find_field($109, $115);
      $var=$116;
      __label__ = 24; break;
    case 24: 
      __label__ = 25; break;
    case 25: 
      var $119=$var;
      var $120=(($119)|0)!=0;
      if ($120) { __label__ = 27; break; } else { __label__ = 26; break; }
    case 26: 
      var $122=$2;
      var $123=$2;
      var $124=(($123)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=(($125+292)|0);
      var $127=(($126+4)|0);
      var $128=HEAP32[(($127)>>2)];
      _parseerror($122, ((STRING_TABLE.__str60632)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$128,tempInt));
      __label__ = 165; break;
    case 27: 
      var $130=$var;
      var $131=$130;
      var $132=(($131+12)|0);
      var $133=HEAP32[(($132)>>2)];
      var $134=(($133)|0)==2;
      if ($134) { __label__ = 28; break; } else { __label__ = 29; break; }
    case 28: 
      var $136=$var;
      var $137=$136;
      var $138=(($137+76)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=((($139)+(1))|0);
      HEAP32[(($138)>>2)]=$140;
      __label__ = 29; break;
    case 29: 
      var $142=$2;
      var $143=(($142)|0);
      var $144=HEAP32[(($143)>>2)];
      var $145=(($144+292)|0);
      var $146=(($145+28)|0);
      var $147=$var;
      var $148=(($146)|0);
      var $149=HEAP32[(($148)>>2)];
      var $150=(($146+4)|0);
      var $151=HEAP32[(($150)>>2)];
      _syexp($4, $149, $151, $147);
      var $152=_shunt_out_add($sy, $4);
      if ($152) { __label__ = 31; break; } else { __label__ = 30; break; }
    case 30: 
      var $154=$2;
      _parseerror($154, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 31: 
      __label__ = 146; break;
    case 32: 
      var $157=$2;
      var $158=(($157+4)|0);
      var $159=HEAP32[(($158)>>2)];
      var $160=(($159)|0)==138;
      if ($160) { __label__ = 33; break; } else { __label__ = 40; break; }
    case 33: 
      var $162=$wantop;
      var $163=(($162) & 1);
      if ($163) { __label__ = 34; break; } else { __label__ = 35; break; }
    case 34: 
      var $165=$2;
      _parseerror($165, ((STRING_TABLE.__str62634)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 35: 
      $wantop=1;
      var $167=$2;
      var $168=$2;
      var $169=(($168)|0);
      var $170=HEAP32[(($169)>>2)];
      var $171=(($170+292)|0);
      var $172=(($171+16)|0);
      var $173=$172;
      var $174=(tempDoubleI32[0]=HEAP32[(($173)>>2)],tempDoubleI32[1]=HEAP32[((($173)+(4))>>2)],tempDoubleF64[0]);
      var $175=_parser_const_float($167, $174);
      $val=$175;
      var $176=$val;
      var $177=(($176)|0)!=0;
      if ($177) { __label__ = 37; break; } else { __label__ = 36; break; }
    case 36: 
      $1=0;
      __label__ = 170; break;
    case 37: 
      var $180=$2;
      var $181=(($180)|0);
      var $182=HEAP32[(($181)>>2)];
      var $183=(($182+292)|0);
      var $184=(($183+28)|0);
      var $185=$val;
      var $186=$185;
      var $187=(($184)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=(($184+4)|0);
      var $190=HEAP32[(($189)>>2)];
      _syexp($5, $188, $190, $186);
      var $191=_shunt_out_add($sy, $5);
      if ($191) { __label__ = 39; break; } else { __label__ = 38; break; }
    case 38: 
      var $193=$2;
      _parseerror($193, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 39: 
      __label__ = 145; break;
    case 40: 
      var $196=$2;
      var $197=(($196+4)|0);
      var $198=HEAP32[(($197)>>2)];
      var $199=(($198)|0)==137;
      if ($199) { __label__ = 41; break; } else { __label__ = 48; break; }
    case 41: 
      var $201=$wantop;
      var $202=(($201) & 1);
      if ($202) { __label__ = 42; break; } else { __label__ = 43; break; }
    case 42: 
      var $204=$2;
      _parseerror($204, ((STRING_TABLE.__str62634)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 43: 
      $wantop=1;
      var $206=$2;
      var $207=$2;
      var $208=(($207)|0);
      var $209=HEAP32[(($208)>>2)];
      var $210=(($209+292)|0);
      var $211=(($210+16)|0);
      var $212=$211;
      var $213=HEAP32[(($212)>>2)];
      var $214=(($213)|0);
      var $215=_parser_const_float($206, $214);
      $val1=$215;
      var $216=$val1;
      var $217=(($216)|0)!=0;
      if ($217) { __label__ = 45; break; } else { __label__ = 44; break; }
    case 44: 
      $1=0;
      __label__ = 170; break;
    case 45: 
      var $220=$2;
      var $221=(($220)|0);
      var $222=HEAP32[(($221)>>2)];
      var $223=(($222+292)|0);
      var $224=(($223+28)|0);
      var $225=$val1;
      var $226=$225;
      var $227=(($224)|0);
      var $228=HEAP32[(($227)>>2)];
      var $229=(($224+4)|0);
      var $230=HEAP32[(($229)>>2)];
      _syexp($6, $228, $230, $226);
      var $231=_shunt_out_add($sy, $6);
      if ($231) { __label__ = 47; break; } else { __label__ = 46; break; }
    case 46: 
      var $233=$2;
      _parseerror($233, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 47: 
      __label__ = 144; break;
    case 48: 
      var $236=$2;
      var $237=(($236+4)|0);
      var $238=HEAP32[(($237)>>2)];
      var $239=(($238)|0)==134;
      if ($239) { __label__ = 49; break; } else { __label__ = 56; break; }
    case 49: 
      var $241=$wantop;
      var $242=(($241) & 1);
      if ($242) { __label__ = 50; break; } else { __label__ = 51; break; }
    case 50: 
      var $244=$2;
      _parseerror($244, ((STRING_TABLE.__str62634)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 51: 
      $wantop=1;
      var $246=$2;
      var $247=$2;
      var $248=(($247)|0);
      var $249=HEAP32[(($248)>>2)];
      var $250=(($249+292)|0);
      var $251=(($250+4)|0);
      var $252=HEAP32[(($251)>>2)];
      var $253=_parser_const_string($246, $252);
      $val2=$253;
      var $254=$val2;
      var $255=(($254)|0)!=0;
      if ($255) { __label__ = 53; break; } else { __label__ = 52; break; }
    case 52: 
      $1=0;
      __label__ = 170; break;
    case 53: 
      var $258=$2;
      var $259=(($258)|0);
      var $260=HEAP32[(($259)>>2)];
      var $261=(($260+292)|0);
      var $262=(($261+28)|0);
      var $263=$val2;
      var $264=$263;
      var $265=(($262)|0);
      var $266=HEAP32[(($265)>>2)];
      var $267=(($262+4)|0);
      var $268=HEAP32[(($267)>>2)];
      _syexp($7, $266, $268, $264);
      var $269=_shunt_out_add($sy, $7);
      if ($269) { __label__ = 55; break; } else { __label__ = 54; break; }
    case 54: 
      var $271=$2;
      _parseerror($271, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 55: 
      __label__ = 143; break;
    case 56: 
      var $274=$2;
      var $275=(($274+4)|0);
      var $276=HEAP32[(($275)>>2)];
      var $277=(($276)|0)==136;
      if ($277) { __label__ = 57; break; } else { __label__ = 64; break; }
    case 57: 
      var $279=$wantop;
      var $280=(($279) & 1);
      if ($280) { __label__ = 58; break; } else { __label__ = 59; break; }
    case 58: 
      var $282=$2;
      _parseerror($282, ((STRING_TABLE.__str62634)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 59: 
      $wantop=1;
      var $284=$2;
      var $285=$2;
      var $286=(($285)|0);
      var $287=HEAP32[(($286)>>2)];
      var $288=(($287+292)|0);
      var $289=(($288+16)|0);
      var $290=$289;
      var $291=(($290)|0);
      var $292=HEAPF32[(($291)>>2)];
      var $293=(($290+4)|0);
      var $294=HEAPF32[(($293)>>2)];
      var $295=(($290+8)|0);
      var $296=HEAPF32[(($295)>>2)];
      var $297=_parser_const_vector($284, $292, $294, $296);
      $val3=$297;
      var $298=$val3;
      var $299=(($298)|0)!=0;
      if ($299) { __label__ = 61; break; } else { __label__ = 60; break; }
    case 60: 
      $1=0;
      __label__ = 170; break;
    case 61: 
      var $302=$2;
      var $303=(($302)|0);
      var $304=HEAP32[(($303)>>2)];
      var $305=(($304+292)|0);
      var $306=(($305+28)|0);
      var $307=$val3;
      var $308=$307;
      var $309=(($306)|0);
      var $310=HEAP32[(($309)>>2)];
      var $311=(($306+4)|0);
      var $312=HEAP32[(($311)>>2)];
      _syexp($8, $310, $312, $308);
      var $313=_shunt_out_add($sy, $8);
      if ($313) { __label__ = 63; break; } else { __label__ = 62; break; }
    case 62: 
      var $315=$2;
      _parseerror($315, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 63: 
      __label__ = 142; break;
    case 64: 
      var $318=$2;
      var $319=(($318+4)|0);
      var $320=HEAP32[(($319)>>2)];
      var $321=(($320)|0)==40;
      if ($321) { __label__ = 65; break; } else { __label__ = 66; break; }
    case 65: 
      var $323=$2;
      _parseerror($323, ((STRING_TABLE.__str63635)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 66: 
      var $325=$2;
      var $326=(($325+4)|0);
      var $327=HEAP32[(($326)>>2)];
      var $328=(($327)|0)==41;
      if ($328) { __label__ = 67; break; } else { __label__ = 79; break; }
    case 67: 
      var $330=$wantop;
      var $331=(($330) & 1);
      if ($331) { __label__ = 68; break; } else { __label__ = 73; break; }
    case 68: 
      var $333=$parens;
      var $334=((($333)-(1))|0);
      $parens=$334;
      var $335=$parens;
      var $336=(($335)|0) < 0;
      if ($336) { __label__ = 69; break; } else { __label__ = 70; break; }
    case 69: 
      __label__ = 152; break;
    case 70: 
      var $339=$2;
      var $340=_parser_close_paren($339, $sy, 0);
      if ($340) { __label__ = 72; break; } else { __label__ = 71; break; }
    case 71: 
      __label__ = 165; break;
    case 72: 
      __label__ = 78; break;
    case 73: 
      var $344=$parens;
      var $345=((($344)-(1))|0);
      $parens=$345;
      var $346=$parens;
      var $347=(($346)|0) < 0;
      if ($347) { __label__ = 74; break; } else { __label__ = 75; break; }
    case 74: 
      __label__ = 152; break;
    case 75: 
      var $350=$2;
      var $351=_parser_close_paren($350, $sy, 1);
      if ($351) { __label__ = 77; break; } else { __label__ = 76; break; }
    case 76: 
      __label__ = 165; break;
    case 77: 
      __label__ = 78; break;
    case 78: 
      $wantop=1;
      __label__ = 140; break;
    case 79: 
      var $356=$2;
      var $357=(($356+4)|0);
      var $358=HEAP32[(($357)>>2)];
      var $359=(($358)|0)!=131;
      if ($359) { __label__ = 80; break; } else { __label__ = 83; break; }
    case 80: 
      var $361=$wantop;
      var $362=(($361) & 1);
      if ($362) { __label__ = 81; break; } else { __label__ = 82; break; }
    case 81: 
      var $364=$2;
      _parseerror($364, ((STRING_TABLE.__str57629)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 82: 
      __label__ = 152; break;
    case 83: 
      $olast=0;
      $o=0;
      __label__ = 84; break;
    case 84: 
      var $368=$o;
      var $369=HEAP32[((_operator_count)>>2)];
      var $370=(($368)>>>0) < (($369)>>>0);
      if ($370) { __label__ = 85; break; } else { __label__ = 91; break; }
    case 85: 
      var $372=$o;
      var $373=HEAP32[((_operators)>>2)];
      var $374=(($373+($372)*(24))|0);
      var $375=(($374+20)|0);
      var $376=HEAP32[(($375)>>2)];
      var $377=$376 & 2;
      var $378=(($377)|0)!=0;
      var $379=$378 ^ 1;
      var $380=(($379)&1);
      var $381=$wantop;
      var $382=(($381) & 1);
      var $383=(($382)&1);
      var $384=(($380)|0)==(($383)|0);
      if ($384) { __label__ = 86; break; } else { __label__ = 89; break; }
    case 86: 
      var $386=$o;
      var $387=HEAP32[((_operators)>>2)];
      var $388=(($387+($386)*(24))|0);
      var $389=(($388+20)|0);
      var $390=HEAP32[(($389)>>2)];
      var $391=$390 & 1;
      var $392=(($391)|0)!=0;
      if ($392) { __label__ = 89; break; } else { __label__ = 87; break; }
    case 87: 
      var $394=$2;
      var $395=(($394)|0);
      var $396=HEAP32[(($395)>>2)];
      var $397=(($396+292)|0);
      var $398=(($397+4)|0);
      var $399=HEAP32[(($398)>>2)];
      var $400=$o;
      var $401=HEAP32[((_operators)>>2)];
      var $402=(($401+($400)*(24))|0);
      var $403=(($402)|0);
      var $404=HEAP32[(($403)>>2)];
      var $405=_strcmp($399, $404);
      var $406=(($405)|0)!=0;
      if ($406) { __label__ = 89; break; } else { __label__ = 88; break; }
    case 88: 
      __label__ = 91; break;
    case 89: 
      __label__ = 90; break;
    case 90: 
      var $410=$o;
      var $411=((($410)+(1))|0);
      $o=$411;
      __label__ = 84; break;
    case 91: 
      var $413=$o;
      var $414=HEAP32[((_operator_count)>>2)];
      var $415=(($413)|0)==(($414)|0);
      if ($415) { __label__ = 92; break; } else { __label__ = 93; break; }
    case 92: 
      __label__ = 152; break;
    case 93: 
      var $418=$o;
      var $419=HEAP32[((_operators)>>2)];
      var $420=(($419+($418)*(24))|0);
      $op=$420;
      var $421=$op;
      var $422=(($421+8)|0);
      var $423=HEAP32[(($422)>>2)];
      var $424=(($423)|0)==44;
      if ($424) { __label__ = 94; break; } else { __label__ = 97; break; }
    case 94: 
      var $426=$parens;
      var $427=(($426)|0)!=0;
      if ($427) { __label__ = 97; break; } else { __label__ = 95; break; }
    case 95: 
      var $429=$3;
      var $430=(($429) & 1);
      if ($430) { __label__ = 96; break; } else { __label__ = 97; break; }
    case 96: 
      var $432=$2;
      var $433=(($432+4)|0);
      HEAP32[(($433)>>2)]=44;
      __label__ = 152; break;
    case 97: 
      var $435=(($sy+16)|0);
      var $436=HEAP32[(($435)>>2)];
      var $437=(($436)|0)!=0;
      if ($437) { __label__ = 98; break; } else { __label__ = 100; break; }
    case 98: 
      var $439=(($sy+16)|0);
      var $440=HEAP32[(($439)>>2)];
      var $441=((($440)-(1))|0);
      var $442=(($sy+12)|0);
      var $443=HEAP32[(($442)>>2)];
      var $444=(($443+($441)*(28))|0);
      var $445=(($444+4)|0);
      var $446=HEAP32[(($445)>>2)];
      var $447=(($446)|0)!=0;
      if ($447) { __label__ = 100; break; } else { __label__ = 99; break; }
    case 99: 
      var $449=(($sy+16)|0);
      var $450=HEAP32[(($449)>>2)];
      var $451=((($450)-(1))|0);
      var $452=(($sy+12)|0);
      var $453=HEAP32[(($452)>>2)];
      var $454=(($453+($451)*(28))|0);
      var $455=(($454)|0);
      var $456=HEAP32[(($455)>>2)];
      var $457=((($456)-(1))|0);
      var $458=HEAP32[((_operators)>>2)];
      var $459=(($458+($457)*(24))|0);
      $olast=$459;
      __label__ = 100; break;
    case 100: 
      __label__ = 101; break;
    case 101: 
      var $462=$olast;
      var $463=(($462)|0)!=0;
      if ($463) { __label__ = 102; break; } else { var $490 = 0;__label__ = 107; break; }
    case 102: 
      var $465=$op;
      var $466=(($465+16)|0);
      var $467=HEAP32[(($466)>>2)];
      var $468=$olast;
      var $469=(($468+16)|0);
      var $470=HEAP32[(($469)>>2)];
      var $471=(($467)>>>0) < (($470)>>>0);
      if ($471) { var $488 = 1;__label__ = 106; break; } else { __label__ = 103; break; }
    case 103: 
      var $473=$op;
      var $474=(($473+12)|0);
      var $475=HEAP32[(($474)>>2)];
      var $476=(($475)|0)==0;
      if ($476) { __label__ = 104; break; } else { var $486 = 0;__label__ = 105; break; }
    case 104: 
      var $478=$op;
      var $479=(($478+16)|0);
      var $480=HEAP32[(($479)>>2)];
      var $481=$olast;
      var $482=(($481+16)|0);
      var $483=HEAP32[(($482)>>2)];
      var $484=(($480)>>>0) <= (($483)>>>0);
      var $486 = $484;__label__ = 105; break;
    case 105: 
      var $486;
      var $488 = $486;__label__ = 106; break;
    case 106: 
      var $488;
      var $490 = $488;__label__ = 107; break;
    case 107: 
      var $490;
      if ($490) { __label__ = 108; break; } else { __label__ = 115; break; }
    case 108: 
      var $492=$2;
      var $493=_parser_sy_pop($492, $sy);
      if ($493) { __label__ = 110; break; } else { __label__ = 109; break; }
    case 109: 
      __label__ = 165; break;
    case 110: 
      var $496=(($sy+16)|0);
      var $497=HEAP32[(($496)>>2)];
      var $498=(($497)|0)!=0;
      if ($498) { __label__ = 111; break; } else { __label__ = 113; break; }
    case 111: 
      var $500=(($sy+16)|0);
      var $501=HEAP32[(($500)>>2)];
      var $502=((($501)-(1))|0);
      var $503=(($sy+12)|0);
      var $504=HEAP32[(($503)>>2)];
      var $505=(($504+($502)*(28))|0);
      var $506=(($505+4)|0);
      var $507=HEAP32[(($506)>>2)];
      var $508=(($507)|0)!=0;
      if ($508) { __label__ = 113; break; } else { __label__ = 112; break; }
    case 112: 
      var $510=(($sy+16)|0);
      var $511=HEAP32[(($510)>>2)];
      var $512=((($511)-(1))|0);
      var $513=(($sy+12)|0);
      var $514=HEAP32[(($513)>>2)];
      var $515=(($514+($512)*(28))|0);
      var $516=(($515)|0);
      var $517=HEAP32[(($516)>>2)];
      var $518=((($517)-(1))|0);
      var $519=HEAP32[((_operators)>>2)];
      var $520=(($519+($518)*(24))|0);
      $olast=$520;
      __label__ = 114; break;
    case 113: 
      $olast=0;
      __label__ = 114; break;
    case 114: 
      __label__ = 101; break;
    case 115: 
      var $524=$op;
      var $525=(($524+8)|0);
      var $526=HEAP32[(($525)>>2)];
      var $527=(($526)|0)==46;
      if ($527) { __label__ = 116; break; } else { __label__ = 126; break; }
    case 116: 
      var $529=HEAP32[((_opts_standard)>>2)];
      var $530=(($529)|0)==3;
      if ($530) { __label__ = 117; break; } else { __label__ = 126; break; }
    case 117: 
      var $532=(($sy+4)|0);
      var $533=HEAP32[(($532)>>2)];
      var $534=((($533)-(1))|0);
      var $535=(($sy)|0);
      var $536=HEAP32[(($535)>>2)];
      var $537=(($536+($534)*(28))|0);
      var $538=(($537+12)|0);
      var $539=HEAP32[(($538)>>2)];
      $prevex=$539;
      var $540=$prevex;
      var $541=(($540)|0)!=0;
      if ($541) { __label__ = 119; break; } else { __label__ = 118; break; }
    case 118: 
      var $543=$2;
      _parseerror($543, ((STRING_TABLE.__str64636)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 119: 
      var $545=$prevex;
      var $546=$545;
      var $547=(($546+24)|0);
      var $548=HEAP32[(($547)>>2)];
      var $549=(($548)|0)==4;
      if ($549) { __label__ = 120; break; } else { __label__ = 121; break; }
    case 120: 
      var $551=$2;
      var $552=(($551+120)|0);
      HEAP32[(($552)>>2)]=4;
      __label__ = 125; break;
    case 121: 
      var $554=$prevex;
      var $555=$554;
      var $556=(($555+24)|0);
      var $557=HEAP32[(($556)>>2)];
      var $558=(($557)|0)==3;
      if ($558) { __label__ = 122; break; } else { __label__ = 123; break; }
    case 122: 
      var $560=$2;
      var $561=(($560+120)|0);
      HEAP32[(($561)>>2)]=3;
      __label__ = 124; break;
    case 123: 
      var $563=$2;
      _parseerror($563, ((STRING_TABLE.__str65637)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 124: 
      __label__ = 125; break;
    case 125: 
      $gotmemberof=1;
      __label__ = 126; break;
    case 126: 
      var $567=$op;
      var $568=(($567+8)|0);
      var $569=HEAP32[(($568)>>2)];
      var $570=(($569)|0)==40;
      if ($570) { __label__ = 127; break; } else { __label__ = 135; break; }
    case 127: 
      var $572=$wantop;
      var $573=(($572) & 1);
      if ($573) { __label__ = 128; break; } else { __label__ = 131; break; }
    case 128: 
      var $575=$parens;
      var $576=((($575)+(1))|0);
      $parens=$576;
      var $577=$2;
      var $578=(($577)|0);
      var $579=HEAP32[(($578)>>2)];
      var $580=(($579+292)|0);
      var $581=(($580+28)|0);
      var $582=(($sy+4)|0);
      var $583=HEAP32[(($582)>>2)];
      var $584=((($583)-(1))|0);
      var $585=(($581)|0);
      var $586=HEAP32[(($585)>>2)];
      var $587=(($581+4)|0);
      var $588=HEAP32[(($587)>>2)];
      _syparen($9, $586, $588, 102, $584);
      var $589=_shunt_ops_add($sy, $9);
      if ($589) { __label__ = 130; break; } else { __label__ = 129; break; }
    case 129: 
      var $591=$2;
      _parseerror($591, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 130: 
      __label__ = 134; break;
    case 131: 
      var $594=$parens;
      var $595=((($594)+(1))|0);
      $parens=$595;
      var $596=$2;
      var $597=(($596)|0);
      var $598=HEAP32[(($597)>>2)];
      var $599=(($598+292)|0);
      var $600=(($599+28)|0);
      var $601=(($600)|0);
      var $602=HEAP32[(($601)>>2)];
      var $603=(($600+4)|0);
      var $604=HEAP32[(($603)>>2)];
      _syparen($10, $602, $604, 1, 0);
      var $605=_shunt_ops_add($sy, $10);
      if ($605) { __label__ = 133; break; } else { __label__ = 132; break; }
    case 132: 
      var $607=$2;
      _parseerror($607, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 165; break;
    case 133: 
      __label__ = 134; break;
    case 134: 
      $wantop=0;
      __label__ = 138; break;
    case 135: 
      var $611=$2;
      var $612=(($611)|0);
      var $613=HEAP32[(($612)>>2)];
      var $614=(($613+292)|0);
      var $615=(($614+28)|0);
      var $616=$op;
      var $617=(($615)|0);
      var $618=HEAP32[(($617)>>2)];
      var $619=(($615+4)|0);
      var $620=HEAP32[(($619)>>2)];
      _syop($11, $618, $620, $616);
      var $621=_shunt_ops_add($sy, $11);
      if ($621) { __label__ = 137; break; } else { __label__ = 136; break; }
    case 136: 
      __label__ = 165; break;
    case 137: 
      $wantop=0;
      __label__ = 138; break;
    case 138: 
      __label__ = 139; break;
    case 139: 
      __label__ = 140; break;
    case 140: 
      __label__ = 141; break;
    case 141: 
      __label__ = 142; break;
    case 142: 
      __label__ = 143; break;
    case 143: 
      __label__ = 144; break;
    case 144: 
      __label__ = 145; break;
    case 145: 
      __label__ = 146; break;
    case 146: 
      var $633=$2;
      var $634=_parser_next($633);
      if ($634) { __label__ = 148; break; } else { __label__ = 147; break; }
    case 147: 
      __label__ = 165; break;
    case 148: 
      var $637=$2;
      var $638=(($637+4)|0);
      var $639=HEAP32[(($638)>>2)];
      var $640=(($639)|0)==59;
      if ($640) { __label__ = 150; break; } else { __label__ = 149; break; }
    case 149: 
      var $642=$2;
      var $643=(($642+4)|0);
      var $644=HEAP32[(($643)>>2)];
      var $645=(($644)|0)==93;
      if ($645) { __label__ = 150; break; } else { __label__ = 151; break; }
    case 150: 
      __label__ = 152; break;
    case 151: 
      __label__ = 3; break;
    case 152: 
      __label__ = 153; break;
    case 153: 
      var $650=(($sy+16)|0);
      var $651=HEAP32[(($650)>>2)];
      var $652=(($651)|0)!=0;
      if ($652) { __label__ = 154; break; } else { __label__ = 157; break; }
    case 154: 
      var $654=$2;
      var $655=_parser_sy_pop($654, $sy);
      if ($655) { __label__ = 156; break; } else { __label__ = 155; break; }
    case 155: 
      __label__ = 165; break;
    case 156: 
      __label__ = 153; break;
    case 157: 
      var $659=$2;
      var $660=(($659)|0);
      var $661=HEAP32[(($660)>>2)];
      var $662=(($661+328)|0);
      var $663=(($662)|0);
      HEAP8[($663)]=1;
      var $664=(($sy+4)|0);
      var $665=HEAP32[(($664)>>2)];
      var $666=(($665)|0)!=0;
      if ($666) { __label__ = 159; break; } else { __label__ = 158; break; }
    case 158: 
      var $668=$2;
      _parseerror($668, ((STRING_TABLE.__str66638)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $expr=0;
      __label__ = 160; break;
    case 159: 
      var $670=(($sy)|0);
      var $671=HEAP32[(($670)>>2)];
      var $672=(($671)|0);
      var $673=(($672+12)|0);
      var $674=HEAP32[(($673)>>2)];
      $expr=$674;
      __label__ = 160; break;
    case 160: 
      var $676=(($sy)|0);
      var $677=HEAP32[(($676)>>2)];
      var $678=(($677)|0)!=0;
      if ($678) { __label__ = 161; break; } else { __label__ = 162; break; }
    case 161: 
      var $680=(($sy)|0);
      var $681=HEAP32[(($680)>>2)];
      var $682=$681;
      _util_memory_d($682, 1393, ((STRING_TABLE.__str572)|0));
      __label__ = 162; break;
    case 162: 
      var $684=(($sy)|0);
      HEAP32[(($684)>>2)]=0;
      var $685=(($sy+4)|0);
      HEAP32[(($685)>>2)]=0;
      var $686=(($sy+8)|0);
      HEAP32[(($686)>>2)]=0;
      var $687=(($sy+12)|0);
      var $688=HEAP32[(($687)>>2)];
      var $689=(($688)|0)!=0;
      if ($689) { __label__ = 163; break; } else { __label__ = 164; break; }
    case 163: 
      var $691=(($sy+12)|0);
      var $692=HEAP32[(($691)>>2)];
      var $693=$692;
      _util_memory_d($693, 1394, ((STRING_TABLE.__str572)|0));
      __label__ = 164; break;
    case 164: 
      var $695=(($sy+12)|0);
      HEAP32[(($695)>>2)]=0;
      var $696=(($sy+16)|0);
      HEAP32[(($696)>>2)]=0;
      var $697=(($sy+20)|0);
      HEAP32[(($697)>>2)]=0;
      var $698=$expr;
      $1=$698;
      __label__ = 170; break;
    case 165: 
      var $700=$2;
      var $701=(($700)|0);
      var $702=HEAP32[(($701)>>2)];
      var $703=(($702+328)|0);
      var $704=(($703)|0);
      HEAP8[($704)]=1;
      var $705=(($sy)|0);
      var $706=HEAP32[(($705)>>2)];
      var $707=(($706)|0)!=0;
      if ($707) { __label__ = 166; break; } else { __label__ = 167; break; }
    case 166: 
      var $709=(($sy)|0);
      var $710=HEAP32[(($709)>>2)];
      var $711=$710;
      _util_memory_d($711, 1400, ((STRING_TABLE.__str572)|0));
      __label__ = 167; break;
    case 167: 
      var $713=(($sy)|0);
      HEAP32[(($713)>>2)]=0;
      var $714=(($sy+4)|0);
      HEAP32[(($714)>>2)]=0;
      var $715=(($sy+8)|0);
      HEAP32[(($715)>>2)]=0;
      var $716=(($sy+12)|0);
      var $717=HEAP32[(($716)>>2)];
      var $718=(($717)|0)!=0;
      if ($718) { __label__ = 168; break; } else { __label__ = 169; break; }
    case 168: 
      var $720=(($sy+12)|0);
      var $721=HEAP32[(($720)>>2)];
      var $722=$721;
      _util_memory_d($722, 1401, ((STRING_TABLE.__str572)|0));
      __label__ = 169; break;
    case 169: 
      var $724=(($sy+12)|0);
      HEAP32[(($724)>>2)]=0;
      var $725=(($sy+16)|0);
      HEAP32[(($725)>>2)]=0;
      var $726=(($sy+20)|0);
      HEAP32[(($726)>>2)]=0;
      $1=0;
      __label__ = 170; break;
    case 170: 
      var $728=$1;
      STACKTOP = __stackBase__;
      return $728;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_expression_leave["X"]=1;

function _parser_strdup($str) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $out;
      $2=$str;
      var $3=$2;
      var $4=(($3)|0)!=0;
      if ($4) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $6=$2;
      var $7=HEAP8[($6)];
      var $8=(($7 << 24) >> 24)!=0;
      if ($8) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $10=_util_memory_a(1, 194, ((STRING_TABLE.__str572)|0));
      $out=$10;
      var $11=$out;
      HEAP8[($11)]=0;
      var $12=$out;
      $1=$12;
      __label__ = 6; break;
    case 5: 
      var $14=$2;
      var $15=_util_strdup($14);
      $1=$15;
      __label__ = 6; break;
    case 6: 
      var $17=$1;
      ;
      return $17;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_reclassify_token($parser) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      $1=$parser;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $3=$i;
      var $4=HEAP32[((_operator_count)>>2)];
      var $5=(($3)>>>0) < (($4)>>>0);
      if ($5) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $7=$1;
      var $8=(($7)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=(($9+292)|0);
      var $11=(($10+4)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=$i;
      var $14=HEAP32[((_operators)>>2)];
      var $15=(($14+($13)*(24))|0);
      var $16=(($15)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=_strcmp($12, $17);
      var $19=(($18)|0)!=0;
      if ($19) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $21=$1;
      var $22=(($21+4)|0);
      HEAP32[(($22)>>2)]=131;
      __label__ = 8; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $25=$i;
      var $26=((($25)+(1))|0);
      $i=$26;
      __label__ = 3; break;
    case 8: 
      ;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_find_var($parser, $name) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $dummy=__stackBase__;
      var $v;
      $1=$parser;
      $2=$name;
      var $3=$1;
      var $4=$2;
      var $5=_parser_find_local($3, $4, 0, $dummy);
      $v=$5;
      var $6=$v;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $9=$1;
      var $10=$2;
      var $11=_parser_find_global($9, $10);
      $v=$11;
      __label__ = 4; break;
    case 4: 
      var $13=$v;
      STACKTOP = __stackBase__;
      return $13;
    default: assert(0, "bad label: " + __label__);
  }
}


function _syexp($agg_result, $ctx_0, $ctx_1, $v) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $e=(__stackBase__)+(8);
  var $2=(($ctx)|0);
  HEAP32[(($2)>>2)]=$ctx_0;
  var $3=(($ctx+4)|0);
  HEAP32[(($3)>>2)]=$ctx_1;
  $1=$v;
  var $4=(($e)|0);
  HEAP32[(($4)>>2)]=0;
  var $5=(($e+8)|0);
  HEAP32[(($5)>>2)]=0;
  var $6=$1;
  var $7=(($e+12)|0);
  HEAP32[(($7)>>2)]=$6;
  var $8=(($e+16)|0);
  HEAP32[(($8)>>2)]=0;
  var $9=(($e+20)|0);
  var $10=$9;
  var $11=$ctx;
  assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
  var $12=(($e+4)|0);
  HEAP32[(($12)>>2)]=0;
  var $13=$agg_result;
  var $14=$e;
  assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($13)>>2)]=HEAP32[(($14)>>2)];HEAP32[((($13)+(4))>>2)]=HEAP32[((($14)+(4))>>2)];HEAP32[((($13)+(8))>>2)]=HEAP32[((($14)+(8))>>2)];HEAP32[((($13)+(12))>>2)]=HEAP32[((($14)+(12))>>2)];HEAP32[((($13)+(16))>>2)]=HEAP32[((($14)+(16))>>2)];HEAP32[((($13)+(20))>>2)]=HEAP32[((($14)+(20))>>2)];HEAP32[((($13)+(24))>>2)]=HEAP32[((($14)+(24))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _parser_const_float($parser, $d) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $out;
      $2=$parser;
      $3=$d;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+48)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+44)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<2))|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16+64)|0);
      var $18=$17;
      var $19=(tempDoubleI32[0]=HEAP32[(($18)>>2)],tempDoubleI32[1]=HEAP32[((($18)+(4))>>2)],tempDoubleF64[0]);
      var $20=$3;
      var $21=$19 == $20;
      if ($21) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $23=$i;
      var $24=$2;
      var $25=(($24+44)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26+($23<<2))|0);
      var $28=HEAP32[(($27)>>2)];
      $1=$28;
      __label__ = 11; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $31=$i;
      var $32=((($31)+(1))|0);
      $i=$32;
      __label__ = 3; break;
    case 8: 
      var $34=$2;
      var $35=(($34)|0);
      var $36=HEAP32[(($35)>>2)];
      var $37=(($36+292)|0);
      var $38=(($37+28)|0);
      var $39=(($38)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($38+4)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=_ast_value_new($40, $42, ((STRING_TABLE.__str102674)|0), 2);
      $out=$43;
      var $44=$out;
      var $45=(($44+60)|0);
      HEAP8[($45)]=1;
      var $46=$3;
      var $47=$out;
      var $48=(($47+64)|0);
      var $49=$48;
      (tempDoubleF64[0]=$46,HEAP32[(($49)>>2)]=tempDoubleI32[0],HEAP32[((($49)+(4))>>2)]=tempDoubleI32[1]);
      var $50=$2;
      var $51=$out;
      var $52=_parser_t_imm_float_add($50, $51);
      if ($52) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $54=$out;
      _ast_value_delete($54);
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $56=$out;
      $1=$56;
      __label__ = 11; break;
    case 11: 
      var $58=$1;
      ;
      return $58;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_const_float["X"]=1;

function _parser_const_string($parser, $str) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $out;
      $2=$parser;
      $3=$str;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $5=$i;
      var $6=$2;
      var $7=(($6+60)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($5)>>>0) < (($8)>>>0);
      if ($9) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $11=$i;
      var $12=$2;
      var $13=(($12+56)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11<<2))|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16+64)|0);
      var $18=$17;
      var $19=HEAP32[(($18)>>2)];
      var $20=$3;
      var $21=_strcmp($19, $20);
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $24=$i;
      var $25=$2;
      var $26=(($25+56)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27+($24<<2))|0);
      var $29=HEAP32[(($28)>>2)];
      $1=$29;
      __label__ = 11; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $32=$i;
      var $33=((($32)+(1))|0);
      $i=$33;
      __label__ = 3; break;
    case 8: 
      var $35=$2;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37+292)|0);
      var $39=(($38+28)|0);
      var $40=(($39)|0);
      var $41=HEAP32[(($40)>>2)];
      var $42=(($39+4)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=_ast_value_new($41, $43, ((STRING_TABLE.__str102674)|0), 1);
      $out=$44;
      var $45=$out;
      var $46=(($45+60)|0);
      HEAP8[($46)]=1;
      var $47=$3;
      var $48=_parser_strdup($47);
      var $49=$out;
      var $50=(($49+64)|0);
      var $51=$50;
      HEAP32[(($51)>>2)]=$48;
      var $52=$2;
      var $53=$out;
      var $54=_parser_t_imm_string_add($52, $53);
      if ($54) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $56=$out;
      _ast_value_delete($56);
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $58=$out;
      $1=$58;
      __label__ = 11; break;
    case 11: 
      var $60=$1;
      ;
      return $60;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_const_string["X"]=1;

function _parser_const_vector($parser, $v_0, $v_1, $v_2) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $v=__stackBase__;
      var $i;
      var $out;
      $2=$parser;
      var $3=(($v)|0);
      HEAPF32[(($3)>>2)]=$v_0;
      var $4=(($v+4)|0);
      HEAPF32[(($4)>>2)]=$v_1;
      var $5=(($v+8)|0);
      HEAPF32[(($5)>>2)]=$v_2;
      $i=0;
      __label__ = 3; break;
    case 3: 
      var $7=$i;
      var $8=$2;
      var $9=(($8+72)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=(($7)>>>0) < (($10)>>>0);
      if ($11) { __label__ = 4; break; } else { __label__ = 8; break; }
    case 4: 
      var $13=$i;
      var $14=$2;
      var $15=(($14+68)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16+($13<<2))|0);
      var $18=HEAP32[(($17)>>2)];
      var $19=(($18+64)|0);
      var $20=$19;
      var $21=$20;
      var $22=$v;
      var $23=_memcmp($21, $22, 12);
      var $24=(($23)|0)!=0;
      if ($24) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $26=$i;
      var $27=$2;
      var $28=(($27+68)|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+($26<<2))|0);
      var $31=HEAP32[(($30)>>2)];
      $1=$31;
      __label__ = 11; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $34=$i;
      var $35=((($34)+(1))|0);
      $i=$35;
      __label__ = 3; break;
    case 8: 
      var $37=$2;
      var $38=(($37)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=(($39+292)|0);
      var $41=(($40+28)|0);
      var $42=(($41)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($41+4)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=_ast_value_new($43, $45, ((STRING_TABLE.__str102674)|0), 3);
      $out=$46;
      var $47=$out;
      var $48=(($47+60)|0);
      HEAP8[($48)]=1;
      var $49=$out;
      var $50=(($49+64)|0);
      var $51=$50;
      var $52=$51;
      var $53=$v;
      assert(12 % 1 === 0, 'memcpy given ' + 12 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($52)>>2)]=HEAP32[(($53)>>2)];HEAP32[((($52)+(4))>>2)]=HEAP32[((($53)+(4))>>2)];HEAP32[((($52)+(8))>>2)]=HEAP32[((($53)+(8))>>2)];
      var $54=$2;
      var $55=$out;
      var $56=_parser_t_imm_vector_add($54, $55);
      if ($56) { __label__ = 10; break; } else { __label__ = 9; break; }
    case 9: 
      var $58=$out;
      _ast_value_delete($58);
      $1=0;
      __label__ = 11; break;
    case 10: 
      var $60=$out;
      $1=$60;
      __label__ = 11; break;
    case 11: 
      var $62=$1;
      STACKTOP = __stackBase__;
      return $62;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_const_vector["X"]=1;

function _parser_close_paren($parser, $sy, $functions_only) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      $2=$parser;
      $3=$sy;
      var $5=(($functions_only)&1);
      $4=$5;
      var $6=$3;
      var $7=(($6+16)|0);
      var $8=HEAP32[(($7)>>2)];
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $11=$2;
      _parseerror($11, ((STRING_TABLE.__str93665)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $14=$3;
      var $15=(($14+16)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 6; break; } else { __label__ = 15; break; }
    case 6: 
      var $19=$3;
      var $20=(($19+16)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=((($21)-(1))|0);
      var $23=$3;
      var $24=(($23+12)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25+($22)*(28))|0);
      var $27=(($26+4)|0);
      var $28=HEAP32[(($27)>>2)];
      var $29=(($28)|0)==102;
      if ($29) { __label__ = 7; break; } else { __label__ = 10; break; }
    case 7: 
      var $31=$2;
      var $32=$3;
      var $33=_parser_close_call($31, $32);
      if ($33) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 16; break;
    case 9: 
      __label__ = 15; break;
    case 10: 
      var $37=$3;
      var $38=(($37+16)|0);
      var $39=HEAP32[(($38)>>2)];
      var $40=((($39)-(1))|0);
      var $41=$3;
      var $42=(($41+12)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($43+($40)*(28))|0);
      var $45=(($44+4)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=(($46)|0)==1;
      if ($47) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $49=$3;
      var $50=(($49+16)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=((($51)-(1))|0);
      HEAP32[(($50)>>2)]=$52;
      var $53=$4;
      var $54=(($53) & 1);
      var $55=$54 ^ 1;
      $1=$55;
      __label__ = 16; break;
    case 12: 
      var $57=$2;
      var $58=$3;
      var $59=_parser_sy_pop($57, $58);
      if ($59) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      $1=0;
      __label__ = 16; break;
    case 14: 
      __label__ = 5; break;
    case 15: 
      $1=1;
      __label__ = 16; break;
    case 16: 
      var $64=$1;
      STACKTOP = __stackBase__;
      return $64;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_close_paren["X"]=1;

function _parser_sy_pop($parser, $sy) {
  var __stackBase__  = STACKTOP; STACKTOP += 4244; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $op;
      var $ctx=__stackBase__;
      var $out;
      var $exprs=(__stackBase__)+(8);
      var $blocks=(__stackBase__)+(20);
      var $asvalue=(__stackBase__)+(32);
      var $i;
      var $assignop;
      var $generated_op;
      var $4=(__stackBase__)+(44);
      var $5=(__stackBase__)+(72);
      var $6=(__stackBase__)+(84);
      var $7=(__stackBase__)+(96);
      var $8=(__stackBase__)+(108);
      var $field;
      var $ty1=(__stackBase__)+(120);
      var $ty2=(__stackBase__)+(1144);
      var $ty11=(__stackBase__)+(2168);
      var $ty22=(__stackBase__)+(3192);
      var $9=(__stackBase__)+(4216);
      $2=$parser;
      $3=$sy;
      $out=0;
      $generated_op=0;
      var $10=$3;
      var $11=(($10+16)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $15=$2;
      _parseerror($15, ((STRING_TABLE.__str67639)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 4: 
      var $17=$3;
      var $18=(($17+16)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=((($19)-(1))|0);
      var $21=$3;
      var $22=(($21+12)|0);
      var $23=HEAP32[(($22)>>2)];
      var $24=(($23+($20)*(28))|0);
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26)|0)!=0;
      if ($27) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $29=$2;
      _parseerror($29, ((STRING_TABLE.__str68640)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 6: 
      var $31=$3;
      var $32=(($31+16)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=((($33)-(1))|0);
      var $35=$3;
      var $36=(($35+12)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37+($34)*(28))|0);
      var $39=(($38)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=((($40)-(1))|0);
      var $42=HEAP32[((_operators)>>2)];
      var $43=(($42+($41)*(24))|0);
      $op=$43;
      var $44=$3;
      var $45=(($44+16)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47=((($46)-(1))|0);
      var $48=$3;
      var $49=(($48+12)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=(($50+($47)*(28))|0);
      var $52=(($51+20)|0);
      var $53=$ctx;
      var $54=$52;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($53)>>2)]=HEAP32[(($54)>>2)];HEAP32[((($53)+(4))>>2)]=HEAP32[((($54)+(4))>>2)];
      var $55=$3;
      var $56=(($55+4)|0);
      var $57=HEAP32[(($56)>>2)];
      var $58=$op;
      var $59=(($58+4)|0);
      var $60=HEAP32[(($59)>>2)];
      var $61=(($57)>>>0) < (($60)>>>0);
      if ($61) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $63=$2;
      var $64=$3;
      var $65=(($64+4)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=$op;
      var $68=(($67)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=$op;
      var $71=(($70+8)|0);
      var $72=HEAP32[(($71)>>2)];
      _parseerror($63, ((STRING_TABLE.__str69641)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$66,HEAP32[(((tempInt)+(4))>>2)]=$69,HEAP32[(((tempInt)+(8))>>2)]=$72,tempInt));
      $1=0;
      __label__ = 254; break;
    case 8: 
      var $74=$3;
      var $75=(($74+16)|0);
      var $76=HEAP32[(($75)>>2)];
      var $77=((($76)-(1))|0);
      HEAP32[(($75)>>2)]=$77;
      var $78=$op;
      var $79=(($78+4)|0);
      var $80=HEAP32[(($79)>>2)];
      var $81=$3;
      var $82=(($81+4)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=((($83)-($80))|0);
      HEAP32[(($82)>>2)]=$84;
      $i=0;
      __label__ = 9; break;
    case 9: 
      var $86=$i;
      var $87=$op;
      var $88=(($87+4)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($86)>>>0) < (($89)>>>0);
      if ($90) { __label__ = 10; break; } else { __label__ = 12; break; }
    case 10: 
      var $92=$3;
      var $93=(($92+4)|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=$i;
      var $96=((($94)+($95))|0);
      var $97=$3;
      var $98=(($97)|0);
      var $99=HEAP32[(($98)>>2)];
      var $100=(($99+($96)*(28))|0);
      var $101=(($100+12)|0);
      var $102=HEAP32[(($101)>>2)];
      var $103=$i;
      var $104=(($exprs+($103<<2))|0);
      HEAP32[(($104)>>2)]=$102;
      var $105=$3;
      var $106=(($105+4)|0);
      var $107=HEAP32[(($106)>>2)];
      var $108=$i;
      var $109=((($107)+($108))|0);
      var $110=$3;
      var $111=(($110)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($112+($109)*(28))|0);
      var $114=(($113+16)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=$i;
      var $117=(($blocks+($116<<2))|0);
      HEAP32[(($117)>>2)]=$115;
      var $118=$i;
      var $119=(($exprs+($118<<2))|0);
      var $120=HEAP32[(($119)>>2)];
      var $121=$120;
      var $122=$i;
      var $123=(($asvalue+($122<<2))|0);
      HEAP32[(($123)>>2)]=$121;
      __label__ = 11; break;
    case 11: 
      var $125=$i;
      var $126=((($125)+(1))|0);
      $i=$126;
      __label__ = 9; break;
    case 12: 
      var $128=(($blocks)|0);
      var $129=HEAP32[(($128)>>2)];
      var $130=(($129)|0)!=0;
      if ($130) { __label__ = 13; break; } else { __label__ = 16; break; }
    case 13: 
      var $132=(($blocks)|0);
      var $133=HEAP32[(($132)>>2)];
      var $134=(($133+72)|0);
      var $135=HEAP32[(($134)>>2)];
      var $136=(($135)|0)!=0;
      if ($136) { __label__ = 16; break; } else { __label__ = 14; break; }
    case 14: 
      var $138=$op;
      var $139=(($138+8)|0);
      var $140=HEAP32[(($139)>>2)];
      var $141=(($140)|0)!=44;
      if ($141) { __label__ = 15; break; } else { __label__ = 16; break; }
    case 15: 
      var $143=$2;
      _parseerror($143, ((STRING_TABLE.__str70642)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 16: 
      var $145=$op;
      var $146=(($145+8)|0);
      var $147=HEAP32[(($146)>>2)];
      if ((($147)|0) == 46) {
        __label__ = 18; break;
      }
      else if ((($147)|0) == 44) {
        __label__ = 26; break;
      }
      else if ((($147)|0) == 11600) {
        __label__ = 37; break;
      }
      else if ((($147)|0) == 8528) {
        __label__ = 50; break;
      }
      else if ((($147)|0) == 43) {
        __label__ = 75; break;
      }
      else if ((($147)|0) == 45) {
        __label__ = 96; break;
      }
      else if ((($147)|0) == 42) {
        __label__ = 117; break;
      }
      else if ((($147)|0) == 47) {
        __label__ = 158; break;
      }
      else if ((($147)|0) == 37 || (($147)|0) == 9533) {
        __label__ = 168; break;
      }
      else if ((($147)|0) == 124 || (($147)|0) == 38) {
        __label__ = 169; break;
      }
      else if ((($147)|0) == 94) {
        __label__ = 182; break;
      }
      else if ((($147)|0) == 15420 || (($147)|0) == 15934 || (($147)|0) == 3947581 || (($147)|0) == 4079165) {
        __label__ = 183; break;
      }
      else if ((($147)|0) == 31868) {
        __label__ = 184; break;
      }
      else if ((($147)|0) == 9766) {
        __label__ = 185; break;
      }
      else if ((($147)|0) == 62) {
        __label__ = 204; break;
      }
      else if ((($147)|0) == 60) {
        __label__ = 205; break;
      }
      else if ((($147)|0) == 15933) {
        __label__ = 206; break;
      }
      else if ((($147)|0) == 15421) {
        __label__ = 207; break;
      }
      else if ((($147)|0) == 8509) {
        __label__ = 211; break;
      }
      else if ((($147)|0) == 15677) {
        __label__ = 214; break;
      }
      else if ((($147)|0) == 61) {
        __label__ = 217; break;
      }
      else if ((($147)|0) == 11069 || (($147)|0) == 11581) {
        __label__ = 239; break;
      }
      else {
      __label__ = 17; break;
      }
      
    case 17: 
      var $149=$2;
      var $150=$op;
      var $151=(($150)|0);
      var $152=HEAP32[(($151)>>2)];
      var $153=$op;
      var $154=(($153+8)|0);
      var $155=HEAP32[(($154)>>2)];
      _parseerror($149, ((STRING_TABLE.__str71643)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$152,HEAP32[(((tempInt)+(4))>>2)]=$155,tempInt));
      $1=0;
      __label__ = 254; break;
    case 18: 
      var $157=(($exprs)|0);
      var $158=HEAP32[(($157)>>2)];
      var $159=$158;
      var $160=(($159+24)|0);
      var $161=HEAP32[(($160)>>2)];
      var $162=(($161)|0)==4;
      if ($162) { __label__ = 19; break; } else { __label__ = 22; break; }
    case 19: 
      var $164=(($exprs+4)|0);
      var $165=HEAP32[(($164)>>2)];
      var $166=$165;
      var $167=(($166+24)|0);
      var $168=HEAP32[(($167)>>2)];
      var $169=(($168)|0)!=5;
      if ($169) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      var $171=$2;
      _parseerror($171, ((STRING_TABLE.__str72644)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 21: 
      var $173=(($exprs)|0);
      var $174=HEAP32[(($173)>>2)];
      var $175=(($exprs+4)|0);
      var $176=HEAP32[(($175)>>2)];
      var $177=(($ctx)|0);
      var $178=HEAP32[(($177)>>2)];
      var $179=(($ctx+4)|0);
      var $180=HEAP32[(($179)>>2)];
      var $181=_ast_entfield_new($178, $180, $174, $176);
      var $182=$181;
      $out=$182;
      __label__ = 25; break;
    case 22: 
      var $184=(($exprs)|0);
      var $185=HEAP32[(($184)>>2)];
      var $186=$185;
      var $187=(($186+24)|0);
      var $188=HEAP32[(($187)>>2)];
      var $189=(($188)|0)==3;
      if ($189) { __label__ = 23; break; } else { __label__ = 24; break; }
    case 23: 
      var $191=$2;
      _parseerror($191, ((STRING_TABLE.__str73645)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 24: 
      var $193=$2;
      _parseerror($193, ((STRING_TABLE.__str74646)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 25: 
      __label__ = 251; break;
    case 26: 
      var $196=(($blocks)|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=(($197)|0)!=0;
      if ($198) { __label__ = 27; break; } else { __label__ = 30; break; }
    case 27: 
      var $200=(($blocks)|0);
      var $201=HEAP32[(($200)>>2)];
      var $202=(($exprs+4)|0);
      var $203=HEAP32[(($202)>>2)];
      var $204=_ast_block_exprs_add($201, $203);
      if ($204) { __label__ = 29; break; } else { __label__ = 28; break; }
    case 28: 
      $1=0;
      __label__ = 254; break;
    case 29: 
      __label__ = 34; break;
    case 30: 
      var $208=(($ctx)|0);
      var $209=HEAP32[(($208)>>2)];
      var $210=(($ctx+4)|0);
      var $211=HEAP32[(($210)>>2)];
      var $212=_ast_block_new($209, $211);
      var $213=(($blocks)|0);
      HEAP32[(($213)>>2)]=$212;
      var $214=(($blocks)|0);
      var $215=HEAP32[(($214)>>2)];
      var $216=(($exprs)|0);
      var $217=HEAP32[(($216)>>2)];
      var $218=_ast_block_exprs_add($215, $217);
      if ($218) { __label__ = 31; break; } else { __label__ = 32; break; }
    case 31: 
      var $220=(($blocks)|0);
      var $221=HEAP32[(($220)>>2)];
      var $222=(($exprs+4)|0);
      var $223=HEAP32[(($222)>>2)];
      var $224=_ast_block_exprs_add($221, $223);
      if ($224) { __label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      $1=0;
      __label__ = 254; break;
    case 33: 
      __label__ = 34; break;
    case 34: 
      var $228=(($blocks)|0);
      var $229=HEAP32[(($228)>>2)];
      var $230=(($exprs+4)|0);
      var $231=HEAP32[(($230)>>2)];
      var $232=_ast_block_set_type($229, $231);
      if ($232) { __label__ = 36; break; } else { __label__ = 35; break; }
    case 35: 
      $1=0;
      __label__ = 254; break;
    case 36: 
      var $235=$3;
      var $236=(($235+4)|0);
      var $237=HEAP32[(($236)>>2)];
      var $238=((($237)+(1))|0);
      HEAP32[(($236)>>2)]=$238;
      var $239=$3;
      var $240=(($239)|0);
      var $241=HEAP32[(($240)>>2)];
      var $242=(($241+($237)*(28))|0);
      var $243=(($blocks)|0);
      var $244=HEAP32[(($243)>>2)];
      var $245=(($ctx)|0);
      var $246=HEAP32[(($245)>>2)];
      var $247=(($ctx+4)|0);
      var $248=HEAP32[(($247)>>2)];
      _syblock($4, $246, $248, $244);
      var $249=$242;
      var $250=$4;
      assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($249)>>2)]=HEAP32[(($250)>>2)];HEAP32[((($249)+(4))>>2)]=HEAP32[((($250)+(4))>>2)];HEAP32[((($249)+(8))>>2)]=HEAP32[((($250)+(8))>>2)];HEAP32[((($249)+(12))>>2)]=HEAP32[((($250)+(12))>>2)];HEAP32[((($249)+(16))>>2)]=HEAP32[((($250)+(16))>>2)];HEAP32[((($249)+(20))>>2)]=HEAP32[((($250)+(20))>>2)];HEAP32[((($249)+(24))>>2)]=HEAP32[((($250)+(24))>>2)];
      $1=1;
      __label__ = 254; break;
    case 37: 
      var $252=(($exprs)|0);
      var $253=HEAP32[(($252)>>2)];
      var $254=$253;
      var $255=(($254+24)|0);
      var $256=HEAP32[(($255)>>2)];
      if ((($256)|0) == 2) {
        __label__ = 38; break;
      }
      else if ((($256)|0) == 3) {
        __label__ = 43; break;
      }
      else {
      __label__ = 48; break;
      }
      
    case 38: 
      var $258=(($exprs)|0);
      var $259=HEAP32[(($258)>>2)];
      var $260=$259;
      var $261=(($260+12)|0);
      var $262=HEAP32[(($261)>>2)];
      var $263=(($262)|0)==2;
      if ($263) { __label__ = 39; break; } else { __label__ = 41; break; }
    case 39: 
      var $265=(($exprs)|0);
      var $266=HEAP32[(($265)>>2)];
      var $267=$266;
      var $268=(($267+60)|0);
      var $269=HEAP8[($268)];
      var $270=(($269) & 1);
      if ($270) { __label__ = 40; break; } else { __label__ = 41; break; }
    case 40: 
      var $272=$2;
      var $273=(($asvalue)|0);
      var $274=HEAP32[(($273)>>2)];
      var $275=(($274+64)|0);
      var $276=$275;
      var $277=(tempDoubleI32[0]=HEAP32[(($276)>>2)],tempDoubleI32[1]=HEAP32[((($276)+(4))>>2)],tempDoubleF64[0]);
      var $278=(-$277);
      var $279=_parser_const_float($272, $278);
      var $280=$279;
      $out=$280;
      __label__ = 42; break;
    case 41: 
      var $282=$2;
      var $283=_parser_const_float_0($282);
      var $284=$283;
      var $285=(($exprs)|0);
      var $286=HEAP32[(($285)>>2)];
      var $287=(($ctx)|0);
      var $288=HEAP32[(($287)>>2)];
      var $289=(($ctx+4)|0);
      var $290=HEAP32[(($289)>>2)];
      var $291=_ast_binary_new($288, $290, 8, $284, $286);
      var $292=$291;
      $out=$292;
      __label__ = 42; break;
    case 42: 
      __label__ = 49; break;
    case 43: 
      var $295=(($exprs)|0);
      var $296=HEAP32[(($295)>>2)];
      var $297=$296;
      var $298=(($297+12)|0);
      var $299=HEAP32[(($298)>>2)];
      var $300=(($299)|0)==2;
      if ($300) { __label__ = 44; break; } else { __label__ = 46; break; }
    case 44: 
      var $302=(($exprs)|0);
      var $303=HEAP32[(($302)>>2)];
      var $304=$303;
      var $305=(($304+60)|0);
      var $306=HEAP8[($305)];
      var $307=(($306) & 1);
      if ($307) { __label__ = 45; break; } else { __label__ = 46; break; }
    case 45: 
      var $309=$2;
      var $310=(($asvalue)|0);
      var $311=HEAP32[(($310)>>2)];
      var $312=(($311+64)|0);
      var $313=$312;
      var $314=(($313)|0);
      var $315=HEAPF32[(($314)>>2)];
      var $316=(-$315);
      var $317=(($asvalue)|0);
      var $318=HEAP32[(($317)>>2)];
      var $319=(($318+64)|0);
      var $320=$319;
      var $321=(($320+4)|0);
      var $322=HEAPF32[(($321)>>2)];
      var $323=(-$322);
      var $324=(($asvalue)|0);
      var $325=HEAP32[(($324)>>2)];
      var $326=(($325+64)|0);
      var $327=$326;
      var $328=(($327+8)|0);
      var $329=HEAPF32[(($328)>>2)];
      var $330=(-$329);
      var $331=_parser_const_vector_f($309, $316, $323, $330);
      var $332=$331;
      $out=$332;
      __label__ = 47; break;
    case 46: 
      var $334=$2;
      var $335=_parser_const_vector_0($334);
      var $336=$335;
      var $337=(($exprs)|0);
      var $338=HEAP32[(($337)>>2)];
      var $339=(($ctx)|0);
      var $340=HEAP32[(($339)>>2)];
      var $341=(($ctx+4)|0);
      var $342=HEAP32[(($341)>>2)];
      var $343=_ast_binary_new($340, $342, 9, $336, $338);
      var $344=$343;
      $out=$344;
      __label__ = 47; break;
    case 47: 
      __label__ = 49; break;
    case 48: 
      var $347=$2;
      var $348=(($exprs)|0);
      var $349=HEAP32[(($348)>>2)];
      var $350=$349;
      var $351=(($350+24)|0);
      var $352=HEAP32[(($351)>>2)];
      var $353=((_type_name+($352<<2))|0);
      var $354=HEAP32[(($353)>>2)];
      _parseerror($347, ((STRING_TABLE.__str75647)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$354,tempInt));
      $1=0;
      __label__ = 254; break;
    case 49: 
      __label__ = 251; break;
    case 50: 
      var $357=(($exprs)|0);
      var $358=HEAP32[(($357)>>2)];
      var $359=$358;
      var $360=(($359+24)|0);
      var $361=HEAP32[(($360)>>2)];
      if ((($361)|0) == 2) {
        __label__ = 51; break;
      }
      else if ((($361)|0) == 3) {
        __label__ = 56; break;
      }
      else if ((($361)|0) == 1) {
        __label__ = 64; break;
      }
      else if ((($361)|0) == 4) {
        __label__ = 71; break;
      }
      else if ((($361)|0) == 6) {
        __label__ = 72; break;
      }
      else {
      __label__ = 73; break;
      }
      
    case 51: 
      var $363=(($exprs)|0);
      var $364=HEAP32[(($363)>>2)];
      var $365=$364;
      var $366=(($365+12)|0);
      var $367=HEAP32[(($366)>>2)];
      var $368=(($367)|0)==2;
      if ($368) { __label__ = 52; break; } else { __label__ = 54; break; }
    case 52: 
      var $370=(($exprs)|0);
      var $371=HEAP32[(($370)>>2)];
      var $372=$371;
      var $373=(($372+60)|0);
      var $374=HEAP8[($373)];
      var $375=(($374) & 1);
      if ($375) { __label__ = 53; break; } else { __label__ = 54; break; }
    case 53: 
      var $377=$2;
      var $378=(($asvalue)|0);
      var $379=HEAP32[(($378)>>2)];
      var $380=(($379+64)|0);
      var $381=$380;
      var $382=(tempDoubleI32[0]=HEAP32[(($381)>>2)],tempDoubleI32[1]=HEAP32[((($381)+(4))>>2)],tempDoubleF64[0]);
      var $383=$382 != 0;
      var $384=$383 ^ 1;
      var $385=(($384)&1);
      var $386=(($385)|0);
      var $387=_parser_const_float($377, $386);
      var $388=$387;
      $out=$388;
      __label__ = 55; break;
    case 54: 
      var $390=(($exprs)|0);
      var $391=HEAP32[(($390)>>2)];
      var $392=(($ctx)|0);
      var $393=HEAP32[(($392)>>2)];
      var $394=(($ctx+4)|0);
      var $395=HEAP32[(($394)>>2)];
      var $396=_ast_unary_new($393, $395, 44, $391);
      var $397=$396;
      $out=$397;
      __label__ = 55; break;
    case 55: 
      __label__ = 74; break;
    case 56: 
      var $400=(($exprs)|0);
      var $401=HEAP32[(($400)>>2)];
      var $402=$401;
      var $403=(($402+12)|0);
      var $404=HEAP32[(($403)>>2)];
      var $405=(($404)|0)==2;
      if ($405) { __label__ = 57; break; } else { __label__ = 62; break; }
    case 57: 
      var $407=(($exprs)|0);
      var $408=HEAP32[(($407)>>2)];
      var $409=$408;
      var $410=(($409+60)|0);
      var $411=HEAP8[($410)];
      var $412=(($411) & 1);
      if ($412) { __label__ = 58; break; } else { __label__ = 62; break; }
    case 58: 
      var $414=$2;
      var $415=(($asvalue)|0);
      var $416=HEAP32[(($415)>>2)];
      var $417=(($416+64)|0);
      var $418=$417;
      var $419=(($418)|0);
      var $420=HEAPF32[(($419)>>2)];
      var $421=$420 != 0;
      if ($421) { var $440 = 0;__label__ = 61; break; } else { __label__ = 59; break; }
    case 59: 
      var $423=(($asvalue)|0);
      var $424=HEAP32[(($423)>>2)];
      var $425=(($424+64)|0);
      var $426=$425;
      var $427=(($426+4)|0);
      var $428=HEAPF32[(($427)>>2)];
      var $429=$428 != 0;
      if ($429) { var $440 = 0;__label__ = 61; break; } else { __label__ = 60; break; }
    case 60: 
      var $431=(($asvalue)|0);
      var $432=HEAP32[(($431)>>2)];
      var $433=(($432+64)|0);
      var $434=$433;
      var $435=(($434+8)|0);
      var $436=HEAPF32[(($435)>>2)];
      var $437=$436 != 0;
      var $438=$437 ^ 1;
      var $440 = $438;__label__ = 61; break;
    case 61: 
      var $440;
      var $441=(($440)&1);
      var $442=(($441)|0);
      var $443=_parser_const_float($414, $442);
      var $444=$443;
      $out=$444;
      __label__ = 63; break;
    case 62: 
      var $446=(($exprs)|0);
      var $447=HEAP32[(($446)>>2)];
      var $448=(($ctx)|0);
      var $449=HEAP32[(($448)>>2)];
      var $450=(($ctx+4)|0);
      var $451=HEAP32[(($450)>>2)];
      var $452=_ast_unary_new($449, $451, 45, $447);
      var $453=$452;
      $out=$453;
      __label__ = 63; break;
    case 63: 
      __label__ = 74; break;
    case 64: 
      var $456=(($exprs)|0);
      var $457=HEAP32[(($456)>>2)];
      var $458=$457;
      var $459=(($458+12)|0);
      var $460=HEAP32[(($459)>>2)];
      var $461=(($460)|0)==2;
      if ($461) { __label__ = 65; break; } else { __label__ = 69; break; }
    case 65: 
      var $463=(($exprs)|0);
      var $464=HEAP32[(($463)>>2)];
      var $465=$464;
      var $466=(($465+60)|0);
      var $467=HEAP8[($466)];
      var $468=(($467) & 1);
      if ($468) { __label__ = 66; break; } else { __label__ = 69; break; }
    case 66: 
      var $470=$2;
      var $471=(($asvalue)|0);
      var $472=HEAP32[(($471)>>2)];
      var $473=(($472+64)|0);
      var $474=$473;
      var $475=HEAP32[(($474)>>2)];
      var $476=(($475)|0)!=0;
      if ($476) { __label__ = 67; break; } else { var $487 = 1;__label__ = 68; break; }
    case 67: 
      var $478=(($asvalue)|0);
      var $479=HEAP32[(($478)>>2)];
      var $480=(($479+64)|0);
      var $481=$480;
      var $482=HEAP32[(($481)>>2)];
      var $483=HEAP8[($482)];
      var $484=(($483 << 24) >> 24)!=0;
      var $485=$484 ^ 1;
      var $487 = $485;__label__ = 68; break;
    case 68: 
      var $487;
      var $488=(($487)&1);
      var $489=(($488)|0);
      var $490=_parser_const_float($470, $489);
      var $491=$490;
      $out=$491;
      __label__ = 70; break;
    case 69: 
      var $493=(($exprs)|0);
      var $494=HEAP32[(($493)>>2)];
      var $495=(($ctx)|0);
      var $496=HEAP32[(($495)>>2)];
      var $497=(($ctx+4)|0);
      var $498=HEAP32[(($497)>>2)];
      var $499=_ast_unary_new($496, $498, 46, $494);
      var $500=$499;
      $out=$500;
      __label__ = 70; break;
    case 70: 
      __label__ = 74; break;
    case 71: 
      var $503=(($exprs)|0);
      var $504=HEAP32[(($503)>>2)];
      var $505=(($ctx)|0);
      var $506=HEAP32[(($505)>>2)];
      var $507=(($ctx+4)|0);
      var $508=HEAP32[(($507)>>2)];
      var $509=_ast_unary_new($506, $508, 47, $504);
      var $510=$509;
      $out=$510;
      __label__ = 74; break;
    case 72: 
      var $512=(($exprs)|0);
      var $513=HEAP32[(($512)>>2)];
      var $514=(($ctx)|0);
      var $515=HEAP32[(($514)>>2)];
      var $516=(($ctx+4)|0);
      var $517=HEAP32[(($516)>>2)];
      var $518=_ast_unary_new($515, $517, 48, $513);
      var $519=$518;
      $out=$519;
      __label__ = 74; break;
    case 73: 
      var $521=$2;
      var $522=(($exprs)|0);
      var $523=HEAP32[(($522)>>2)];
      var $524=$523;
      var $525=(($524+24)|0);
      var $526=HEAP32[(($525)>>2)];
      var $527=((_type_name+($526<<2))|0);
      var $528=HEAP32[(($527)>>2)];
      _parseerror($521, ((STRING_TABLE.__str76648)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$528,tempInt));
      $1=0;
      __label__ = 254; break;
    case 74: 
      __label__ = 251; break;
    case 75: 
      var $531=(($exprs)|0);
      var $532=HEAP32[(($531)>>2)];
      var $533=$532;
      var $534=(($533+24)|0);
      var $535=HEAP32[(($534)>>2)];
      var $536=(($exprs+4)|0);
      var $537=HEAP32[(($536)>>2)];
      var $538=$537;
      var $539=(($538+24)|0);
      var $540=HEAP32[(($539)>>2)];
      var $541=(($535)|0)!=(($540)|0);
      if ($541) { __label__ = 78; break; } else { __label__ = 76; break; }
    case 76: 
      var $543=(($exprs)|0);
      var $544=HEAP32[(($543)>>2)];
      var $545=$544;
      var $546=(($545+24)|0);
      var $547=HEAP32[(($546)>>2)];
      var $548=(($547)|0)!=3;
      if ($548) { __label__ = 77; break; } else { __label__ = 79; break; }
    case 77: 
      var $550=(($exprs)|0);
      var $551=HEAP32[(($550)>>2)];
      var $552=$551;
      var $553=(($552+24)|0);
      var $554=HEAP32[(($553)>>2)];
      var $555=(($554)|0)!=2;
      if ($555) { __label__ = 78; break; } else { __label__ = 79; break; }
    case 78: 
      var $557=$2;
      var $558=(($exprs)|0);
      var $559=HEAP32[(($558)>>2)];
      var $560=$559;
      var $561=(($560+24)|0);
      var $562=HEAP32[(($561)>>2)];
      var $563=((_type_name+($562<<2))|0);
      var $564=HEAP32[(($563)>>2)];
      var $565=(($exprs+4)|0);
      var $566=HEAP32[(($565)>>2)];
      var $567=$566;
      var $568=(($567+24)|0);
      var $569=HEAP32[(($568)>>2)];
      var $570=((_type_name+($569<<2))|0);
      var $571=HEAP32[(($570)>>2)];
      _parseerror($557, ((STRING_TABLE.__str77649)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$564,HEAP32[(((tempInt)+(4))>>2)]=$571,tempInt));
      $1=0;
      __label__ = 254; break;
    case 79: 
      var $573=(($exprs)|0);
      var $574=HEAP32[(($573)>>2)];
      var $575=$574;
      var $576=(($575+24)|0);
      var $577=HEAP32[(($576)>>2)];
      if ((($577)|0) == 2) {
        __label__ = 80; break;
      }
      else if ((($577)|0) == 3) {
        __label__ = 87; break;
      }
      else {
      __label__ = 94; break;
      }
      
    case 80: 
      var $579=(($exprs)|0);
      var $580=HEAP32[(($579)>>2)];
      var $581=$580;
      var $582=(($581+12)|0);
      var $583=HEAP32[(($582)>>2)];
      var $584=(($583)|0)==2;
      if ($584) { __label__ = 81; break; } else { __label__ = 85; break; }
    case 81: 
      var $586=(($exprs)|0);
      var $587=HEAP32[(($586)>>2)];
      var $588=$587;
      var $589=(($588+60)|0);
      var $590=HEAP8[($589)];
      var $591=(($590) & 1);
      if ($591) { __label__ = 82; break; } else { __label__ = 85; break; }
    case 82: 
      var $593=(($exprs+4)|0);
      var $594=HEAP32[(($593)>>2)];
      var $595=$594;
      var $596=(($595+12)|0);
      var $597=HEAP32[(($596)>>2)];
      var $598=(($597)|0)==2;
      if ($598) { __label__ = 83; break; } else { __label__ = 85; break; }
    case 83: 
      var $600=(($exprs+4)|0);
      var $601=HEAP32[(($600)>>2)];
      var $602=$601;
      var $603=(($602+60)|0);
      var $604=HEAP8[($603)];
      var $605=(($604) & 1);
      if ($605) { __label__ = 84; break; } else { __label__ = 85; break; }
    case 84: 
      var $607=$2;
      var $608=(($asvalue)|0);
      var $609=HEAP32[(($608)>>2)];
      var $610=(($609+64)|0);
      var $611=$610;
      var $612=(tempDoubleI32[0]=HEAP32[(($611)>>2)],tempDoubleI32[1]=HEAP32[((($611)+(4))>>2)],tempDoubleF64[0]);
      var $613=(($asvalue+4)|0);
      var $614=HEAP32[(($613)>>2)];
      var $615=(($614+64)|0);
      var $616=$615;
      var $617=(tempDoubleI32[0]=HEAP32[(($616)>>2)],tempDoubleI32[1]=HEAP32[((($616)+(4))>>2)],tempDoubleF64[0]);
      var $618=($612)+($617);
      var $619=_parser_const_float($607, $618);
      var $620=$619;
      $out=$620;
      __label__ = 86; break;
    case 85: 
      var $622=(($exprs)|0);
      var $623=HEAP32[(($622)>>2)];
      var $624=(($exprs+4)|0);
      var $625=HEAP32[(($624)>>2)];
      var $626=(($ctx)|0);
      var $627=HEAP32[(($626)>>2)];
      var $628=(($ctx+4)|0);
      var $629=HEAP32[(($628)>>2)];
      var $630=_ast_binary_new($627, $629, 6, $623, $625);
      var $631=$630;
      $out=$631;
      __label__ = 86; break;
    case 86: 
      __label__ = 95; break;
    case 87: 
      var $634=(($exprs)|0);
      var $635=HEAP32[(($634)>>2)];
      var $636=$635;
      var $637=(($636+12)|0);
      var $638=HEAP32[(($637)>>2)];
      var $639=(($638)|0)==2;
      if ($639) { __label__ = 88; break; } else { __label__ = 92; break; }
    case 88: 
      var $641=(($exprs)|0);
      var $642=HEAP32[(($641)>>2)];
      var $643=$642;
      var $644=(($643+60)|0);
      var $645=HEAP8[($644)];
      var $646=(($645) & 1);
      if ($646) { __label__ = 89; break; } else { __label__ = 92; break; }
    case 89: 
      var $648=(($exprs+4)|0);
      var $649=HEAP32[(($648)>>2)];
      var $650=$649;
      var $651=(($650+12)|0);
      var $652=HEAP32[(($651)>>2)];
      var $653=(($652)|0)==2;
      if ($653) { __label__ = 90; break; } else { __label__ = 92; break; }
    case 90: 
      var $655=(($exprs+4)|0);
      var $656=HEAP32[(($655)>>2)];
      var $657=$656;
      var $658=(($657+60)|0);
      var $659=HEAP8[($658)];
      var $660=(($659) & 1);
      if ($660) { __label__ = 91; break; } else { __label__ = 92; break; }
    case 91: 
      var $662=$2;
      var $663=(($asvalue)|0);
      var $664=HEAP32[(($663)>>2)];
      var $665=(($664+64)|0);
      var $666=$665;
      var $667=(($asvalue+4)|0);
      var $668=HEAP32[(($667)>>2)];
      var $669=(($668+64)|0);
      var $670=$669;
      var $671=(($666)|0);
      var $672=HEAPF32[(($671)>>2)];
      var $673=(($666+4)|0);
      var $674=HEAPF32[(($673)>>2)];
      var $675=(($666+8)|0);
      var $676=HEAPF32[(($675)>>2)];
      var $677=(($670)|0);
      var $678=HEAPF32[(($677)>>2)];
      var $679=(($670+4)|0);
      var $680=HEAPF32[(($679)>>2)];
      var $681=(($670+8)|0);
      var $682=HEAPF32[(($681)>>2)];
      _vec3_add($5, $672, $674, $676, $678, $680, $682);
      var $683=(($5)|0);
      var $684=HEAPF32[(($683)>>2)];
      var $685=(($5+4)|0);
      var $686=HEAPF32[(($685)>>2)];
      var $687=(($5+8)|0);
      var $688=HEAPF32[(($687)>>2)];
      var $689=_parser_const_vector($662, $684, $686, $688);
      var $690=$689;
      $out=$690;
      __label__ = 93; break;
    case 92: 
      var $692=(($exprs)|0);
      var $693=HEAP32[(($692)>>2)];
      var $694=(($exprs+4)|0);
      var $695=HEAP32[(($694)>>2)];
      var $696=(($ctx)|0);
      var $697=HEAP32[(($696)>>2)];
      var $698=(($ctx+4)|0);
      var $699=HEAP32[(($698)>>2)];
      var $700=_ast_binary_new($697, $699, 7, $693, $695);
      var $701=$700;
      $out=$701;
      __label__ = 93; break;
    case 93: 
      __label__ = 95; break;
    case 94: 
      var $704=$2;
      var $705=(($exprs)|0);
      var $706=HEAP32[(($705)>>2)];
      var $707=$706;
      var $708=(($707+24)|0);
      var $709=HEAP32[(($708)>>2)];
      var $710=((_type_name+($709<<2))|0);
      var $711=HEAP32[(($710)>>2)];
      var $712=(($exprs+4)|0);
      var $713=HEAP32[(($712)>>2)];
      var $714=$713;
      var $715=(($714+24)|0);
      var $716=HEAP32[(($715)>>2)];
      var $717=((_type_name+($716<<2))|0);
      var $718=HEAP32[(($717)>>2)];
      _parseerror($704, ((STRING_TABLE.__str77649)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$711,HEAP32[(((tempInt)+(4))>>2)]=$718,tempInt));
      $1=0;
      __label__ = 254; break;
    case 95: 
      __label__ = 251; break;
    case 96: 
      var $721=(($exprs)|0);
      var $722=HEAP32[(($721)>>2)];
      var $723=$722;
      var $724=(($723+24)|0);
      var $725=HEAP32[(($724)>>2)];
      var $726=(($exprs+4)|0);
      var $727=HEAP32[(($726)>>2)];
      var $728=$727;
      var $729=(($728+24)|0);
      var $730=HEAP32[(($729)>>2)];
      var $731=(($725)|0)!=(($730)|0);
      if ($731) { __label__ = 99; break; } else { __label__ = 97; break; }
    case 97: 
      var $733=(($exprs)|0);
      var $734=HEAP32[(($733)>>2)];
      var $735=$734;
      var $736=(($735+24)|0);
      var $737=HEAP32[(($736)>>2)];
      var $738=(($737)|0)!=3;
      if ($738) { __label__ = 98; break; } else { __label__ = 100; break; }
    case 98: 
      var $740=(($exprs)|0);
      var $741=HEAP32[(($740)>>2)];
      var $742=$741;
      var $743=(($742+24)|0);
      var $744=HEAP32[(($743)>>2)];
      var $745=(($744)|0)!=2;
      if ($745) { __label__ = 99; break; } else { __label__ = 100; break; }
    case 99: 
      var $747=$2;
      var $748=(($exprs+4)|0);
      var $749=HEAP32[(($748)>>2)];
      var $750=$749;
      var $751=(($750+24)|0);
      var $752=HEAP32[(($751)>>2)];
      var $753=((_type_name+($752<<2))|0);
      var $754=HEAP32[(($753)>>2)];
      var $755=(($exprs)|0);
      var $756=HEAP32[(($755)>>2)];
      var $757=$756;
      var $758=(($757+24)|0);
      var $759=HEAP32[(($758)>>2)];
      var $760=((_type_name+($759<<2))|0);
      var $761=HEAP32[(($760)>>2)];
      _parseerror($747, ((STRING_TABLE.__str78650)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$754,HEAP32[(((tempInt)+(4))>>2)]=$761,tempInt));
      $1=0;
      __label__ = 254; break;
    case 100: 
      var $763=(($exprs)|0);
      var $764=HEAP32[(($763)>>2)];
      var $765=$764;
      var $766=(($765+24)|0);
      var $767=HEAP32[(($766)>>2)];
      if ((($767)|0) == 2) {
        __label__ = 101; break;
      }
      else if ((($767)|0) == 3) {
        __label__ = 108; break;
      }
      else {
      __label__ = 115; break;
      }
      
    case 101: 
      var $769=(($exprs)|0);
      var $770=HEAP32[(($769)>>2)];
      var $771=$770;
      var $772=(($771+12)|0);
      var $773=HEAP32[(($772)>>2)];
      var $774=(($773)|0)==2;
      if ($774) { __label__ = 102; break; } else { __label__ = 106; break; }
    case 102: 
      var $776=(($exprs)|0);
      var $777=HEAP32[(($776)>>2)];
      var $778=$777;
      var $779=(($778+60)|0);
      var $780=HEAP8[($779)];
      var $781=(($780) & 1);
      if ($781) { __label__ = 103; break; } else { __label__ = 106; break; }
    case 103: 
      var $783=(($exprs+4)|0);
      var $784=HEAP32[(($783)>>2)];
      var $785=$784;
      var $786=(($785+12)|0);
      var $787=HEAP32[(($786)>>2)];
      var $788=(($787)|0)==2;
      if ($788) { __label__ = 104; break; } else { __label__ = 106; break; }
    case 104: 
      var $790=(($exprs+4)|0);
      var $791=HEAP32[(($790)>>2)];
      var $792=$791;
      var $793=(($792+60)|0);
      var $794=HEAP8[($793)];
      var $795=(($794) & 1);
      if ($795) { __label__ = 105; break; } else { __label__ = 106; break; }
    case 105: 
      var $797=$2;
      var $798=(($asvalue)|0);
      var $799=HEAP32[(($798)>>2)];
      var $800=(($799+64)|0);
      var $801=$800;
      var $802=(tempDoubleI32[0]=HEAP32[(($801)>>2)],tempDoubleI32[1]=HEAP32[((($801)+(4))>>2)],tempDoubleF64[0]);
      var $803=(($asvalue+4)|0);
      var $804=HEAP32[(($803)>>2)];
      var $805=(($804+64)|0);
      var $806=$805;
      var $807=(tempDoubleI32[0]=HEAP32[(($806)>>2)],tempDoubleI32[1]=HEAP32[((($806)+(4))>>2)],tempDoubleF64[0]);
      var $808=($802)-($807);
      var $809=_parser_const_float($797, $808);
      var $810=$809;
      $out=$810;
      __label__ = 107; break;
    case 106: 
      var $812=(($exprs)|0);
      var $813=HEAP32[(($812)>>2)];
      var $814=(($exprs+4)|0);
      var $815=HEAP32[(($814)>>2)];
      var $816=(($ctx)|0);
      var $817=HEAP32[(($816)>>2)];
      var $818=(($ctx+4)|0);
      var $819=HEAP32[(($818)>>2)];
      var $820=_ast_binary_new($817, $819, 8, $813, $815);
      var $821=$820;
      $out=$821;
      __label__ = 107; break;
    case 107: 
      __label__ = 116; break;
    case 108: 
      var $824=(($exprs)|0);
      var $825=HEAP32[(($824)>>2)];
      var $826=$825;
      var $827=(($826+12)|0);
      var $828=HEAP32[(($827)>>2)];
      var $829=(($828)|0)==2;
      if ($829) { __label__ = 109; break; } else { __label__ = 113; break; }
    case 109: 
      var $831=(($exprs)|0);
      var $832=HEAP32[(($831)>>2)];
      var $833=$832;
      var $834=(($833+60)|0);
      var $835=HEAP8[($834)];
      var $836=(($835) & 1);
      if ($836) { __label__ = 110; break; } else { __label__ = 113; break; }
    case 110: 
      var $838=(($exprs+4)|0);
      var $839=HEAP32[(($838)>>2)];
      var $840=$839;
      var $841=(($840+12)|0);
      var $842=HEAP32[(($841)>>2)];
      var $843=(($842)|0)==2;
      if ($843) { __label__ = 111; break; } else { __label__ = 113; break; }
    case 111: 
      var $845=(($exprs+4)|0);
      var $846=HEAP32[(($845)>>2)];
      var $847=$846;
      var $848=(($847+60)|0);
      var $849=HEAP8[($848)];
      var $850=(($849) & 1);
      if ($850) { __label__ = 112; break; } else { __label__ = 113; break; }
    case 112: 
      var $852=$2;
      var $853=(($asvalue)|0);
      var $854=HEAP32[(($853)>>2)];
      var $855=(($854+64)|0);
      var $856=$855;
      var $857=(($asvalue+4)|0);
      var $858=HEAP32[(($857)>>2)];
      var $859=(($858+64)|0);
      var $860=$859;
      var $861=(($856)|0);
      var $862=HEAPF32[(($861)>>2)];
      var $863=(($856+4)|0);
      var $864=HEAPF32[(($863)>>2)];
      var $865=(($856+8)|0);
      var $866=HEAPF32[(($865)>>2)];
      var $867=(($860)|0);
      var $868=HEAPF32[(($867)>>2)];
      var $869=(($860+4)|0);
      var $870=HEAPF32[(($869)>>2)];
      var $871=(($860+8)|0);
      var $872=HEAPF32[(($871)>>2)];
      _vec3_sub($6, $862, $864, $866, $868, $870, $872);
      var $873=(($6)|0);
      var $874=HEAPF32[(($873)>>2)];
      var $875=(($6+4)|0);
      var $876=HEAPF32[(($875)>>2)];
      var $877=(($6+8)|0);
      var $878=HEAPF32[(($877)>>2)];
      var $879=_parser_const_vector($852, $874, $876, $878);
      var $880=$879;
      $out=$880;
      __label__ = 114; break;
    case 113: 
      var $882=(($exprs)|0);
      var $883=HEAP32[(($882)>>2)];
      var $884=(($exprs+4)|0);
      var $885=HEAP32[(($884)>>2)];
      var $886=(($ctx)|0);
      var $887=HEAP32[(($886)>>2)];
      var $888=(($ctx+4)|0);
      var $889=HEAP32[(($888)>>2)];
      var $890=_ast_binary_new($887, $889, 9, $883, $885);
      var $891=$890;
      $out=$891;
      __label__ = 114; break;
    case 114: 
      __label__ = 116; break;
    case 115: 
      var $894=$2;
      var $895=(($exprs+4)|0);
      var $896=HEAP32[(($895)>>2)];
      var $897=$896;
      var $898=(($897+24)|0);
      var $899=HEAP32[(($898)>>2)];
      var $900=((_type_name+($899<<2))|0);
      var $901=HEAP32[(($900)>>2)];
      var $902=(($exprs)|0);
      var $903=HEAP32[(($902)>>2)];
      var $904=$903;
      var $905=(($904+24)|0);
      var $906=HEAP32[(($905)>>2)];
      var $907=((_type_name+($906<<2))|0);
      var $908=HEAP32[(($907)>>2)];
      _parseerror($894, ((STRING_TABLE.__str78650)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$901,HEAP32[(((tempInt)+(4))>>2)]=$908,tempInt));
      $1=0;
      __label__ = 254; break;
    case 116: 
      __label__ = 251; break;
    case 117: 
      var $911=(($exprs)|0);
      var $912=HEAP32[(($911)>>2)];
      var $913=$912;
      var $914=(($913+24)|0);
      var $915=HEAP32[(($914)>>2)];
      var $916=(($exprs+4)|0);
      var $917=HEAP32[(($916)>>2)];
      var $918=$917;
      var $919=(($918+24)|0);
      var $920=HEAP32[(($919)>>2)];
      var $921=(($915)|0)!=(($920)|0);
      if ($921) { __label__ = 118; break; } else { __label__ = 123; break; }
    case 118: 
      var $923=(($exprs)|0);
      var $924=HEAP32[(($923)>>2)];
      var $925=$924;
      var $926=(($925+24)|0);
      var $927=HEAP32[(($926)>>2)];
      var $928=(($927)|0)!=3;
      if ($928) { __label__ = 119; break; } else { __label__ = 123; break; }
    case 119: 
      var $930=(($exprs)|0);
      var $931=HEAP32[(($930)>>2)];
      var $932=$931;
      var $933=(($932+24)|0);
      var $934=HEAP32[(($933)>>2)];
      var $935=(($934)|0)!=2;
      if ($935) { __label__ = 120; break; } else { __label__ = 123; break; }
    case 120: 
      var $937=(($exprs+4)|0);
      var $938=HEAP32[(($937)>>2)];
      var $939=$938;
      var $940=(($939+24)|0);
      var $941=HEAP32[(($940)>>2)];
      var $942=(($941)|0)!=3;
      if ($942) { __label__ = 121; break; } else { __label__ = 123; break; }
    case 121: 
      var $944=(($exprs+4)|0);
      var $945=HEAP32[(($944)>>2)];
      var $946=$945;
      var $947=(($946+24)|0);
      var $948=HEAP32[(($947)>>2)];
      var $949=(($948)|0)!=2;
      if ($949) { __label__ = 122; break; } else { __label__ = 123; break; }
    case 122: 
      var $951=$2;
      var $952=(($exprs+4)|0);
      var $953=HEAP32[(($952)>>2)];
      var $954=$953;
      var $955=(($954+24)|0);
      var $956=HEAP32[(($955)>>2)];
      var $957=((_type_name+($956<<2))|0);
      var $958=HEAP32[(($957)>>2)];
      var $959=(($exprs)|0);
      var $960=HEAP32[(($959)>>2)];
      var $961=$960;
      var $962=(($961+24)|0);
      var $963=HEAP32[(($962)>>2)];
      var $964=((_type_name+($963<<2))|0);
      var $965=HEAP32[(($964)>>2)];
      _parseerror($951, ((STRING_TABLE.__str79651)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$958,HEAP32[(((tempInt)+(4))>>2)]=$965,tempInt));
      $1=0;
      __label__ = 254; break;
    case 123: 
      var $967=(($exprs)|0);
      var $968=HEAP32[(($967)>>2)];
      var $969=$968;
      var $970=(($969+24)|0);
      var $971=HEAP32[(($970)>>2)];
      if ((($971)|0) == 2) {
        __label__ = 124; break;
      }
      else if ((($971)|0) == 3) {
        __label__ = 140; break;
      }
      else {
      __label__ = 156; break;
      }
      
    case 124: 
      var $973=(($exprs+4)|0);
      var $974=HEAP32[(($973)>>2)];
      var $975=$974;
      var $976=(($975+24)|0);
      var $977=HEAP32[(($976)>>2)];
      var $978=(($977)|0)==3;
      if ($978) { __label__ = 125; break; } else { __label__ = 132; break; }
    case 125: 
      var $980=(($exprs)|0);
      var $981=HEAP32[(($980)>>2)];
      var $982=$981;
      var $983=(($982+12)|0);
      var $984=HEAP32[(($983)>>2)];
      var $985=(($984)|0)==2;
      if ($985) { __label__ = 126; break; } else { __label__ = 130; break; }
    case 126: 
      var $987=(($exprs)|0);
      var $988=HEAP32[(($987)>>2)];
      var $989=$988;
      var $990=(($989+60)|0);
      var $991=HEAP8[($990)];
      var $992=(($991) & 1);
      if ($992) { __label__ = 127; break; } else { __label__ = 130; break; }
    case 127: 
      var $994=(($exprs+4)|0);
      var $995=HEAP32[(($994)>>2)];
      var $996=$995;
      var $997=(($996+12)|0);
      var $998=HEAP32[(($997)>>2)];
      var $999=(($998)|0)==2;
      if ($999) { __label__ = 128; break; } else { __label__ = 130; break; }
    case 128: 
      var $1001=(($exprs+4)|0);
      var $1002=HEAP32[(($1001)>>2)];
      var $1003=$1002;
      var $1004=(($1003+60)|0);
      var $1005=HEAP8[($1004)];
      var $1006=(($1005) & 1);
      if ($1006) { __label__ = 129; break; } else { __label__ = 130; break; }
    case 129: 
      var $1008=$2;
      var $1009=(($asvalue+4)|0);
      var $1010=HEAP32[(($1009)>>2)];
      var $1011=(($1010+64)|0);
      var $1012=$1011;
      var $1013=(($asvalue)|0);
      var $1014=HEAP32[(($1013)>>2)];
      var $1015=(($1014+64)|0);
      var $1016=$1015;
      var $1017=(tempDoubleI32[0]=HEAP32[(($1016)>>2)],tempDoubleI32[1]=HEAP32[((($1016)+(4))>>2)],tempDoubleF64[0]);
      var $1018=$1017;
      var $1019=(($1012)|0);
      var $1020=HEAPF32[(($1019)>>2)];
      var $1021=(($1012+4)|0);
      var $1022=HEAPF32[(($1021)>>2)];
      var $1023=(($1012+8)|0);
      var $1024=HEAPF32[(($1023)>>2)];
      _vec3_mulvf($7, $1020, $1022, $1024, $1018);
      var $1025=(($7)|0);
      var $1026=HEAPF32[(($1025)>>2)];
      var $1027=(($7+4)|0);
      var $1028=HEAPF32[(($1027)>>2)];
      var $1029=(($7+8)|0);
      var $1030=HEAPF32[(($1029)>>2)];
      var $1031=_parser_const_vector($1008, $1026, $1028, $1030);
      var $1032=$1031;
      $out=$1032;
      __label__ = 131; break;
    case 130: 
      var $1034=(($exprs)|0);
      var $1035=HEAP32[(($1034)>>2)];
      var $1036=(($exprs+4)|0);
      var $1037=HEAP32[(($1036)>>2)];
      var $1038=(($ctx)|0);
      var $1039=HEAP32[(($1038)>>2)];
      var $1040=(($ctx+4)|0);
      var $1041=HEAP32[(($1040)>>2)];
      var $1042=_ast_binary_new($1039, $1041, 3, $1035, $1037);
      var $1043=$1042;
      $out=$1043;
      __label__ = 131; break;
    case 131: 
      __label__ = 139; break;
    case 132: 
      var $1046=(($exprs)|0);
      var $1047=HEAP32[(($1046)>>2)];
      var $1048=$1047;
      var $1049=(($1048+12)|0);
      var $1050=HEAP32[(($1049)>>2)];
      var $1051=(($1050)|0)==2;
      if ($1051) { __label__ = 133; break; } else { __label__ = 137; break; }
    case 133: 
      var $1053=(($exprs)|0);
      var $1054=HEAP32[(($1053)>>2)];
      var $1055=$1054;
      var $1056=(($1055+60)|0);
      var $1057=HEAP8[($1056)];
      var $1058=(($1057) & 1);
      if ($1058) { __label__ = 134; break; } else { __label__ = 137; break; }
    case 134: 
      var $1060=(($exprs+4)|0);
      var $1061=HEAP32[(($1060)>>2)];
      var $1062=$1061;
      var $1063=(($1062+12)|0);
      var $1064=HEAP32[(($1063)>>2)];
      var $1065=(($1064)|0)==2;
      if ($1065) { __label__ = 135; break; } else { __label__ = 137; break; }
    case 135: 
      var $1067=(($exprs+4)|0);
      var $1068=HEAP32[(($1067)>>2)];
      var $1069=$1068;
      var $1070=(($1069+60)|0);
      var $1071=HEAP8[($1070)];
      var $1072=(($1071) & 1);
      if ($1072) { __label__ = 136; break; } else { __label__ = 137; break; }
    case 136: 
      var $1074=$2;
      var $1075=(($asvalue)|0);
      var $1076=HEAP32[(($1075)>>2)];
      var $1077=(($1076+64)|0);
      var $1078=$1077;
      var $1079=(tempDoubleI32[0]=HEAP32[(($1078)>>2)],tempDoubleI32[1]=HEAP32[((($1078)+(4))>>2)],tempDoubleF64[0]);
      var $1080=(($asvalue+4)|0);
      var $1081=HEAP32[(($1080)>>2)];
      var $1082=(($1081+64)|0);
      var $1083=$1082;
      var $1084=(tempDoubleI32[0]=HEAP32[(($1083)>>2)],tempDoubleI32[1]=HEAP32[((($1083)+(4))>>2)],tempDoubleF64[0]);
      var $1085=($1079)*($1084);
      var $1086=_parser_const_float($1074, $1085);
      var $1087=$1086;
      $out=$1087;
      __label__ = 138; break;
    case 137: 
      var $1089=(($exprs)|0);
      var $1090=HEAP32[(($1089)>>2)];
      var $1091=(($exprs+4)|0);
      var $1092=HEAP32[(($1091)>>2)];
      var $1093=(($ctx)|0);
      var $1094=HEAP32[(($1093)>>2)];
      var $1095=(($ctx+4)|0);
      var $1096=HEAP32[(($1095)>>2)];
      var $1097=_ast_binary_new($1094, $1096, 1, $1090, $1092);
      var $1098=$1097;
      $out=$1098;
      __label__ = 138; break;
    case 138: 
      __label__ = 139; break;
    case 139: 
      __label__ = 157; break;
    case 140: 
      var $1102=(($exprs+4)|0);
      var $1103=HEAP32[(($1102)>>2)];
      var $1104=$1103;
      var $1105=(($1104+24)|0);
      var $1106=HEAP32[(($1105)>>2)];
      var $1107=(($1106)|0)==2;
      if ($1107) { __label__ = 141; break; } else { __label__ = 148; break; }
    case 141: 
      var $1109=(($exprs)|0);
      var $1110=HEAP32[(($1109)>>2)];
      var $1111=$1110;
      var $1112=(($1111+12)|0);
      var $1113=HEAP32[(($1112)>>2)];
      var $1114=(($1113)|0)==2;
      if ($1114) { __label__ = 142; break; } else { __label__ = 146; break; }
    case 142: 
      var $1116=(($exprs)|0);
      var $1117=HEAP32[(($1116)>>2)];
      var $1118=$1117;
      var $1119=(($1118+60)|0);
      var $1120=HEAP8[($1119)];
      var $1121=(($1120) & 1);
      if ($1121) { __label__ = 143; break; } else { __label__ = 146; break; }
    case 143: 
      var $1123=(($exprs+4)|0);
      var $1124=HEAP32[(($1123)>>2)];
      var $1125=$1124;
      var $1126=(($1125+12)|0);
      var $1127=HEAP32[(($1126)>>2)];
      var $1128=(($1127)|0)==2;
      if ($1128) { __label__ = 144; break; } else { __label__ = 146; break; }
    case 144: 
      var $1130=(($exprs+4)|0);
      var $1131=HEAP32[(($1130)>>2)];
      var $1132=$1131;
      var $1133=(($1132+60)|0);
      var $1134=HEAP8[($1133)];
      var $1135=(($1134) & 1);
      if ($1135) { __label__ = 145; break; } else { __label__ = 146; break; }
    case 145: 
      var $1137=$2;
      var $1138=(($asvalue)|0);
      var $1139=HEAP32[(($1138)>>2)];
      var $1140=(($1139+64)|0);
      var $1141=$1140;
      var $1142=(($asvalue+4)|0);
      var $1143=HEAP32[(($1142)>>2)];
      var $1144=(($1143+64)|0);
      var $1145=$1144;
      var $1146=(tempDoubleI32[0]=HEAP32[(($1145)>>2)],tempDoubleI32[1]=HEAP32[((($1145)+(4))>>2)],tempDoubleF64[0]);
      var $1147=$1146;
      var $1148=(($1141)|0);
      var $1149=HEAPF32[(($1148)>>2)];
      var $1150=(($1141+4)|0);
      var $1151=HEAPF32[(($1150)>>2)];
      var $1152=(($1141+8)|0);
      var $1153=HEAPF32[(($1152)>>2)];
      _vec3_mulvf($8, $1149, $1151, $1153, $1147);
      var $1154=(($8)|0);
      var $1155=HEAPF32[(($1154)>>2)];
      var $1156=(($8+4)|0);
      var $1157=HEAPF32[(($1156)>>2)];
      var $1158=(($8+8)|0);
      var $1159=HEAPF32[(($1158)>>2)];
      var $1160=_parser_const_vector($1137, $1155, $1157, $1159);
      var $1161=$1160;
      $out=$1161;
      __label__ = 147; break;
    case 146: 
      var $1163=(($exprs)|0);
      var $1164=HEAP32[(($1163)>>2)];
      var $1165=(($exprs+4)|0);
      var $1166=HEAP32[(($1165)>>2)];
      var $1167=(($ctx)|0);
      var $1168=HEAP32[(($1167)>>2)];
      var $1169=(($ctx+4)|0);
      var $1170=HEAP32[(($1169)>>2)];
      var $1171=_ast_binary_new($1168, $1170, 4, $1164, $1166);
      var $1172=$1171;
      $out=$1172;
      __label__ = 147; break;
    case 147: 
      __label__ = 155; break;
    case 148: 
      var $1175=(($exprs)|0);
      var $1176=HEAP32[(($1175)>>2)];
      var $1177=$1176;
      var $1178=(($1177+12)|0);
      var $1179=HEAP32[(($1178)>>2)];
      var $1180=(($1179)|0)==2;
      if ($1180) { __label__ = 149; break; } else { __label__ = 153; break; }
    case 149: 
      var $1182=(($exprs)|0);
      var $1183=HEAP32[(($1182)>>2)];
      var $1184=$1183;
      var $1185=(($1184+60)|0);
      var $1186=HEAP8[($1185)];
      var $1187=(($1186) & 1);
      if ($1187) { __label__ = 150; break; } else { __label__ = 153; break; }
    case 150: 
      var $1189=(($exprs+4)|0);
      var $1190=HEAP32[(($1189)>>2)];
      var $1191=$1190;
      var $1192=(($1191+12)|0);
      var $1193=HEAP32[(($1192)>>2)];
      var $1194=(($1193)|0)==2;
      if ($1194) { __label__ = 151; break; } else { __label__ = 153; break; }
    case 151: 
      var $1196=(($exprs+4)|0);
      var $1197=HEAP32[(($1196)>>2)];
      var $1198=$1197;
      var $1199=(($1198+60)|0);
      var $1200=HEAP8[($1199)];
      var $1201=(($1200) & 1);
      if ($1201) { __label__ = 152; break; } else { __label__ = 153; break; }
    case 152: 
      var $1203=$2;
      var $1204=(($asvalue)|0);
      var $1205=HEAP32[(($1204)>>2)];
      var $1206=(($1205+64)|0);
      var $1207=$1206;
      var $1208=(($asvalue+4)|0);
      var $1209=HEAP32[(($1208)>>2)];
      var $1210=(($1209+64)|0);
      var $1211=$1210;
      var $1212=(($1207)|0);
      var $1213=HEAPF32[(($1212)>>2)];
      var $1214=(($1207+4)|0);
      var $1215=HEAPF32[(($1214)>>2)];
      var $1216=(($1207+8)|0);
      var $1217=HEAPF32[(($1216)>>2)];
      var $1218=(($1211)|0);
      var $1219=HEAPF32[(($1218)>>2)];
      var $1220=(($1211+4)|0);
      var $1221=HEAPF32[(($1220)>>2)];
      var $1222=(($1211+8)|0);
      var $1223=HEAPF32[(($1222)>>2)];
      var $1224=_vec3_mulvv($1213, $1215, $1217, $1219, $1221, $1223);
      var $1225=$1224;
      var $1226=_parser_const_float($1203, $1225);
      var $1227=$1226;
      $out=$1227;
      __label__ = 154; break;
    case 153: 
      var $1229=(($exprs)|0);
      var $1230=HEAP32[(($1229)>>2)];
      var $1231=(($exprs+4)|0);
      var $1232=HEAP32[(($1231)>>2)];
      var $1233=(($ctx)|0);
      var $1234=HEAP32[(($1233)>>2)];
      var $1235=(($ctx+4)|0);
      var $1236=HEAP32[(($1235)>>2)];
      var $1237=_ast_binary_new($1234, $1236, 2, $1230, $1232);
      var $1238=$1237;
      $out=$1238;
      __label__ = 154; break;
    case 154: 
      __label__ = 155; break;
    case 155: 
      __label__ = 157; break;
    case 156: 
      var $1242=$2;
      var $1243=(($exprs+4)|0);
      var $1244=HEAP32[(($1243)>>2)];
      var $1245=$1244;
      var $1246=(($1245+24)|0);
      var $1247=HEAP32[(($1246)>>2)];
      var $1248=((_type_name+($1247<<2))|0);
      var $1249=HEAP32[(($1248)>>2)];
      var $1250=(($exprs)|0);
      var $1251=HEAP32[(($1250)>>2)];
      var $1252=$1251;
      var $1253=(($1252+24)|0);
      var $1254=HEAP32[(($1253)>>2)];
      var $1255=((_type_name+($1254<<2))|0);
      var $1256=HEAP32[(($1255)>>2)];
      _parseerror($1242, ((STRING_TABLE.__str79651)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1249,HEAP32[(((tempInt)+(4))>>2)]=$1256,tempInt));
      $1=0;
      __label__ = 254; break;
    case 157: 
      __label__ = 251; break;
    case 158: 
      var $1259=(($exprs)|0);
      var $1260=HEAP32[(($1259)>>2)];
      var $1261=$1260;
      var $1262=(($1261+24)|0);
      var $1263=HEAP32[(($1262)>>2)];
      var $1264=(($exprs+4)|0);
      var $1265=HEAP32[(($1264)>>2)];
      var $1266=$1265;
      var $1267=(($1266+24)|0);
      var $1268=HEAP32[(($1267)>>2)];
      var $1269=(($1263)|0)!=(($1268)|0);
      if ($1269) { __label__ = 160; break; } else { __label__ = 159; break; }
    case 159: 
      var $1271=(($exprs)|0);
      var $1272=HEAP32[(($1271)>>2)];
      var $1273=$1272;
      var $1274=(($1273+24)|0);
      var $1275=HEAP32[(($1274)>>2)];
      var $1276=(($1275)|0)!=2;
      if ($1276) { __label__ = 160; break; } else { __label__ = 161; break; }
    case 160: 
      var $1278=$2;
      var $1279=(($exprs)|0);
      var $1280=HEAP32[(($1279)>>2)];
      var $1281=$1280;
      var $1282=(($1281+24)|0);
      var $1283=HEAP32[(($1282)>>2)];
      var $1284=((_type_name+($1283<<2))|0);
      var $1285=HEAP32[(($1284)>>2)];
      var $1286=(($exprs+4)|0);
      var $1287=HEAP32[(($1286)>>2)];
      var $1288=$1287;
      var $1289=(($1288+24)|0);
      var $1290=HEAP32[(($1289)>>2)];
      var $1291=((_type_name+($1290<<2))|0);
      var $1292=HEAP32[(($1291)>>2)];
      _parseerror($1278, ((STRING_TABLE.__str80652)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1285,HEAP32[(((tempInt)+(4))>>2)]=$1292,tempInt));
      $1=0;
      __label__ = 254; break;
    case 161: 
      var $1294=(($exprs)|0);
      var $1295=HEAP32[(($1294)>>2)];
      var $1296=$1295;
      var $1297=(($1296+12)|0);
      var $1298=HEAP32[(($1297)>>2)];
      var $1299=(($1298)|0)==2;
      if ($1299) { __label__ = 162; break; } else { __label__ = 166; break; }
    case 162: 
      var $1301=(($exprs)|0);
      var $1302=HEAP32[(($1301)>>2)];
      var $1303=$1302;
      var $1304=(($1303+60)|0);
      var $1305=HEAP8[($1304)];
      var $1306=(($1305) & 1);
      if ($1306) { __label__ = 163; break; } else { __label__ = 166; break; }
    case 163: 
      var $1308=(($exprs+4)|0);
      var $1309=HEAP32[(($1308)>>2)];
      var $1310=$1309;
      var $1311=(($1310+12)|0);
      var $1312=HEAP32[(($1311)>>2)];
      var $1313=(($1312)|0)==2;
      if ($1313) { __label__ = 164; break; } else { __label__ = 166; break; }
    case 164: 
      var $1315=(($exprs+4)|0);
      var $1316=HEAP32[(($1315)>>2)];
      var $1317=$1316;
      var $1318=(($1317+60)|0);
      var $1319=HEAP8[($1318)];
      var $1320=(($1319) & 1);
      if ($1320) { __label__ = 165; break; } else { __label__ = 166; break; }
    case 165: 
      var $1322=$2;
      var $1323=(($asvalue)|0);
      var $1324=HEAP32[(($1323)>>2)];
      var $1325=(($1324+64)|0);
      var $1326=$1325;
      var $1327=(tempDoubleI32[0]=HEAP32[(($1326)>>2)],tempDoubleI32[1]=HEAP32[((($1326)+(4))>>2)],tempDoubleF64[0]);
      var $1328=(($asvalue+4)|0);
      var $1329=HEAP32[(($1328)>>2)];
      var $1330=(($1329+64)|0);
      var $1331=$1330;
      var $1332=(tempDoubleI32[0]=HEAP32[(($1331)>>2)],tempDoubleI32[1]=HEAP32[((($1331)+(4))>>2)],tempDoubleF64[0]);
      var $1333=($1327)/($1332);
      var $1334=_parser_const_float($1322, $1333);
      var $1335=$1334;
      $out=$1335;
      __label__ = 167; break;
    case 166: 
      var $1337=(($exprs)|0);
      var $1338=HEAP32[(($1337)>>2)];
      var $1339=(($exprs+4)|0);
      var $1340=HEAP32[(($1339)>>2)];
      var $1341=(($ctx)|0);
      var $1342=HEAP32[(($1341)>>2)];
      var $1343=(($ctx+4)|0);
      var $1344=HEAP32[(($1343)>>2)];
      var $1345=_ast_binary_new($1342, $1344, 5, $1338, $1340);
      var $1346=$1345;
      $out=$1346;
      __label__ = 167; break;
    case 167: 
      __label__ = 251; break;
    case 168: 
      var $1349=$2;
      _parseerror($1349, ((STRING_TABLE.__str81653)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 169: 
      var $1351=(($exprs)|0);
      var $1352=HEAP32[(($1351)>>2)];
      var $1353=$1352;
      var $1354=(($1353+24)|0);
      var $1355=HEAP32[(($1354)>>2)];
      var $1356=(($exprs+4)|0);
      var $1357=HEAP32[(($1356)>>2)];
      var $1358=$1357;
      var $1359=(($1358+24)|0);
      var $1360=HEAP32[(($1359)>>2)];
      var $1361=(($1355)|0)!=(($1360)|0);
      if ($1361) { __label__ = 171; break; } else { __label__ = 170; break; }
    case 170: 
      var $1363=(($exprs)|0);
      var $1364=HEAP32[(($1363)>>2)];
      var $1365=$1364;
      var $1366=(($1365+24)|0);
      var $1367=HEAP32[(($1366)>>2)];
      var $1368=(($1367)|0)!=2;
      if ($1368) { __label__ = 171; break; } else { __label__ = 172; break; }
    case 171: 
      var $1370=$2;
      var $1371=(($exprs)|0);
      var $1372=HEAP32[(($1371)>>2)];
      var $1373=$1372;
      var $1374=(($1373+24)|0);
      var $1375=HEAP32[(($1374)>>2)];
      var $1376=((_type_name+($1375<<2))|0);
      var $1377=HEAP32[(($1376)>>2)];
      var $1378=(($exprs+4)|0);
      var $1379=HEAP32[(($1378)>>2)];
      var $1380=$1379;
      var $1381=(($1380+24)|0);
      var $1382=HEAP32[(($1381)>>2)];
      var $1383=((_type_name+($1382<<2))|0);
      var $1384=HEAP32[(($1383)>>2)];
      _parseerror($1370, ((STRING_TABLE.__str82654)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1377,HEAP32[(((tempInt)+(4))>>2)]=$1384,tempInt));
      $1=0;
      __label__ = 254; break;
    case 172: 
      var $1386=(($exprs)|0);
      var $1387=HEAP32[(($1386)>>2)];
      var $1388=$1387;
      var $1389=(($1388+12)|0);
      var $1390=HEAP32[(($1389)>>2)];
      var $1391=(($1390)|0)==2;
      if ($1391) { __label__ = 173; break; } else { __label__ = 180; break; }
    case 173: 
      var $1393=(($exprs)|0);
      var $1394=HEAP32[(($1393)>>2)];
      var $1395=$1394;
      var $1396=(($1395+60)|0);
      var $1397=HEAP8[($1396)];
      var $1398=(($1397) & 1);
      if ($1398) { __label__ = 174; break; } else { __label__ = 180; break; }
    case 174: 
      var $1400=(($exprs+4)|0);
      var $1401=HEAP32[(($1400)>>2)];
      var $1402=$1401;
      var $1403=(($1402+12)|0);
      var $1404=HEAP32[(($1403)>>2)];
      var $1405=(($1404)|0)==2;
      if ($1405) { __label__ = 175; break; } else { __label__ = 180; break; }
    case 175: 
      var $1407=(($exprs+4)|0);
      var $1408=HEAP32[(($1407)>>2)];
      var $1409=$1408;
      var $1410=(($1409+60)|0);
      var $1411=HEAP8[($1410)];
      var $1412=(($1411) & 1);
      if ($1412) { __label__ = 176; break; } else { __label__ = 180; break; }
    case 176: 
      var $1414=$2;
      var $1415=$op;
      var $1416=(($1415+8)|0);
      var $1417=HEAP32[(($1416)>>2)];
      var $1418=(($1417)|0)==124;
      if ($1418) { __label__ = 177; break; } else { __label__ = 178; break; }
    case 177: 
      var $1420=(($asvalue)|0);
      var $1421=HEAP32[(($1420)>>2)];
      var $1422=(($1421+64)|0);
      var $1423=$1422;
      var $1424=(tempDoubleI32[0]=HEAP32[(($1423)>>2)],tempDoubleI32[1]=HEAP32[((($1423)+(4))>>2)],tempDoubleF64[0]);
      var $1425=(($1424)&-1);
      var $1426=(($asvalue+4)|0);
      var $1427=HEAP32[(($1426)>>2)];
      var $1428=(($1427+64)|0);
      var $1429=$1428;
      var $1430=(tempDoubleI32[0]=HEAP32[(($1429)>>2)],tempDoubleI32[1]=HEAP32[((($1429)+(4))>>2)],tempDoubleF64[0]);
      var $1431=(($1430)&-1);
      var $1432=$1425 | $1431;
      var $1433=(($1432)|0);
      var $1450 = $1433;__label__ = 179; break;
    case 178: 
      var $1435=(($asvalue)|0);
      var $1436=HEAP32[(($1435)>>2)];
      var $1437=(($1436+64)|0);
      var $1438=$1437;
      var $1439=(tempDoubleI32[0]=HEAP32[(($1438)>>2)],tempDoubleI32[1]=HEAP32[((($1438)+(4))>>2)],tempDoubleF64[0]);
      var $1440=(($1439)&-1);
      var $1441=(($asvalue+4)|0);
      var $1442=HEAP32[(($1441)>>2)];
      var $1443=(($1442+64)|0);
      var $1444=$1443;
      var $1445=(tempDoubleI32[0]=HEAP32[(($1444)>>2)],tempDoubleI32[1]=HEAP32[((($1444)+(4))>>2)],tempDoubleF64[0]);
      var $1446=(($1445)&-1);
      var $1447=$1440 & $1446;
      var $1448=(($1447)|0);
      var $1450 = $1448;__label__ = 179; break;
    case 179: 
      var $1450;
      var $1451=$1450;
      var $1452=_parser_const_float($1414, $1451);
      var $1453=$1452;
      $out=$1453;
      __label__ = 181; break;
    case 180: 
      var $1455=$op;
      var $1456=(($1455+8)|0);
      var $1457=HEAP32[(($1456)>>2)];
      var $1458=(($1457)|0)==124;
      var $1459=$1458 ? 65 : 64;
      var $1460=(($exprs)|0);
      var $1461=HEAP32[(($1460)>>2)];
      var $1462=(($exprs+4)|0);
      var $1463=HEAP32[(($1462)>>2)];
      var $1464=(($ctx)|0);
      var $1465=HEAP32[(($1464)>>2)];
      var $1466=(($ctx+4)|0);
      var $1467=HEAP32[(($1466)>>2)];
      var $1468=_ast_binary_new($1465, $1467, $1459, $1461, $1463);
      var $1469=$1468;
      $out=$1469;
      __label__ = 181; break;
    case 181: 
      __label__ = 251; break;
    case 182: 
      var $1472=$2;
      _parseerror($1472, ((STRING_TABLE.__str83655)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 183: 
      var $1474=$2;
      _parseerror($1474, ((STRING_TABLE.__str84656)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 184: 
      var $1476=$generated_op;
      var $1477=((($1476)+(1))|0);
      $generated_op=$1477;
      __label__ = 185; break;
    case 185: 
      var $1479=$generated_op;
      var $1480=((($1479)+(62))|0);
      $generated_op=$1480;
      var $1481=(($exprs)|0);
      var $1482=HEAP32[(($1481)>>2)];
      var $1483=$1482;
      var $1484=(($1483+24)|0);
      var $1485=HEAP32[(($1484)>>2)];
      var $1486=(($exprs+4)|0);
      var $1487=HEAP32[(($1486)>>2)];
      var $1488=$1487;
      var $1489=(($1488+24)|0);
      var $1490=HEAP32[(($1489)>>2)];
      var $1491=(($1485)|0)!=(($1490)|0);
      if ($1491) { __label__ = 187; break; } else { __label__ = 186; break; }
    case 186: 
      var $1493=(($exprs)|0);
      var $1494=HEAP32[(($1493)>>2)];
      var $1495=$1494;
      var $1496=(($1495+24)|0);
      var $1497=HEAP32[(($1496)>>2)];
      var $1498=(($1497)|0)!=2;
      if ($1498) { __label__ = 187; break; } else { __label__ = 188; break; }
    case 187: 
      var $1500=$2;
      var $1501=(($exprs)|0);
      var $1502=HEAP32[(($1501)>>2)];
      var $1503=$1502;
      var $1504=(($1503+24)|0);
      var $1505=HEAP32[(($1504)>>2)];
      var $1506=((_type_name+($1505<<2))|0);
      var $1507=HEAP32[(($1506)>>2)];
      var $1508=(($exprs+4)|0);
      var $1509=HEAP32[(($1508)>>2)];
      var $1510=$1509;
      var $1511=(($1510+24)|0);
      var $1512=HEAP32[(($1511)>>2)];
      var $1513=((_type_name+($1512<<2))|0);
      var $1514=HEAP32[(($1513)>>2)];
      _parseerror($1500, ((STRING_TABLE.__str85657)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1507,HEAP32[(((tempInt)+(4))>>2)]=$1514,tempInt));
      var $1515=$2;
      _parseerror($1515, ((STRING_TABLE.__str86658)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $1516=$2;
      _parseerror($1516, ((STRING_TABLE.__str87659)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 254; break;
    case 188: 
      var $1518=HEAP32[((_opts_standard)>>2)];
      var $1519=(($1518)|0)==3;
      if ($1519) { __label__ = 189; break; } else { __label__ = 190; break; }
    case 189: 
      var $1521=_printf(((STRING_TABLE.__str88660)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 190; break;
    case 190: 
      var $1523=(($exprs)|0);
      var $1524=HEAP32[(($1523)>>2)];
      var $1525=$1524;
      var $1526=(($1525+12)|0);
      var $1527=HEAP32[(($1526)>>2)];
      var $1528=(($1527)|0)==2;
      if ($1528) { __label__ = 191; break; } else { __label__ = 202; break; }
    case 191: 
      var $1530=(($exprs)|0);
      var $1531=HEAP32[(($1530)>>2)];
      var $1532=$1531;
      var $1533=(($1532+60)|0);
      var $1534=HEAP8[($1533)];
      var $1535=(($1534) & 1);
      if ($1535) { __label__ = 192; break; } else { __label__ = 202; break; }
    case 192: 
      var $1537=(($exprs+4)|0);
      var $1538=HEAP32[(($1537)>>2)];
      var $1539=$1538;
      var $1540=(($1539+12)|0);
      var $1541=HEAP32[(($1540)>>2)];
      var $1542=(($1541)|0)==2;
      if ($1542) { __label__ = 193; break; } else { __label__ = 202; break; }
    case 193: 
      var $1544=(($exprs+4)|0);
      var $1545=HEAP32[(($1544)>>2)];
      var $1546=$1545;
      var $1547=(($1546+60)|0);
      var $1548=HEAP8[($1547)];
      var $1549=(($1548) & 1);
      if ($1549) { __label__ = 194; break; } else { __label__ = 202; break; }
    case 194: 
      var $1551=$2;
      var $1552=$generated_op;
      var $1553=(($1552)|0)==63;
      if ($1553) { __label__ = 195; break; } else { __label__ = 198; break; }
    case 195: 
      var $1555=(($asvalue)|0);
      var $1556=HEAP32[(($1555)>>2)];
      var $1557=(($1556+64)|0);
      var $1558=$1557;
      var $1559=(tempDoubleI32[0]=HEAP32[(($1558)>>2)],tempDoubleI32[1]=HEAP32[((($1558)+(4))>>2)],tempDoubleF64[0]);
      var $1560=$1559 != 0;
      if ($1560) { var $1569 = 1;__label__ = 197; break; } else { __label__ = 196; break; }
    case 196: 
      var $1562=(($asvalue+4)|0);
      var $1563=HEAP32[(($1562)>>2)];
      var $1564=(($1563+64)|0);
      var $1565=$1564;
      var $1566=(tempDoubleI32[0]=HEAP32[(($1565)>>2)],tempDoubleI32[1]=HEAP32[((($1565)+(4))>>2)],tempDoubleF64[0]);
      var $1567=$1566 != 0;
      var $1569 = $1567;__label__ = 197; break;
    case 197: 
      var $1569;
      var $1570=(($1569)&1);
      var $1589 = $1570;__label__ = 201; break;
    case 198: 
      var $1572=(($asvalue)|0);
      var $1573=HEAP32[(($1572)>>2)];
      var $1574=(($1573+64)|0);
      var $1575=$1574;
      var $1576=(tempDoubleI32[0]=HEAP32[(($1575)>>2)],tempDoubleI32[1]=HEAP32[((($1575)+(4))>>2)],tempDoubleF64[0]);
      var $1577=$1576 != 0;
      if ($1577) { __label__ = 199; break; } else { var $1586 = 0;__label__ = 200; break; }
    case 199: 
      var $1579=(($asvalue+4)|0);
      var $1580=HEAP32[(($1579)>>2)];
      var $1581=(($1580+64)|0);
      var $1582=$1581;
      var $1583=(tempDoubleI32[0]=HEAP32[(($1582)>>2)],tempDoubleI32[1]=HEAP32[((($1582)+(4))>>2)],tempDoubleF64[0]);
      var $1584=$1583 != 0;
      var $1586 = $1584;__label__ = 200; break;
    case 200: 
      var $1586;
      var $1587=(($1586)&1);
      var $1589 = $1587;__label__ = 201; break;
    case 201: 
      var $1589;
      var $1590=(($1589)|0);
      var $1591=_parser_const_float($1551, $1590);
      var $1592=$1591;
      $out=$1592;
      __label__ = 203; break;
    case 202: 
      var $1594=$generated_op;
      var $1595=(($exprs)|0);
      var $1596=HEAP32[(($1595)>>2)];
      var $1597=(($exprs+4)|0);
      var $1598=HEAP32[(($1597)>>2)];
      var $1599=(($ctx)|0);
      var $1600=HEAP32[(($1599)>>2)];
      var $1601=(($ctx+4)|0);
      var $1602=HEAP32[(($1601)>>2)];
      var $1603=_ast_binary_new($1600, $1602, $1594, $1596, $1598);
      var $1604=$1603;
      $out=$1604;
      __label__ = 203; break;
    case 203: 
      __label__ = 251; break;
    case 204: 
      var $1607=$generated_op;
      var $1608=((($1607)+(1))|0);
      $generated_op=$1608;
      __label__ = 205; break;
    case 205: 
      var $1610=$generated_op;
      var $1611=((($1610)+(1))|0);
      $generated_op=$1611;
      __label__ = 206; break;
    case 206: 
      var $1613=$generated_op;
      var $1614=((($1613)+(1))|0);
      $generated_op=$1614;
      __label__ = 207; break;
    case 207: 
      var $1616=$generated_op;
      var $1617=((($1616)+(20))|0);
      $generated_op=$1617;
      var $1618=(($exprs)|0);
      var $1619=HEAP32[(($1618)>>2)];
      var $1620=$1619;
      var $1621=(($1620+24)|0);
      var $1622=HEAP32[(($1621)>>2)];
      var $1623=(($exprs+4)|0);
      var $1624=HEAP32[(($1623)>>2)];
      var $1625=$1624;
      var $1626=(($1625+24)|0);
      var $1627=HEAP32[(($1626)>>2)];
      var $1628=(($1622)|0)!=(($1627)|0);
      if ($1628) { __label__ = 209; break; } else { __label__ = 208; break; }
    case 208: 
      var $1630=(($exprs)|0);
      var $1631=HEAP32[(($1630)>>2)];
      var $1632=$1631;
      var $1633=(($1632+24)|0);
      var $1634=HEAP32[(($1633)>>2)];
      var $1635=(($1634)|0)!=2;
      if ($1635) { __label__ = 209; break; } else { __label__ = 210; break; }
    case 209: 
      var $1637=$2;
      var $1638=(($exprs)|0);
      var $1639=HEAP32[(($1638)>>2)];
      var $1640=$1639;
      var $1641=(($1640+24)|0);
      var $1642=HEAP32[(($1641)>>2)];
      var $1643=((_type_name+($1642<<2))|0);
      var $1644=HEAP32[(($1643)>>2)];
      var $1645=(($exprs+4)|0);
      var $1646=HEAP32[(($1645)>>2)];
      var $1647=$1646;
      var $1648=(($1647+24)|0);
      var $1649=HEAP32[(($1648)>>2)];
      var $1650=((_type_name+($1649<<2))|0);
      var $1651=HEAP32[(($1650)>>2)];
      _parseerror($1637, ((STRING_TABLE.__str89661)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1644,HEAP32[(((tempInt)+(4))>>2)]=$1651,tempInt));
      $1=0;
      __label__ = 254; break;
    case 210: 
      var $1653=$generated_op;
      var $1654=(($exprs)|0);
      var $1655=HEAP32[(($1654)>>2)];
      var $1656=(($exprs+4)|0);
      var $1657=HEAP32[(($1656)>>2)];
      var $1658=(($ctx)|0);
      var $1659=HEAP32[(($1658)>>2)];
      var $1660=(($ctx+4)|0);
      var $1661=HEAP32[(($1660)>>2)];
      var $1662=_ast_binary_new($1659, $1661, $1653, $1655, $1657);
      var $1663=$1662;
      $out=$1663;
      __label__ = 251; break;
    case 211: 
      var $1665=(($exprs)|0);
      var $1666=HEAP32[(($1665)>>2)];
      var $1667=$1666;
      var $1668=(($1667+24)|0);
      var $1669=HEAP32[(($1668)>>2)];
      var $1670=(($exprs+4)|0);
      var $1671=HEAP32[(($1670)>>2)];
      var $1672=$1671;
      var $1673=(($1672+24)|0);
      var $1674=HEAP32[(($1673)>>2)];
      var $1675=(($1669)|0)!=(($1674)|0);
      if ($1675) { __label__ = 212; break; } else { __label__ = 213; break; }
    case 212: 
      var $1677=$2;
      var $1678=(($exprs)|0);
      var $1679=HEAP32[(($1678)>>2)];
      var $1680=$1679;
      var $1681=(($1680+24)|0);
      var $1682=HEAP32[(($1681)>>2)];
      var $1683=((_type_name+($1682<<2))|0);
      var $1684=HEAP32[(($1683)>>2)];
      var $1685=(($exprs+4)|0);
      var $1686=HEAP32[(($1685)>>2)];
      var $1687=$1686;
      var $1688=(($1687+24)|0);
      var $1689=HEAP32[(($1688)>>2)];
      var $1690=((_type_name+($1689<<2))|0);
      var $1691=HEAP32[(($1690)>>2)];
      _parseerror($1677, ((STRING_TABLE.__str89661)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1684,HEAP32[(((tempInt)+(4))>>2)]=$1691,tempInt));
      $1=0;
      __label__ = 254; break;
    case 213: 
      var $1693=(($exprs)|0);
      var $1694=HEAP32[(($1693)>>2)];
      var $1695=$1694;
      var $1696=(($1695+24)|0);
      var $1697=HEAP32[(($1696)>>2)];
      var $1698=((_type_ne_instr+($1697<<1))|0);
      var $1699=HEAP16[(($1698)>>1)];
      var $1700=(($1699)&65535);
      var $1701=(($exprs)|0);
      var $1702=HEAP32[(($1701)>>2)];
      var $1703=(($exprs+4)|0);
      var $1704=HEAP32[(($1703)>>2)];
      var $1705=(($ctx)|0);
      var $1706=HEAP32[(($1705)>>2)];
      var $1707=(($ctx+4)|0);
      var $1708=HEAP32[(($1707)>>2)];
      var $1709=_ast_binary_new($1706, $1708, $1700, $1702, $1704);
      var $1710=$1709;
      $out=$1710;
      __label__ = 251; break;
    case 214: 
      var $1712=(($exprs)|0);
      var $1713=HEAP32[(($1712)>>2)];
      var $1714=$1713;
      var $1715=(($1714+24)|0);
      var $1716=HEAP32[(($1715)>>2)];
      var $1717=(($exprs+4)|0);
      var $1718=HEAP32[(($1717)>>2)];
      var $1719=$1718;
      var $1720=(($1719+24)|0);
      var $1721=HEAP32[(($1720)>>2)];
      var $1722=(($1716)|0)!=(($1721)|0);
      if ($1722) { __label__ = 215; break; } else { __label__ = 216; break; }
    case 215: 
      var $1724=$2;
      var $1725=(($exprs)|0);
      var $1726=HEAP32[(($1725)>>2)];
      var $1727=$1726;
      var $1728=(($1727+24)|0);
      var $1729=HEAP32[(($1728)>>2)];
      var $1730=((_type_name+($1729<<2))|0);
      var $1731=HEAP32[(($1730)>>2)];
      var $1732=(($exprs+4)|0);
      var $1733=HEAP32[(($1732)>>2)];
      var $1734=$1733;
      var $1735=(($1734+24)|0);
      var $1736=HEAP32[(($1735)>>2)];
      var $1737=((_type_name+($1736<<2))|0);
      var $1738=HEAP32[(($1737)>>2)];
      _parseerror($1724, ((STRING_TABLE.__str89661)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1731,HEAP32[(((tempInt)+(4))>>2)]=$1738,tempInt));
      $1=0;
      __label__ = 254; break;
    case 216: 
      var $1740=(($exprs)|0);
      var $1741=HEAP32[(($1740)>>2)];
      var $1742=$1741;
      var $1743=(($1742+24)|0);
      var $1744=HEAP32[(($1743)>>2)];
      var $1745=((_type_eq_instr+($1744<<1))|0);
      var $1746=HEAP16[(($1745)>>1)];
      var $1747=(($1746)&65535);
      var $1748=(($exprs)|0);
      var $1749=HEAP32[(($1748)>>2)];
      var $1750=(($exprs+4)|0);
      var $1751=HEAP32[(($1750)>>2)];
      var $1752=(($ctx)|0);
      var $1753=HEAP32[(($1752)>>2)];
      var $1754=(($ctx+4)|0);
      var $1755=HEAP32[(($1754)>>2)];
      var $1756=_ast_binary_new($1753, $1755, $1747, $1749, $1751);
      var $1757=$1756;
      $out=$1757;
      __label__ = 251; break;
    case 217: 
      var $1759=(($exprs)|0);
      var $1760=HEAP32[(($1759)>>2)];
      var $1761=$1760;
      var $1762=(($1761+12)|0);
      var $1763=HEAP32[(($1762)>>2)];
      var $1764=(($1763)|0)==8;
      if ($1764) { __label__ = 218; break; } else { __label__ = 228; break; }
    case 218: 
      var $1766=(($exprs)|0);
      var $1767=HEAP32[(($1766)>>2)];
      var $1768=$1767;
      var $1769=(($1768+60)|0);
      var $1770=HEAP32[(($1769)>>2)];
      $field=$1770;
      var $1771=(($exprs)|0);
      var $1772=HEAP32[(($1771)>>2)];
      var $1773=$1772;
      var $1774=(($1773+24)|0);
      var $1775=HEAP32[(($1774)>>2)];
      var $1776=((_type_storep_instr+($1775<<1))|0);
      var $1777=HEAP16[(($1776)>>1)];
      var $1778=(($1777)&65535);
      $assignop=$1778;
      var $1779=$field;
      var $1780=$1779;
      var $1781=(($1780+28)|0);
      var $1782=HEAP32[(($1781)>>2)];
      var $1783=(($exprs+4)|0);
      var $1784=HEAP32[(($1783)>>2)];
      var $1785=_ast_compare_type($1782, $1784);
      if ($1785) { __label__ = 227; break; } else { __label__ = 219; break; }
    case 219: 
      var $1787=$field;
      var $1788=$1787;
      var $1789=(($1788+28)|0);
      var $1790=HEAP32[(($1789)>>2)];
      var $1791=(($ty1)|0);
      _ast_type_to_string($1790, $1791, 1024);
      var $1792=(($exprs+4)|0);
      var $1793=HEAP32[(($1792)>>2)];
      var $1794=(($ty2)|0);
      _ast_type_to_string($1793, $1794, 1024);
      var $1795=HEAP32[((_opts_standard)>>2)];
      var $1796=(($1795)|0)==0;
      if ($1796) { __label__ = 220; break; } else { __label__ = 225; break; }
    case 220: 
      var $1798=$field;
      var $1799=$1798;
      var $1800=(($1799+28)|0);
      var $1801=HEAP32[(($1800)>>2)];
      var $1802=$1801;
      var $1803=(($1802+24)|0);
      var $1804=HEAP32[(($1803)>>2)];
      var $1805=(($1804)|0)==6;
      if ($1805) { __label__ = 221; break; } else { __label__ = 225; break; }
    case 221: 
      var $1807=(($exprs+4)|0);
      var $1808=HEAP32[(($1807)>>2)];
      var $1809=$1808;
      var $1810=(($1809+24)|0);
      var $1811=HEAP32[(($1810)>>2)];
      var $1812=(($1811)|0)==6;
      if ($1812) { __label__ = 222; break; } else { __label__ = 225; break; }
    case 222: 
      var $1814=$2;
      var $1815=(($ty2)|0);
      var $1816=(($ty1)|0);
      var $1817=_parsewarning($1814, 16, ((STRING_TABLE.__str90662)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1815,HEAP32[(((tempInt)+(4))>>2)]=$1816,tempInt));
      if ($1817) { __label__ = 223; break; } else { __label__ = 224; break; }
    case 223: 
      var $1819=$2;
      var $1820=(($1819+116)|0);
      var $1821=HEAP32[(($1820)>>2)];
      var $1822=((($1821)+(1))|0);
      HEAP32[(($1820)>>2)]=$1822;
      __label__ = 224; break;
    case 224: 
      __label__ = 226; break;
    case 225: 
      var $1825=$2;
      var $1826=(($ty2)|0);
      var $1827=(($ty1)|0);
      _parseerror($1825, ((STRING_TABLE.__str90662)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1826,HEAP32[(((tempInt)+(4))>>2)]=$1827,tempInt));
      __label__ = 226; break;
    case 226: 
      __label__ = 227; break;
    case 227: 
      __label__ = 238; break;
    case 228: 
      var $1831=(($exprs)|0);
      var $1832=HEAP32[(($1831)>>2)];
      var $1833=$1832;
      var $1834=(($1833+24)|0);
      var $1835=HEAP32[(($1834)>>2)];
      var $1836=((_type_store_instr+($1835<<1))|0);
      var $1837=HEAP16[(($1836)>>1)];
      var $1838=(($1837)&65535);
      $assignop=$1838;
      var $1839=(($exprs)|0);
      var $1840=HEAP32[(($1839)>>2)];
      var $1841=(($exprs+4)|0);
      var $1842=HEAP32[(($1841)>>2)];
      var $1843=_ast_compare_type($1840, $1842);
      if ($1843) { __label__ = 237; break; } else { __label__ = 229; break; }
    case 229: 
      var $1845=(($exprs)|0);
      var $1846=HEAP32[(($1845)>>2)];
      var $1847=(($ty11)|0);
      _ast_type_to_string($1846, $1847, 1024);
      var $1848=(($exprs+4)|0);
      var $1849=HEAP32[(($1848)>>2)];
      var $1850=(($ty22)|0);
      _ast_type_to_string($1849, $1850, 1024);
      var $1851=HEAP32[((_opts_standard)>>2)];
      var $1852=(($1851)|0)==0;
      if ($1852) { __label__ = 230; break; } else { __label__ = 235; break; }
    case 230: 
      var $1854=(($exprs)|0);
      var $1855=HEAP32[(($1854)>>2)];
      var $1856=$1855;
      var $1857=(($1856+24)|0);
      var $1858=HEAP32[(($1857)>>2)];
      var $1859=(($1858)|0)==6;
      if ($1859) { __label__ = 231; break; } else { __label__ = 235; break; }
    case 231: 
      var $1861=(($exprs+4)|0);
      var $1862=HEAP32[(($1861)>>2)];
      var $1863=$1862;
      var $1864=(($1863+24)|0);
      var $1865=HEAP32[(($1864)>>2)];
      var $1866=(($1865)|0)==6;
      if ($1866) { __label__ = 232; break; } else { __label__ = 235; break; }
    case 232: 
      var $1868=$2;
      var $1869=(($ty22)|0);
      var $1870=(($ty11)|0);
      var $1871=_parsewarning($1868, 16, ((STRING_TABLE.__str90662)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1869,HEAP32[(((tempInt)+(4))>>2)]=$1870,tempInt));
      if ($1871) { __label__ = 233; break; } else { __label__ = 234; break; }
    case 233: 
      var $1873=$2;
      var $1874=(($1873+116)|0);
      var $1875=HEAP32[(($1874)>>2)];
      var $1876=((($1875)+(1))|0);
      HEAP32[(($1874)>>2)]=$1876;
      __label__ = 234; break;
    case 234: 
      __label__ = 236; break;
    case 235: 
      var $1879=$2;
      var $1880=(($ty22)|0);
      var $1881=(($ty11)|0);
      _parseerror($1879, ((STRING_TABLE.__str90662)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1880,HEAP32[(((tempInt)+(4))>>2)]=$1881,tempInt));
      __label__ = 236; break;
    case 236: 
      __label__ = 237; break;
    case 237: 
      __label__ = 238; break;
    case 238: 
      var $1885=$assignop;
      var $1886=(($exprs)|0);
      var $1887=HEAP32[(($1886)>>2)];
      var $1888=(($exprs+4)|0);
      var $1889=HEAP32[(($1888)>>2)];
      var $1890=(($ctx)|0);
      var $1891=HEAP32[(($1890)>>2)];
      var $1892=(($ctx+4)|0);
      var $1893=HEAP32[(($1892)>>2)];
      var $1894=_ast_store_new($1891, $1893, $1885, $1887, $1889);
      var $1895=$1894;
      $out=$1895;
      __label__ = 251; break;
    case 239: 
      var $1897=(($exprs)|0);
      var $1898=HEAP32[(($1897)>>2)];
      var $1899=$1898;
      var $1900=(($1899+24)|0);
      var $1901=HEAP32[(($1900)>>2)];
      var $1902=(($exprs+4)|0);
      var $1903=HEAP32[(($1902)>>2)];
      var $1904=$1903;
      var $1905=(($1904+24)|0);
      var $1906=HEAP32[(($1905)>>2)];
      var $1907=(($1901)|0)!=(($1906)|0);
      if ($1907) { __label__ = 242; break; } else { __label__ = 240; break; }
    case 240: 
      var $1909=(($exprs)|0);
      var $1910=HEAP32[(($1909)>>2)];
      var $1911=$1910;
      var $1912=(($1911+24)|0);
      var $1913=HEAP32[(($1912)>>2)];
      var $1914=(($1913)|0)!=3;
      if ($1914) { __label__ = 241; break; } else { __label__ = 243; break; }
    case 241: 
      var $1916=(($exprs)|0);
      var $1917=HEAP32[(($1916)>>2)];
      var $1918=$1917;
      var $1919=(($1918+24)|0);
      var $1920=HEAP32[(($1919)>>2)];
      var $1921=(($1920)|0)!=2;
      if ($1921) { __label__ = 242; break; } else { __label__ = 243; break; }
    case 242: 
      var $1923=$2;
      var $1924=(($exprs)|0);
      var $1925=HEAP32[(($1924)>>2)];
      var $1926=$1925;
      var $1927=(($1926+24)|0);
      var $1928=HEAP32[(($1927)>>2)];
      var $1929=((_type_name+($1928<<2))|0);
      var $1930=HEAP32[(($1929)>>2)];
      var $1931=(($exprs+4)|0);
      var $1932=HEAP32[(($1931)>>2)];
      var $1933=$1932;
      var $1934=(($1933+24)|0);
      var $1935=HEAP32[(($1934)>>2)];
      var $1936=((_type_name+($1935<<2))|0);
      var $1937=HEAP32[(($1936)>>2)];
      _parseerror($1923, ((STRING_TABLE.__str91663)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$1930,HEAP32[(((tempInt)+(4))>>2)]=$1937,tempInt));
      $1=0;
      __label__ = 254; break;
    case 243: 
      var $1939=(($exprs)|0);
      var $1940=HEAP32[(($1939)>>2)];
      var $1941=$1940;
      var $1942=(($1941+12)|0);
      var $1943=HEAP32[(($1942)>>2)];
      var $1944=(($1943)|0)==8;
      if ($1944) { __label__ = 244; break; } else { __label__ = 245; break; }
    case 244: 
      var $1946=(($exprs)|0);
      var $1947=HEAP32[(($1946)>>2)];
      var $1948=$1947;
      var $1949=(($1948+24)|0);
      var $1950=HEAP32[(($1949)>>2)];
      var $1951=((_type_storep_instr+($1950<<1))|0);
      var $1952=HEAP16[(($1951)>>1)];
      var $1953=(($1952)&65535);
      $assignop=$1953;
      __label__ = 246; break;
    case 245: 
      var $1955=(($exprs)|0);
      var $1956=HEAP32[(($1955)>>2)];
      var $1957=$1956;
      var $1958=(($1957+24)|0);
      var $1959=HEAP32[(($1958)>>2)];
      var $1960=((_type_store_instr+($1959<<1))|0);
      var $1961=HEAP16[(($1960)>>1)];
      var $1962=(($1961)&65535);
      $assignop=$1962;
      __label__ = 246; break;
    case 246: 
      var $1964=(($exprs)|0);
      var $1965=HEAP32[(($1964)>>2)];
      var $1966=$1965;
      var $1967=(($1966+24)|0);
      var $1968=HEAP32[(($1967)>>2)];
      if ((($1968)|0) == 2) {
        __label__ = 247; break;
      }
      else if ((($1968)|0) == 3) {
        __label__ = 248; break;
      }
      else {
      __label__ = 249; break;
      }
      
    case 247: 
      var $1970=$assignop;
      var $1971=$op;
      var $1972=(($1971+8)|0);
      var $1973=HEAP32[(($1972)>>2)];
      var $1974=(($1973)|0)==11069;
      var $1975=$1974 ? 6 : 8;
      var $1976=(($exprs)|0);
      var $1977=HEAP32[(($1976)>>2)];
      var $1978=(($exprs+4)|0);
      var $1979=HEAP32[(($1978)>>2)];
      var $1980=(($ctx)|0);
      var $1981=HEAP32[(($1980)>>2)];
      var $1982=(($ctx+4)|0);
      var $1983=HEAP32[(($1982)>>2)];
      var $1984=_ast_binstore_new($1981, $1983, $1970, $1975, $1977, $1979);
      var $1985=$1984;
      $out=$1985;
      __label__ = 250; break;
    case 248: 
      var $1987=$assignop;
      var $1988=$op;
      var $1989=(($1988+8)|0);
      var $1990=HEAP32[(($1989)>>2)];
      var $1991=(($1990)|0)==11069;
      var $1992=$1991 ? 7 : 9;
      var $1993=(($exprs)|0);
      var $1994=HEAP32[(($1993)>>2)];
      var $1995=(($exprs+4)|0);
      var $1996=HEAP32[(($1995)>>2)];
      var $1997=(($ctx)|0);
      var $1998=HEAP32[(($1997)>>2)];
      var $1999=(($ctx+4)|0);
      var $2000=HEAP32[(($1999)>>2)];
      var $2001=_ast_binstore_new($1998, $2000, $1987, $1992, $1994, $1996);
      var $2002=$2001;
      $out=$2002;
      __label__ = 250; break;
    case 249: 
      var $2004=$2;
      var $2005=(($exprs)|0);
      var $2006=HEAP32[(($2005)>>2)];
      var $2007=$2006;
      var $2008=(($2007+24)|0);
      var $2009=HEAP32[(($2008)>>2)];
      var $2010=((_type_name+($2009<<2))|0);
      var $2011=HEAP32[(($2010)>>2)];
      var $2012=(($exprs+4)|0);
      var $2013=HEAP32[(($2012)>>2)];
      var $2014=$2013;
      var $2015=(($2014+24)|0);
      var $2016=HEAP32[(($2015)>>2)];
      var $2017=((_type_name+($2016<<2))|0);
      var $2018=HEAP32[(($2017)>>2)];
      _parseerror($2004, ((STRING_TABLE.__str91663)|0), (tempInt=STACKTOP,STACKTOP += 8,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$2011,HEAP32[(((tempInt)+(4))>>2)]=$2018,tempInt));
      $1=0;
      __label__ = 254; break;
    case 250: 
      __label__ = 251; break;
    case 251: 
      var $2021=$out;
      var $2022=(($2021)|0)!=0;
      if ($2022) { __label__ = 253; break; } else { __label__ = 252; break; }
    case 252: 
      var $2024=$2;
      var $2025=$op;
      var $2026=(($2025)|0);
      var $2027=HEAP32[(($2026)>>2)];
      _parseerror($2024, ((STRING_TABLE.__str92664)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$2027,tempInt));
      $1=0;
      __label__ = 254; break;
    case 253: 
      var $2029=$3;
      var $2030=(($2029+4)|0);
      var $2031=HEAP32[(($2030)>>2)];
      var $2032=((($2031)+(1))|0);
      HEAP32[(($2030)>>2)]=$2032;
      var $2033=$3;
      var $2034=(($2033)|0);
      var $2035=HEAP32[(($2034)>>2)];
      var $2036=(($2035+($2031)*(28))|0);
      var $2037=$out;
      var $2038=(($ctx)|0);
      var $2039=HEAP32[(($2038)>>2)];
      var $2040=(($ctx+4)|0);
      var $2041=HEAP32[(($2040)>>2)];
      _syexp($9, $2039, $2041, $2037);
      var $2042=$2036;
      var $2043=$9;
      assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($2042)>>2)]=HEAP32[(($2043)>>2)];HEAP32[((($2042)+(4))>>2)]=HEAP32[((($2043)+(4))>>2)];HEAP32[((($2042)+(8))>>2)]=HEAP32[((($2043)+(8))>>2)];HEAP32[((($2042)+(12))>>2)]=HEAP32[((($2043)+(12))>>2)];HEAP32[((($2042)+(16))>>2)]=HEAP32[((($2043)+(16))>>2)];HEAP32[((($2042)+(20))>>2)]=HEAP32[((($2043)+(20))>>2)];HEAP32[((($2042)+(24))>>2)]=HEAP32[((($2043)+(24))>>2)];
      $1=1;
      __label__ = 254; break;
    case 254: 
      var $2045=$1;
      STACKTOP = __stackBase__;
      return $2045;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_sy_pop["X"]=1;

function _syparen($agg_result, $ctx_0, $ctx_1, $p, $off) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $2;
  var $e=(__stackBase__)+(8);
  var $3=(($ctx)|0);
  HEAP32[(($3)>>2)]=$ctx_0;
  var $4=(($ctx+4)|0);
  HEAP32[(($4)>>2)]=$ctx_1;
  $1=$p;
  $2=$off;
  var $5=(($e)|0);
  HEAP32[(($5)>>2)]=0;
  var $6=$2;
  var $7=(($e+8)|0);
  HEAP32[(($7)>>2)]=$6;
  var $8=(($e+12)|0);
  HEAP32[(($8)>>2)]=0;
  var $9=(($e+16)|0);
  HEAP32[(($9)>>2)]=0;
  var $10=(($e+20)|0);
  var $11=$10;
  var $12=$ctx;
  assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($11)>>2)]=HEAP32[(($12)>>2)];HEAP32[((($11)+(4))>>2)]=HEAP32[((($12)+(4))>>2)];
  var $13=$1;
  var $14=(($e+4)|0);
  HEAP32[(($14)>>2)]=$13;
  var $15=$agg_result;
  var $16=$e;
  assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($15)>>2)]=HEAP32[(($16)>>2)];HEAP32[((($15)+(4))>>2)]=HEAP32[((($16)+(4))>>2)];HEAP32[((($15)+(8))>>2)]=HEAP32[((($16)+(8))>>2)];HEAP32[((($15)+(12))>>2)]=HEAP32[((($16)+(12))>>2)];HEAP32[((($15)+(16))>>2)]=HEAP32[((($16)+(16))>>2)];HEAP32[((($15)+(20))>>2)]=HEAP32[((($16)+(20))>>2)];HEAP32[((($15)+(24))>>2)]=HEAP32[((($16)+(24))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _syop($agg_result, $ctx_0, $ctx_1, $op) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $e=(__stackBase__)+(8);
  var $2=(($ctx)|0);
  HEAP32[(($2)>>2)]=$ctx_0;
  var $3=(($ctx+4)|0);
  HEAP32[(($3)>>2)]=$ctx_1;
  $1=$op;
  var $4=$1;
  var $5=HEAP32[((_operators)>>2)];
  var $6=$4;
  var $7=$5;
  var $8=((($6)-($7))|0);
  var $9=((((($8)|0))/(24))&-1);
  var $10=((($9)+(1))|0);
  var $11=(($e)|0);
  HEAP32[(($11)>>2)]=$10;
  var $12=(($e+8)|0);
  HEAP32[(($12)>>2)]=0;
  var $13=(($e+12)|0);
  HEAP32[(($13)>>2)]=0;
  var $14=(($e+16)|0);
  HEAP32[(($14)>>2)]=0;
  var $15=(($e+20)|0);
  var $16=$15;
  var $17=$ctx;
  assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($16)>>2)]=HEAP32[(($17)>>2)];HEAP32[((($16)+(4))>>2)]=HEAP32[((($17)+(4))>>2)];
  var $18=(($e+4)|0);
  HEAP32[(($18)>>2)]=0;
  var $19=$agg_result;
  var $20=$e;
  assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($19)>>2)]=HEAP32[(($20)>>2)];HEAP32[((($19)+(4))>>2)]=HEAP32[((($20)+(4))>>2)];HEAP32[((($19)+(8))>>2)]=HEAP32[((($20)+(8))>>2)];HEAP32[((($19)+(12))>>2)]=HEAP32[((($20)+(12))>>2)];HEAP32[((($19)+(16))>>2)]=HEAP32[((($20)+(16))>>2)];HEAP32[((($19)+(20))>>2)]=HEAP32[((($20)+(20))>>2)];HEAP32[((($19)+(24))>>2)]=HEAP32[((($20)+(24))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _syblock($agg_result, $ctx_0, $ctx_1, $v) {
  var __stackBase__  = STACKTOP; STACKTOP += 36; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $ctx=__stackBase__;
  var $1;
  var $e=(__stackBase__)+(8);
  var $2=(($ctx)|0);
  HEAP32[(($2)>>2)]=$ctx_0;
  var $3=(($ctx+4)|0);
  HEAP32[(($3)>>2)]=$ctx_1;
  $1=$v;
  var $4=(($e)|0);
  HEAP32[(($4)>>2)]=0;
  var $5=(($e+8)|0);
  HEAP32[(($5)>>2)]=0;
  var $6=$1;
  var $7=$6;
  var $8=(($e+12)|0);
  HEAP32[(($8)>>2)]=$7;
  var $9=$1;
  var $10=(($e+16)|0);
  HEAP32[(($10)>>2)]=$9;
  var $11=(($e+20)|0);
  var $12=$11;
  var $13=$ctx;
  assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($12)>>2)]=HEAP32[(($13)>>2)];HEAP32[((($12)+(4))>>2)]=HEAP32[((($13)+(4))>>2)];
  var $14=(($e+4)|0);
  HEAP32[(($14)>>2)]=0;
  var $15=$agg_result;
  var $16=$e;
  assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($15)>>2)]=HEAP32[(($16)>>2)];HEAP32[((($15)+(4))>>2)]=HEAP32[((($16)+(4))>>2)];HEAP32[((($15)+(8))>>2)]=HEAP32[((($16)+(8))>>2)];HEAP32[((($15)+(12))>>2)]=HEAP32[((($16)+(12))>>2)];HEAP32[((($15)+(16))>>2)]=HEAP32[((($16)+(16))>>2)];HEAP32[((($15)+(20))>>2)]=HEAP32[((($16)+(20))>>2)];HEAP32[((($15)+(24))>>2)]=HEAP32[((($16)+(24))>>2)];
  STACKTOP = __stackBase__;
  return;
}


function _parser_const_float_0($parser) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$parser;
      var $2=$1;
      var $3=(($2+80)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $7=$1;
      var $8=_parser_const_float($7, 0);
      var $9=$1;
      var $10=(($9+80)|0);
      HEAP32[(($10)>>2)]=$8;
      __label__ = 4; break;
    case 4: 
      var $12=$1;
      var $13=(($12+80)|0);
      var $14=HEAP32[(($13)>>2)];
      ;
      return $14;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_const_vector_f($parser, $x, $y, $z) {
  var __stackBase__  = STACKTOP; STACKTOP += 12; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;

  var $1;
  var $2;
  var $3;
  var $4;
  var $v=__stackBase__;
  $1=$parser;
  $2=$x;
  $3=$y;
  $4=$z;
  var $5=$2;
  var $6=(($v)|0);
  HEAPF32[(($6)>>2)]=$5;
  var $7=$3;
  var $8=(($v+4)|0);
  HEAPF32[(($8)>>2)]=$7;
  var $9=$4;
  var $10=(($v+8)|0);
  HEAPF32[(($10)>>2)]=$9;
  var $11=$1;
  var $12=(($v)|0);
  var $13=HEAPF32[(($12)>>2)];
  var $14=(($v+4)|0);
  var $15=HEAPF32[(($14)>>2)];
  var $16=(($v+8)|0);
  var $17=HEAPF32[(($16)>>2)];
  var $18=_parser_const_vector($11, $13, $15, $17);
  STACKTOP = __stackBase__;
  return $18;
}


function _parser_const_vector_0($parser) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      $1=$parser;
      var $2=$1;
      var $3=(($2+84)|0);
      var $4=HEAP32[(($3)>>2)];
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $7=$1;
      var $8=_parser_const_vector_f($7, 0, 0, 0);
      var $9=$1;
      var $10=(($9+84)|0);
      HEAP32[(($10)>>2)]=$8;
      __label__ = 4; break;
    case 4: 
      var $12=$1;
      var $13=(($12+84)|0);
      var $14=HEAP32[(($13)>>2)];
      ;
      return $14;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_close_call($parser, $sy) {
  var __stackBase__  = STACKTOP; STACKTOP += 28; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $fun;
      var $call;
      var $fid;
      var $paramcount;
      var $params;
      var $4=__stackBase__;
      var $fval;
      var $fewmany;
      $2=$parser;
      $3=$sy;
      var $5=$3;
      var $6=(($5+16)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=((($7)-(1))|0);
      HEAP32[(($6)>>2)]=$8;
      var $9=$3;
      var $10=(($9+16)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=$3;
      var $13=(($12+12)|0);
      var $14=HEAP32[(($13)>>2)];
      var $15=(($14+($11)*(28))|0);
      var $16=(($15+8)|0);
      var $17=HEAP32[(($16)>>2)];
      $fid=$17;
      var $18=$3;
      var $19=(($18+4)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($20)>>>0) < 1;
      if ($21) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $23=$3;
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=$fid;
      var $27=(($25)>>>0) <= (($26)>>>0);
      if ($27) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $29=$2;
      _parseerror($29, ((STRING_TABLE.__str94666)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 40; break;
    case 5: 
      var $31=$fid;
      var $32=$3;
      var $33=(($32)|0);
      var $34=HEAP32[(($33)>>2)];
      var $35=(($34+($31)*(28))|0);
      var $36=(($35+12)|0);
      var $37=HEAP32[(($36)>>2)];
      $fun=$37;
      var $38=$3;
      var $39=(($38+16)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$3;
      var $42=(($41+12)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($43+($40)*(28))|0);
      var $45=(($44+20)|0);
      var $46=$fun;
      var $47=(($45)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($45+4)|0);
      var $50=HEAP32[(($49)>>2)];
      var $51=_ast_call_new($48, $50, $46);
      $call=$51;
      var $52=$call;
      var $53=(($52)|0)!=0;
      if ($53) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $55=$2;
      _parseerror($55, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 40; break;
    case 7: 
      var $57=$fid;
      var $58=((($57)+(1))|0);
      var $59=$3;
      var $60=(($59+4)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($58)|0)==(($61)|0);
      if ($62) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      $paramcount=0;
      __label__ = 20; break;
    case 9: 
      var $65=$fid;
      var $66=((($65)+(2))|0);
      var $67=$3;
      var $68=(($67+4)|0);
      var $69=HEAP32[(($68)>>2)];
      var $70=(($66)|0)==(($69)|0);
      if ($70) { __label__ = 10; break; } else { __label__ = 18; break; }
    case 10: 
      var $72=$3;
      var $73=(($72+4)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=((($74)-(1))|0);
      HEAP32[(($73)>>2)]=$75;
      var $76=$3;
      var $77=(($76+4)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=$3;
      var $80=(($79)|0);
      var $81=HEAP32[(($80)>>2)];
      var $82=(($81+($78)*(28))|0);
      var $83=(($82+16)|0);
      var $84=HEAP32[(($83)>>2)];
      $params=$84;
      var $85=$params;
      var $86=(($85)|0)!=0;
      if ($86) { __label__ = 14; break; } else { __label__ = 11; break; }
    case 11: 
      $paramcount=1;
      var $88=$call;
      var $89=$3;
      var $90=(($89+4)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=$3;
      var $93=(($92)|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=(($94+($91)*(28))|0);
      var $96=(($95+12)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=_ast_call_params_add($88, $97);
      if ($98) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      var $100=$3;
      var $101=(($100+4)|0);
      var $102=HEAP32[(($101)>>2)];
      var $103=$3;
      var $104=(($103)|0);
      var $105=HEAP32[(($104)>>2)];
      var $106=(($105+($102)*(28))|0);
      var $107=(($106+12)|0);
      var $108=HEAP32[(($107)>>2)];
      var $109=$108;
      var $110=$109;
      var $111=(($110+8)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=$3;
      var $114=(($113+4)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=$3;
      var $117=(($116)|0);
      var $118=HEAP32[(($117)>>2)];
      var $119=(($118+($115)*(28))|0);
      var $120=(($119+12)|0);
      var $121=HEAP32[(($120)>>2)];
      var $122=$121;
      FUNCTION_TABLE[$112]($122);
      var $123=$2;
      _parseerror($123, ((STRING_TABLE.__str61633)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 40; break;
    case 13: 
      __label__ = 15; break;
    case 14: 
      var $126=$params;
      var $127=(($126+72)|0);
      var $128=HEAP32[(($127)>>2)];
      $paramcount=$128;
      var $129=$params;
      var $130=(($129+68)|0);
      var $131=HEAP32[(($130)>>2)];
      var $132=$call;
      var $133=(($132+60)|0);
      HEAP32[(($133)>>2)]=$131;
      var $134=$params;
      var $135=(($134+72)|0);
      var $136=HEAP32[(($135)>>2)];
      var $137=$call;
      var $138=(($137+64)|0);
      HEAP32[(($138)>>2)]=$136;
      var $139=$params;
      var $140=(($139+76)|0);
      var $141=HEAP32[(($140)>>2)];
      var $142=$call;
      var $143=(($142+68)|0);
      HEAP32[(($143)>>2)]=$141;
      var $144=$params;
      var $145=(($144+68)|0);
      HEAP32[(($145)>>2)]=0;
      var $146=$params;
      var $147=(($146+72)|0);
      HEAP32[(($147)>>2)]=0;
      var $148=$params;
      var $149=(($148+76)|0);
      HEAP32[(($149)>>2)]=0;
      var $150=$params;
      var $151=$150;
      var $152=$151;
      var $153=(($152+8)|0);
      var $154=HEAP32[(($153)>>2)];
      var $155=$params;
      var $156=$155;
      FUNCTION_TABLE[$154]($156);
      __label__ = 15; break;
    case 15: 
      var $158=$call;
      var $159=_ast_call_check_types($158);
      if ($159) { __label__ = 17; break; } else { __label__ = 16; break; }
    case 16: 
      var $161=$2;
      var $162=(($161+116)|0);
      var $163=HEAP32[(($162)>>2)];
      var $164=((($163)+(1))|0);
      HEAP32[(($162)>>2)]=$164;
      __label__ = 17; break;
    case 17: 
      __label__ = 19; break;
    case 18: 
      var $167=$2;
      _parseerror($167, ((STRING_TABLE.__str95667)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 40; break;
    case 19: 
      __label__ = 20; break;
    case 20: 
      var $170=$fid;
      var $171=$3;
      var $172=(($171)|0);
      var $173=HEAP32[(($172)>>2)];
      var $174=(($173+($170)*(28))|0);
      var $175=$call;
      var $176=(($175)|0);
      var $177=(($176)|0);
      var $178=(($177)|0);
      var $179=$call;
      var $180=$179;
      var $181=(($178)|0);
      var $182=HEAP32[(($181)>>2)];
      var $183=(($178+4)|0);
      var $184=HEAP32[(($183)>>2)];
      _syexp($4, $182, $184, $180);
      var $185=$174;
      var $186=$4;
      assert(28 % 1 === 0, 'memcpy given ' + 28 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($185)>>2)]=HEAP32[(($186)>>2)];HEAP32[((($185)+(4))>>2)]=HEAP32[((($186)+(4))>>2)];HEAP32[((($185)+(8))>>2)]=HEAP32[((($186)+(8))>>2)];HEAP32[((($185)+(12))>>2)]=HEAP32[((($186)+(12))>>2)];HEAP32[((($185)+(16))>>2)]=HEAP32[((($186)+(16))>>2)];HEAP32[((($185)+(20))>>2)]=HEAP32[((($186)+(20))>>2)];HEAP32[((($185)+(24))>>2)]=HEAP32[((($186)+(24))>>2)];
      var $187=$fun;
      var $188=$187;
      var $189=(($188+24)|0);
      var $190=HEAP32[(($189)>>2)];
      var $191=(($190)|0)!=6;
      if ($191) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      var $193=$2;
      var $194=$fun;
      var $195=$194;
      var $196=(($195+24)|0);
      var $197=HEAP32[(($196)>>2)];
      var $198=((_type_name+($197<<2))|0);
      var $199=HEAP32[(($198)>>2)];
      _parseerror($193, ((STRING_TABLE.__str96668)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$199,tempInt));
      $1=0;
      __label__ = 40; break;
    case 22: 
      var $201=$fun;
      var $202=$201;
      var $203=(($202+28)|0);
      var $204=HEAP32[(($203)>>2)];
      var $205=(($204)|0)!=0;
      if ($205) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $207=$2;
      _parseerror($207, ((STRING_TABLE.__str97669)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 40; break;
    case 24: 
      var $209=$fun;
      var $210=$209;
      var $211=(($210+36)|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=$paramcount;
      var $214=(($212)|0)!=(($213)|0);
      if ($214) { __label__ = 25; break; } else { __label__ = 38; break; }
    case 25: 
      var $216=$fun;
      var $217=$216;
      var $218=(($217+44)|0);
      var $219=HEAP8[($218)];
      var $220=(($219) & 1);
      if ($220) { __label__ = 26; break; } else { __label__ = 27; break; }
    case 26: 
      var $222=$fun;
      var $223=$222;
      var $224=(($223+36)|0);
      var $225=HEAP32[(($224)>>2)];
      var $226=$paramcount;
      var $227=(($225)>>>0) < (($226)>>>0);
      if ($227) { __label__ = 38; break; } else { __label__ = 27; break; }
    case 27: 
      var $229=$fun;
      var $230=$229;
      var $231=(($230+36)|0);
      var $232=HEAP32[(($231)>>2)];
      var $233=$paramcount;
      var $234=(($232)>>>0) > (($233)>>>0);
      var $235=$234 ? (((STRING_TABLE.__str98670)|0)) : (((STRING_TABLE.__str99671)|0));
      $fewmany=$235;
      var $236=$fun;
      var $237=$236;
      var $238=(($237+12)|0);
      var $239=HEAP32[(($238)>>2)];
      var $240=(($239)|0)==2;
      if ($240) { __label__ = 28; break; } else { __label__ = 29; break; }
    case 28: 
      var $242=$fun;
      var $243=$242;
      var $246 = $243;__label__ = 30; break;
    case 29: 
      var $246 = 0;__label__ = 30; break;
    case 30: 
      var $246;
      $fval=$246;
      var $247=HEAP32[((_opts_standard)>>2)];
      var $248=(($247)|0)==3;
      if ($248) { __label__ = 31; break; } else { __label__ = 35; break; }
    case 31: 
      var $250=$fval;
      var $251=(($250)|0)!=0;
      if ($251) { __label__ = 32; break; } else { __label__ = 33; break; }
    case 32: 
      var $253=$2;
      var $254=$fewmany;
      var $255=$fval;
      var $256=(($255+56)|0);
      var $257=HEAP32[(($256)>>2)];
      var $258=$fun;
      var $259=$258;
      var $260=(($259+36)|0);
      var $261=HEAP32[(($260)>>2)];
      var $262=$paramcount;
      var $263=$fval;
      var $264=(($263+56)|0);
      var $265=HEAP32[(($264)>>2)];
      var $266=$fun;
      var $267=$266;
      var $268=(($267)|0);
      var $269=(($268)|0);
      var $270=HEAP32[(($269)>>2)];
      var $271=$fun;
      var $272=$271;
      var $273=(($272)|0);
      var $274=(($273+4)|0);
      var $275=HEAP32[(($274)>>2)];
      _parseerror($253, ((STRING_TABLE.__str100672)|0), (tempInt=STACKTOP,STACKTOP += 28,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$254,HEAP32[(((tempInt)+(4))>>2)]=$257,HEAP32[(((tempInt)+(8))>>2)]=$261,HEAP32[(((tempInt)+(12))>>2)]=$262,HEAP32[(((tempInt)+(16))>>2)]=$265,HEAP32[(((tempInt)+(20))>>2)]=$270,HEAP32[(((tempInt)+(24))>>2)]=$275,tempInt));
      __label__ = 34; break;
    case 33: 
      var $277=$2;
      var $278=$fewmany;
      var $279=$fval;
      var $280=(($279+56)|0);
      var $281=HEAP32[(($280)>>2)];
      var $282=$fun;
      var $283=$282;
      var $284=(($283+36)|0);
      var $285=HEAP32[(($284)>>2)];
      var $286=$paramcount;
      var $287=$fval;
      var $288=(($287+56)|0);
      var $289=HEAP32[(($288)>>2)];
      var $290=$fun;
      var $291=$290;
      var $292=(($291)|0);
      var $293=(($292)|0);
      var $294=HEAP32[(($293)>>2)];
      var $295=$fun;
      var $296=$295;
      var $297=(($296)|0);
      var $298=(($297+4)|0);
      var $299=HEAP32[(($298)>>2)];
      _parseerror($277, ((STRING_TABLE.__str101673)|0), (tempInt=STACKTOP,STACKTOP += 28,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$278,HEAP32[(((tempInt)+(4))>>2)]=$281,HEAP32[(((tempInt)+(8))>>2)]=$285,HEAP32[(((tempInt)+(12))>>2)]=$286,HEAP32[(((tempInt)+(16))>>2)]=$289,HEAP32[(((tempInt)+(20))>>2)]=$294,HEAP32[(((tempInt)+(24))>>2)]=$299,tempInt));
      __label__ = 34; break;
    case 34: 
      $1=0;
      __label__ = 40; break;
    case 35: 
      var $302=$fval;
      var $303=(($302)|0)!=0;
      if ($303) { __label__ = 36; break; } else { __label__ = 37; break; }
    case 36: 
      var $305=$2;
      var $306=$fewmany;
      var $307=$fval;
      var $308=(($307+56)|0);
      var $309=HEAP32[(($308)>>2)];
      var $310=$fun;
      var $311=$310;
      var $312=(($311+36)|0);
      var $313=HEAP32[(($312)>>2)];
      var $314=$paramcount;
      var $315=$fval;
      var $316=(($315+56)|0);
      var $317=HEAP32[(($316)>>2)];
      var $318=$fun;
      var $319=$318;
      var $320=(($319)|0);
      var $321=(($320)|0);
      var $322=HEAP32[(($321)>>2)];
      var $323=$fun;
      var $324=$323;
      var $325=(($324)|0);
      var $326=(($325+4)|0);
      var $327=HEAP32[(($326)>>2)];
      var $328=_parsewarning($305, 7, ((STRING_TABLE.__str100672)|0), (tempInt=STACKTOP,STACKTOP += 28,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$306,HEAP32[(((tempInt)+(4))>>2)]=$309,HEAP32[(((tempInt)+(8))>>2)]=$313,HEAP32[(((tempInt)+(12))>>2)]=$314,HEAP32[(((tempInt)+(16))>>2)]=$317,HEAP32[(((tempInt)+(20))>>2)]=$322,HEAP32[(((tempInt)+(24))>>2)]=$327,tempInt));
      var $329=$328 ^ 1;
      $1=$329;
      __label__ = 40; break;
    case 37: 
      var $331=$2;
      var $332=$fewmany;
      var $333=$fval;
      var $334=(($333+56)|0);
      var $335=HEAP32[(($334)>>2)];
      var $336=$fun;
      var $337=$336;
      var $338=(($337+36)|0);
      var $339=HEAP32[(($338)>>2)];
      var $340=$paramcount;
      var $341=$fval;
      var $342=(($341+56)|0);
      var $343=HEAP32[(($342)>>2)];
      var $344=$fun;
      var $345=$344;
      var $346=(($345)|0);
      var $347=(($346)|0);
      var $348=HEAP32[(($347)>>2)];
      var $349=$fun;
      var $350=$349;
      var $351=(($350)|0);
      var $352=(($351+4)|0);
      var $353=HEAP32[(($352)>>2)];
      var $354=_parsewarning($331, 7, ((STRING_TABLE.__str101673)|0), (tempInt=STACKTOP,STACKTOP += 28,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$332,HEAP32[(((tempInt)+(4))>>2)]=$335,HEAP32[(((tempInt)+(8))>>2)]=$339,HEAP32[(((tempInt)+(12))>>2)]=$340,HEAP32[(((tempInt)+(16))>>2)]=$343,HEAP32[(((tempInt)+(20))>>2)]=$348,HEAP32[(((tempInt)+(24))>>2)]=$353,tempInt));
      var $355=$354 ^ 1;
      $1=$355;
      __label__ = 40; break;
    case 38: 
      __label__ = 39; break;
    case 39: 
      $1=1;
      __label__ = 40; break;
    case 40: 
      var $359=$1;
      STACKTOP = __stackBase__;
      return $359;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_close_call["X"]=1;

function _parse_block_into($parser, $block, $warnreturn) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $oldblocklocal;
      var $retval;
      var $expr=__stackBase__;
      $1=$parser;
      $2=$block;
      var $4=(($warnreturn)&1);
      $3=$4;
      $retval=1;
      var $5=$1;
      var $6=(($5+112)|0);
      var $7=HEAP32[(($6)>>2)];
      $oldblocklocal=$7;
      var $8=$1;
      var $9=(($8+104)|0);
      var $10=HEAP32[(($9)>>2)];
      var $11=$1;
      var $12=(($11+112)|0);
      HEAP32[(($12)>>2)]=$10;
      var $13=$1;
      var $14=_parser_next($13);
      if ($14) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $16=$1;
      _parseerror($16, ((STRING_TABLE.__str126698)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 29; break;
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $19=$1;
      var $20=(($19+4)|0);
      var $21=HEAP32[(($20)>>2)];
      var $22=(($21)|0)!=141;
      if ($22) { __label__ = 6; break; } else { var $29 = 0;__label__ = 7; break; }
    case 6: 
      var $24=$1;
      var $25=(($24+4)|0);
      var $26=HEAP32[(($25)>>2)];
      var $27=(($26)|0) < 142;
      var $29 = $27;__label__ = 7; break;
    case 7: 
      var $29;
      if ($29) { __label__ = 8; break; } else { __label__ = 17; break; }
    case 8: 
      var $31=$1;
      var $32=(($31+4)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=(($33)|0)==125;
      if ($34) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      __label__ = 17; break;
    case 10: 
      var $37=$1;
      var $38=$2;
      var $39=_parse_statement($37, $38, $expr);
      if ($39) { __label__ = 12; break; } else { __label__ = 11; break; }
    case 11: 
      $2=0;
      __label__ = 29; break;
    case 12: 
      var $42=HEAP32[(($expr)>>2)];
      var $43=(($42)|0)!=0;
      if ($43) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      __label__ = 5; break;
    case 14: 
      var $46=$2;
      var $47=HEAP32[(($expr)>>2)];
      var $48=_ast_block_exprs_add($46, $47);
      if ($48) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $50=HEAP32[(($expr)>>2)];
      var $51=$50;
      var $52=$51;
      var $53=(($52+8)|0);
      var $54=HEAP32[(($53)>>2)];
      var $55=HEAP32[(($expr)>>2)];
      var $56=$55;
      FUNCTION_TABLE[$54]($56);
      $2=0;
      __label__ = 29; break;
    case 16: 
      __label__ = 5; break;
    case 17: 
      var $59=$1;
      var $60=(($59+4)|0);
      var $61=HEAP32[(($60)>>2)];
      var $62=(($61)|0)!=125;
      if ($62) { __label__ = 18; break; } else { __label__ = 19; break; }
    case 18: 
      $2=0;
      __label__ = 28; break;
    case 19: 
      var $65=$3;
      var $66=(($65) & 1);
      if ($66) { __label__ = 20; break; } else { __label__ = 27; break; }
    case 20: 
      var $68=$1;
      var $69=(($68+96)|0);
      var $70=HEAP32[(($69)>>2)];
      var $71=(($70+20)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=(($72)|0);
      var $74=(($73+28)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=$75;
      var $77=(($76+24)|0);
      var $78=HEAP32[(($77)>>2)];
      var $79=(($78)|0)!=0;
      if ($79) { __label__ = 21; break; } else { __label__ = 27; break; }
    case 21: 
      var $81=$2;
      var $82=(($81+72)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=(($83)|0)!=0;
      if ($84) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $86=$2;
      var $87=(($86+72)|0);
      var $88=HEAP32[(($87)>>2)];
      var $89=((($88)-(1))|0);
      var $90=$2;
      var $91=(($90+68)|0);
      var $92=HEAP32[(($91)>>2)];
      var $93=(($92+($89<<2))|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=$94;
      var $96=(($95+12)|0);
      var $97=HEAP32[(($96)>>2)];
      var $98=(($97)|0)==14;
      if ($98) { __label__ = 26; break; } else { __label__ = 23; break; }
    case 23: 
      var $100=$1;
      var $101=_parsewarning($100, 6, ((STRING_TABLE.__str127699)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($101) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      $2=0;
      __label__ = 29; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $106=$1;
      var $107=_parser_next($106);
      __label__ = 28; break;
    case 28: 
      __label__ = 29; break;
    case 29: 
      __label__ = 30; break;
    case 30: 
      var $111=$1;
      var $112=(($111+104)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=$1;
      var $115=(($114+112)|0);
      var $116=HEAP32[(($115)>>2)];
      var $117=(($113)>>>0) > (($116)>>>0);
      if ($117) { __label__ = 31; break; } else { __label__ = 34; break; }
    case 31: 
      var $119=$retval;
      var $120=(($119) & 1);
      if ($120) { __label__ = 32; break; } else { var $125 = 0;__label__ = 33; break; }
    case 32: 
      var $122=$1;
      var $123=_parser_pop_local($122);
      var $125 = $123;__label__ = 33; break;
    case 33: 
      var $125;
      var $126=(($125)&1);
      $retval=$126;
      __label__ = 30; break;
    case 34: 
      var $128=$oldblocklocal;
      var $129=$1;
      var $130=(($129+112)|0);
      HEAP32[(($130)>>2)]=$128;
      var $131=$2;
      var $132=(($131)|0)!=0;
      var $133=$132 ^ 1;
      var $134=$133 ^ 1;
      STACKTOP = __stackBase__;
      return $134;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_block_into["X"]=1;

function _parser_pop_local($parser) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $ve;
      $2=$parser;
      var $3=$2;
      var $4=(($3+104)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=((($5)-(1))|0);
      HEAP32[(($4)>>2)]=$6;
      var $7=$2;
      var $8=(($7+104)|0);
      var $9=HEAP32[(($8)>>2)];
      var $10=$2;
      var $11=(($10+100)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12+($9<<3))|0);
      $ve=$13;
      var $14=$ve;
      var $15=(($14+4)|0);
      var $16=HEAP32[(($15)>>2)];
      var $17=$16;
      var $18=(($17+12)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20=(($19)|0)==2;
      if ($20) { __label__ = 3; break; } else { __label__ = 7; break; }
    case 3: 
      var $22=$ve;
      var $23=(($22+4)|0);
      var $24=HEAP32[(($23)>>2)];
      var $25=$24;
      var $26=(($25+76)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27)|0)!=0;
      if ($28) { __label__ = 7; break; } else { __label__ = 4; break; }
    case 4: 
      var $30=$2;
      var $31=$ve;
      var $32=(($31)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=_parsewarning($30, 1, ((STRING_TABLE.__str125697)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$33,tempInt));
      if ($34) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      $1=0;
      __label__ = 8; break;
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $38=$2;
      var $39=(($38+104)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=$2;
      var $42=(($41+100)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=(($43+($40<<3))|0);
      var $45=(($44)|0);
      var $46=HEAP32[(($45)>>2)];
      _util_memory_d($46, 1842, ((STRING_TABLE.__str572)|0));
      $1=1;
      __label__ = 8; break;
    case 8: 
      var $48=$1;
      STACKTOP = __stackBase__;
      return $48;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_pop_local["X"]=1;

function _parse_statement($parser, $block, $out) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $exp;
      var $ret;
      var $expected;
      var $inner;
      var $exp1;
      $2=$parser;
      $3=$block;
      $4=$out;
      var $5=$2;
      var $6=(($5+4)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7)|0)==130;
      if ($8) { __label__ = 3; break; } else { __label__ = 12; break; }
    case 3: 
      var $10=$3;
      var $11=(($10)|0)!=0;
      if ($11) { __label__ = 5; break; } else { __label__ = 4; break; }
    case 4: 
      var $13=$2;
      _parseerror($13, ((STRING_TABLE.__str128700)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 72; break;
    case 5: 
      var $15=HEAP32[((_opts_standard)>>2)];
      var $16=(($15)|0)==0;
      if ($16) { __label__ = 6; break; } else { __label__ = 9; break; }
    case 6: 
      var $18=$2;
      var $19=_parsewarning($18, 4, ((STRING_TABLE.__str129701)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($19) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      $1=0;
      __label__ = 72; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $23=$2;
      var $24=$3;
      var $25=_parse_variable($23, $24);
      if ($25) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      $1=0;
      __label__ = 72; break;
    case 11: 
      var $28=$4;
      HEAP32[(($28)>>2)]=0;
      $1=1;
      __label__ = 72; break;
    case 12: 
      var $30=$2;
      var $31=(($30+4)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=(($32)|0)==132;
      if ($33) { __label__ = 13; break; } else { __label__ = 59; break; }
    case 13: 
      var $35=$2;
      var $36=(($35)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37+292)|0);
      var $39=(($38+4)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=_strcmp($40, ((STRING_TABLE.__str130702)|0));
      var $42=(($41)|0)!=0;
      if ($42) { __label__ = 21; break; } else { __label__ = 14; break; }
    case 14: 
      var $44=$3;
      var $45=(($44)|0)!=0;
      if ($45) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      var $47=$2;
      _parseerror($47, ((STRING_TABLE.__str131703)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 72; break;
    case 16: 
      var $49=$2;
      var $50=_parser_next($49);
      if ($50) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $52=$2;
      _parseerror($52, ((STRING_TABLE.__str132704)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 72; break;
    case 18: 
      var $54=$2;
      var $55=$3;
      var $56=_parse_variable($54, $55);
      if ($56) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      $1=0;
      __label__ = 72; break;
    case 20: 
      var $59=$4;
      HEAP32[(($59)>>2)]=0;
      $1=1;
      __label__ = 72; break;
    case 21: 
      var $61=$2;
      var $62=(($61)|0);
      var $63=HEAP32[(($62)>>2)];
      var $64=(($63+292)|0);
      var $65=(($64+4)|0);
      var $66=HEAP32[(($65)>>2)];
      var $67=_strcmp($66, ((STRING_TABLE.__str133705)|0));
      var $68=(($67)|0)!=0;
      if ($68) { __label__ = 41; break; } else { __label__ = 22; break; }
    case 22: 
      $exp=0;
      $ret=0;
      var $70=$2;
      var $71=(($70+96)|0);
      var $72=HEAP32[(($71)>>2)];
      var $73=(($72+20)|0);
      var $74=HEAP32[(($73)>>2)];
      $expected=$74;
      var $75=$2;
      var $76=_parser_next($75);
      if ($76) { __label__ = 24; break; } else { __label__ = 23; break; }
    case 23: 
      var $78=$2;
      _parseerror($78, ((STRING_TABLE.__str134706)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 72; break;
    case 24: 
      var $80=$2;
      var $81=(($80+4)|0);
      var $82=HEAP32[(($81)>>2)];
      var $83=(($82)|0)!=59;
      if ($83) { __label__ = 25; break; } else { __label__ = 32; break; }
    case 25: 
      var $85=$2;
      var $86=_parse_expression($85, 0);
      $exp=$86;
      var $87=$exp;
      var $88=(($87)|0)!=0;
      if ($88) { __label__ = 27; break; } else { __label__ = 26; break; }
    case 26: 
      $1=0;
      __label__ = 72; break;
    case 27: 
      var $91=$exp;
      var $92=$91;
      var $93=(($92+24)|0);
      var $94=HEAP32[(($93)>>2)];
      var $95=$expected;
      var $96=(($95)|0);
      var $97=(($96+28)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=$98;
      var $100=(($99+24)|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=(($94)|0)!=(($101)|0);
      if ($102) { __label__ = 28; break; } else { __label__ = 29; break; }
    case 28: 
      var $104=$2;
      _parseerror($104, ((STRING_TABLE.__str135707)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 29; break;
    case 29: 
      var $106=$exp;
      var $107=$106;
      var $108=(($107)|0);
      var $109=(($108)|0);
      var $110=$exp;
      var $111=(($109)|0);
      var $112=HEAP32[(($111)>>2)];
      var $113=(($109+4)|0);
      var $114=HEAP32[(($113)>>2)];
      var $115=_ast_return_new($112, $114, $110);
      $ret=$115;
      var $116=$ret;
      var $117=(($116)|0)!=0;
      if ($117) { __label__ = 31; break; } else { __label__ = 30; break; }
    case 30: 
      var $119=$exp;
      var $120=$119;
      var $121=$120;
      var $122=(($121+8)|0);
      var $123=HEAP32[(($122)>>2)];
      var $124=$exp;
      var $125=$124;
      FUNCTION_TABLE[$123]($125);
      $1=0;
      __label__ = 72; break;
    case 31: 
      __label__ = 40; break;
    case 32: 
      var $128=$2;
      var $129=_parser_next($128);
      if ($129) { __label__ = 34; break; } else { __label__ = 33; break; }
    case 33: 
      var $131=$2;
      _parseerror($131, ((STRING_TABLE.__str4576)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 34; break;
    case 34: 
      var $133=$expected;
      var $134=(($133)|0);
      var $135=(($134+28)|0);
      var $136=HEAP32[(($135)>>2)];
      var $137=$136;
      var $138=(($137+24)|0);
      var $139=HEAP32[(($138)>>2)];
      var $140=(($139)|0)!=0;
      if ($140) { __label__ = 35; break; } else { __label__ = 39; break; }
    case 35: 
      var $142=HEAP32[((_opts_standard)>>2)];
      var $143=(($142)|0)!=3;
      if ($143) { __label__ = 36; break; } else { __label__ = 37; break; }
    case 36: 
      var $145=$2;
      var $146=_parsewarning($145, 6, ((STRING_TABLE.__str136708)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $147=$146 ^ 1;
      var $148=(($147)&1);
      __label__ = 38; break;
    case 37: 
      var $150=$2;
      _parseerror($150, ((STRING_TABLE.__str136708)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 38; break;
    case 38: 
      __label__ = 39; break;
    case 39: 
      var $153=$2;
      var $154=(($153)|0);
      var $155=HEAP32[(($154)>>2)];
      var $156=(($155+292)|0);
      var $157=(($156+28)|0);
      var $158=(($157)|0);
      var $159=HEAP32[(($158)>>2)];
      var $160=(($157+4)|0);
      var $161=HEAP32[(($160)>>2)];
      var $162=_ast_return_new($159, $161, 0);
      $ret=$162;
      __label__ = 40; break;
    case 40: 
      var $164=$ret;
      var $165=$164;
      var $166=$4;
      HEAP32[(($166)>>2)]=$165;
      $1=1;
      __label__ = 72; break;
    case 41: 
      var $168=$2;
      var $169=(($168)|0);
      var $170=HEAP32[(($169)>>2)];
      var $171=(($170+292)|0);
      var $172=(($171+4)|0);
      var $173=HEAP32[(($172)>>2)];
      var $174=_strcmp($173, ((STRING_TABLE.__str137709)|0));
      var $175=(($174)|0)!=0;
      if ($175) { __label__ = 43; break; } else { __label__ = 42; break; }
    case 42: 
      var $177=$2;
      var $178=$3;
      var $179=$4;
      var $180=_parse_if($177, $178, $179);
      $1=$180;
      __label__ = 72; break;
    case 43: 
      var $182=$2;
      var $183=(($182)|0);
      var $184=HEAP32[(($183)>>2)];
      var $185=(($184+292)|0);
      var $186=(($185+4)|0);
      var $187=HEAP32[(($186)>>2)];
      var $188=_strcmp($187, ((STRING_TABLE.__str138710)|0));
      var $189=(($188)|0)!=0;
      if ($189) { __label__ = 45; break; } else { __label__ = 44; break; }
    case 44: 
      var $191=$2;
      var $192=$3;
      var $193=$4;
      var $194=_parse_while($191, $192, $193);
      $1=$194;
      __label__ = 72; break;
    case 45: 
      var $196=$2;
      var $197=(($196)|0);
      var $198=HEAP32[(($197)>>2)];
      var $199=(($198+292)|0);
      var $200=(($199+4)|0);
      var $201=HEAP32[(($200)>>2)];
      var $202=_strcmp($201, ((STRING_TABLE.__str139711)|0));
      var $203=(($202)|0)!=0;
      if ($203) { __label__ = 47; break; } else { __label__ = 46; break; }
    case 46: 
      var $205=$2;
      var $206=$3;
      var $207=$4;
      var $208=_parse_dowhile($205, $206, $207);
      $1=$208;
      __label__ = 72; break;
    case 47: 
      var $210=$2;
      var $211=(($210)|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=(($212+292)|0);
      var $214=(($213+4)|0);
      var $215=HEAP32[(($214)>>2)];
      var $216=_strcmp($215, ((STRING_TABLE.__str140712)|0));
      var $217=(($216)|0)!=0;
      if ($217) { __label__ = 53; break; } else { __label__ = 48; break; }
    case 48: 
      var $219=HEAP32[((_opts_standard)>>2)];
      var $220=(($219)|0)==0;
      if ($220) { __label__ = 49; break; } else { __label__ = 52; break; }
    case 49: 
      var $222=$2;
      var $223=_parsewarning($222, 4, ((STRING_TABLE.__str141713)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($223) { __label__ = 50; break; } else { __label__ = 51; break; }
    case 50: 
      $1=0;
      __label__ = 72; break;
    case 51: 
      __label__ = 52; break;
    case 52: 
      var $227=$2;
      var $228=$3;
      var $229=$4;
      var $230=_parse_for($227, $228, $229);
      $1=$230;
      __label__ = 72; break;
    case 53: 
      __label__ = 54; break;
    case 54: 
      __label__ = 55; break;
    case 55: 
      __label__ = 56; break;
    case 56: 
      __label__ = 57; break;
    case 57: 
      __label__ = 58; break;
    case 58: 
      var $237=$2;
      _parseerror($237, ((STRING_TABLE.__str142714)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 72; break;
    case 59: 
      var $239=$2;
      var $240=(($239+4)|0);
      var $241=HEAP32[(($240)>>2)];
      var $242=(($241)|0)==123;
      if ($242) { __label__ = 60; break; } else { __label__ = 63; break; }
    case 60: 
      var $244=$2;
      var $245=_parse_block($244, 0);
      $inner=$245;
      var $246=$inner;
      var $247=(($246)|0)!=0;
      if ($247) { __label__ = 62; break; } else { __label__ = 61; break; }
    case 61: 
      $1=0;
      __label__ = 72; break;
    case 62: 
      var $250=$inner;
      var $251=$250;
      var $252=$4;
      HEAP32[(($252)>>2)]=$251;
      $1=1;
      __label__ = 72; break;
    case 63: 
      var $254=$2;
      var $255=_parse_expression($254, 0);
      $exp1=$255;
      var $256=$exp1;
      var $257=(($256)|0)!=0;
      if ($257) { __label__ = 65; break; } else { __label__ = 64; break; }
    case 64: 
      $1=0;
      __label__ = 72; break;
    case 65: 
      var $260=$exp1;
      var $261=$4;
      HEAP32[(($261)>>2)]=$260;
      var $262=$exp1;
      var $263=$262;
      var $264=(($263+12)|0);
      var $265=HEAP32[(($264)>>2)];
      var $266=(($265)|0)==6;
      if ($266) { __label__ = 71; break; } else { __label__ = 66; break; }
    case 66: 
      var $268=$exp1;
      var $269=$268;
      var $270=(($269+12)|0);
      var $271=HEAP32[(($270)>>2)];
      var $272=(($271)|0)==12;
      if ($272) { __label__ = 71; break; } else { __label__ = 67; break; }
    case 67: 
      var $274=$exp1;
      var $275=$274;
      var $276=(($275+12)|0);
      var $277=HEAP32[(($276)>>2)];
      var $278=(($277)|0)==7;
      if ($278) { __label__ = 71; break; } else { __label__ = 68; break; }
    case 68: 
      var $280=$exp1;
      var $281=$280;
      var $282=(($281)|0);
      var $283=(($282)|0);
      var $284=HEAP32[(($283)>>2)];
      var $285=(($282+4)|0);
      var $286=HEAP32[(($285)>>2)];
      var $287=_genwarning($284, $286, 14, ((STRING_TABLE.__str143715)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($287) { __label__ = 69; break; } else { __label__ = 70; break; }
    case 69: 
      $1=0;
      __label__ = 72; break;
    case 70: 
      __label__ = 71; break;
    case 71: 
      $1=1;
      __label__ = 72; break;
    case 72: 
      var $292=$1;
      STACKTOP = __stackBase__;
      return $292;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_statement["X"]=1;

function _parse_expression($parser, $stopatcomma) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $e;
      $2=$parser;
      var $4=(($stopatcomma)&1);
      $3=$4;
      var $5=$2;
      var $6=$3;
      var $7=(($6) & 1);
      var $8=_parse_expression_leave($5, $7);
      $e=$8;
      var $9=$e;
      var $10=(($9)|0)!=0;
      if ($10) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $13=$2;
      var $14=_parser_next($13);
      if ($14) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $16=$e;
      var $17=$16;
      var $18=$17;
      var $19=(($18+8)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=$e;
      var $22=$21;
      FUNCTION_TABLE[$20]($22);
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $24=$e;
      $1=$24;
      __label__ = 7; break;
    case 7: 
      var $26=$1;
      ;
      return $26;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parse_if($parser, $block, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $ifthen;
      var $cond;
      var $ontrue;
      var $onfalse;
      var $ctx=__stackBase__;
      $2=$parser;
      $3=$block;
      $4=$out;
      $onfalse=0;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=$ctx;
      var $11=$9;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$2;
      var $13=_parser_next($12);
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$2;
      var $16=(($15+4)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17)|0)!=40;
      if ($18) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $20=$2;
      _parseerror($20, ((STRING_TABLE.__str159)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 22; break;
    case 5: 
      var $22=$2;
      var $23=_parser_next($22);
      if ($23) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$2;
      _parseerror($25, ((STRING_TABLE.__str160)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 22; break;
    case 7: 
      var $27=$2;
      var $28=_parse_expression_leave($27, 0);
      $cond=$28;
      var $29=$cond;
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 22; break;
    case 9: 
      var $33=$2;
      var $34=(($33+4)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)!=41;
      if ($36) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $38=$2;
      _parseerror($38, ((STRING_TABLE.__str161)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $39=$cond;
      var $40=$39;
      var $41=$40;
      var $42=(($41+8)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=$cond;
      var $45=$44;
      FUNCTION_TABLE[$43]($45);
      $1=0;
      __label__ = 22; break;
    case 11: 
      var $47=$2;
      var $48=_parser_next($47);
      if ($48) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      var $50=$2;
      _parseerror($50, ((STRING_TABLE.__str162)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $51=$cond;
      var $52=$51;
      var $53=$52;
      var $54=(($53+8)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$cond;
      var $57=$56;
      FUNCTION_TABLE[$55]($57);
      $1=0;
      __label__ = 22; break;
    case 13: 
      var $59=$2;
      var $60=_parse_statement_or_block($59);
      $ontrue=$60;
      var $61=$ontrue;
      var $62=(($61)|0)!=0;
      if ($62) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      var $64=$cond;
      var $65=$64;
      var $66=$65;
      var $67=(($66+8)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$cond;
      var $70=$69;
      FUNCTION_TABLE[$68]($70);
      $1=0;
      __label__ = 22; break;
    case 15: 
      var $72=$2;
      var $73=(($72)|0);
      var $74=HEAP32[(($73)>>2)];
      var $75=(($74+292)|0);
      var $76=(($75+4)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=_strcmp($77, ((STRING_TABLE.__str163)|0));
      var $79=(($78)|0)!=0;
      if ($79) { __label__ = 21; break; } else { __label__ = 16; break; }
    case 16: 
      var $81=$2;
      var $82=_parser_next($81);
      if ($82) { __label__ = 18; break; } else { __label__ = 17; break; }
    case 17: 
      var $84=$2;
      _parseerror($84, ((STRING_TABLE.__str164)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $85=$ontrue;
      var $86=$85;
      var $87=$86;
      var $88=(($87+8)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=$ontrue;
      var $91=$90;
      FUNCTION_TABLE[$89]($91);
      var $92=$cond;
      var $93=$92;
      var $94=$93;
      var $95=(($94+8)|0);
      var $96=HEAP32[(($95)>>2)];
      var $97=$cond;
      var $98=$97;
      FUNCTION_TABLE[$96]($98);
      $1=0;
      __label__ = 22; break;
    case 18: 
      var $100=$2;
      var $101=_parse_statement_or_block($100);
      $onfalse=$101;
      var $102=$onfalse;
      var $103=(($102)|0)!=0;
      if ($103) { __label__ = 20; break; } else { __label__ = 19; break; }
    case 19: 
      var $105=$ontrue;
      var $106=$105;
      var $107=$106;
      var $108=(($107+8)|0);
      var $109=HEAP32[(($108)>>2)];
      var $110=$ontrue;
      var $111=$110;
      FUNCTION_TABLE[$109]($111);
      var $112=$cond;
      var $113=$112;
      var $114=$113;
      var $115=(($114+8)|0);
      var $116=HEAP32[(($115)>>2)];
      var $117=$cond;
      var $118=$117;
      FUNCTION_TABLE[$116]($118);
      $1=0;
      __label__ = 22; break;
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $121=$cond;
      var $122=$ontrue;
      var $123=$onfalse;
      var $124=(($ctx)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=(($ctx+4)|0);
      var $127=HEAP32[(($126)>>2)];
      var $128=_ast_ifthen_new($125, $127, $121, $122, $123);
      $ifthen=$128;
      var $129=$ifthen;
      var $130=$129;
      var $131=$4;
      HEAP32[(($131)>>2)]=$130;
      $1=1;
      __label__ = 22; break;
    case 22: 
      var $133=$1;
      STACKTOP = __stackBase__;
      return $133;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_if["X"]=1;

function _parse_while($parser, $block, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $aloop;
      var $cond;
      var $ontrue;
      var $ctx=__stackBase__;
      $2=$parser;
      $3=$block;
      $4=$out;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=$ctx;
      var $11=$9;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$2;
      var $13=_parser_next($12);
      if ($13) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $15=$2;
      var $16=(($15+4)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=(($17)|0)!=40;
      if ($18) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $20=$2;
      _parseerror($20, ((STRING_TABLE.__str154)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 5: 
      var $22=$2;
      var $23=_parser_next($22);
      if ($23) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $25=$2;
      _parseerror($25, ((STRING_TABLE.__str155)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 16; break;
    case 7: 
      var $27=$2;
      var $28=_parse_expression_leave($27, 0);
      $cond=$28;
      var $29=$cond;
      var $30=(($29)|0)!=0;
      if ($30) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=0;
      __label__ = 16; break;
    case 9: 
      var $33=$2;
      var $34=(($33+4)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35)|0)!=41;
      if ($36) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $38=$2;
      _parseerror($38, ((STRING_TABLE.__str156)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $39=$cond;
      var $40=$39;
      var $41=$40;
      var $42=(($41+8)|0);
      var $43=HEAP32[(($42)>>2)];
      var $44=$cond;
      var $45=$44;
      FUNCTION_TABLE[$43]($45);
      $1=0;
      __label__ = 16; break;
    case 11: 
      var $47=$2;
      var $48=_parser_next($47);
      if ($48) { __label__ = 13; break; } else { __label__ = 12; break; }
    case 12: 
      var $50=$2;
      _parseerror($50, ((STRING_TABLE.__str158)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $51=$cond;
      var $52=$51;
      var $53=$52;
      var $54=(($53+8)|0);
      var $55=HEAP32[(($54)>>2)];
      var $56=$cond;
      var $57=$56;
      FUNCTION_TABLE[$55]($57);
      $1=0;
      __label__ = 16; break;
    case 13: 
      var $59=$2;
      var $60=_parse_statement_or_block($59);
      $ontrue=$60;
      var $61=$ontrue;
      var $62=(($61)|0)!=0;
      if ($62) { __label__ = 15; break; } else { __label__ = 14; break; }
    case 14: 
      var $64=$cond;
      var $65=$64;
      var $66=$65;
      var $67=(($66+8)|0);
      var $68=HEAP32[(($67)>>2)];
      var $69=$cond;
      var $70=$69;
      FUNCTION_TABLE[$68]($70);
      $1=0;
      __label__ = 16; break;
    case 15: 
      var $72=$cond;
      var $73=$ontrue;
      var $74=(($ctx)|0);
      var $75=HEAP32[(($74)>>2)];
      var $76=(($ctx+4)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=_ast_loop_new($75, $77, 0, $72, 0, 0, $73);
      $aloop=$78;
      var $79=$aloop;
      var $80=$79;
      var $81=$4;
      HEAP32[(($81)>>2)]=$80;
      $1=1;
      __label__ = 16; break;
    case 16: 
      var $83=$1;
      STACKTOP = __stackBase__;
      return $83;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_while["X"]=1;

function _parse_dowhile($parser, $block, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $aloop;
      var $cond;
      var $ontrue;
      var $ctx=__stackBase__;
      $2=$parser;
      $3=$block;
      $4=$out;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=$ctx;
      var $11=$9;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$2;
      var $13=_parser_next($12);
      if ($13) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      var $15=$2;
      _parseerror($15, ((STRING_TABLE.__str152724)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      $1=0;
      __label__ = 24; break;
    case 4: 
      var $17=$2;
      var $18=_parse_statement_or_block($17);
      $ontrue=$18;
      var $19=$ontrue;
      var $20=(($19)|0)!=0;
      if ($20) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 24; break;
    case 6: 
      var $23=$2;
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)!=132;
      if ($26) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $28=$2;
      var $29=(($28)|0);
      var $30=HEAP32[(($29)>>2)];
      var $31=(($30+292)|0);
      var $32=(($31+4)|0);
      var $33=HEAP32[(($32)>>2)];
      var $34=_strcmp($33, ((STRING_TABLE.__str138710)|0));
      var $35=(($34)|0)!=0;
      if ($35) { __label__ = 8; break; } else { __label__ = 9; break; }
    case 8: 
      var $37=$2;
      _parseerror($37, ((STRING_TABLE.__str153725)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $38=$ontrue;
      var $39=$38;
      var $40=$39;
      var $41=(($40+8)|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$ontrue;
      var $44=$43;
      FUNCTION_TABLE[$42]($44);
      $1=0;
      __label__ = 24; break;
    case 9: 
      var $46=$2;
      var $47=_parser_next($46);
      if ($47) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $49=$2;
      var $50=(($49+4)|0);
      var $51=HEAP32[(($50)>>2)];
      var $52=(($51)|0)!=40;
      if ($52) { __label__ = 11; break; } else { __label__ = 12; break; }
    case 11: 
      var $54=$2;
      _parseerror($54, ((STRING_TABLE.__str154)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $55=$ontrue;
      var $56=$55;
      var $57=$56;
      var $58=(($57+8)|0);
      var $59=HEAP32[(($58)>>2)];
      var $60=$ontrue;
      var $61=$60;
      FUNCTION_TABLE[$59]($61);
      $1=0;
      __label__ = 24; break;
    case 12: 
      var $63=$2;
      var $64=_parser_next($63);
      if ($64) { __label__ = 14; break; } else { __label__ = 13; break; }
    case 13: 
      var $66=$2;
      _parseerror($66, ((STRING_TABLE.__str155)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $67=$ontrue;
      var $68=$67;
      var $69=$68;
      var $70=(($69+8)|0);
      var $71=HEAP32[(($70)>>2)];
      var $72=$ontrue;
      var $73=$72;
      FUNCTION_TABLE[$71]($73);
      $1=0;
      __label__ = 24; break;
    case 14: 
      var $75=$2;
      var $76=_parse_expression_leave($75, 0);
      $cond=$76;
      var $77=$cond;
      var $78=(($77)|0)!=0;
      if ($78) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      $1=0;
      __label__ = 24; break;
    case 16: 
      var $81=$2;
      var $82=(($81+4)|0);
      var $83=HEAP32[(($82)>>2)];
      var $84=(($83)|0)!=41;
      if ($84) { __label__ = 17; break; } else { __label__ = 18; break; }
    case 17: 
      var $86=$2;
      _parseerror($86, ((STRING_TABLE.__str156)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $87=$ontrue;
      var $88=$87;
      var $89=$88;
      var $90=(($89+8)|0);
      var $91=HEAP32[(($90)>>2)];
      var $92=$ontrue;
      var $93=$92;
      FUNCTION_TABLE[$91]($93);
      var $94=$cond;
      var $95=$94;
      var $96=$95;
      var $97=(($96+8)|0);
      var $98=HEAP32[(($97)>>2)];
      var $99=$cond;
      var $100=$99;
      FUNCTION_TABLE[$98]($100);
      $1=0;
      __label__ = 24; break;
    case 18: 
      var $102=$2;
      var $103=_parser_next($102);
      if ($103) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $105=$2;
      var $106=(($105+4)|0);
      var $107=HEAP32[(($106)>>2)];
      var $108=(($107)|0)!=59;
      if ($108) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      var $110=$2;
      _parseerror($110, ((STRING_TABLE.__str157)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $111=$ontrue;
      var $112=$111;
      var $113=$112;
      var $114=(($113+8)|0);
      var $115=HEAP32[(($114)>>2)];
      var $116=$ontrue;
      var $117=$116;
      FUNCTION_TABLE[$115]($117);
      var $118=$cond;
      var $119=$118;
      var $120=$119;
      var $121=(($120+8)|0);
      var $122=HEAP32[(($121)>>2)];
      var $123=$cond;
      var $124=$123;
      FUNCTION_TABLE[$122]($124);
      $1=0;
      __label__ = 24; break;
    case 21: 
      var $126=$2;
      var $127=_parser_next($126);
      if ($127) { __label__ = 23; break; } else { __label__ = 22; break; }
    case 22: 
      var $129=$2;
      _parseerror($129, ((STRING_TABLE.__str4576)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $130=$ontrue;
      var $131=$130;
      var $132=$131;
      var $133=(($132+8)|0);
      var $134=HEAP32[(($133)>>2)];
      var $135=$ontrue;
      var $136=$135;
      FUNCTION_TABLE[$134]($136);
      var $137=$cond;
      var $138=$137;
      var $139=$138;
      var $140=(($139+8)|0);
      var $141=HEAP32[(($140)>>2)];
      var $142=$cond;
      var $143=$142;
      FUNCTION_TABLE[$141]($143);
      $1=0;
      __label__ = 24; break;
    case 23: 
      var $145=$cond;
      var $146=$ontrue;
      var $147=(($ctx)|0);
      var $148=HEAP32[(($147)>>2)];
      var $149=(($ctx+4)|0);
      var $150=HEAP32[(($149)>>2)];
      var $151=_ast_loop_new($148, $150, 0, 0, $145, 0, $146);
      $aloop=$151;
      var $152=$aloop;
      var $153=$152;
      var $154=$4;
      HEAP32[(($154)>>2)]=$153;
      $1=1;
      __label__ = 24; break;
    case 24: 
      var $156=$1;
      STACKTOP = __stackBase__;
      return $156;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_dowhile["X"]=1;

function _parse_for($parser, $block, $out) {
  var __stackBase__  = STACKTOP; STACKTOP += 8; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $aloop;
      var $initexpr;
      var $cond;
      var $increment;
      var $ontrue;
      var $oldblocklocal;
      var $retval;
      var $ctx=__stackBase__;
      $2=$parser;
      $3=$block;
      $4=$out;
      $retval=1;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=$ctx;
      var $11=$9;
      assert(8 % 1 === 0, 'memcpy given ' + 8 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($10)>>2)]=HEAP32[(($11)>>2)];HEAP32[((($10)+(4))>>2)]=HEAP32[((($11)+(4))>>2)];
      var $12=$2;
      var $13=(($12+112)|0);
      var $14=HEAP32[(($13)>>2)];
      $oldblocklocal=$14;
      var $15=$2;
      var $16=(($15+104)|0);
      var $17=HEAP32[(($16)>>2)];
      var $18=$2;
      var $19=(($18+112)|0);
      HEAP32[(($19)>>2)]=$17;
      $initexpr=0;
      $cond=0;
      $increment=0;
      $ontrue=0;
      var $20=$2;
      var $21=_parser_next($20);
      if ($21) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $23=$2;
      var $24=(($23+4)|0);
      var $25=HEAP32[(($24)>>2)];
      var $26=(($25)|0)!=40;
      if ($26) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $28=$2;
      _parseerror($28, ((STRING_TABLE.__str144716)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 5: 
      var $30=$2;
      var $31=_parser_next($30);
      if ($31) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      var $33=$2;
      _parseerror($33, ((STRING_TABLE.__str145717)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 7: 
      var $35=$2;
      var $36=(($35+4)|0);
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)|0)==130;
      if ($38) { __label__ = 8; break; } else { __label__ = 13; break; }
    case 8: 
      var $40=HEAP32[((_opts_standard)>>2)];
      var $41=(($40)|0)!=3;
      if ($41) { __label__ = 9; break; } else { __label__ = 12; break; }
    case 9: 
      var $43=$2;
      var $44=_parsewarning($43, 4, ((STRING_TABLE.__str146718)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($44) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      __label__ = 52; break;
    case 11: 
      __label__ = 12; break;
    case 12: 
      var $48=$2;
      _parseerror($48, ((STRING_TABLE.__str147719)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 13: 
      var $50=$2;
      var $51=(($50+4)|0);
      var $52=HEAP32[(($51)>>2)];
      var $53=(($52)|0)!=59;
      if ($53) { __label__ = 14; break; } else { __label__ = 17; break; }
    case 14: 
      var $55=$2;
      var $56=_parse_expression_leave($55, 0);
      $initexpr=$56;
      var $57=$initexpr;
      var $58=(($57)|0)!=0;
      if ($58) { __label__ = 16; break; } else { __label__ = 15; break; }
    case 15: 
      __label__ = 52; break;
    case 16: 
      __label__ = 17; break;
    case 17: 
      __label__ = 18; break;
    case 18: 
      var $63=$2;
      var $64=(($63+4)|0);
      var $65=HEAP32[(($64)>>2)];
      var $66=(($65)|0)!=59;
      if ($66) { __label__ = 19; break; } else { __label__ = 20; break; }
    case 19: 
      var $68=$2;
      _parseerror($68, ((STRING_TABLE.__str148720)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 20: 
      var $70=$2;
      var $71=_parser_next($70);
      if ($71) { __label__ = 22; break; } else { __label__ = 21; break; }
    case 21: 
      var $73=$2;
      _parseerror($73, ((STRING_TABLE.__str149721)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 22: 
      var $75=$2;
      var $76=(($75+4)|0);
      var $77=HEAP32[(($76)>>2)];
      var $78=(($77)|0)!=59;
      if ($78) { __label__ = 23; break; } else { __label__ = 26; break; }
    case 23: 
      var $80=$2;
      var $81=_parse_expression_leave($80, 0);
      $cond=$81;
      var $82=$cond;
      var $83=(($82)|0)!=0;
      if ($83) { __label__ = 25; break; } else { __label__ = 24; break; }
    case 24: 
      __label__ = 52; break;
    case 25: 
      __label__ = 26; break;
    case 26: 
      var $87=$2;
      var $88=(($87+4)|0);
      var $89=HEAP32[(($88)>>2)];
      var $90=(($89)|0)!=59;
      if ($90) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      var $92=$2;
      _parseerror($92, ((STRING_TABLE.__str148720)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 28: 
      var $94=$2;
      var $95=_parser_next($94);
      if ($95) { __label__ = 30; break; } else { __label__ = 29; break; }
    case 29: 
      var $97=$2;
      _parseerror($97, ((STRING_TABLE.__str149721)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 30: 
      var $99=$2;
      var $100=(($99+4)|0);
      var $101=HEAP32[(($100)>>2)];
      var $102=(($101)|0)!=41;
      if ($102) { __label__ = 31; break; } else { __label__ = 40; break; }
    case 31: 
      var $104=$2;
      var $105=_parse_expression_leave($104, 0);
      $increment=$105;
      var $106=$increment;
      var $107=(($106)|0)!=0;
      if ($107) { __label__ = 33; break; } else { __label__ = 32; break; }
    case 32: 
      __label__ = 52; break;
    case 33: 
      var $110=$increment;
      var $111=$110;
      var $112=(($111+12)|0);
      var $113=HEAP32[(($112)>>2)];
      var $114=(($113)|0)==6;
      if ($114) { __label__ = 39; break; } else { __label__ = 34; break; }
    case 34: 
      var $116=$increment;
      var $117=$116;
      var $118=(($117+12)|0);
      var $119=HEAP32[(($118)>>2)];
      var $120=(($119)|0)==12;
      if ($120) { __label__ = 39; break; } else { __label__ = 35; break; }
    case 35: 
      var $122=$increment;
      var $123=$122;
      var $124=(($123+12)|0);
      var $125=HEAP32[(($124)>>2)];
      var $126=(($125)|0)==7;
      if ($126) { __label__ = 39; break; } else { __label__ = 36; break; }
    case 36: 
      var $128=$increment;
      var $129=$128;
      var $130=(($129)|0);
      var $131=(($130)|0);
      var $132=HEAP32[(($131)>>2)];
      var $133=(($130+4)|0);
      var $134=HEAP32[(($133)>>2)];
      var $135=_genwarning($132, $134, 14, ((STRING_TABLE.__str143715)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      if ($135) { __label__ = 37; break; } else { __label__ = 38; break; }
    case 37: 
      __label__ = 52; break;
    case 38: 
      __label__ = 39; break;
    case 39: 
      __label__ = 40; break;
    case 40: 
      var $140=$2;
      var $141=(($140+4)|0);
      var $142=HEAP32[(($141)>>2)];
      var $143=(($142)|0)!=41;
      if ($143) { __label__ = 41; break; } else { __label__ = 42; break; }
    case 41: 
      var $145=$2;
      _parseerror($145, ((STRING_TABLE.__str150722)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 42: 
      var $147=$2;
      var $148=_parser_next($147);
      if ($148) { __label__ = 44; break; } else { __label__ = 43; break; }
    case 43: 
      var $150=$2;
      _parseerror($150, ((STRING_TABLE.__str151723)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      __label__ = 52; break;
    case 44: 
      var $152=$2;
      var $153=_parse_statement_or_block($152);
      $ontrue=$153;
      var $154=$ontrue;
      var $155=(($154)|0)!=0;
      if ($155) { __label__ = 46; break; } else { __label__ = 45; break; }
    case 45: 
      __label__ = 52; break;
    case 46: 
      var $158=$initexpr;
      var $159=$cond;
      var $160=$increment;
      var $161=$ontrue;
      var $162=(($ctx)|0);
      var $163=HEAP32[(($162)>>2)];
      var $164=(($ctx+4)|0);
      var $165=HEAP32[(($164)>>2)];
      var $166=_ast_loop_new($163, $165, $158, $159, 0, $160, $161);
      $aloop=$166;
      var $167=$aloop;
      var $168=$167;
      var $169=$4;
      HEAP32[(($169)>>2)]=$168;
      __label__ = 47; break;
    case 47: 
      var $171=$2;
      var $172=(($171+104)|0);
      var $173=HEAP32[(($172)>>2)];
      var $174=$2;
      var $175=(($174+112)|0);
      var $176=HEAP32[(($175)>>2)];
      var $177=(($173)>>>0) > (($176)>>>0);
      if ($177) { __label__ = 48; break; } else { __label__ = 51; break; }
    case 48: 
      var $179=$retval;
      var $180=(($179) & 1);
      if ($180) { __label__ = 49; break; } else { var $185 = 0;__label__ = 50; break; }
    case 49: 
      var $182=$2;
      var $183=_parser_pop_local($182);
      var $185 = $183;__label__ = 50; break;
    case 50: 
      var $185;
      var $186=(($185)&1);
      $retval=$186;
      __label__ = 47; break;
    case 51: 
      var $188=$oldblocklocal;
      var $189=$2;
      var $190=(($189+112)|0);
      HEAP32[(($190)>>2)]=$188;
      var $191=$retval;
      var $192=(($191) & 1);
      $1=$192;
      __label__ = 62; break;
    case 52: 
      var $194=$initexpr;
      var $195=(($194)|0)!=0;
      if ($195) { __label__ = 53; break; } else { __label__ = 54; break; }
    case 53: 
      var $197=$initexpr;
      var $198=$197;
      var $199=$198;
      var $200=(($199+8)|0);
      var $201=HEAP32[(($200)>>2)];
      var $202=$initexpr;
      var $203=$202;
      FUNCTION_TABLE[$201]($203);
      __label__ = 54; break;
    case 54: 
      var $205=$cond;
      var $206=(($205)|0)!=0;
      if ($206) { __label__ = 55; break; } else { __label__ = 56; break; }
    case 55: 
      var $208=$cond;
      var $209=$208;
      var $210=$209;
      var $211=(($210+8)|0);
      var $212=HEAP32[(($211)>>2)];
      var $213=$cond;
      var $214=$213;
      FUNCTION_TABLE[$212]($214);
      __label__ = 56; break;
    case 56: 
      var $216=$increment;
      var $217=(($216)|0)!=0;
      if ($217) { __label__ = 57; break; } else { __label__ = 58; break; }
    case 57: 
      var $219=$increment;
      var $220=$219;
      var $221=$220;
      var $222=(($221+8)|0);
      var $223=HEAP32[(($222)>>2)];
      var $224=$increment;
      var $225=$224;
      FUNCTION_TABLE[$223]($225);
      __label__ = 58; break;
    case 58: 
      __label__ = 59; break;
    case 59: 
      var $228=$2;
      var $229=(($228+104)|0);
      var $230=HEAP32[(($229)>>2)];
      var $231=$2;
      var $232=(($231+112)|0);
      var $233=HEAP32[(($232)>>2)];
      var $234=(($230)>>>0) > (($233)>>>0);
      if ($234) { __label__ = 60; break; } else { __label__ = 61; break; }
    case 60: 
      var $236=$2;
      var $237=_parser_pop_local($236);
      var $238=$237 ^ 1;
      var $239=(($238)&1);
      __label__ = 59; break;
    case 61: 
      var $241=$oldblocklocal;
      var $242=$2;
      var $243=(($242+112)|0);
      HEAP32[(($243)>>2)]=$241;
      $1=0;
      __label__ = 62; break;
    case 62: 
      var $245=$1;
      STACKTOP = __stackBase__;
      return $245;
    default: assert(0, "bad label: " + __label__);
  }
}
_parse_for["X"]=1;

function _parse_block($parser, $warnreturn) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $block;
      $2=$parser;
      var $4=(($warnreturn)&1);
      $3=$4;
      var $5=$2;
      var $6=(($5)|0);
      var $7=HEAP32[(($6)>>2)];
      var $8=(($7+292)|0);
      var $9=(($8+28)|0);
      var $10=(($9)|0);
      var $11=HEAP32[(($10)>>2)];
      var $12=(($9+4)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=_ast_block_new($11, $13);
      $block=$14;
      var $15=$block;
      var $16=(($15)|0)!=0;
      if ($16) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $19=$2;
      var $20=$block;
      var $21=$3;
      var $22=(($21) & 1);
      var $23=_parse_block_into($19, $20, $22);
      if ($23) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      var $25=$block;
      _ast_block_delete($25);
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $27=$block;
      $1=$27;
      __label__ = 7; break;
    case 7: 
      var $29=$1;
      ;
      return $29;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parse_statement_or_block($parser) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $expr=__stackBase__;
      $2=$parser;
      HEAP32[(($expr)>>2)]=0;
      var $3=$2;
      var $4=(($3+4)|0);
      var $5=HEAP32[(($4)>>2)];
      var $6=(($5)|0)==123;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      var $8=$2;
      var $9=_parse_block($8, 0);
      var $10=$9;
      $1=$10;
      __label__ = 7; break;
    case 4: 
      var $12=$2;
      var $13=_parse_statement($12, 0, $expr);
      if ($13) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=0;
      __label__ = 7; break;
    case 6: 
      var $16=HEAP32[(($expr)>>2)];
      $1=$16;
      __label__ = 7; break;
    case 7: 
      var $18=$1;
      STACKTOP = __stackBase__;
      return $18;
    default: assert(0, "bad label: " + __label__);
  }
}


function _parser_find_param($parser, $name) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $i;
      var $fun;
      $2=$parser;
      $3=$name;
      var $4=$2;
      var $5=(($4+96)|0);
      var $6=HEAP32[(($5)>>2)];
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 11; break;
    case 4: 
      var $10=$2;
      var $11=(($10+96)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=(($12+20)|0);
      var $14=HEAP32[(($13)>>2)];
      $fun=$14;
      $i=0;
      __label__ = 5; break;
    case 5: 
      var $16=$i;
      var $17=$fun;
      var $18=(($17)|0);
      var $19=(($18+36)|0);
      var $20=HEAP32[(($19)>>2)];
      var $21=(($16)>>>0) < (($20)>>>0);
      if ($21) { __label__ = 6; break; } else { __label__ = 10; break; }
    case 6: 
      var $23=$i;
      var $24=$fun;
      var $25=(($24)|0);
      var $26=(($25+32)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27+($23<<2))|0);
      var $29=HEAP32[(($28)>>2)];
      var $30=(($29+56)|0);
      var $31=HEAP32[(($30)>>2)];
      var $32=$3;
      var $33=_strcmp($31, $32);
      var $34=(($33)|0)!=0;
      if ($34) { __label__ = 8; break; } else { __label__ = 7; break; }
    case 7: 
      var $36=$i;
      var $37=$fun;
      var $38=(($37)|0);
      var $39=(($38+32)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40+($36<<2))|0);
      var $42=HEAP32[(($41)>>2)];
      var $43=$42;
      $1=$43;
      __label__ = 11; break;
    case 8: 
      __label__ = 9; break;
    case 9: 
      var $46=$i;
      var $47=((($46)+(1))|0);
      $i=$47;
      __label__ = 5; break;
    case 10: 
      $1=0;
      __label__ = 11; break;
    case 11: 
      var $50=$1;
      ;
      return $50;
    default: assert(0, "bad label: " + __label__);
  }
}
_parser_find_param["X"]=1;

function _util_memory_a($byte, $line, $file) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $info;
      var $data;
      $2=$byte;
      $3=$line;
      $4=$file;
      var $5=$2;
      var $6=((($5)+(20))|0);
      var $7=_malloc($6);
      var $8=$7;
      $info=$8;
      var $9=$info;
      var $10=(($9+20)|0);
      var $11=$10;
      $data=$11;
      var $12=$info;
      var $13=(($12)|0)!=0;
      if ($13) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 7; break;
    case 4: 
      var $16=$3;
      var $17=$info;
      var $18=(($17+4)|0);
      HEAP32[(($18)>>2)]=$16;
      var $19=$2;
      var $20=$info;
      var $21=(($20+8)|0);
      HEAP32[(($21)>>2)]=$19;
      var $22=$4;
      var $23=$info;
      var $24=(($23)|0);
      HEAP32[(($24)>>2)]=$22;
      var $25=$info;
      var $26=(($25+16)|0);
      HEAP32[(($26)>>2)]=0;
      var $27=HEAP32[((_mem_start)>>2)];
      var $28=$info;
      var $29=(($28+12)|0);
      HEAP32[(($29)>>2)]=$27;
      var $30=HEAP32[((_mem_start)>>2)];
      var $31=(($30)|0)!=0;
      if ($31) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $33=$info;
      var $34=HEAP32[((_mem_start)>>2)];
      var $35=(($34+16)|0);
      HEAP32[(($35)>>2)]=$33;
      __label__ = 6; break;
    case 6: 
      var $37=$info;
      HEAP32[((_mem_start)>>2)]=$37;
      var $38=$2;
      var $39=$data;
      var $40=$4;
      var $41=$3;
      _util_debug(((STRING_TABLE.__str736)|0), ((STRING_TABLE.__str1737)|0), (tempInt=STACKTOP,STACKTOP += 16,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$38,HEAP32[(((tempInt)+(4))>>2)]=$39,HEAP32[(((tempInt)+(8))>>2)]=$40,HEAP32[(((tempInt)+(12))>>2)]=$41,tempInt));
      var $st$7$0=((_mem_at)|0);
      var $42$0=HEAP32[(($st$7$0)>>2)];
      var $st$7$1=((_mem_at+4)|0);
      var $42$1=HEAP32[(($st$7$1)>>2)];
      var $$emscripten$temp$0$0=1;
      var $$emscripten$temp$0$1=0;
      var $43$0 = (i64Math.add($42$0,$42$1,$$emscripten$temp$0$0,$$emscripten$temp$0$1),i64Math.result[0]); var $43$1 = i64Math.result[1];
      var $st$14$0=((_mem_at)|0);
      HEAP32[(($st$14$0)>>2)]=$43$0;
      var $st$14$1=((_mem_at+4)|0);
      HEAP32[(($st$14$1)>>2)]=$43$1;
      var $44=$info;
      var $45=(($44+8)|0);
      var $46=HEAP32[(($45)>>2)];
      var $47$0=$46;
      var $47$1=0;
      var $st$23$0=((_mem_ab)|0);
      var $48$0=HEAP32[(($st$23$0)>>2)];
      var $st$23$1=((_mem_ab+4)|0);
      var $48$1=HEAP32[(($st$23$1)>>2)];
      var $49$0 = (i64Math.add($48$0,$48$1,$47$0,$47$1),i64Math.result[0]); var $49$1 = i64Math.result[1];
      var $st$28$0=((_mem_ab)|0);
      HEAP32[(($st$28$0)>>2)]=$49$0;
      var $st$28$1=((_mem_ab+4)|0);
      HEAP32[(($st$28$1)>>2)]=$49$1;
      var $50=$data;
      $1=$50;
      __label__ = 7; break;
    case 7: 
      var $52=$1;
      STACKTOP = __stackBase__;
      return $52;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_memory_a["X"]=1;

function _util_debug($area, $ms) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $va=__stackBase__;
      $1=$area;
      $2=$ms;
      var $3=HEAP8[(_opts_debug)];
      var $4=(($3) & 1);
      if ($4) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      __label__ = 8; break;
    case 4: 
      var $7=$1;
      var $8=_strcmp($7, ((STRING_TABLE.__str736)|0));
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 7; break; } else { __label__ = 5; break; }
    case 5: 
      var $11=HEAP8[(_opts_memchk)];
      var $12=(($11) & 1);
      if ($12) { __label__ = 7; break; } else { __label__ = 6; break; }
    case 6: 
      __label__ = 8; break;
    case 7: 
      var $15=$va;
      HEAP32[(($15)>>2)]=arguments[_util_debug.length];
      var $16=HEAP32[((_stdout)>>2)];
      var $17=_fprintf($16, ((STRING_TABLE.__str7743)|0), (tempInt=STACKTOP,STACKTOP += 1,STACKTOP = ((((STACKTOP)+3)>>2)<<2),assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=0,tempInt));
      var $18=HEAP32[((_stdout)>>2)];
      var $19=_fputc(91, $18);
      var $20=HEAP32[((_stdout)>>2)];
      var $21=$1;
      var $22=_fprintf($20, ((STRING_TABLE.__str8744)|0), (tempInt=STACKTOP,STACKTOP += 4,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$21,tempInt));
      var $23=HEAP32[((_stdout)>>2)];
      var $24=_fputs(((STRING_TABLE.__str9745)|0), $23);
      var $25=HEAP32[((_stdout)>>2)];
      var $26=$2;
      var $27=HEAP32[(($va)>>2)];
      var $28=_vfprintf($25, $26, $27);
      var $29=$va;
      ;
      __label__ = 8; break;
    case 8: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}


function _util_endianswap($m, $s, $l) {
  var __stackBase__  = STACKTOP; STACKTOP += 4; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2=__stackBase__;
      var $3;
      var $w;
      var $i;
      var $p;
      var $t;
      $1=$m;
      HEAP32[(($2)>>2)]=$s;
      $3=$l;
      $w=0;
      $i=0;
      var $4=$2;
      var $5=HEAP8[($4)];
      var $6=(($5 << 24) >> 24)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 4; break; }
    case 3: 
      __label__ = 12; break;
    case 4: 
      __label__ = 5; break;
    case 5: 
      var $10=$w;
      var $11=$3;
      var $12=(($10)>>>0) < (($11)>>>0);
      if ($12) { __label__ = 6; break; } else { __label__ = 12; break; }
    case 6: 
      __label__ = 7; break;
    case 7: 
      var $15=$i;
      var $16=HEAP32[(($2)>>2)];
      var $17=$16 << 1;
      var $18=(($15)>>>0) < (($17)>>>0);
      if ($18) { __label__ = 8; break; } else { __label__ = 10; break; }
    case 8: 
      var $20=$1;
      var $21=$w;
      var $22=HEAP32[(($2)>>2)];
      var $23=((($21)*($22))|0);
      var $24=(($20+$23)|0);
      $p=$24;
      var $25=$i;
      var $26=$p;
      var $27=(($26+$25)|0);
      var $28=HEAP8[($27)];
      $t=$28;
      var $29=HEAP32[(($2)>>2)];
      var $30=$i;
      var $31=((($29)-($30))|0);
      var $32=((($31)-(1))|0);
      var $33=$p;
      var $34=(($33+$32)|0);
      var $35=HEAP8[($34)];
      var $36=$i;
      var $37=$p;
      var $38=(($37+$36)|0);
      HEAP8[($38)]=$35;
      var $39=$t;
      var $40=HEAP32[(($2)>>2)];
      var $41=$i;
      var $42=((($40)-($41))|0);
      var $43=((($42)-(1))|0);
      var $44=$p;
      var $45=(($44+$43)|0);
      HEAP8[($45)]=$39;
      __label__ = 9; break;
    case 9: 
      var $47=$i;
      var $48=((($47)+(1))|0);
      $i=$48;
      __label__ = 7; break;
    case 10: 
      __label__ = 11; break;
    case 11: 
      var $51=$w;
      var $52=((($51)+(1))|0);
      $w=$52;
      __label__ = 5; break;
    case 12: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_endianswap["X"]=1;

function _util_crc16($current, $k, $len) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $h;
      $1=$current;
      $2=$k;
      $3=$len;
      var $4=$1;
      $h=$4;
      __label__ = 3; break;
    case 3: 
      var $6=$3;
      var $7=(($6)|0)!=0;
      if ($7) { __label__ = 4; break; } else { __label__ = 6; break; }
    case 4: 
      var $9=$h;
      var $10=(($9)&65535);
      var $11=$10 >> 8;
      var $12=$2;
      var $13=HEAP8[($12)];
      var $14=(($13)&255);
      var $15=$11 ^ $14;
      var $16=((_util_crc16_table+($15<<1))|0);
      var $17=HEAP16[(($16)>>1)];
      var $18=(($17)&65535);
      var $19=$h;
      var $20=(($19)&65535);
      var $21=$20 << 8;
      var $22=$18 ^ $21;
      var $23=(($22) & 65535);
      $h=$23;
      __label__ = 5; break;
    case 5: 
      var $25=$3;
      var $26=((($25)-(1))|0);
      $3=$26;
      var $27=$2;
      var $28=(($27+1)|0);
      $2=$28;
      __label__ = 3; break;
    case 6: 
      var $30=$h;
      ;
      return $30;
    default: assert(0, "bad label: " + __label__);
  }
}


function _util_memory_d($ptrn, $line, $file) {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $info;
      $1=$ptrn;
      $2=$line;
      $3=$file;
      $info=0;
      var $4=$1;
      var $5=(($4)|0)!=0;
      if ($5) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      __label__ = 11; break;
    case 4: 
      var $8=$1;
      var $9=$8;
      var $10=((($9)-(20))|0);
      $info=$10;
      var $11=$info;
      var $12=(($11+8)|0);
      var $13=HEAP32[(($12)>>2)];
      var $14=$1;
      var $15=$3;
      var $16=$2;
      _util_debug(((STRING_TABLE.__str736)|0), ((STRING_TABLE.__str2738)|0), (tempInt=STACKTOP,STACKTOP += 16,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$13,HEAP32[(((tempInt)+(4))>>2)]=$14,HEAP32[(((tempInt)+(8))>>2)]=$15,HEAP32[(((tempInt)+(12))>>2)]=$16,tempInt));
      var $17=$info;
      var $18=(($17+8)|0);
      var $19=HEAP32[(($18)>>2)];
      var $20$0=$19;
      var $20$1=0;
      var $st$16$0=((_mem_db)|0);
      var $21$0=HEAP32[(($st$16$0)>>2)];
      var $st$16$1=((_mem_db+4)|0);
      var $21$1=HEAP32[(($st$16$1)>>2)];
      var $22$0 = (i64Math.add($21$0,$21$1,$20$0,$20$1),i64Math.result[0]); var $22$1 = i64Math.result[1];
      var $st$21$0=((_mem_db)|0);
      HEAP32[(($st$21$0)>>2)]=$22$0;
      var $st$21$1=((_mem_db+4)|0);
      HEAP32[(($st$21$1)>>2)]=$22$1;
      var $st$25$0=((_mem_dt)|0);
      var $23$0=HEAP32[(($st$25$0)>>2)];
      var $st$25$1=((_mem_dt+4)|0);
      var $23$1=HEAP32[(($st$25$1)>>2)];
      var $$emscripten$temp$0$0=1;
      var $$emscripten$temp$0$1=0;
      var $24$0 = (i64Math.add($23$0,$23$1,$$emscripten$temp$0$0,$$emscripten$temp$0$1),i64Math.result[0]); var $24$1 = i64Math.result[1];
      var $st$32$0=((_mem_dt)|0);
      HEAP32[(($st$32$0)>>2)]=$24$0;
      var $st$32$1=((_mem_dt+4)|0);
      HEAP32[(($st$32$1)>>2)]=$24$1;
      var $25=$info;
      var $26=(($25+16)|0);
      var $27=HEAP32[(($26)>>2)];
      var $28=(($27)|0)!=0;
      if ($28) { __label__ = 5; break; } else { __label__ = 6; break; }
    case 5: 
      var $30=$info;
      var $31=(($30+12)|0);
      var $32=HEAP32[(($31)>>2)];
      var $33=$info;
      var $34=(($33+16)|0);
      var $35=HEAP32[(($34)>>2)];
      var $36=(($35+12)|0);
      HEAP32[(($36)>>2)]=$32;
      __label__ = 6; break;
    case 6: 
      var $38=$info;
      var $39=(($38+12)|0);
      var $40=HEAP32[(($39)>>2)];
      var $41=(($40)|0)!=0;
      if ($41) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $43=$info;
      var $44=(($43+16)|0);
      var $45=HEAP32[(($44)>>2)];
      var $46=$info;
      var $47=(($46+12)|0);
      var $48=HEAP32[(($47)>>2)];
      var $49=(($48+16)|0);
      HEAP32[(($49)>>2)]=$45;
      __label__ = 8; break;
    case 8: 
      var $51=$info;
      var $52=HEAP32[((_mem_start)>>2)];
      var $53=(($51)|0)==(($52)|0);
      if ($53) { __label__ = 9; break; } else { __label__ = 10; break; }
    case 9: 
      var $55=$info;
      var $56=(($55+12)|0);
      var $57=HEAP32[(($56)>>2)];
      HEAP32[((_mem_start)>>2)]=$57;
      __label__ = 10; break;
    case 10: 
      var $59=$info;
      var $60=$59;
      _free($60);
      __label__ = 11; break;
    case 11: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_memory_d["X"]=1;

function _util_meminfo() {
  var __stackBase__  = STACKTOP; assert(STACKTOP % 4 == 0, "Stack is unaligned"); assert(STACKTOP < STACK_MAX, "Ran out of stack");
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $info;
      var $1=HEAP8[(_opts_memchk)];
      var $2=(($1) & 1);
      if ($2) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      __label__ = 9; break;
    case 4: 
      var $5=HEAP32[((_mem_start)>>2)];
      $info=$5;
      __label__ = 5; break;
    case 5: 
      var $7=$info;
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 6; break; } else { __label__ = 8; break; }
    case 6: 
      var $10=$info;
      var $11=(($10+8)|0);
      var $12=HEAP32[(($11)>>2)];
      var $13=$info;
      var $14=(($13)|0);
      var $15=HEAP32[(($14)>>2)];
      var $16=$info;
      var $17=(($16+4)|0);
      var $18=HEAP32[(($17)>>2)];
      _util_debug(((STRING_TABLE.__str736)|0), ((STRING_TABLE.__str4740)|0), (tempInt=STACKTOP,STACKTOP += 12,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$12,HEAP32[(((tempInt)+(4))>>2)]=$15,HEAP32[(((tempInt)+(8))>>2)]=$18,tempInt));
      __label__ = 7; break;
    case 7: 
      var $20=$info;
      var $21=(($20+12)|0);
      var $22=HEAP32[(($21)>>2)];
      $info=$22;
      __label__ = 5; break;
    case 8: 
      var $st$0$0=((_mem_at)|0);
      var $24$0=HEAP32[(($st$0$0)>>2)];
      var $st$0$1=((_mem_at+4)|0);
      var $24$1=HEAP32[(($st$0$1)>>2)];
      var $st$4$0=((_mem_dt)|0);
      var $25$0=HEAP32[(($st$4$0)>>2)];
      var $st$4$1=((_mem_dt+4)|0);
      var $25$1=HEAP32[(($st$4$1)>>2)];
      var $st$8$0=((_mem_ab)|0);
      var $26$0=HEAP32[(($st$8$0)>>2)];
      var $st$8$1=((_mem_ab+4)|0);
      var $26$1=HEAP32[(($st$8$1)>>2)];
      var $st$12$0=((_mem_db)|0);
      var $27$0=HEAP32[(($st$12$0)>>2)];
      var $st$12$1=((_mem_db+4)|0);
      var $27$1=HEAP32[(($st$12$1)>>2)];
      var $st$16$0=((_mem_ab)|0);
      var $28$0=HEAP32[(($st$16$0)>>2)];
      var $st$16$1=((_mem_ab+4)|0);
      var $28$1=HEAP32[(($st$16$1)>>2)];
      var $st$20$0=((_mem_db)|0);
      var $29$0=HEAP32[(($st$20$0)>>2)];
      var $st$20$1=((_mem_db+4)|0);
      var $29$1=HEAP32[(($st$20$1)>>2)];
      var $30$0 = (i64Math.subtract($28$0,$28$1,$29$0,$29$1),i64Math.result[0]); var $30$1 = i64Math.result[1];
      var $st$25$0=((_mem_at)|0);
      var $31$0=HEAP32[(($st$25$0)>>2)];
      var $st$25$1=((_mem_at+4)|0);
      var $31$1=HEAP32[(($st$25$1)>>2)];
      var $st$29$0=((_mem_dt)|0);
      var $32$0=HEAP32[(($st$29$0)>>2)];
      var $st$29$1=((_mem_dt+4)|0);
      var $32$1=HEAP32[(($st$29$1)>>2)];
      var $33$0 = (i64Math.subtract($31$0,$31$1,$32$0,$32$1),i64Math.result[0]); var $33$1 = i64Math.result[1];
      var $$emscripten$temp$1=((STRING_TABLE.__str5741)|0);
      var $$emscripten$temp$0=((STRING_TABLE.__str736)|0);
      _util_debug($$emscripten$temp$0, $$emscripten$temp$1, (tempInt=STACKTOP,STACKTOP += 48,assert(STACKTOP < STACK_ROOT + STACK_MAX, "Ran out of stack"),HEAP32[((tempInt)>>2)]=$24$0,HEAP32[(((tempInt)+(4))>>2)]=$24$1,HEAP32[(((tempInt)+(8))>>2)]=$25$0,HEAP32[(((tempInt)+(12))>>2)]=$25$1,HEAP32[(((tempInt)+(16))>>2)]=$26$0,HEAP32[(((tempInt)+(20))>>2)]=$26$1,HEAP32[(((tempInt)+(24))>>2)]=$27$0,HEAP32[(((tempInt)+(28))>>2)]=$27$1,HEAP32[(((tempInt)+(32))>>2)]=$30$0,HEAP32[(((tempInt)+(36))>>2)]=$30$1,HEAP32[(((tempInt)+(40))>>2)]=$33$0,HEAP32[(((tempInt)+(44))>>2)]=$33$1,tempInt));
      __label__ = 9; break;
    case 9: 
      STACKTOP = __stackBase__;
      return;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_meminfo["X"]=1;

function _util_strdup($s) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $len;
      var $ptr;
      $2=$s;
      $len=0;
      $ptr=0;
      var $3=$2;
      var $4=(($3)|0)!=0;
      if ($4) { __label__ = 4; break; } else { __label__ = 3; break; }
    case 3: 
      $1=0;
      __label__ = 8; break;
    case 4: 
      var $7=$2;
      var $8=_strlen($7);
      $len=$8;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 5; break; } else { __label__ = 7; break; }
    case 5: 
      var $11=$len;
      var $12=((($11)+(1))|0);
      var $13=_util_memory_a($12, 161, ((STRING_TABLE.__str6742)|0));
      $ptr=$13;
      var $14=(($13)|0)!=0;
      if ($14) { __label__ = 6; break; } else { __label__ = 7; break; }
    case 6: 
      var $16=$ptr;
      var $17=$2;
      var $18=$len;
      assert($18 % 1 === 0, 'memcpy given ' + $18 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($16, $17, $18, 1);
      var $19=$len;
      var $20=$ptr;
      var $21=(($20+$19)|0);
      HEAP8[($21)]=0;
      __label__ = 7; break;
    case 7: 
      var $23=$ptr;
      $1=$23;
      __label__ = 8; break;
    case 8: 
      var $25=$1;
      ;
      return $25;
    default: assert(0, "bad label: " + __label__);
  }
}


function _util_getline($lineptr, $n, $stream) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $chr;
      var $ret;
      var $pos;
      var $c;
      var $tmp;
      $2=$lineptr;
      $3=$n;
      $4=$stream;
      var $5=$2;
      var $6=(($5)|0)!=0;
      if ($6) { __label__ = 3; break; } else { __label__ = 5; break; }
    case 3: 
      var $8=$3;
      var $9=(($8)|0)!=0;
      if ($9) { __label__ = 4; break; } else { __label__ = 5; break; }
    case 4: 
      var $11=$4;
      var $12=(($11)|0)!=0;
      if ($12) { __label__ = 6; break; } else { __label__ = 5; break; }
    case 5: 
      $1=-1;
      __label__ = 30; break;
    case 6: 
      var $15=$2;
      var $16=HEAP32[(($15)>>2)];
      var $17=(($16)|0)!=0;
      if ($17) { __label__ = 10; break; } else { __label__ = 7; break; }
    case 7: 
      var $19=$3;
      HEAP32[(($19)>>2)]=64;
      var $20=_util_memory_a(64, 435, ((STRING_TABLE.__str6742)|0));
      var $21=$2;
      HEAP32[(($21)>>2)]=$20;
      var $22=(($20)|0)!=0;
      if ($22) { __label__ = 9; break; } else { __label__ = 8; break; }
    case 8: 
      $1=-1;
      __label__ = 30; break;
    case 9: 
      __label__ = 10; break;
    case 10: 
      var $26=$3;
      var $27=HEAP32[(($26)>>2)];
      $chr=$27;
      var $28=$2;
      var $29=HEAP32[(($28)>>2)];
      $pos=$29;
      __label__ = 11; break;
    case 11: 
      var $31=$4;
      var $32=_getc($31);
      $c=$32;
      var $33=$chr;
      var $34=(($33)|0) < 2;
      if ($34) { __label__ = 12; break; } else { __label__ = 20; break; }
    case 12: 
      var $36=$3;
      var $37=HEAP32[(($36)>>2)];
      var $38=(($37)>>>0) > 16;
      if ($38) { __label__ = 13; break; } else { __label__ = 14; break; }
    case 13: 
      var $40=$3;
      var $41=HEAP32[(($40)>>2)];
      var $44 = $41;__label__ = 15; break;
    case 14: 
      var $44 = 64;__label__ = 15; break;
    case 15: 
      var $44;
      var $45=$3;
      var $46=HEAP32[(($45)>>2)];
      var $47=((($46)+($44))|0);
      HEAP32[(($45)>>2)]=$47;
      var $48=_util_memory_a($47, 446, ((STRING_TABLE.__str6742)|0));
      $tmp=$48;
      var $49=$tmp;
      var $50=(($49)|0)!=0;
      if ($50) { __label__ = 17; break; } else { __label__ = 16; break; }
    case 16: 
      $1=-1;
      __label__ = 30; break;
    case 17: 
      var $53=$tmp;
      var $54=$2;
      var $55=HEAP32[(($54)>>2)];
      var $56=$pos;
      var $57=$2;
      var $58=HEAP32[(($57)>>2)];
      var $59=$56;
      var $60=$58;
      var $61=((($59)-($60))|0);
      assert($61 % 1 === 0, 'memcpy given ' + $61 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');_memcpy($53, $55, $61, 1);
      var $62=$3;
      var $63=HEAP32[(($62)>>2)];
      var $64=$2;
      var $65=HEAP32[(($64)>>2)];
      var $66=(($65+$63)|0);
      var $67=$pos;
      var $68=$66;
      var $69=$67;
      var $70=((($68)-($69))|0);
      $chr=$70;
      var $71=$tmp;
      var $72=$2;
      HEAP32[(($72)>>2)]=$71;
      var $73=(($71)|0)!=0;
      if ($73) { __label__ = 19; break; } else { __label__ = 18; break; }
    case 18: 
      var $75=$tmp;
      _util_memory_d($75, 453, ((STRING_TABLE.__str6742)|0));
      $1=-1;
      __label__ = 30; break;
    case 19: 
      var $77=$3;
      var $78=HEAP32[(($77)>>2)];
      var $79=$chr;
      var $80=((($78)-($79))|0);
      var $81=$2;
      var $82=HEAP32[(($81)>>2)];
      var $83=(($82+$80)|0);
      $pos=$83;
      __label__ = 20; break;
    case 20: 
      var $85=$4;
      var $86=_ferror($85);
      var $87=(($86)|0)!=0;
      if ($87) { __label__ = 21; break; } else { __label__ = 22; break; }
    case 21: 
      $1=-1;
      __label__ = 30; break;
    case 22: 
      var $90=$c;
      var $91=(($90)|0)==-1;
      if ($91) { __label__ = 23; break; } else { __label__ = 26; break; }
    case 23: 
      var $93=$pos;
      var $94=$2;
      var $95=HEAP32[(($94)>>2)];
      var $96=(($93)|0)==(($95)|0);
      if ($96) { __label__ = 24; break; } else { __label__ = 25; break; }
    case 24: 
      $1=-1;
      __label__ = 30; break;
    case 25: 
      __label__ = 29; break;
    case 26: 
      var $100=$c;
      var $101=(($100) & 255);
      var $102=$pos;
      var $103=(($102+1)|0);
      $pos=$103;
      HEAP8[($102)]=$101;
      var $104=$chr;
      var $105=((($104)-(1))|0);
      $chr=$105;
      var $106=$c;
      var $107=(($106)|0)==10;
      if ($107) { __label__ = 27; break; } else { __label__ = 28; break; }
    case 27: 
      __label__ = 29; break;
    case 28: 
      __label__ = 11; break;
    case 29: 
      var $111=$pos;
      HEAP8[($111)]=0;
      var $112=$pos;
      var $113=$2;
      var $114=HEAP32[(($113)>>2)];
      var $115=$112;
      var $116=$114;
      var $117=((($115)-($116))|0);
      $ret=$117;
      $1=$117;
      __label__ = 30; break;
    case 30: 
      var $119=$1;
      ;
      return $119;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_getline["X"]=1;

function _util_strtocmd($in, $out, $outsz) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $sz;
      $1=$in;
      $2=$out;
      $3=$outsz;
      $sz=1;
      __label__ = 3; break;
    case 3: 
      var $5=$1;
      var $6=HEAP8[($5)];
      var $7=(($6 << 24) >> 24);
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { var $14 = 0;__label__ = 5; break; }
    case 4: 
      var $10=$sz;
      var $11=$3;
      var $12=(($10)>>>0) < (($11)>>>0);
      var $14 = $12;__label__ = 5; break;
    case 5: 
      var $14;
      if ($14) { __label__ = 6; break; } else { __label__ = 15; break; }
    case 6: 
      var $16=$1;
      var $17=HEAP8[($16)];
      var $18=(($17 << 24) >> 24);
      var $19=(($18)|0)==45;
      if ($19) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $21=$2;
      HEAP8[($21)]=95;
      __label__ = 13; break;
    case 8: 
      var $23=$1;
      var $24=HEAP8[($23)];
      var $25=(($24 << 24) >> 24);
      var $26=_isalpha($25);
      var $27=(($26)|0)!=0;
      if ($27) { __label__ = 9; break; } else { __label__ = 11; break; }
    case 9: 
      var $29=$1;
      var $30=HEAP8[($29)];
      var $31=(($30 << 24) >> 24);
      var $32=_isupper($31);
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 11; break; } else { __label__ = 10; break; }
    case 10: 
      var $35=$1;
      var $36=HEAP8[($35)];
      var $37=(($36 << 24) >> 24);
      var $38=((($37)+(65))|0);
      var $39=((($38)-(97))|0);
      var $40=(($39) & 255);
      var $41=$2;
      HEAP8[($41)]=$40;
      __label__ = 12; break;
    case 11: 
      var $43=$1;
      var $44=HEAP8[($43)];
      var $45=$2;
      HEAP8[($45)]=$44;
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $49=$1;
      var $50=(($49+1)|0);
      $1=$50;
      var $51=$2;
      var $52=(($51+1)|0);
      $2=$52;
      var $53=$sz;
      var $54=((($53)+(1))|0);
      $sz=$54;
      __label__ = 3; break;
    case 15: 
      var $56=$2;
      HEAP8[($56)]=0;
      var $57=$sz;
      var $58=((($57)-(1))|0);
      ;
      return $58;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_strtocmd["X"]=1;

function _util_strtononcmd($in, $out, $outsz) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $sz;
      $1=$in;
      $2=$out;
      $3=$outsz;
      $sz=1;
      __label__ = 3; break;
    case 3: 
      var $5=$1;
      var $6=HEAP8[($5)];
      var $7=(($6 << 24) >> 24);
      var $8=(($7)|0)!=0;
      if ($8) { __label__ = 4; break; } else { var $14 = 0;__label__ = 5; break; }
    case 4: 
      var $10=$sz;
      var $11=$3;
      var $12=(($10)>>>0) < (($11)>>>0);
      var $14 = $12;__label__ = 5; break;
    case 5: 
      var $14;
      if ($14) { __label__ = 6; break; } else { __label__ = 15; break; }
    case 6: 
      var $16=$1;
      var $17=HEAP8[($16)];
      var $18=(($17 << 24) >> 24);
      var $19=(($18)|0)==95;
      if ($19) { __label__ = 7; break; } else { __label__ = 8; break; }
    case 7: 
      var $21=$2;
      HEAP8[($21)]=45;
      __label__ = 13; break;
    case 8: 
      var $23=$1;
      var $24=HEAP8[($23)];
      var $25=(($24 << 24) >> 24);
      var $26=_isalpha($25);
      var $27=(($26)|0)!=0;
      if ($27) { __label__ = 9; break; } else { __label__ = 11; break; }
    case 9: 
      var $29=$1;
      var $30=HEAP8[($29)];
      var $31=(($30 << 24) >> 24);
      var $32=_isupper($31);
      var $33=(($32)|0)!=0;
      if ($33) { __label__ = 10; break; } else { __label__ = 11; break; }
    case 10: 
      var $35=$1;
      var $36=HEAP8[($35)];
      var $37=(($36 << 24) >> 24);
      var $38=((($37)+(97))|0);
      var $39=((($38)-(65))|0);
      var $40=(($39) & 255);
      var $41=$2;
      HEAP8[($41)]=$40;
      __label__ = 12; break;
    case 11: 
      var $43=$1;
      var $44=HEAP8[($43)];
      var $45=$2;
      HEAP8[($45)]=$44;
      __label__ = 12; break;
    case 12: 
      __label__ = 13; break;
    case 13: 
      __label__ = 14; break;
    case 14: 
      var $49=$1;
      var $50=(($49+1)|0);
      $1=$50;
      var $51=$2;
      var $52=(($51+1)|0);
      $2=$52;
      var $53=$sz;
      var $54=((($53)+(1))|0);
      $sz=$54;
      __label__ = 3; break;
    case 15: 
      var $56=$2;
      HEAP8[($56)]=0;
      var $57=$sz;
      var $58=((($57)-(1))|0);
      ;
      return $58;
    default: assert(0, "bad label: " + __label__);
  }
}
_util_strtononcmd["X"]=1;

function _util_fopen($filename, $mode) {
  ;
  var __label__;

  var $1;
  var $2;
  $1=$filename;
  $2=$mode;
  var $3=$1;
  var $4=$2;
  var $5=_fopen($3, $4);
  ;
  return $5;
}


function _malloc($bytes) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $mem;
      var $nb;
      var $idx;
      var $smallbits;
      var $b;
      var $p;
      var $F;
      var $b1;
      var $p2;
      var $r;
      var $rsize;
      var $i;
      var $leftbits;
      var $leastbit;
      var $Y;
      var $K;
      var $N;
      var $F3;
      var $DVS;
      var $DV;
      var $I;
      var $B;
      var $F4;
      var $rsize5;
      var $p6;
      var $r7;
      var $dvs;
      var $rsize8;
      var $p9;
      var $r10;
      $1=$bytes;
      var $2=$1; //@line 4629 "/root/emscripten/system/lib/dlmalloc.c"
      var $3=(($2)>>>0) <= 244; //@line 4629 "/root/emscripten/system/lib/dlmalloc.c"
      if ($3) { __label__ = 3; break; } else { __label__ = 38; break; } //@line 4629 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $5=$1; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=(($5)>>>0) < 11; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      if ($6) { __label__ = 4; break; } else { __label__ = 5; break; } //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $14 = 16;__label__ = 6; break; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $9=$1; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=((($9)+(4))|0); //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=((($10)+(7))|0); //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=$11 & -8; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $14 = $12;__label__ = 6; break; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $14; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      $nb=$14; //@line 4632 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$nb; //@line 4633 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$15 >>> 3; //@line 4633 "/root/emscripten/system/lib/dlmalloc.c"
      $idx=$16; //@line 4633 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=HEAP32[((((__gm_)|0))>>2)]; //@line 4634 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=$idx; //@line 4634 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=$17 >>> (($18)>>>0); //@line 4634 "/root/emscripten/system/lib/dlmalloc.c"
      $smallbits=$19; //@line 4634 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$smallbits; //@line 4636 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=$20 & 3; //@line 4636 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=(($21)|0)!=0; //@line 4636 "/root/emscripten/system/lib/dlmalloc.c"
      if ($22) { __label__ = 7; break; } else { __label__ = 14; break; } //@line 4636 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $24=$smallbits; //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$24 ^ -1; //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$25 & 1; //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$idx; //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=((($27)+($26))|0); //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      $idx=$28; //@line 4638 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=$idx; //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$29 << 1; //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=((((__gm_+40)|0)+($30<<2))|0); //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=$31; //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$32; //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      $b=$33; //@line 4639 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=$b; //@line 4640 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=(($34+8)|0); //@line 4640 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=HEAP32[(($35)>>2)]; //@line 4640 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$36; //@line 4640 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$p; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=(($37+8)|0); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=HEAP32[(($38)>>2)]; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$39; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$b; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$F; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=(($40)|0)==(($41)|0); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      if ($42) { __label__ = 8; break; } else { __label__ = 9; break; } //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $44=$idx; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=1 << $44; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=$45 ^ -1; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=HEAP32[((((__gm_)|0))>>2)]; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=$47 & $46; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$48; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 13; break; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $50=$F; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=$50; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=(($51)>>>0) >= (($52)>>>0); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=(($53)&1); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=(($54)==(1)); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=(($55)|0)!=0; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      if ($56) { __label__ = 10; break; } else { __label__ = 11; break; } //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $58=$F; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=$b; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=(($59+8)|0); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($60)>>2)]=$58; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=$b; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=$F; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=(($62+12)|0); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($63)>>2)]=$61; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 12; break; //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      _abort(); //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4642 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      __label__ = 13; break;
    case 13: 
      var $67=$idx; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=$67 << 3; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=$68 | 1; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=$69 | 2; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=$p; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=(($71+4)|0); //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($72)>>2)]=$70; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=$p; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=$73; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=$idx; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=$75 << 3; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=(($74+$76)|0); //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=$77; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=(($78+4)|0); //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=HEAP32[(($79)>>2)]; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=$80 | 1; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($79)>>2)]=$81; //@line 4643 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=$p; //@line 4644 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=$82; //@line 4644 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=(($83+8)|0); //@line 4644 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$84; //@line 4644 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 54; break; //@line 4646 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $86=$nb; //@line 4649 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4649 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=(($86)>>>0) > (($87)>>>0); //@line 4649 "/root/emscripten/system/lib/dlmalloc.c"
      if ($88) { __label__ = 15; break; } else { __label__ = 36; break; } //@line 4649 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $90=$smallbits; //@line 4650 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=(($90)|0)!=0; //@line 4650 "/root/emscripten/system/lib/dlmalloc.c"
      if ($91) { __label__ = 16; break; } else { __label__ = 31; break; } //@line 4650 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      var $93=$smallbits; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=$idx; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=$93 << $94; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $96=$idx; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $97=1 << $96; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=$97 << 1; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=$idx; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=1 << $99; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$100 << 1; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=(((-$101))|0); //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=$98 | $102; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=$95 & $103; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      $leftbits=$104; //@line 4654 "/root/emscripten/system/lib/dlmalloc.c"
      var $105=$leftbits; //@line 4655 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=$leftbits; //@line 4655 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=(((-$106))|0); //@line 4655 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=$105 & $107; //@line 4655 "/root/emscripten/system/lib/dlmalloc.c"
      $leastbit=$108; //@line 4655 "/root/emscripten/system/lib/dlmalloc.c"
      var $109=$leastbit; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $110=((($109)-(1))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$110; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=$111 >>> 12; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=$112 & 16; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$113; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$114; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=$116 >>> (($115)>>>0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$117; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $119=$118 >>> 5; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=$119 & 8; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$120; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=$N; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=((($121)+($120))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$122; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $123=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $124=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=$124 >>> (($123)>>>0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$125; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=$126 >>> 2; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=$127 & 4; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$128; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=$N; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=((($129)+($128))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$130; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $132=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=$132 >>> (($131)>>>0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$133; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=$134 >>> 1; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=$135 & 2; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$136; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=$N; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=((($137)+($136))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$138; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $140=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=$140 >>> (($139)>>>0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$141; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=$142 >>> 1; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=$143 & 1; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$144; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=$N; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=((($145)+($144))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$146; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=$K; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $149=$148 >>> (($147)>>>0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$149; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $150=$N; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=$Y; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=((($150)+($151))|0); //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      $i=$152; //@line 4656 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=$i; //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=$153 << 1; //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=((((__gm_+40)|0)+($154<<2))|0); //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=$155; //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=$156; //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      $b1=$157; //@line 4657 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=$b1; //@line 4658 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=(($158+8)|0); //@line 4658 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=HEAP32[(($159)>>2)]; //@line 4658 "/root/emscripten/system/lib/dlmalloc.c"
      $p2=$160; //@line 4658 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=$p2; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=(($161+8)|0); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=HEAP32[(($162)>>2)]; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      $F3=$163; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $164=$b1; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=$F3; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $166=(($164)|0)==(($165)|0); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      if ($166) { __label__ = 17; break; } else { __label__ = 18; break; } //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $168=$i; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=1 << $168; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=$169 ^ -1; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $171=HEAP32[((((__gm_)|0))>>2)]; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=$171 & $170; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$172; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 22; break; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $174=$F3; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $175=$174; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $177=(($175)>>>0) >= (($176)>>>0); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $178=(($177)&1); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $179=(($178)==(1)); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $180=(($179)|0)!=0; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      if ($180) { __label__ = 19; break; } else { __label__ = 20; break; } //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $182=$F3; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=$b1; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=(($183+8)|0); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($184)>>2)]=$182; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $185=$b1; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=$F3; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      var $187=(($186+12)|0); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($187)>>2)]=$185; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 21; break; //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      _abort(); //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4660 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      __label__ = 22; break;
    case 22: 
      var $191=$i; //@line 4661 "/root/emscripten/system/lib/dlmalloc.c"
      var $192=$191 << 3; //@line 4661 "/root/emscripten/system/lib/dlmalloc.c"
      var $193=$nb; //@line 4661 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=((($192)-($193))|0); //@line 4661 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$194; //@line 4661 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=$nb; //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=$195 | 1; //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      var $197=$196 | 2; //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      var $198=$p2; //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=(($198+4)|0); //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($199)>>2)]=$197; //@line 4666 "/root/emscripten/system/lib/dlmalloc.c"
      var $200=$p2; //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      var $201=$200; //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      var $202=$nb; //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      var $203=(($201+$202)|0); //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=$203; //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      $r=$204; //@line 4667 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=$rsize; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=$205 | 1; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=$r; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=(($207+4)|0); //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($208)>>2)]=$206; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=$rsize; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=$r; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=$210; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=$rsize; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $213=(($211+$212)|0); //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $214=$213; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $215=(($214)|0); //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($215)>>2)]=$209; //@line 4668 "/root/emscripten/system/lib/dlmalloc.c"
      var $216=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $DVS=$216; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $217=$DVS; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $218=(($217)|0)!=0; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      if ($218) { __label__ = 23; break; } else { __label__ = 30; break; } //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      var $220=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $DV=$220; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=$DVS; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=$221 >>> 3; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$222; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=$I; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=$223 << 1; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $225=((((__gm_+40)|0)+($224<<2))|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=$225; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=$226; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$227; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=$B; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $F4=$228; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=HEAP32[((((__gm_)|0))>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=$I; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=1 << $230; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $232=$229 & $231; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $233=(($232)|0)!=0; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      if ($233) { __label__ = 25; break; } else { __label__ = 24; break; } //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $235=$I; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=1 << $235; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=HEAP32[((((__gm_)|0))>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=$237 | $236; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$238; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 29; break; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $240=$B; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $241=(($240+8)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $242=HEAP32[(($241)>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=$242; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=(($243)>>>0) >= (($244)>>>0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=(($245)&1); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=(($246)==(1)); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($247)|0)!=0; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      if ($248) { __label__ = 26; break; } else { __label__ = 27; break; } //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $250=$B; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=(($250+8)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $252=HEAP32[(($251)>>2)]; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      $F4=$252; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 28; break; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      _abort(); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      __label__ = 29; break;
    case 29: 
      var $256=$DV; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $257=$B; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=(($257+8)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($258)>>2)]=$256; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=$DV; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=$F4; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=(($260+12)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($261)>>2)]=$259; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $262=$F4; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=$DV; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=(($263+8)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($264)>>2)]=$262; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=$B; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $266=$DV; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $267=(($266+12)|0); //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($267)>>2)]=$265; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 30; break; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $269=$rsize; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=$269; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $270=$r; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+20)|0))>>2)]=$270; //@line 4669 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=$p2; //@line 4671 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=$271; //@line 4671 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=(($272+8)|0); //@line 4671 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$273; //@line 4671 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 54; break; //@line 4673 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $275=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($275)|0)!=0; //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      if ($276) { __label__ = 32; break; } else { __label__ = 34; break; } //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $278=$nb; //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=_tmalloc_small(__gm_, $278); //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$279; //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=(($279)|0)!=0; //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
      if ($280) { __label__ = 33; break; } else { __label__ = 34; break; } //@line 4676 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      __label__ = 54; break; //@line 4678 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      __label__ = 35; break;
    case 35: 
      __label__ = 36; break; //@line 4680 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      __label__ = 37; break;
    case 37: 
      __label__ = 45; break; //@line 4681 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $287=$1; //@line 4682 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=(($287)>>>0) >= 4294967232; //@line 4682 "/root/emscripten/system/lib/dlmalloc.c"
      if ($288) { __label__ = 39; break; } else { __label__ = 40; break; } //@line 4682 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      $nb=-1; //@line 4683 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 44; break; //@line 4683 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      var $291=$1; //@line 4685 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=((($291)+(4))|0); //@line 4685 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=((($292)+(7))|0); //@line 4685 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=$293 & -8; //@line 4685 "/root/emscripten/system/lib/dlmalloc.c"
      $nb=$294; //@line 4685 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=(($295)|0)!=0; //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      if ($296) { __label__ = 41; break; } else { __label__ = 43; break; } //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
    case 41: 
      var $298=$nb; //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      var $299=_tmalloc_large(__gm_, $298); //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$299; //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      var $300=(($299)|0)!=0; //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
      if ($300) { __label__ = 42; break; } else { __label__ = 43; break; } //@line 4686 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      __label__ = 54; break; //@line 4688 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      __label__ = 44; break;
    case 44: 
      __label__ = 45; break;
    case 45: 
      var $305=$nb; //@line 4692 "/root/emscripten/system/lib/dlmalloc.c"
      var $306=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4692 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=(($305)>>>0) <= (($306)>>>0); //@line 4692 "/root/emscripten/system/lib/dlmalloc.c"
      if ($307) { __label__ = 46; break; } else { __label__ = 50; break; } //@line 4692 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $309=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4693 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=$nb; //@line 4693 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=((($309)-($310))|0); //@line 4693 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize5=$311; //@line 4693 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4694 "/root/emscripten/system/lib/dlmalloc.c"
      $p6=$312; //@line 4694 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=$rsize5; //@line 4695 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=(($313)>>>0) >= 16; //@line 4695 "/root/emscripten/system/lib/dlmalloc.c"
      if ($314) { __label__ = 47; break; } else { __label__ = 48; break; } //@line 4695 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      var $316=$p6; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=$316; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=$nb; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      var $319=(($317+$318)|0); //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=$319; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+20)|0))>>2)]=$320; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      $r7=$320; //@line 4696 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=$rsize5; //@line 4697 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=$321; //@line 4697 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=$rsize5; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=$322 | 1; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=$r7; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=(($324+4)|0); //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($325)>>2)]=$323; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=$rsize5; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $327=$r7; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $328=$327; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $329=$rsize5; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $330=(($328+$329)|0); //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $331=$330; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $332=(($331)|0); //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($332)>>2)]=$326; //@line 4698 "/root/emscripten/system/lib/dlmalloc.c"
      var $333=$nb; //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      var $334=$333 | 1; //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=$334 | 2; //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=$p6; //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      var $337=(($336+4)|0); //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($337)>>2)]=$335; //@line 4699 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 49; break; //@line 4700 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      var $339=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4702 "/root/emscripten/system/lib/dlmalloc.c"
      $dvs=$339; //@line 4702 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=0; //@line 4703 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+20)|0))>>2)]=0; //@line 4704 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=$dvs; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=$340 | 1; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=$341 | 2; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $343=$p6; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $344=(($343+4)|0); //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($344)>>2)]=$342; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=$p6; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=$345; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=$dvs; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=(($346+$347)|0); //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=$348; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=(($349+4)|0); //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=HEAP32[(($350)>>2)]; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=$351 | 1; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($350)>>2)]=$352; //@line 4705 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 49; break;
    case 49: 
      var $354=$p6; //@line 4707 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=$354; //@line 4707 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=(($355+8)|0); //@line 4707 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$356; //@line 4707 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 54; break; //@line 4709 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      var $358=$nb; //@line 4712 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=HEAP32[((((__gm_+12)|0))>>2)]; //@line 4712 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=(($358)>>>0) < (($359)>>>0); //@line 4712 "/root/emscripten/system/lib/dlmalloc.c"
      if ($360) { __label__ = 51; break; } else { __label__ = 52; break; } //@line 4712 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      var $362=$nb; //@line 4713 "/root/emscripten/system/lib/dlmalloc.c"
      var $363=HEAP32[((((__gm_+12)|0))>>2)]; //@line 4713 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=((($363)-($362))|0); //@line 4713 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+12)|0))>>2)]=$364; //@line 4713 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize8=$364; //@line 4713 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=HEAP32[((((__gm_+24)|0))>>2)]; //@line 4714 "/root/emscripten/system/lib/dlmalloc.c"
      $p9=$365; //@line 4714 "/root/emscripten/system/lib/dlmalloc.c"
      var $366=$p9; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=$366; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$nb; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=(($367+$368)|0); //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=$369; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+24)|0))>>2)]=$370; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      $r10=$370; //@line 4715 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=$rsize8; //@line 4716 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=$371 | 1; //@line 4716 "/root/emscripten/system/lib/dlmalloc.c"
      var $373=$r10; //@line 4716 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=(($373+4)|0); //@line 4716 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($374)>>2)]=$372; //@line 4716 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=$nb; //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=$375 | 1; //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      var $377=$376 | 2; //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      var $378=$p9; //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      var $379=(($378+4)|0); //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($379)>>2)]=$377; //@line 4717 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=$p9; //@line 4718 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=$380; //@line 4718 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=(($381+8)|0); //@line 4718 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$382; //@line 4718 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 54; break; //@line 4721 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      __label__ = 53; break;
    case 53: 
      var $385=$nb; //@line 4724 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=_sys_alloc(__gm_, $385); //@line 4724 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$386; //@line 4724 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 54; break; //@line 4724 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      var $388=$mem; //@line 4728 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $388; //@line 4728 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
Module["_malloc"] = _malloc;_malloc["X"]=1;

function _tmalloc_small($m, $nb) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $t;
      var $v;
      var $rsize;
      var $i;
      var $leastbit;
      var $Y;
      var $K;
      var $N;
      var $trem;
      var $r;
      var $XP;
      var $R;
      var $F;
      var $RP;
      var $CP;
      var $H;
      var $C0;
      var $C1;
      var $DVS;
      var $DV;
      var $I;
      var $B;
      var $F1;
      $1=$m;
      $2=$nb;
      var $3=$1; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=(($3+4)|0); //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=HEAP32[(($4)>>2)]; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=$1; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=(($6+4)|0); //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=HEAP32[(($7)>>2)]; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(((-$8))|0); //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=$5 & $9; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      $leastbit=$10; //@line 4269 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=$leastbit; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=((($11)-(1))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$12; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=$13 >>> 12; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$14 & 16; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$15; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$16; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=$18 >>> (($17)>>>0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$19; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=$20 >>> 5; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=$21 & 8; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$22; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$N; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=((($23)+($22))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$24; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$26 >>> (($25)>>>0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$27; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=$28 >>> 2; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$29 & 4; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$30; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=$N; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=((($31)+($30))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$32; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=$34 >>> (($33)>>>0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$35; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$36 >>> 1; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=$37 & 2; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$38; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=$N; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=((($39)+($38))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$40; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$42 >>> (($41)>>>0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$43; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$44 >>> 1; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=$45 & 1; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$46; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=$N; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=((($47)+($46))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$48; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=$K; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=$50 >>> (($49)>>>0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$51; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=$N; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=$Y; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=((($52)+($53))|0); //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      $i=$54; //@line 4270 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=$i; //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$1; //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56+304)|0); //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=(($57+($55<<2))|0); //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=HEAP32[(($58)>>2)]; //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$59; //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      $v=$59; //@line 4271 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=$t; //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=(($60+4)|0); //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=HEAP32[(($61)>>2)]; //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$62 & -8; //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=$2; //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=((($63)-($64))|0); //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$65; //@line 4272 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $67=$t; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=(($67+16)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=(($68)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=HEAP32[(($69)>>2)]; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=(($70)|0)!=0; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      if ($71) { __label__ = 4; break; } else { __label__ = 5; break; } //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $73=$t; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=(($73+16)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=(($74)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=HEAP32[(($75)>>2)]; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $83 = $76;__label__ = 6; break; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $78=$t; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=(($78+16)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=(($79+4)|0); //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=HEAP32[(($80)>>2)]; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $83 = $81;__label__ = 6; break; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $83; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$83; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=(($83)|0)!=0; //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
      if ($84) { __label__ = 7; break; } else { __label__ = 10; break; } //@line 4274 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $86=$t; //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=(($86+4)|0); //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=HEAP32[(($87)>>2)]; //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=$88 & -8; //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=$2; //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=((($89)-($90))|0); //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      $trem=$91; //@line 4275 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=$trem; //@line 4276 "/root/emscripten/system/lib/dlmalloc.c"
      var $93=$rsize; //@line 4276 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=(($92)>>>0) < (($93)>>>0); //@line 4276 "/root/emscripten/system/lib/dlmalloc.c"
      if ($94) { __label__ = 8; break; } else { __label__ = 9; break; } //@line 4276 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $96=$trem; //@line 4277 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$96; //@line 4277 "/root/emscripten/system/lib/dlmalloc.c"
      var $97=$t; //@line 4278 "/root/emscripten/system/lib/dlmalloc.c"
      $v=$97; //@line 4278 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 9; break; //@line 4279 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      __label__ = 3; break; //@line 4280 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $100=$v; //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$100; //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=$1; //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=(($102+16)|0); //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=HEAP32[(($103)>>2)]; //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $105=(($101)>>>0) >= (($104)>>>0); //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=(($105)&1); //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=(($106)==(1)); //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=(($107)|0)!=0; //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
      if ($108) { __label__ = 11; break; } else { __label__ = 70; break; } //@line 4282 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $110=$v; //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=$110; //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=$2; //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=(($111+$112)|0); //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=$113; //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      $r=$114; //@line 4283 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=$v; //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=$115; //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=$r; //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=$117; //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $119=(($116)>>>0) < (($118)>>>0); //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=(($119)&1); //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=(($120)==(1)); //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=(($121)|0)!=0; //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
      if ($122) { __label__ = 12; break; } else { __label__ = 69; break; } //@line 4285 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $124=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=(($124+24)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=HEAP32[(($125)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $XP=$126; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=(($127+12)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=HEAP32[(($128)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=(($129)|0)!=(($130)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($131) { __label__ = 13; break; } else { __label__ = 17; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $133=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=(($133+8)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=HEAP32[(($134)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$135; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=(($136+12)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=HEAP32[(($137)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$138; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=$F; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $140=$139; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=(($141+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=HEAP32[(($142)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=(($140)>>>0) >= (($143)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=(($144)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=(($145)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=(($146)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($147) { __label__ = 14; break; } else { __label__ = 15; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $149=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $150=$F; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=(($150+12)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($151)>>2)]=$149; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=$F; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=(($153+8)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($154)>>2)]=$152; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 16; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      __label__ = 29; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $158=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=(($158+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=(($159+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$160; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=HEAP32[(($160)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$161; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=(($161)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($162) { __label__ = 19; break; } else { __label__ = 18; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $164=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=(($164+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $166=(($165)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$166; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $167=HEAP32[(($166)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$167; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=(($167)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($168) { __label__ = 19; break; } else { __label__ = 28; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      __label__ = 20; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      var $171=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=(($171+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $173=(($172+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$173; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $174=HEAP32[(($173)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $175=(($174)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($175) { var $183 = 1;__label__ = 22; break; } else { __label__ = 21; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      var $177=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $178=(($177+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $179=(($178)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$179; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $180=HEAP32[(($179)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $181=(($180)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $183 = $181;__label__ = 22; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      var $183;
      if ($183) { __label__ = 23; break; } else { __label__ = 24; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      var $185=$CP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$185; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=HEAP32[(($185)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$186; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 20; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $188=$RP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=$188; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $190=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $191=(($190+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $192=HEAP32[(($191)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $193=(($189)>>>0) >= (($192)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=(($193)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=(($194)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=(($195)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($196) { __label__ = 25; break; } else { __label__ = 26; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $198=$RP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($198)>>2)]=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 27; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      __label__ = 28; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      __label__ = 29; break;
    case 29: 
      var $203=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=(($203)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($204) { __label__ = 30; break; } else { __label__ = 57; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $206=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=(($206+28)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=HEAP32[(($207)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=(($209+304)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=(($210+($208<<2))|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$211; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $213=$H; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $214=HEAP32[(($213)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $215=(($212)|0)==(($214)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($215) { __label__ = 31; break; } else { __label__ = 34; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $217=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $218=$H; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($218)>>2)]=$217; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $219=(($217)|0)==0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($219) { __label__ = 32; break; } else { __label__ = 33; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $221=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=(($221+28)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=HEAP32[(($222)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=1 << $223; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $225=$224 ^ -1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=(($226+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=HEAP32[(($227)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=$228 & $225; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($227)>>2)]=$229; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 33; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      __label__ = 41; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $232=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $233=$232; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $235=(($234+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=HEAP32[(($235)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=(($233)>>>0) >= (($236)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=(($237)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $239=(($238)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $240=(($239)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($240) { __label__ = 35; break; } else { __label__ = 39; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $242=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=(($242+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=(($243)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=HEAP32[(($244)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=(($245)|0)==(($246)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($247) { __label__ = 36; break; } else { __label__ = 37; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $249=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=(($250+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $252=(($251)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($252)>>2)]=$249; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 38; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $254=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $255=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $256=(($255+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $257=(($256+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($257)>>2)]=$254; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 38; break;
    case 38: 
      __label__ = 40; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      __label__ = 41; break;
    case 41: 
      var $262=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=(($262)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($263) { __label__ = 42; break; } else { __label__ = 56; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      var $265=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $266=$265; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $267=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $268=(($267+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $269=HEAP32[(($268)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $270=(($266)>>>0) >= (($269)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=(($270)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=(($271)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=(($272)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($273) { __label__ = 43; break; } else { __label__ = 54; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      var $275=$XP; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $277=(($276+24)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($277)>>2)]=$275; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $278=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=(($278+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=(($279)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $281=HEAP32[(($280)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $C0=$281; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=(($281)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($282) { __label__ = 44; break; } else { __label__ = 48; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      var $284=$C0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=$284; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=(($286+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=HEAP32[(($287)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $289=(($285)>>>0) >= (($288)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $290=(($289)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $291=(($290)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=(($291)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($292) { __label__ = 45; break; } else { __label__ = 46; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      var $294=$C0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=(($295+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=(($296)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($297)>>2)]=$294; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $298=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $299=$C0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $300=(($299+24)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($300)>>2)]=$298; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 47; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      __label__ = 48; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      var $304=$v; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $305=(($304+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $306=(($305+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=HEAP32[(($306)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      $C1=$307; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $308=(($307)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($308) { __label__ = 49; break; } else { __label__ = 53; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $310=$C1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=$310; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=$1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=(($312+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=HEAP32[(($313)>>2)]; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=(($311)>>>0) >= (($314)>>>0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=(($315)&1); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=(($316)==(1)); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=(($317)|0)!=0; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      if ($318) { __label__ = 50; break; } else { __label__ = 51; break; } //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      var $320=$C1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=(($321+16)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=(($322+4)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($323)>>2)]=$320; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=$R; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=$C1; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=(($325+24)|0); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($326)>>2)]=$324; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 52; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      __label__ = 53; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 53: 
      __label__ = 55; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      _abort(); //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 55: 
      __label__ = 56; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      __label__ = 57; break; //@line 4286 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      var $334=$rsize; //@line 4287 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=(($334)>>>0) < 16; //@line 4287 "/root/emscripten/system/lib/dlmalloc.c"
      if ($335) { __label__ = 58; break; } else { __label__ = 59; break; } //@line 4287 "/root/emscripten/system/lib/dlmalloc.c"
    case 58: 
      var $337=$rsize; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $338=$2; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=((($337)+($338))|0); //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=$339 | 1; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=$340 | 2; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=$v; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $343=(($342+4)|0); //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($343)>>2)]=$341; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $344=$v; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=$344; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=$rsize; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=$2; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=((($346)+($347))|0); //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=(($345+$348)|0); //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=$349; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=(($350+4)|0); //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=HEAP32[(($351)>>2)]; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      var $353=$352 | 1; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($351)>>2)]=$353; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 68; break; //@line 4288 "/root/emscripten/system/lib/dlmalloc.c"
    case 59: 
      var $355=$2; //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=$355 | 1; //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      var $357=$356 | 2; //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=$v; //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=(($358+4)|0); //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($359)>>2)]=$357; //@line 4290 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=$rsize; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=$360 | 1; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $362=$r; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $363=(($362+4)|0); //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($363)>>2)]=$361; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=$rsize; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=$r; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $366=$365; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=$rsize; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=(($366+$367)|0); //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=$368; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=(($369)|0); //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($370)>>2)]=$364; //@line 4291 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=(($371+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $373=HEAP32[(($372)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $DVS=$373; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=$DVS; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=(($374)|0)!=0; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      if ($375) { __label__ = 60; break; } else { __label__ = 67; break; } //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      var $377=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $378=(($377+20)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $379=HEAP32[(($378)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $DV=$379; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=$DVS; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=$380 >>> 3; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$381; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=$I; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $383=$382 << 1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $384=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=(($384+40)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=(($385+($383<<2))|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=$386; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $388=$387; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$388; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $389=$B; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $F1=$389; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $391=(($390)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $392=HEAP32[(($391)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $393=$I; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=1 << $393; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=$392 & $394; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $396=(($395)|0)!=0; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      if ($396) { __label__ = 62; break; } else { __label__ = 61; break; } //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      var $398=$I; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $399=1 << $398; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $400=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $401=(($400)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $402=HEAP32[(($401)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $403=$402 | $399; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($401)>>2)]=$403; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 66; break; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      var $405=$B; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $406=(($405+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $407=HEAP32[(($406)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $408=$407; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $409=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $410=(($409+16)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $411=HEAP32[(($410)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $412=(($408)>>>0) >= (($411)>>>0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $413=(($412)&1); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=(($413)==(1)); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=(($414)|0)!=0; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      if ($415) { __label__ = 63; break; } else { __label__ = 64; break; } //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 63: 
      var $417=$B; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $418=(($417+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $419=HEAP32[(($418)>>2)]; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      $F1=$419; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 65; break; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 64: 
      _abort(); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 65: 
      __label__ = 66; break;
    case 66: 
      var $423=$DV; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=$B; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=(($424+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($425)>>2)]=$423; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $426=$DV; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $427=$F1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=(($427+12)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($428)>>2)]=$426; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=$F1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $430=$DV; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $431=(($430+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($431)>>2)]=$429; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $432=$B; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $433=$DV; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=(($433+12)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($434)>>2)]=$432; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 67; break; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
    case 67: 
      var $436=$rsize; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $437=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=(($437+8)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($438)>>2)]=$436; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $439=$r; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $440=$1; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=(($440+20)|0); //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($441)>>2)]=$439; //@line 4292 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 68; break;
    case 68: 
      var $443=$v; //@line 4294 "/root/emscripten/system/lib/dlmalloc.c"
      var $444=$443; //@line 4294 "/root/emscripten/system/lib/dlmalloc.c"
      var $445=(($444+8)|0); //@line 4294 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $445; //@line 4294 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      __label__ = 70; break; //@line 4296 "/root/emscripten/system/lib/dlmalloc.c"
    case 70: 
      _abort(); //@line 4298 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4298 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_tmalloc_small["X"]=1;

function _tmalloc_large($m, $nb) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $v;
      var $rsize;
      var $t;
      var $idx;
      var $X;
      var $Y;
      var $N;
      var $K;
      var $sizebits;
      var $rst;
      var $rt;
      var $trem;
      var $leftbits;
      var $i;
      var $leastbit;
      var $Y1;
      var $K2;
      var $N3;
      var $trem4;
      var $r;
      var $XP;
      var $R;
      var $F;
      var $RP;
      var $CP;
      var $H;
      var $C0;
      var $C1;
      var $I;
      var $B;
      var $F5;
      var $TP;
      var $H6;
      var $I7;
      var $X8;
      var $Y9;
      var $N10;
      var $K11;
      var $T;
      var $K12;
      var $C;
      var $F13;
      $2=$m;
      $3=$nb;
      $v=0; //@line 4195 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=$3; //@line 4196 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=(((-$4))|0); //@line 4196 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$5; //@line 4196 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=$3; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=$6 >>> 8; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $X=$7; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$X; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(($8)|0)==0; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; } //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      $idx=0; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 8; break; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $12=$X; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=(($12)>>>0) > 65535; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      if ($13) { __label__ = 5; break; } else { __label__ = 6; break; } //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      $idx=31; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 7; break; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $16=$X; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$16; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=$Y; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=((($17)-(256))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=$18 >>> 16; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$19 & 8; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$20; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=$N; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=$Y; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$22 << $21; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$23; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=((($23)-(4096))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$24 >>> 16; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$25 & 4; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$26; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$K; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$N; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=((($28)+($27))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$29; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$K; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=$Y; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=$31 << $30; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$32; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=((($32)-(16384))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=$33 >>> 16; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=$34 & 2; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$35; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$N; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=((($36)+($35))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$37; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=$N; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=(((14)-($38))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$K; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$Y; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$41 << $40; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$42; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$42 >>> 15; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=((($39)+($43))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$44; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$K; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=$45 << 1; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=$3; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=$K; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=((($48)+(7))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$47 >>> (($49)>>>0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=$50 & 1; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=((($46)+($51))|0); //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      $idx=$52; //@line 4199 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 7; break;
    case 7: 
      __label__ = 8; break;
    case 8: 
      var $55=$idx; //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$2; //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56+304)|0); //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=(($57+($55<<2))|0); //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=HEAP32[(($58)>>2)]; //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$59; //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=(($59)|0)!=0; //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
      if ($60) { __label__ = 9; break; } else { __label__ = 24; break; } //@line 4200 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $62=$3; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$idx; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=(($63)|0)==31; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      if ($64) { __label__ = 10; break; } else { __label__ = 11; break; } //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $73 = 0;__label__ = 12; break; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $67=$idx; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=$67 >>> 1; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=((($68)+(8))|0); //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=((($69)-(2))|0); //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=(((31)-($70))|0); //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $73 = $71;__label__ = 12; break; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $73; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=$62 << $73; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      $sizebits=$74; //@line 4202 "/root/emscripten/system/lib/dlmalloc.c"
      $rst=0; //@line 4203 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 13; break; //@line 4204 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $76=$t; //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=(($76+4)|0); //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=HEAP32[(($77)>>2)]; //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=$78 & -8; //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=$3; //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=((($79)-($80))|0); //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      $trem=$81; //@line 4206 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=$trem; //@line 4207 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=$rsize; //@line 4207 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=(($82)>>>0) < (($83)>>>0); //@line 4207 "/root/emscripten/system/lib/dlmalloc.c"
      if ($84) { __label__ = 14; break; } else { __label__ = 17; break; } //@line 4207 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $86=$t; //@line 4208 "/root/emscripten/system/lib/dlmalloc.c"
      $v=$86; //@line 4208 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=$trem; //@line 4209 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$87; //@line 4209 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=(($87)|0)==0; //@line 4209 "/root/emscripten/system/lib/dlmalloc.c"
      if ($88) { __label__ = 15; break; } else { __label__ = 16; break; } //@line 4209 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      __label__ = 23; break; //@line 4210 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      __label__ = 17; break; //@line 4211 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $92=$t; //@line 4212 "/root/emscripten/system/lib/dlmalloc.c"
      var $93=(($92+16)|0); //@line 4212 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=(($93+4)|0); //@line 4212 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=HEAP32[(($94)>>2)]; //@line 4212 "/root/emscripten/system/lib/dlmalloc.c"
      $rt=$95; //@line 4212 "/root/emscripten/system/lib/dlmalloc.c"
      var $96=$sizebits; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $97=$96 >>> 31; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=$97 & 1; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=$t; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=(($99+16)|0); //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=(($100+($98<<2))|0); //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=HEAP32[(($101)>>2)]; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$102; //@line 4213 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=$rt; //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=(($103)|0)!=0; //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
      if ($104) { __label__ = 18; break; } else { __label__ = 20; break; } //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $106=$rt; //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=$t; //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=(($106)|0)!=(($107)|0); //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
      if ($108) { __label__ = 19; break; } else { __label__ = 20; break; } //@line 4214 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $110=$rt; //@line 4215 "/root/emscripten/system/lib/dlmalloc.c"
      $rst=$110; //@line 4215 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 20; break; //@line 4215 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      var $112=$t; //@line 4216 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=(($112)|0)==0; //@line 4216 "/root/emscripten/system/lib/dlmalloc.c"
      if ($113) { __label__ = 21; break; } else { __label__ = 22; break; } //@line 4216 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      var $115=$rst; //@line 4217 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$115; //@line 4217 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 23; break; //@line 4218 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      var $117=$sizebits; //@line 4220 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=$117 << 1; //@line 4220 "/root/emscripten/system/lib/dlmalloc.c"
      $sizebits=$118; //@line 4220 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 13; break; //@line 4221 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      __label__ = 24; break; //@line 4222 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $121=$t; //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=(($121)|0)==0; //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
      if ($122) { __label__ = 25; break; } else { __label__ = 29; break; } //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $124=$v; //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=(($124)|0)==0; //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
      if ($125) { __label__ = 26; break; } else { __label__ = 29; break; } //@line 4223 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $127=$idx; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=1 << $127; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=$128 << 1; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=$idx; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=1 << $130; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $132=$131 << 1; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=(((-$132))|0); //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=$129 | $133; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=$2; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=(($135+4)|0); //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=HEAP32[(($136)>>2)]; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=$134 & $137; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      $leftbits=$138; //@line 4224 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=$leftbits; //@line 4225 "/root/emscripten/system/lib/dlmalloc.c"
      var $140=(($139)|0)!=0; //@line 4225 "/root/emscripten/system/lib/dlmalloc.c"
      if ($140) { __label__ = 27; break; } else { __label__ = 28; break; } //@line 4225 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      var $142=$leftbits; //@line 4227 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=$leftbits; //@line 4227 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=(((-$143))|0); //@line 4227 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=$142 & $144; //@line 4227 "/root/emscripten/system/lib/dlmalloc.c"
      $leastbit=$145; //@line 4227 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=$leastbit; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=((($146)-(1))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$147; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $149=$148 >>> 12; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $150=$149 & 16; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$150; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $N3=$151; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=$153 >>> (($152)>>>0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$154; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=$155 >>> 5; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=$156 & 8; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$157; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=$N3; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=((($158)+($157))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $N3=$159; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=$161 >>> (($160)>>>0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$162; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $164=$163 >>> 2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=$164 & 4; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$165; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $166=$N3; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $167=((($166)+($165))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $N3=$167; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=$169 >>> (($168)>>>0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$170; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $171=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=$171 >>> 1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $173=$172 & 2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$173; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $174=$N3; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $175=((($174)+($173))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $N3=$175; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $177=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $178=$177 >>> (($176)>>>0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$178; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $179=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $180=$179 >>> 1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $181=$180 & 1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$181; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $182=$N3; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=((($182)+($181))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $N3=$183; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=$K2; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $185=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=$185 >>> (($184)>>>0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $Y1=$186; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $187=$N3; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $188=$Y1; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=((($187)+($188))|0); //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      $i=$189; //@line 4228 "/root/emscripten/system/lib/dlmalloc.c"
      var $190=$i; //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      var $191=$2; //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      var $192=(($191+304)|0); //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      var $193=(($192+($190<<2))|0); //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=HEAP32[(($193)>>2)]; //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$194; //@line 4229 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 28; break; //@line 4230 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      __label__ = 29; break; //@line 4231 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      __label__ = 30; break; //@line 4233 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $198=$t; //@line 4233 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=(($198)|0)!=0; //@line 4233 "/root/emscripten/system/lib/dlmalloc.c"
      if ($199) { __label__ = 31; break; } else { __label__ = 37; break; } //@line 4233 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $201=$t; //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $202=(($201+4)|0); //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $203=HEAP32[(($202)>>2)]; //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=$203 & -8; //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=$3; //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=((($204)-($205))|0); //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      $trem4=$206; //@line 4234 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=$trem4; //@line 4235 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=$rsize; //@line 4235 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=(($207)>>>0) < (($208)>>>0); //@line 4235 "/root/emscripten/system/lib/dlmalloc.c"
      if ($209) { __label__ = 32; break; } else { __label__ = 33; break; } //@line 4235 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $211=$trem4; //@line 4236 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$211; //@line 4236 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=$t; //@line 4237 "/root/emscripten/system/lib/dlmalloc.c"
      $v=$212; //@line 4237 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 33; break; //@line 4238 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      var $214=$t; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $215=(($214+16)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $216=(($215)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $217=HEAP32[(($216)>>2)]; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $218=(($217)|0)!=0; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      if ($218) { __label__ = 34; break; } else { __label__ = 35; break; } //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $220=$t; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=(($220+16)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=(($221)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=HEAP32[(($222)>>2)]; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $230 = $223;__label__ = 36; break; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $225=$t; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=(($225+16)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=(($226+4)|0); //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=HEAP32[(($227)>>2)]; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      var $230 = $228;__label__ = 36; break; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $230; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      $t=$230; //@line 4239 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 30; break; //@line 4240 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $232=$v; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $233=(($232)|0)!=0; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      if ($233) { __label__ = 38; break; } else { __label__ = 127; break; } //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $235=$rsize; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=$2; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=(($236+8)|0); //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=HEAP32[(($237)>>2)]; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $239=$3; //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $240=((($238)-($239))|0); //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      var $241=(($235)>>>0) < (($240)>>>0); //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
      if ($241) { __label__ = 39; break; } else { __label__ = 127; break; } //@line 4243 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      var $243=$v; //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=$243; //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=$2; //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=(($245+16)|0); //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=HEAP32[(($246)>>2)]; //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($244)>>>0) >= (($247)>>>0); //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $249=(($248)&1); //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=(($249)==(1)); //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=(($250)|0)!=0; //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
      if ($251) { __label__ = 40; break; } else { __label__ = 126; break; } //@line 4244 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      var $253=$v; //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      var $254=$253; //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      var $255=$3; //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      var $256=(($254+$255)|0); //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      var $257=$256; //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      $r=$257; //@line 4245 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=$v; //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=$258; //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=$r; //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=$260; //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $262=(($259)>>>0) < (($261)>>>0); //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=(($262)&1); //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=(($263)==(1)); //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=(($264)|0)!=0; //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
      if ($265) { __label__ = 41; break; } else { __label__ = 125; break; } //@line 4247 "/root/emscripten/system/lib/dlmalloc.c"
    case 41: 
      var $267=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $268=(($267+24)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $269=HEAP32[(($268)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $XP=$269; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $270=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=(($270+12)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=HEAP32[(($271)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $274=(($272)|0)!=(($273)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($274) { __label__ = 42; break; } else { __label__ = 46; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      var $276=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $277=(($276+8)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $278=HEAP32[(($277)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$278; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=(($279+12)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $281=HEAP32[(($280)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$281; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=$F; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=$282; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=(($284+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=HEAP32[(($285)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=(($283)>>>0) >= (($286)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=(($287)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $289=(($288)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $290=(($289)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($290) { __label__ = 43; break; } else { __label__ = 44; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      var $292=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=$F; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=(($293+12)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($294)>>2)]=$292; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=$F; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=(($296+8)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($297)>>2)]=$295; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 45; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      __label__ = 58; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $301=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $302=(($301+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $303=(($302+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$303; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $304=HEAP32[(($303)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$304; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $305=(($304)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($305) { __label__ = 48; break; } else { __label__ = 47; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      var $307=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $308=(($307+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $309=(($308)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$309; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=HEAP32[(($309)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$310; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=(($310)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($311) { __label__ = 48; break; } else { __label__ = 57; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      __label__ = 49; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $314=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=(($314+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=(($315+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$316; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=HEAP32[(($316)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=(($317)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($318) { var $326 = 1;__label__ = 51; break; } else { __label__ = 50; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      var $320=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=(($320+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=(($321)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$322; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=HEAP32[(($322)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=(($323)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $326 = $324;__label__ = 51; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      var $326;
      if ($326) { __label__ = 52; break; } else { __label__ = 53; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      var $328=$CP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$328; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $329=HEAP32[(($328)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$329; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 49; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 53: 
      var $331=$RP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $332=$331; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $333=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $334=(($333+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=HEAP32[(($334)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=(($332)>>>0) >= (($335)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $337=(($336)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $338=(($337)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=(($338)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($339) { __label__ = 54; break; } else { __label__ = 55; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      var $341=$RP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($341)>>2)]=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 56; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 55: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      __label__ = 57; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      __label__ = 58; break;
    case 58: 
      var $346=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=(($346)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($347) { __label__ = 59; break; } else { __label__ = 86; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 59: 
      var $349=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=(($349+28)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=HEAP32[(($350)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $353=(($352+304)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $354=(($353+($351<<2))|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$354; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=$H; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $357=HEAP32[(($356)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=(($355)|0)==(($357)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($358) { __label__ = 60; break; } else { __label__ = 63; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      var $360=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=$H; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($361)>>2)]=$360; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $362=(($360)|0)==0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($362) { __label__ = 61; break; } else { __label__ = 62; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      var $364=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=(($364+28)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $366=HEAP32[(($365)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=1 << $366; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$367 ^ -1; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=(($369+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=HEAP32[(($370)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=$371 & $368; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($370)>>2)]=$372; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 62; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      __label__ = 70; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 63: 
      var $375=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=$375; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $377=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $378=(($377+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $379=HEAP32[(($378)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=(($376)>>>0) >= (($379)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=(($380)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=(($381)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $383=(($382)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($383) { __label__ = 64; break; } else { __label__ = 68; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 64: 
      var $385=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=(($385+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=(($386)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $388=HEAP32[(($387)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $389=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=(($388)|0)==(($389)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($390) { __label__ = 65; break; } else { __label__ = 66; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 65: 
      var $392=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $393=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=(($393+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=(($394)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($395)>>2)]=$392; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 67; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 66: 
      var $397=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $398=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $399=(($398+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $400=(($399+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($400)>>2)]=$397; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 67; break;
    case 67: 
      __label__ = 69; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 68: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      __label__ = 70; break;
    case 70: 
      var $405=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $406=(($405)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($406) { __label__ = 71; break; } else { __label__ = 85; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 71: 
      var $408=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $409=$408; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $410=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $411=(($410+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $412=HEAP32[(($411)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $413=(($409)>>>0) >= (($412)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=(($413)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=(($414)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $416=(($415)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($416) { __label__ = 72; break; } else { __label__ = 83; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 72: 
      var $418=$XP; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $419=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $420=(($419+24)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($420)>>2)]=$418; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $421=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $422=(($421+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $423=(($422)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=HEAP32[(($423)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $C0=$424; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=(($424)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($425) { __label__ = 73; break; } else { __label__ = 77; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 73: 
      var $427=$C0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=$427; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $430=(($429+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $431=HEAP32[(($430)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $432=(($428)>>>0) >= (($431)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $433=(($432)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=(($433)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $435=(($434)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($435) { __label__ = 74; break; } else { __label__ = 75; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 74: 
      var $437=$C0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $439=(($438+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $440=(($439)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($440)>>2)]=$437; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $442=$C0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $443=(($442+24)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($443)>>2)]=$441; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 76; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 75: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 76: 
      __label__ = 77; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 77: 
      var $447=$v; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $448=(($447+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $449=(($448+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $450=HEAP32[(($449)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      $C1=$450; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $451=(($450)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($451) { __label__ = 78; break; } else { __label__ = 82; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 78: 
      var $453=$C1; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $454=$453; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $455=$2; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $456=(($455+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $457=HEAP32[(($456)>>2)]; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $458=(($454)>>>0) >= (($457)>>>0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $459=(($458)&1); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $460=(($459)==(1)); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $461=(($460)|0)!=0; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      if ($461) { __label__ = 79; break; } else { __label__ = 80; break; } //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 79: 
      var $463=$C1; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $464=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $465=(($464+16)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $466=(($465+4)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($466)>>2)]=$463; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $467=$R; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $468=$C1; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      var $469=(($468+24)|0); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($469)>>2)]=$467; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 81; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 80: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 81: 
      __label__ = 82; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 82: 
      __label__ = 84; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 83: 
      _abort(); //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 84: 
      __label__ = 85; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 85: 
      __label__ = 86; break; //@line 4248 "/root/emscripten/system/lib/dlmalloc.c"
    case 86: 
      var $477=$rsize; //@line 4249 "/root/emscripten/system/lib/dlmalloc.c"
      var $478=(($477)>>>0) < 16; //@line 4249 "/root/emscripten/system/lib/dlmalloc.c"
      if ($478) { __label__ = 87; break; } else { __label__ = 88; break; } //@line 4249 "/root/emscripten/system/lib/dlmalloc.c"
    case 87: 
      var $480=$rsize; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $481=$3; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $482=((($480)+($481))|0); //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $483=$482 | 1; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $484=$483 | 2; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $485=$v; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $486=(($485+4)|0); //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($486)>>2)]=$484; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $487=$v; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $488=$487; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $489=$rsize; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $490=$3; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $491=((($489)+($490))|0); //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $492=(($488+$491)|0); //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $493=$492; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $494=(($493+4)|0); //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $495=HEAP32[(($494)>>2)]; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      var $496=$495 | 1; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($494)>>2)]=$496; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 124; break; //@line 4250 "/root/emscripten/system/lib/dlmalloc.c"
    case 88: 
      var $498=$3; //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      var $499=$498 | 1; //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      var $500=$499 | 2; //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      var $501=$v; //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      var $502=(($501+4)|0); //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($502)>>2)]=$500; //@line 4252 "/root/emscripten/system/lib/dlmalloc.c"
      var $503=$rsize; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $504=$503 | 1; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $505=$r; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $506=(($505+4)|0); //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($506)>>2)]=$504; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $507=$rsize; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $508=$r; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $509=$508; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $510=$rsize; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $511=(($509+$510)|0); //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $512=$511; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $513=(($512)|0); //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($513)>>2)]=$507; //@line 4253 "/root/emscripten/system/lib/dlmalloc.c"
      var $514=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $515=$514 >>> 3; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $516=(($515)>>>0) < 32; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($516) { __label__ = 89; break; } else { __label__ = 96; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 89: 
      var $518=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $519=$518 >>> 3; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$519; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $520=$I; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $521=$520 << 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $522=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $523=(($522+40)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $524=(($523+($521<<2))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $525=$524; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $526=$525; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$526; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $527=$B; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $F5=$527; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $528=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $529=(($528)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $530=HEAP32[(($529)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $531=$I; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $532=1 << $531; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $533=$530 & $532; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $534=(($533)|0)!=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($534) { __label__ = 91; break; } else { __label__ = 90; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 90: 
      var $536=$I; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $537=1 << $536; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $538=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $539=(($538)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $540=HEAP32[(($539)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $541=$540 | $537; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($539)>>2)]=$541; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 95; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 91: 
      var $543=$B; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $544=(($543+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $545=HEAP32[(($544)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $546=$545; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $547=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $548=(($547+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $549=HEAP32[(($548)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $550=(($546)>>>0) >= (($549)>>>0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $551=(($550)&1); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $552=(($551)==(1)); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $553=(($552)|0)!=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($553) { __label__ = 92; break; } else { __label__ = 93; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 92: 
      var $555=$B; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $556=(($555+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $557=HEAP32[(($556)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $F5=$557; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 94; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 93: 
      _abort(); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 94: 
      __label__ = 95; break;
    case 95: 
      var $561=$r; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $562=$B; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $563=(($562+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($563)>>2)]=$561; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $564=$r; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $565=$F5; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $566=(($565+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($566)>>2)]=$564; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $567=$F5; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $568=$r; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $569=(($568+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($569)>>2)]=$567; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $570=$B; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $571=$r; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $572=(($571+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($572)>>2)]=$570; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 123; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 96: 
      var $574=$r; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $575=$574; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $TP=$575; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $576=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $577=$576 >>> 8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $X8=$577; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $578=$X8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $579=(($578)|0)==0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($579) { __label__ = 97; break; } else { __label__ = 98; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 97: 
      $I7=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 102; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 98: 
      var $582=$X8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $583=(($582)>>>0) > 65535; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($583) { __label__ = 99; break; } else { __label__ = 100; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 99: 
      $I7=31; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 101; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 100: 
      var $586=$X8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $Y9=$586; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $587=$Y9; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $588=((($587)-(256))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $589=$588 >>> 16; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $590=$589 & 8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $N10=$590; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $591=$N10; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $592=$Y9; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $593=$592 << $591; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $Y9=$593; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $594=((($593)-(4096))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $595=$594 >>> 16; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $596=$595 & 4; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $K11=$596; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $597=$K11; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $598=$N10; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $599=((($598)+($597))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $N10=$599; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $600=$K11; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $601=$Y9; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $602=$601 << $600; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $Y9=$602; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $603=((($602)-(16384))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $604=$603 >>> 16; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $605=$604 & 2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $K11=$605; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $606=$N10; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $607=((($606)+($605))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $N10=$607; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $608=$N10; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $609=(((14)-($608))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $610=$K11; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $611=$Y9; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $612=$611 << $610; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $Y9=$612; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $613=$612 >>> 15; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $614=((($609)+($613))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $K11=$614; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $615=$K11; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $616=$615 << 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $617=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $618=$K11; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $619=((($618)+(7))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $620=$617 >>> (($619)>>>0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $621=$620 & 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $622=((($616)+($621))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $I7=$622; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 101; break;
    case 101: 
      __label__ = 102; break;
    case 102: 
      var $625=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $626=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $627=(($626+304)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $628=(($627+($625<<2))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $H6=$628; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $629=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $630=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $631=(($630+28)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($631)>>2)]=$629; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $632=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $633=(($632+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $634=(($633+4)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($634)>>2)]=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $635=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $636=(($635+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $637=(($636)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($637)>>2)]=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $638=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $639=(($638+4)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $640=HEAP32[(($639)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $641=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $642=1 << $641; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $643=$640 & $642; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $644=(($643)|0)!=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($644) { __label__ = 104; break; } else { __label__ = 103; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 103: 
      var $646=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $647=1 << $646; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $648=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $649=(($648+4)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $650=HEAP32[(($649)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $651=$650 | $647; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($649)>>2)]=$651; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $652=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $653=$H6; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($653)>>2)]=$652; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $654=$H6; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $655=$654; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $656=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $657=(($656+24)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($657)>>2)]=$655; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $658=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $659=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $660=(($659+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($660)>>2)]=$658; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $661=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $662=(($661+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($662)>>2)]=$658; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 122; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 104: 
      var $664=$H6; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $665=HEAP32[(($664)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$665; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $666=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $667=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $668=(($667)|0)==31; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($668) { __label__ = 105; break; } else { __label__ = 106; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 105: 
      var $677 = 0;__label__ = 107; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 106: 
      var $671=$I7; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $672=$671 >>> 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $673=((($672)+(8))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $674=((($673)-(2))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $675=(((31)-($674))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $677 = $675;__label__ = 107; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 107: 
      var $677; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $678=$666 << $677; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $K12=$678; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 108; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 108: 
      var $680=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $681=(($680+4)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $682=HEAP32[(($681)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $683=$682 & -8; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $684=$rsize; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $685=(($683)|0)!=(($684)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($685) { __label__ = 109; break; } else { __label__ = 115; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 109: 
      var $687=$K12; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $688=$687 >>> 31; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $689=$688 & 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $690=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $691=(($690+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $692=(($691+($689<<2))|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $C=$692; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $693=$K12; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $694=$693 << 1; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $K12=$694; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $695=$C; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $696=HEAP32[(($695)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $697=(($696)|0)!=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($697) { __label__ = 110; break; } else { __label__ = 111; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 110: 
      var $699=$C; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $700=HEAP32[(($699)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$700; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 114; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 111: 
      var $702=$C; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $703=$702; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $704=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $705=(($704+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $706=HEAP32[(($705)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $707=(($703)>>>0) >= (($706)>>>0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $708=(($707)&1); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $709=(($708)==(1)); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $710=(($709)|0)!=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($710) { __label__ = 112; break; } else { __label__ = 113; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 112: 
      var $712=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $713=$C; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($713)>>2)]=$712; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $714=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $715=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $716=(($715+24)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($716)>>2)]=$714; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $717=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $718=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $719=(($718+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($719)>>2)]=$717; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $720=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $721=(($720+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($721)>>2)]=$717; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 121; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 113: 
      _abort(); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 114: 
      __label__ = 120; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 115: 
      var $725=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $726=(($725+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $727=HEAP32[(($726)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      $F13=$727; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $728=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $729=$728; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $730=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $731=(($730+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $732=HEAP32[(($731)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $733=(($729)>>>0) >= (($732)>>>0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      if ($733) { __label__ = 116; break; } else { var $742 = 0;__label__ = 117; break; } //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 116: 
      var $735=$F13; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $736=$735; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $737=$2; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $738=(($737+16)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $739=HEAP32[(($738)>>2)]; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $740=(($736)>>>0) >= (($739)>>>0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $742 = $740;__label__ = 117; break;
    case 117: 
      var $742;
      var $743=(($742)&1);
      var $744=(($743)==(1));
      var $745=(($744)|0)!=0;
      if ($745) { __label__ = 118; break; } else { __label__ = 119; break; }
    case 118: 
      var $747=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $748=$F13; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $749=(($748+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($749)>>2)]=$747; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $750=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $751=(($750+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($751)>>2)]=$747; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $752=$F13; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $753=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $754=(($753+8)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($754)>>2)]=$752; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $755=$T; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $756=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $757=(($756+12)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($757)>>2)]=$755; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $758=$TP; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      var $759=(($758+24)|0); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($759)>>2)]=0; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 121; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 119: 
      _abort(); //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 120: 
      __label__ = 108; break; //@line 4254 "/root/emscripten/system/lib/dlmalloc.c"
    case 121: 
      __label__ = 122; break;
    case 122: 
      __label__ = 123; break;
    case 123: 
      __label__ = 124; break;
    case 124: 
      var $766=$v; //@line 4256 "/root/emscripten/system/lib/dlmalloc.c"
      var $767=$766; //@line 4256 "/root/emscripten/system/lib/dlmalloc.c"
      var $768=(($767+8)|0); //@line 4256 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$768; //@line 4256 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 128; break; //@line 4256 "/root/emscripten/system/lib/dlmalloc.c"
    case 125: 
      __label__ = 126; break; //@line 4258 "/root/emscripten/system/lib/dlmalloc.c"
    case 126: 
      _abort(); //@line 4259 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4259 "/root/emscripten/system/lib/dlmalloc.c"
    case 127: 
      $1=0; //@line 4261 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 128; break; //@line 4261 "/root/emscripten/system/lib/dlmalloc.c"
    case 128: 
      var $773=$1; //@line 4262 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $773; //@line 4262 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_tmalloc_large["X"]=1;

function _sys_alloc($m, $nb) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $tbase;
      var $tsize;
      var $mmap_flag;
      var $mem;
      var $br;
      var $ss;
      var $asize;
      var $base;
      var $esize;
      var $end;
      var $asize1;
      var $br2;
      var $end3;
      var $ssize;
      var $mn;
      var $sp;
      var $oldbase;
      var $rsize;
      var $p;
      var $r;
      $2=$m;
      $3=$nb;
      $tbase=-1; //@line 3876 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=0; //@line 3877 "/root/emscripten/system/lib/dlmalloc.c"
      $mmap_flag=0; //@line 3878 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=HEAP32[((((_mparams)|0))>>2)]; //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=(($4)|0)!=0; //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
      if ($5) { var $10 = 1;__label__ = 4; break; } else { __label__ = 3; break; } //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $7=_init_mparams(); //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=(($7)|0)!=0; //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
      var $10 = $8;__label__ = 4; break; //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $10;
      var $11=(($10)&1); //@line 3880 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=$2; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=(($12+440)|0); //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=HEAP32[(($13)>>2)]; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$14 & 0; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=(($15)|0)!=0; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      if ($16) { __label__ = 5; break; } else { __label__ = 10; break; } //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $18=$3; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=HEAP32[((((_mparams+12)|0))>>2)]; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=(($18)>>>0) >= (($19)>>>0); //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      if ($20) { __label__ = 6; break; } else { __label__ = 10; break; } //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $22=$2; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=(($22+12)|0); //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=HEAP32[(($23)>>2)]; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=(($24)|0)!=0; //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
      if ($25) { __label__ = 7; break; } else { __label__ = 10; break; } //@line 3883 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $27=$2; //@line 3884 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$3; //@line 3884 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=_mmap_alloc($27, $28); //@line 3884 "/root/emscripten/system/lib/dlmalloc.c"
      $mem=$29; //@line 3884 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$mem; //@line 3885 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=(($30)|0)!=0; //@line 3885 "/root/emscripten/system/lib/dlmalloc.c"
      if ($31) { __label__ = 8; break; } else { __label__ = 9; break; } //@line 3885 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $33=$mem; //@line 3886 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$33; //@line 3886 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 93; break; //@line 3886 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      __label__ = 10; break; //@line 3887 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $36=$2; //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=(($36+440)|0); //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=HEAP32[(($37)>>2)]; //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=$38 & 4; //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=(($39)|0)!=0; //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
      if ($40) { __label__ = 43; break; } else { __label__ = 11; break; } //@line 3911 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      $br=-1; //@line 3912 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$2; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=(($42+24)|0); //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=HEAP32[(($43)>>2)]; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=(($44)|0)==0; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      if ($45) { __label__ = 12; break; } else { __label__ = 13; break; } //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $55 = 0;__label__ = 14; break; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $48=$2; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=$2; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=(($49+24)|0); //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=HEAP32[(($50)>>2)]; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=$51; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=_segment_holding($48, $52); //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      var $55 = $53;__label__ = 14; break; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $55; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      $ss=$55; //@line 3913 "/root/emscripten/system/lib/dlmalloc.c"
      $asize=0; //@line 3914 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$ss; //@line 3917 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56)|0)==0; //@line 3917 "/root/emscripten/system/lib/dlmalloc.c"
      if ($57) { __label__ = 15; break; } else { __label__ = 23; break; } //@line 3917 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $59=_sbrk(0); //@line 3918 "/root/emscripten/system/lib/dlmalloc.c"
      $base=$59; //@line 3918 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=$base; //@line 3919 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=(($60)|0)!=-1; //@line 3919 "/root/emscripten/system/lib/dlmalloc.c"
      if ($61) { __label__ = 16; break; } else { __label__ = 22; break; } //@line 3919 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      var $63=$3; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=((($63)+(48))|0); //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $66=((($65)-(1))|0); //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $67=((($64)+($66))|0); //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=((($68)-(1))|0); //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=$69 ^ -1; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=$67 & $70; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      $asize=$71; //@line 3920 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=$base; //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=$72; //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=HEAP32[((((_mparams+4)|0))>>2)]; //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=((($74)-(1))|0); //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=$73 & $75; //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=(($76)|0)==0; //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
      if ($77) { __label__ = 18; break; } else { __label__ = 17; break; } //@line 3922 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $79=$base; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=$79; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=HEAP32[((((_mparams+4)|0))>>2)]; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=((($81)-(1))|0); //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=((($80)+($82))|0); //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=HEAP32[((((_mparams+4)|0))>>2)]; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $85=((($84)-(1))|0); //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=$85 ^ -1; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=$83 & $86; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=$base; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=$88; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=((($87)-($89))|0); //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=$asize; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=((($91)+($90))|0); //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      $asize=$92; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 18; break; //@line 3923 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $94=$asize; //@line 3925 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=(($94)>>>0) < 2147483647; //@line 3925 "/root/emscripten/system/lib/dlmalloc.c"
      if ($95) { __label__ = 19; break; } else { __label__ = 21; break; } //@line 3925 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $97=$asize; //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=_sbrk($97); //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
      $br=$98; //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=$base; //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=(($98)|0)==(($99)|0); //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
      if ($100) { __label__ = 20; break; } else { __label__ = 21; break; } //@line 3926 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      var $102=$base; //@line 3927 "/root/emscripten/system/lib/dlmalloc.c"
      $tbase=$102; //@line 3927 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=$asize; //@line 3928 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$103; //@line 3928 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 21; break; //@line 3929 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      __label__ = 22; break; //@line 3930 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      __label__ = 27; break; //@line 3931 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      var $107=$3; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=$2; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $109=(($108+12)|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $110=HEAP32[(($109)>>2)]; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=((($107)-($110))|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=((($111)+(48))|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=((($113)-(1))|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=((($112)+($114))|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=((($116)-(1))|0); //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=$117 ^ -1; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $119=$115 & $118; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      $asize=$119; //@line 3934 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=$asize; //@line 3936 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=(($120)>>>0) < 2147483647; //@line 3936 "/root/emscripten/system/lib/dlmalloc.c"
      if ($121) { __label__ = 24; break; } else { __label__ = 26; break; } //@line 3936 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $123=$asize; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $124=_sbrk($123); //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      $br=$124; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=$ss; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=(($125)|0); //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=HEAP32[(($126)>>2)]; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=$ss; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=(($128+4)|0); //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=HEAP32[(($129)>>2)]; //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=(($127+$130)|0); //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      var $132=(($124)|0)==(($131)|0); //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
      if ($132) { __label__ = 25; break; } else { __label__ = 26; break; } //@line 3937 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $134=$br; //@line 3938 "/root/emscripten/system/lib/dlmalloc.c"
      $tbase=$134; //@line 3938 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=$asize; //@line 3939 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$135; //@line 3939 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 26; break; //@line 3940 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      __label__ = 27; break;
    case 27: 
      var $138=$tbase; //@line 3943 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=(($138)|0)==-1; //@line 3943 "/root/emscripten/system/lib/dlmalloc.c"
      if ($139) { __label__ = 28; break; } else { __label__ = 42; break; } //@line 3943 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      var $141=$br; //@line 3944 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=(($141)|0)!=-1; //@line 3944 "/root/emscripten/system/lib/dlmalloc.c"
      if ($142) { __label__ = 29; break; } else { __label__ = 38; break; } //@line 3944 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      var $144=$asize; //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=(($144)>>>0) < 2147483647; //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      if ($145) { __label__ = 30; break; } else { __label__ = 37; break; } //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $147=$asize; //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=$3; //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      var $149=((($148)+(48))|0); //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      var $150=(($147)>>>0) < (($149)>>>0); //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
      if ($150) { __label__ = 31; break; } else { __label__ = 37; break; } //@line 3945 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $152=$3; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=((($152)+(48))|0); //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=$asize; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=((($153)-($154))|0); //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=((($156)-(1))|0); //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=((($155)+($157))|0); //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=((($159)-(1))|0); //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=$160 ^ -1; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=$158 & $161; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      $esize=$162; //@line 3947 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=$esize; //@line 3948 "/root/emscripten/system/lib/dlmalloc.c"
      var $164=(($163)>>>0) < 2147483647; //@line 3948 "/root/emscripten/system/lib/dlmalloc.c"
      if ($164) { __label__ = 32; break; } else { __label__ = 36; break; } //@line 3948 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $166=$esize; //@line 3949 "/root/emscripten/system/lib/dlmalloc.c"
      var $167=_sbrk($166); //@line 3949 "/root/emscripten/system/lib/dlmalloc.c"
      $end=$167; //@line 3949 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=$end; //@line 3950 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=(($168)|0)!=-1; //@line 3950 "/root/emscripten/system/lib/dlmalloc.c"
      if ($169) { __label__ = 33; break; } else { __label__ = 34; break; } //@line 3950 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      var $171=$esize; //@line 3951 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=$asize; //@line 3951 "/root/emscripten/system/lib/dlmalloc.c"
      var $173=((($172)+($171))|0); //@line 3951 "/root/emscripten/system/lib/dlmalloc.c"
      $asize=$173; //@line 3951 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 35; break; //@line 3951 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $175=$asize; //@line 3953 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=(((-$175))|0); //@line 3953 "/root/emscripten/system/lib/dlmalloc.c"
      var $177=_sbrk($176); //@line 3953 "/root/emscripten/system/lib/dlmalloc.c"
      $br=-1; //@line 3954 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 35; break;
    case 35: 
      __label__ = 36; break; //@line 3956 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      __label__ = 37; break; //@line 3957 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      __label__ = 38; break; //@line 3958 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $182=$br; //@line 3959 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=(($182)|0)!=-1; //@line 3959 "/root/emscripten/system/lib/dlmalloc.c"
      if ($183) { __label__ = 39; break; } else { __label__ = 40; break; } //@line 3959 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      var $185=$br; //@line 3960 "/root/emscripten/system/lib/dlmalloc.c"
      $tbase=$185; //@line 3960 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=$asize; //@line 3961 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$186; //@line 3961 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 41; break; //@line 3962 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      var $188=$2; //@line 3964 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=(($188+440)|0); //@line 3964 "/root/emscripten/system/lib/dlmalloc.c"
      var $190=HEAP32[(($189)>>2)]; //@line 3964 "/root/emscripten/system/lib/dlmalloc.c"
      var $191=$190 | 4; //@line 3964 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($189)>>2)]=$191; //@line 3964 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 41; break;
    case 41: 
      __label__ = 42; break; //@line 3965 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      __label__ = 43; break; //@line 3968 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      var $195=$tbase; //@line 3982 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=(($195)|0)==-1; //@line 3982 "/root/emscripten/system/lib/dlmalloc.c"
      if ($196) { __label__ = 44; break; } else { __label__ = 53; break; } //@line 3982 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      var $198=$3; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=((($198)+(48))|0); //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $200=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $201=((($200)-(1))|0); //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $202=((($199)+($201))|0); //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $203=HEAP32[((((_mparams+8)|0))>>2)]; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=((($203)-(1))|0); //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=$204 ^ -1; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=$202 & $205; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      $asize1=$206; //@line 3983 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=$asize1; //@line 3984 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=(($207)>>>0) < 2147483647; //@line 3984 "/root/emscripten/system/lib/dlmalloc.c"
      if ($208) { __label__ = 45; break; } else { __label__ = 52; break; } //@line 3984 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      $br2=-1; //@line 3985 "/root/emscripten/system/lib/dlmalloc.c"
      $end3=-1; //@line 3986 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=$asize1; //@line 3988 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=_sbrk($210); //@line 3988 "/root/emscripten/system/lib/dlmalloc.c"
      $br2=$211; //@line 3988 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=_sbrk(0); //@line 3989 "/root/emscripten/system/lib/dlmalloc.c"
      $end3=$212; //@line 3989 "/root/emscripten/system/lib/dlmalloc.c"
      var $213=$br2; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      var $214=(($213)|0)!=-1; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      if ($214) { __label__ = 46; break; } else { __label__ = 51; break; } //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $216=$end3; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      var $217=(($216)|0)!=-1; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      if ($217) { __label__ = 47; break; } else { __label__ = 51; break; } //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      var $219=$br2; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      var $220=$end3; //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=(($219)>>>0) < (($220)>>>0); //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
      if ($221) { __label__ = 48; break; } else { __label__ = 51; break; } //@line 3991 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      var $223=$end3; //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=$br2; //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      var $225=$223; //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=$224; //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=((($225)-($226))|0); //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      $ssize=$227; //@line 3992 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=$ssize; //@line 3993 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=$3; //@line 3993 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=((($229)+(40))|0); //@line 3993 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=(($228)>>>0) > (($230)>>>0); //@line 3993 "/root/emscripten/system/lib/dlmalloc.c"
      if ($231) { __label__ = 49; break; } else { __label__ = 50; break; } //@line 3993 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $233=$br2; //@line 3994 "/root/emscripten/system/lib/dlmalloc.c"
      $tbase=$233; //@line 3994 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=$ssize; //@line 3995 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$234; //@line 3995 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 50; break; //@line 3996 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      __label__ = 51; break; //@line 3997 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      __label__ = 52; break; //@line 3998 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      __label__ = 53; break; //@line 3999 "/root/emscripten/system/lib/dlmalloc.c"
    case 53: 
      var $239=$tbase; //@line 4001 "/root/emscripten/system/lib/dlmalloc.c"
      var $240=(($239)|0)!=-1; //@line 4001 "/root/emscripten/system/lib/dlmalloc.c"
      if ($240) { __label__ = 54; break; } else { __label__ = 92; break; } //@line 4001 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      var $242=$tsize; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=$2; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=(($243+432)|0); //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=HEAP32[(($244)>>2)]; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=((($245)+($242))|0); //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($244)>>2)]=$246; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=$2; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($247+436)|0); //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $249=HEAP32[(($248)>>2)]; //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=(($246)>>>0) > (($249)>>>0); //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
      if ($250) { __label__ = 55; break; } else { __label__ = 56; break; } //@line 4003 "/root/emscripten/system/lib/dlmalloc.c"
    case 55: 
      var $252=$2; //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      var $253=(($252+432)|0); //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      var $254=HEAP32[(($253)>>2)]; //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      var $255=$2; //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      var $256=(($255+436)|0); //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($256)>>2)]=$254; //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 56; break; //@line 4004 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      var $258=$2; //@line 4006 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=(($258+24)|0); //@line 4006 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=HEAP32[(($259)>>2)]; //@line 4006 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=(($260)|0)!=0; //@line 4006 "/root/emscripten/system/lib/dlmalloc.c"
      if ($261) { __label__ = 64; break; } else { __label__ = 57; break; } //@line 4006 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      var $263=$2; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=(($263+16)|0); //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=HEAP32[(($264)>>2)]; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $266=(($265)|0)==0; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      if ($266) { __label__ = 59; break; } else { __label__ = 58; break; } //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
    case 58: 
      var $268=$tbase; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $269=$2; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $270=(($269+16)|0); //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=HEAP32[(($270)>>2)]; //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=(($268)>>>0) < (($271)>>>0); //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
      if ($272) { __label__ = 59; break; } else { __label__ = 60; break; } //@line 4007 "/root/emscripten/system/lib/dlmalloc.c"
    case 59: 
      var $274=$tbase; //@line 4008 "/root/emscripten/system/lib/dlmalloc.c"
      var $275=$2; //@line 4008 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($275+16)|0); //@line 4008 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($276)>>2)]=$274; //@line 4008 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 60; break; //@line 4008 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      var $278=$tbase; //@line 4009 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=$2; //@line 4009 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=(($279+444)|0); //@line 4009 "/root/emscripten/system/lib/dlmalloc.c"
      var $281=(($280)|0); //@line 4009 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($281)>>2)]=$278; //@line 4009 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=$tsize; //@line 4010 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=$2; //@line 4010 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=(($283+444)|0); //@line 4010 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=(($284+4)|0); //@line 4010 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($285)>>2)]=$282; //@line 4010 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=$mmap_flag; //@line 4011 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=$2; //@line 4011 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=(($287+444)|0); //@line 4011 "/root/emscripten/system/lib/dlmalloc.c"
      var $289=(($288+12)|0); //@line 4011 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($289)>>2)]=$286; //@line 4011 "/root/emscripten/system/lib/dlmalloc.c"
      var $290=HEAP32[((((_mparams)|0))>>2)]; //@line 4012 "/root/emscripten/system/lib/dlmalloc.c"
      var $291=$2; //@line 4012 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=(($291+36)|0); //@line 4012 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($292)>>2)]=$290; //@line 4012 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=$2; //@line 4013 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=(($293+32)|0); //@line 4013 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($294)>>2)]=-1; //@line 4013 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=$2; //@line 4014 "/root/emscripten/system/lib/dlmalloc.c"
      _init_bins($295); //@line 4014 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=$2; //@line 4016 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=(($296)|0)==((__gm_)|0); //@line 4016 "/root/emscripten/system/lib/dlmalloc.c"
      if ($297) { __label__ = 61; break; } else { __label__ = 62; break; } //@line 4016 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      var $299=$2; //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      var $300=$tbase; //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      var $301=$300; //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      var $302=$tsize; //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      var $303=((($302)-(40))|0); //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      _init_top($299, $301, $303); //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 63; break; //@line 4017 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      var $305=$2; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $306=$305; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=((($306)-(8))|0); //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $308=$307; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $309=$308; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=$2; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=$310; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=((($311)-(8))|0); //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=$312; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=(($313+4)|0); //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=HEAP32[(($314)>>2)]; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=$315 & -8; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=(($309+$316)|0); //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=$317; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      $mn=$318; //@line 4022 "/root/emscripten/system/lib/dlmalloc.c"
      var $319=$2; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=$mn; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=$tbase; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=$tsize; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=(($321+$322)|0); //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=$mn; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=$324; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=$323; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $327=$325; //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $328=((($326)-($327))|0); //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      var $329=((($328)-(40))|0); //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      _init_top($319, $320, $329); //@line 4023 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 63; break;
    case 63: 
      __label__ = 89; break; //@line 4025 "/root/emscripten/system/lib/dlmalloc.c"
    case 64: 
      var $332=$2; //@line 4029 "/root/emscripten/system/lib/dlmalloc.c"
      var $333=(($332+444)|0); //@line 4029 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$333; //@line 4029 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 65; break; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
    case 65: 
      var $335=$sp; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=(($335)|0)!=0; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      if ($336) { __label__ = 66; break; } else { var $348 = 0;__label__ = 67; break; } //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
    case 66: 
      var $338=$tbase; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=$sp; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=(($339)|0); //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=HEAP32[(($340)>>2)]; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=$sp; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $343=(($342+4)|0); //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $344=HEAP32[(($343)>>2)]; //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=(($341+$344)|0); //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=(($338)|0)!=(($345)|0); //@line 4031 "/root/emscripten/system/lib/dlmalloc.c"
      var $348 = $346;__label__ = 67; break;
    case 67: 
      var $348;
      if ($348) { __label__ = 68; break; } else { __label__ = 69; break; }
    case 68: 
      var $350=$sp; //@line 4032 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=(($350+8)|0); //@line 4032 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=HEAP32[(($351)>>2)]; //@line 4032 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$352; //@line 4032 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 65; break; //@line 4032 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      var $354=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=(($354)|0)!=0; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      if ($355) { __label__ = 70; break; } else { __label__ = 75; break; } //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
    case 70: 
      var $357=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=(($357+12)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=HEAP32[(($358)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=$359 & 8; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=(($360)|0)!=0; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      if ($361) { __label__ = 75; break; } else { __label__ = 71; break; } //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
    case 71: 
      var $363=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=(($363+12)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=HEAP32[(($364)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $366=$365 & 0; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=$mmap_flag; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=(($366)|0)==(($367)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      if ($368) { __label__ = 72; break; } else { __label__ = 75; break; } //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
    case 72: 
      var $370=$2; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=(($370+24)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=HEAP32[(($371)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $373=$372; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=(($374)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=HEAP32[(($375)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $377=(($373)>>>0) >= (($376)>>>0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      if ($377) { __label__ = 73; break; } else { __label__ = 75; break; } //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
    case 73: 
      var $379=$2; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=(($379+24)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=HEAP32[(($380)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=$381; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $383=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $384=(($383)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=HEAP32[(($384)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=$sp; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=(($386+4)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $388=HEAP32[(($387)>>2)]; //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $389=(($385+$388)|0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=(($382)>>>0) < (($389)>>>0); //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
      if ($390) { __label__ = 74; break; } else { __label__ = 75; break; } //@line 4033 "/root/emscripten/system/lib/dlmalloc.c"
    case 74: 
      var $392=$tsize; //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      var $393=$sp; //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=(($393+4)|0); //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=HEAP32[(($394)>>2)]; //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      var $396=((($395)+($392))|0); //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($394)>>2)]=$396; //@line 4037 "/root/emscripten/system/lib/dlmalloc.c"
      var $397=$2; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $398=$2; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $399=(($398+24)|0); //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $400=HEAP32[(($399)>>2)]; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $401=$2; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $402=(($401+12)|0); //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $403=HEAP32[(($402)>>2)]; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $404=$tsize; //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      var $405=((($403)+($404))|0); //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      _init_top($397, $400, $405); //@line 4038 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 88; break; //@line 4039 "/root/emscripten/system/lib/dlmalloc.c"
    case 75: 
      var $407=$tbase; //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
      var $408=$2; //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
      var $409=(($408+16)|0); //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
      var $410=HEAP32[(($409)>>2)]; //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
      var $411=(($407)>>>0) < (($410)>>>0); //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
      if ($411) { __label__ = 76; break; } else { __label__ = 77; break; } //@line 4041 "/root/emscripten/system/lib/dlmalloc.c"
    case 76: 
      var $413=$tbase; //@line 4042 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=$2; //@line 4042 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=(($414+16)|0); //@line 4042 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($415)>>2)]=$413; //@line 4042 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 77; break; //@line 4042 "/root/emscripten/system/lib/dlmalloc.c"
    case 77: 
      var $417=$2; //@line 4043 "/root/emscripten/system/lib/dlmalloc.c"
      var $418=(($417+444)|0); //@line 4043 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$418; //@line 4043 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 78; break; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
    case 78: 
      var $420=$sp; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $421=(($420)|0)!=0; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      if ($421) { __label__ = 79; break; } else { var $431 = 0;__label__ = 80; break; } //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
    case 79: 
      var $423=$sp; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=(($423)|0); //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=HEAP32[(($424)>>2)]; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $426=$tbase; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $427=$tsize; //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=(($426+$427)|0); //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=(($425)|0)!=(($428)|0); //@line 4044 "/root/emscripten/system/lib/dlmalloc.c"
      var $431 = $429;__label__ = 80; break;
    case 80: 
      var $431;
      if ($431) { __label__ = 81; break; } else { __label__ = 82; break; }
    case 81: 
      var $433=$sp; //@line 4045 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=(($433+8)|0); //@line 4045 "/root/emscripten/system/lib/dlmalloc.c"
      var $435=HEAP32[(($434)>>2)]; //@line 4045 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$435; //@line 4045 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 78; break; //@line 4045 "/root/emscripten/system/lib/dlmalloc.c"
    case 82: 
      var $437=$sp; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=(($437)|0)!=0; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      if ($438) { __label__ = 83; break; } else { __label__ = 86; break; } //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
    case 83: 
      var $440=$sp; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=(($440+12)|0); //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $442=HEAP32[(($441)>>2)]; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $443=$442 & 8; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $444=(($443)|0)!=0; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      if ($444) { __label__ = 86; break; } else { __label__ = 84; break; } //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
    case 84: 
      var $446=$sp; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $447=(($446+12)|0); //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $448=HEAP32[(($447)>>2)]; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $449=$448 & 0; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $450=$mmap_flag; //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      var $451=(($449)|0)==(($450)|0); //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
      if ($451) { __label__ = 85; break; } else { __label__ = 86; break; } //@line 4046 "/root/emscripten/system/lib/dlmalloc.c"
    case 85: 
      var $453=$sp; //@line 4049 "/root/emscripten/system/lib/dlmalloc.c"
      var $454=(($453)|0); //@line 4049 "/root/emscripten/system/lib/dlmalloc.c"
      var $455=HEAP32[(($454)>>2)]; //@line 4049 "/root/emscripten/system/lib/dlmalloc.c"
      $oldbase=$455; //@line 4049 "/root/emscripten/system/lib/dlmalloc.c"
      var $456=$tbase; //@line 4050 "/root/emscripten/system/lib/dlmalloc.c"
      var $457=$sp; //@line 4050 "/root/emscripten/system/lib/dlmalloc.c"
      var $458=(($457)|0); //@line 4050 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($458)>>2)]=$456; //@line 4050 "/root/emscripten/system/lib/dlmalloc.c"
      var $459=$tsize; //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      var $460=$sp; //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      var $461=(($460+4)|0); //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      var $462=HEAP32[(($461)>>2)]; //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      var $463=((($462)+($459))|0); //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($461)>>2)]=$463; //@line 4051 "/root/emscripten/system/lib/dlmalloc.c"
      var $464=$2; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      var $465=$tbase; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      var $466=$oldbase; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      var $467=$3; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      var $468=_prepend_alloc($464, $465, $466, $467); //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$468; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 93; break; //@line 4052 "/root/emscripten/system/lib/dlmalloc.c"
    case 86: 
      var $470=$2; //@line 4055 "/root/emscripten/system/lib/dlmalloc.c"
      var $471=$tbase; //@line 4055 "/root/emscripten/system/lib/dlmalloc.c"
      var $472=$tsize; //@line 4055 "/root/emscripten/system/lib/dlmalloc.c"
      var $473=$mmap_flag; //@line 4055 "/root/emscripten/system/lib/dlmalloc.c"
      _add_segment($470, $471, $472, $473); //@line 4055 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 87; break;
    case 87: 
      __label__ = 88; break;
    case 88: 
      __label__ = 89; break;
    case 89: 
      var $477=$3; //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
      var $478=$2; //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
      var $479=(($478+12)|0); //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
      var $480=HEAP32[(($479)>>2)]; //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
      var $481=(($477)>>>0) < (($480)>>>0); //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
      if ($481) { __label__ = 90; break; } else { __label__ = 91; break; } //@line 4059 "/root/emscripten/system/lib/dlmalloc.c"
    case 90: 
      var $483=$3; //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      var $484=$2; //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      var $485=(($484+12)|0); //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      var $486=HEAP32[(($485)>>2)]; //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      var $487=((($486)-($483))|0); //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($485)>>2)]=$487; //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      $rsize=$487; //@line 4060 "/root/emscripten/system/lib/dlmalloc.c"
      var $488=$2; //@line 4061 "/root/emscripten/system/lib/dlmalloc.c"
      var $489=(($488+24)|0); //@line 4061 "/root/emscripten/system/lib/dlmalloc.c"
      var $490=HEAP32[(($489)>>2)]; //@line 4061 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$490; //@line 4061 "/root/emscripten/system/lib/dlmalloc.c"
      var $491=$p; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $492=$491; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $493=$3; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $494=(($492+$493)|0); //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $495=$494; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $496=$2; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $497=(($496+24)|0); //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($497)>>2)]=$495; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      $r=$495; //@line 4062 "/root/emscripten/system/lib/dlmalloc.c"
      var $498=$rsize; //@line 4063 "/root/emscripten/system/lib/dlmalloc.c"
      var $499=$498 | 1; //@line 4063 "/root/emscripten/system/lib/dlmalloc.c"
      var $500=$r; //@line 4063 "/root/emscripten/system/lib/dlmalloc.c"
      var $501=(($500+4)|0); //@line 4063 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($501)>>2)]=$499; //@line 4063 "/root/emscripten/system/lib/dlmalloc.c"
      var $502=$3; //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      var $503=$502 | 1; //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      var $504=$503 | 2; //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      var $505=$p; //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      var $506=(($505+4)|0); //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($506)>>2)]=$504; //@line 4064 "/root/emscripten/system/lib/dlmalloc.c"
      var $507=$p; //@line 4067 "/root/emscripten/system/lib/dlmalloc.c"
      var $508=$507; //@line 4067 "/root/emscripten/system/lib/dlmalloc.c"
      var $509=(($508+8)|0); //@line 4067 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$509; //@line 4067 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 93; break; //@line 4067 "/root/emscripten/system/lib/dlmalloc.c"
    case 91: 
      __label__ = 92; break; //@line 4069 "/root/emscripten/system/lib/dlmalloc.c"
    case 92: 
      var $512=___errno(); //@line 4071 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($512)>>2)]=12; //@line 4071 "/root/emscripten/system/lib/dlmalloc.c"
      $1=0; //@line 4072 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 93; break; //@line 4072 "/root/emscripten/system/lib/dlmalloc.c"
    case 93: 
      var $514=$1; //@line 4073 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $514; //@line 4073 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_sys_alloc["X"]=1;

function _free($mem) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $p;
      var $psize;
      var $next;
      var $prevsize;
      var $prev;
      var $F;
      var $B;
      var $I;
      var $TP;
      var $XP;
      var $R;
      var $F1;
      var $RP;
      var $CP;
      var $H;
      var $C0;
      var $C1;
      var $tsize;
      var $dsize;
      var $nsize;
      var $F2;
      var $B3;
      var $I4;
      var $TP5;
      var $XP6;
      var $R7;
      var $F8;
      var $RP9;
      var $CP10;
      var $H11;
      var $C012;
      var $C113;
      var $I14;
      var $B15;
      var $F16;
      var $tp;
      var $H17;
      var $I18;
      var $X;
      var $Y;
      var $N;
      var $K;
      var $T;
      var $K19;
      var $C;
      var $F20;
      $1=$mem;
      var $2=$1; //@line 4741 "/root/emscripten/system/lib/dlmalloc.c"
      var $3=(($2)|0)!=0; //@line 4741 "/root/emscripten/system/lib/dlmalloc.c"
      if ($3) { __label__ = 3; break; } else { __label__ = 197; break; } //@line 4741 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $5=$1; //@line 4742 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=((($5)-(8))|0); //@line 4742 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=$6; //@line 4742 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$7; //@line 4742 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$p; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=$8; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=(($9)>>>0) >= (($10)>>>0); //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      if ($11) { __label__ = 4; break; } else { var $19 = 0;__label__ = 5; break; } //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $13=$p; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=(($13+4)|0); //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=HEAP32[(($14)>>2)]; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$15 & 3; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=(($16)|0)!=1; //@line 4754 "/root/emscripten/system/lib/dlmalloc.c"
      var $19 = $17;__label__ = 5; break;
    case 5: 
      var $19;
      var $20=(($19)&1);
      var $21=(($20)==(1));
      var $22=(($21)|0)!=0;
      if ($22) { __label__ = 6; break; } else { __label__ = 194; break; }
    case 6: 
      var $24=$p; //@line 4755 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=(($24+4)|0); //@line 4755 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=HEAP32[(($25)>>2)]; //@line 4755 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$26 & -8; //@line 4755 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$27; //@line 4755 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$p; //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=$28; //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$psize; //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=(($29+$30)|0); //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=$31; //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      $next=$32; //@line 4756 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$p; //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=(($33+4)|0); //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=HEAP32[(($34)>>2)]; //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$35 & 1; //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=(($36)|0)!=0; //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
      if ($37) { __label__ = 78; break; } else { __label__ = 7; break; } //@line 4757 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $39=$p; //@line 4758 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=(($39)|0); //@line 4758 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=HEAP32[(($40)>>2)]; //@line 4758 "/root/emscripten/system/lib/dlmalloc.c"
      $prevsize=$41; //@line 4758 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$p; //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=(($42+4)|0); //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=HEAP32[(($43)>>2)]; //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$44 & 3; //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=(($45)|0)==0; //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
      if ($46) { __label__ = 8; break; } else { __label__ = 9; break; } //@line 4759 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $48=$prevsize; //@line 4760 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=((($48)+(16))|0); //@line 4760 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$psize; //@line 4760 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=((($50)+($49))|0); //@line 4760 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$51; //@line 4760 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 196; break; //@line 4763 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $53=$p; //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=$53; //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=$prevsize; //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=(((-$55))|0); //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($54+$56)|0); //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=$57; //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      $prev=$58; //@line 4766 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=$prevsize; //@line 4767 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=$psize; //@line 4767 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=((($60)+($59))|0); //@line 4767 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$61; //@line 4767 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=$prev; //@line 4768 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$62; //@line 4768 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$prev; //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=$63; //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $66=(($64)>>>0) >= (($65)>>>0); //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $67=(($66)&1); //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=(($67)==(1)); //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=(($68)|0)!=0; //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
      if ($69) { __label__ = 10; break; } else { __label__ = 75; break; } //@line 4769 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $71=$p; //@line 4770 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4770 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=(($71)|0)!=(($72)|0); //@line 4770 "/root/emscripten/system/lib/dlmalloc.c"
      if ($73) { __label__ = 11; break; } else { __label__ = 71; break; } //@line 4770 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $75=$prevsize; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=$75 >>> 3; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=(($76)>>>0) < 32; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($77) { __label__ = 12; break; } else { __label__ = 24; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $79=$p; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=(($79+8)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=HEAP32[(($80)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$81; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=$p; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=(($82+12)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=HEAP32[(($83)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$84; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $85=$prevsize; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=$85 >>> 3; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$86; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=$F; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=$B; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=(($87)|0)==(($88)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($89) { __label__ = 13; break; } else { __label__ = 14; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $91=$I; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=1 << $91; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $93=$92 ^ -1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=HEAP32[((((__gm_)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=$94 & $93; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$95; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 23; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $97=$F; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=$I; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=$98 << 1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=((((__gm_+40)|0)+($99<<2))|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$100; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=$101; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=(($97)|0)==(($102)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($103) { __label__ = 16; break; } else { __label__ = 15; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $105=$F; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=$105; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=(($106)>>>0) >= (($107)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($108) { __label__ = 16; break; } else { var $125 = 0;__label__ = 19; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      var $110=$B; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=$I; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=$111 << 1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=((((__gm_+40)|0)+($112<<2))|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=$113; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=$114; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=(($110)|0)==(($115)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($116) { var $123 = 1;__label__ = 18; break; } else { __label__ = 17; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $118=$B; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $119=$118; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=(($119)>>>0) >= (($120)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $123 = $121;__label__ = 18; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $123;
      var $125 = $123;__label__ = 19; break;
    case 19: 
      var $125;
      var $126=(($125)&1);
      var $127=(($126)==(1));
      var $128=(($127)|0)!=0;
      if ($128) { __label__ = 20; break; } else { __label__ = 21; break; }
    case 20: 
      var $130=$B; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=$F; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $132=(($131+12)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($132)>>2)]=$130; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=$F; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=$B; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=(($134+8)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($135)>>2)]=$133; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 22; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      __label__ = 23; break;
    case 23: 
      __label__ = 70; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $140=$p; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=$140; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $TP=$141; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=(($142+24)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=HEAP32[(($143)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $XP=$144; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=(($145+12)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=HEAP32[(($146)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $149=(($147)|0)!=(($148)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($149) { __label__ = 25; break; } else { __label__ = 29; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $151=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=(($151+8)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=HEAP32[(($152)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $F1=$153; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=(($154+12)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=HEAP32[(($155)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$156; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=$F1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=$157; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=(($158)>>>0) >= (($159)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=(($160)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=(($161)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=(($162)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($163) { __label__ = 26; break; } else { __label__ = 27; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $165=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $166=$F1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $167=(($166+12)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($167)>>2)]=$165; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=$F1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=(($169+8)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($170)>>2)]=$168; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 28; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      __label__ = 41; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      var $174=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $175=(($174+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=(($175+4)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$176; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $177=HEAP32[(($176)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$177; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $178=(($177)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($178) { __label__ = 31; break; } else { __label__ = 30; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $180=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $181=(($180+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $182=(($181)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$182; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=HEAP32[(($182)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$183; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=(($183)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($184) { __label__ = 31; break; } else { __label__ = 40; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      __label__ = 32; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $187=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $188=(($187+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=(($188+4)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$189; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $190=HEAP32[(($189)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $191=(($190)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($191) { var $199 = 1;__label__ = 34; break; } else { __label__ = 33; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      var $193=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=(($193+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=(($194)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$195; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=HEAP32[(($195)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $197=(($196)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $199 = $197;__label__ = 34; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $199;
      if ($199) { __label__ = 35; break; } else { __label__ = 36; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $201=$CP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$201; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $202=HEAP32[(($201)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$202; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 32; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $204=$RP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=$204; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=(($205)>>>0) >= (($206)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=(($207)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=(($208)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=(($209)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($210) { __label__ = 37; break; } else { __label__ = 38; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $212=$RP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($212)>>2)]=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 39; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      __label__ = 40; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      __label__ = 41; break;
    case 41: 
      var $217=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $218=(($217)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($218) { __label__ = 42; break; } else { __label__ = 69; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      var $220=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=(($220+28)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=HEAP32[(($221)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=((((__gm_+304)|0)+($222<<2))|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$223; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $225=$H; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=HEAP32[(($225)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=(($224)|0)==(($226)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($227) { __label__ = 43; break; } else { __label__ = 46; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      var $229=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=$H; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($230)>>2)]=$229; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=(($229)|0)==0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($231) { __label__ = 44; break; } else { __label__ = 45; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      var $233=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=(($233+28)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $235=HEAP32[(($234)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=1 << $235; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=$236 ^ -1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $239=$238 & $237; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+4)|0))>>2)]=$239; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 45; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      __label__ = 53; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $242=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=$242; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=(($243)>>>0) >= (($244)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=(($245)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=(($246)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($247)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($248) { __label__ = 47; break; } else { __label__ = 51; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      var $250=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=(($250+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $252=(($251)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $253=HEAP32[(($252)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $254=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $255=(($253)|0)==(($254)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($255) { __label__ = 48; break; } else { __label__ = 49; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      var $257=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=(($258+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=(($259)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($260)>>2)]=$257; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 50; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $262=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=(($263+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=(($264+4)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($265)>>2)]=$262; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 50; break;
    case 50: 
      __label__ = 52; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      __label__ = 53; break;
    case 53: 
      var $270=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=(($270)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($271) { __label__ = 54; break; } else { __label__ = 68; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      var $273=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $274=$273; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $275=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($274)>>>0) >= (($275)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $277=(($276)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $278=(($277)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=(($278)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($279) { __label__ = 55; break; } else { __label__ = 66; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 55: 
      var $281=$XP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=(($282+24)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($283)>>2)]=$281; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=(($284+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=(($285)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=HEAP32[(($286)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $C0=$287; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=(($287)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($288) { __label__ = 56; break; } else { __label__ = 60; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      var $290=$C0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $291=$290; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=(($291)>>>0) >= (($292)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=(($293)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=(($294)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=(($295)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($296) { __label__ = 57; break; } else { __label__ = 58; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      var $298=$C0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $299=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $300=(($299+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $301=(($300)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($301)>>2)]=$298; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $302=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $303=$C0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $304=(($303+24)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($304)>>2)]=$302; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 59; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 58: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 59: 
      __label__ = 60; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      var $308=$TP; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $309=(($308+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=(($309+4)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=HEAP32[(($310)>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      $C1=$311; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=(($311)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($312) { __label__ = 61; break; } else { __label__ = 65; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      var $314=$C1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=$314; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=(($315)>>>0) >= (($316)>>>0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=(($317)&1); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $319=(($318)==(1)); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=(($319)|0)!=0; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      if ($320) { __label__ = 62; break; } else { __label__ = 63; break; } //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      var $322=$C1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=(($323+16)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=(($324+4)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($325)>>2)]=$322; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=$R; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $327=$C1; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      var $328=(($327+24)|0); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($328)>>2)]=$326; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 64; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 63: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 64: 
      __label__ = 65; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 65: 
      __label__ = 67; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 66: 
      _abort(); //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 67: 
      __label__ = 68; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 68: 
      __label__ = 69; break; //@line 4771 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      __label__ = 70; break;
    case 70: 
      __label__ = 74; break; //@line 4772 "/root/emscripten/system/lib/dlmalloc.c"
    case 71: 
      var $338=$next; //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=(($338+4)|0); //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=HEAP32[(($339)>>2)]; //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=$340 & 3; //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=(($341)|0)==3; //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
      if ($342) { __label__ = 72; break; } else { __label__ = 73; break; } //@line 4773 "/root/emscripten/system/lib/dlmalloc.c"
    case 72: 
      var $344=$psize; //@line 4774 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=$344; //@line 4774 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=$next; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=(($345+4)|0); //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=HEAP32[(($346)>>2)]; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=$347 & -2; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($346)>>2)]=$348; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=$psize; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=$349 | 1; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=$p; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=(($351+4)|0); //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($352)>>2)]=$350; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $353=$psize; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $354=$p; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=$354; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=$psize; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $357=(($355+$356)|0); //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=$357; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=(($358)|0); //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($359)>>2)]=$353; //@line 4775 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 196; break; //@line 4776 "/root/emscripten/system/lib/dlmalloc.c"
    case 73: 
      __label__ = 74; break;
    case 74: 
      __label__ = 76; break; //@line 4778 "/root/emscripten/system/lib/dlmalloc.c"
    case 75: 
      __label__ = 195; break; //@line 4780 "/root/emscripten/system/lib/dlmalloc.c"
    case 76: 
      __label__ = 77; break;
    case 77: 
      __label__ = 78; break; //@line 4782 "/root/emscripten/system/lib/dlmalloc.c"
    case 78: 
      var $366=$p; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=$366; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$next; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=$368; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=(($367)>>>0) < (($369)>>>0); //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      if ($370) { __label__ = 79; break; } else { var $378 = 0;__label__ = 80; break; } //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
    case 79: 
      var $372=$next; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $373=(($372+4)|0); //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=HEAP32[(($373)>>2)]; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=$374 & 1; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=(($375)|0)!=0; //@line 4784 "/root/emscripten/system/lib/dlmalloc.c"
      var $378 = $376;__label__ = 80; break;
    case 80: 
      var $378;
      var $379=(($378)&1);
      var $380=(($379)==(1));
      var $381=(($380)|0)!=0;
      if ($381) { __label__ = 81; break; } else { __label__ = 193; break; }
    case 81: 
      var $383=$next; //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
      var $384=(($383+4)|0); //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=HEAP32[(($384)>>2)]; //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=$385 & 2; //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=(($386)|0)!=0; //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
      if ($387) { __label__ = 154; break; } else { __label__ = 82; break; } //@line 4785 "/root/emscripten/system/lib/dlmalloc.c"
    case 82: 
      var $389=$next; //@line 4786 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=HEAP32[((((__gm_+24)|0))>>2)]; //@line 4786 "/root/emscripten/system/lib/dlmalloc.c"
      var $391=(($389)|0)==(($390)|0); //@line 4786 "/root/emscripten/system/lib/dlmalloc.c"
      if ($391) { __label__ = 83; break; } else { __label__ = 88; break; } //@line 4786 "/root/emscripten/system/lib/dlmalloc.c"
    case 83: 
      var $393=$psize; //@line 4787 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=HEAP32[((((__gm_+12)|0))>>2)]; //@line 4787 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=((($394)+($393))|0); //@line 4787 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+12)|0))>>2)]=$395; //@line 4787 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$395; //@line 4787 "/root/emscripten/system/lib/dlmalloc.c"
      var $396=$p; //@line 4788 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+24)|0))>>2)]=$396; //@line 4788 "/root/emscripten/system/lib/dlmalloc.c"
      var $397=$tsize; //@line 4789 "/root/emscripten/system/lib/dlmalloc.c"
      var $398=$397 | 1; //@line 4789 "/root/emscripten/system/lib/dlmalloc.c"
      var $399=$p; //@line 4789 "/root/emscripten/system/lib/dlmalloc.c"
      var $400=(($399+4)|0); //@line 4789 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($400)>>2)]=$398; //@line 4789 "/root/emscripten/system/lib/dlmalloc.c"
      var $401=$p; //@line 4790 "/root/emscripten/system/lib/dlmalloc.c"
      var $402=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4790 "/root/emscripten/system/lib/dlmalloc.c"
      var $403=(($401)|0)==(($402)|0); //@line 4790 "/root/emscripten/system/lib/dlmalloc.c"
      if ($403) { __label__ = 84; break; } else { __label__ = 85; break; } //@line 4790 "/root/emscripten/system/lib/dlmalloc.c"
    case 84: 
      HEAP32[((((__gm_+20)|0))>>2)]=0; //@line 4791 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=0; //@line 4792 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 85; break; //@line 4793 "/root/emscripten/system/lib/dlmalloc.c"
    case 85: 
      var $406=$tsize; //@line 4794 "/root/emscripten/system/lib/dlmalloc.c"
      var $407=HEAP32[((((__gm_+28)|0))>>2)]; //@line 4794 "/root/emscripten/system/lib/dlmalloc.c"
      var $408=(($406)>>>0) > (($407)>>>0); //@line 4794 "/root/emscripten/system/lib/dlmalloc.c"
      if ($408) { __label__ = 86; break; } else { __label__ = 87; break; } //@line 4794 "/root/emscripten/system/lib/dlmalloc.c"
    case 86: 
      var $410=_sys_trim(__gm_, 0); //@line 4795 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 87; break; //@line 4795 "/root/emscripten/system/lib/dlmalloc.c"
    case 87: 
      __label__ = 196; break; //@line 4796 "/root/emscripten/system/lib/dlmalloc.c"
    case 88: 
      var $413=$next; //@line 4798 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4798 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=(($413)|0)==(($414)|0); //@line 4798 "/root/emscripten/system/lib/dlmalloc.c"
      if ($415) { __label__ = 89; break; } else { __label__ = 90; break; } //@line 4798 "/root/emscripten/system/lib/dlmalloc.c"
    case 89: 
      var $417=$psize; //@line 4799 "/root/emscripten/system/lib/dlmalloc.c"
      var $418=HEAP32[((((__gm_+8)|0))>>2)]; //@line 4799 "/root/emscripten/system/lib/dlmalloc.c"
      var $419=((($418)+($417))|0); //@line 4799 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=$419; //@line 4799 "/root/emscripten/system/lib/dlmalloc.c"
      $dsize=$419; //@line 4799 "/root/emscripten/system/lib/dlmalloc.c"
      var $420=$p; //@line 4800 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+20)|0))>>2)]=$420; //@line 4800 "/root/emscripten/system/lib/dlmalloc.c"
      var $421=$dsize; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $422=$421 | 1; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $423=$p; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=(($423+4)|0); //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($424)>>2)]=$422; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=$dsize; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $426=$p; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $427=$426; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=$dsize; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=(($427+$428)|0); //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $430=$429; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      var $431=(($430)|0); //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($431)>>2)]=$425; //@line 4801 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 196; break; //@line 4802 "/root/emscripten/system/lib/dlmalloc.c"
    case 90: 
      var $433=$next; //@line 4805 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=(($433+4)|0); //@line 4805 "/root/emscripten/system/lib/dlmalloc.c"
      var $435=HEAP32[(($434)>>2)]; //@line 4805 "/root/emscripten/system/lib/dlmalloc.c"
      var $436=$435 & -8; //@line 4805 "/root/emscripten/system/lib/dlmalloc.c"
      $nsize=$436; //@line 4805 "/root/emscripten/system/lib/dlmalloc.c"
      var $437=$nsize; //@line 4806 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=$psize; //@line 4806 "/root/emscripten/system/lib/dlmalloc.c"
      var $439=((($438)+($437))|0); //@line 4806 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$439; //@line 4806 "/root/emscripten/system/lib/dlmalloc.c"
      var $440=$nsize; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=$440 >>> 3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $442=(($441)>>>0) < 32; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($442) { __label__ = 91; break; } else { __label__ = 103; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 91: 
      var $444=$next; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $445=(($444+8)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $446=HEAP32[(($445)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $F2=$446; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $447=$next; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $448=(($447+12)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $449=HEAP32[(($448)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $B3=$449; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $450=$nsize; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $451=$450 >>> 3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $I4=$451; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $452=$F2; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $453=$B3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $454=(($452)|0)==(($453)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($454) { __label__ = 92; break; } else { __label__ = 93; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 92: 
      var $456=$I4; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $457=1 << $456; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $458=$457 ^ -1; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $459=HEAP32[((((__gm_)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $460=$459 & $458; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$460; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 102; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 93: 
      var $462=$F2; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $463=$I4; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $464=$463 << 1; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $465=((((__gm_+40)|0)+($464<<2))|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $466=$465; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $467=$466; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $468=(($462)|0)==(($467)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($468) { __label__ = 95; break; } else { __label__ = 94; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 94: 
      var $470=$F2; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $471=$470; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $472=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $473=(($471)>>>0) >= (($472)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($473) { __label__ = 95; break; } else { var $490 = 0;__label__ = 98; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 95: 
      var $475=$B3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $476=$I4; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $477=$476 << 1; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $478=((((__gm_+40)|0)+($477<<2))|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $479=$478; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $480=$479; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $481=(($475)|0)==(($480)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($481) { var $488 = 1;__label__ = 97; break; } else { __label__ = 96; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 96: 
      var $483=$B3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $484=$483; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $485=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $486=(($484)>>>0) >= (($485)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $488 = $486;__label__ = 97; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 97: 
      var $488;
      var $490 = $488;__label__ = 98; break;
    case 98: 
      var $490;
      var $491=(($490)&1);
      var $492=(($491)==(1));
      var $493=(($492)|0)!=0;
      if ($493) { __label__ = 99; break; } else { __label__ = 100; break; }
    case 99: 
      var $495=$B3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $496=$F2; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $497=(($496+12)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($497)>>2)]=$495; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $498=$F2; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $499=$B3; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $500=(($499+8)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($500)>>2)]=$498; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 101; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 100: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 101: 
      __label__ = 102; break;
    case 102: 
      __label__ = 149; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 103: 
      var $505=$next; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $506=$505; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $TP5=$506; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $507=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $508=(($507+24)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $509=HEAP32[(($508)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $XP6=$509; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $510=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $511=(($510+12)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $512=HEAP32[(($511)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $513=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $514=(($512)|0)!=(($513)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($514) { __label__ = 104; break; } else { __label__ = 108; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 104: 
      var $516=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $517=(($516+8)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $518=HEAP32[(($517)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $F8=$518; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $519=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $520=(($519+12)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $521=HEAP32[(($520)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $R7=$521; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $522=$F8; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $523=$522; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $524=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $525=(($523)>>>0) >= (($524)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $526=(($525)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $527=(($526)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $528=(($527)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($528) { __label__ = 105; break; } else { __label__ = 106; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 105: 
      var $530=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $531=$F8; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $532=(($531+12)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($532)>>2)]=$530; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $533=$F8; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $534=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $535=(($534+8)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($535)>>2)]=$533; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 107; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 106: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 107: 
      __label__ = 120; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 108: 
      var $539=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $540=(($539+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $541=(($540+4)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $RP9=$541; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $542=HEAP32[(($541)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $R7=$542; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $543=(($542)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($543) { __label__ = 110; break; } else { __label__ = 109; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 109: 
      var $545=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $546=(($545+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $547=(($546)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $RP9=$547; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $548=HEAP32[(($547)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $R7=$548; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $549=(($548)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($549) { __label__ = 110; break; } else { __label__ = 119; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 110: 
      __label__ = 111; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 111: 
      var $552=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $553=(($552+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $554=(($553+4)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $CP10=$554; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $555=HEAP32[(($554)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $556=(($555)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($556) { var $564 = 1;__label__ = 113; break; } else { __label__ = 112; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 112: 
      var $558=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $559=(($558+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $560=(($559)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $CP10=$560; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $561=HEAP32[(($560)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $562=(($561)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $564 = $562;__label__ = 113; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 113: 
      var $564;
      if ($564) { __label__ = 114; break; } else { __label__ = 115; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 114: 
      var $566=$CP10; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $RP9=$566; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $567=HEAP32[(($566)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $R7=$567; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 111; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 115: 
      var $569=$RP9; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $570=$569; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $571=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $572=(($570)>>>0) >= (($571)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $573=(($572)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $574=(($573)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $575=(($574)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($575) { __label__ = 116; break; } else { __label__ = 117; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 116: 
      var $577=$RP9; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($577)>>2)]=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 118; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 117: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 118: 
      __label__ = 119; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 119: 
      __label__ = 120; break;
    case 120: 
      var $582=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $583=(($582)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($583) { __label__ = 121; break; } else { __label__ = 148; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 121: 
      var $585=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $586=(($585+28)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $587=HEAP32[(($586)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $588=((((__gm_+304)|0)+($587<<2))|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $H11=$588; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $589=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $590=$H11; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $591=HEAP32[(($590)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $592=(($589)|0)==(($591)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($592) { __label__ = 122; break; } else { __label__ = 125; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 122: 
      var $594=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $595=$H11; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($595)>>2)]=$594; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $596=(($594)|0)==0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($596) { __label__ = 123; break; } else { __label__ = 124; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 123: 
      var $598=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $599=(($598+28)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $600=HEAP32[(($599)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $601=1 << $600; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $602=$601 ^ -1; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $603=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $604=$603 & $602; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+4)|0))>>2)]=$604; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 124; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 124: 
      __label__ = 132; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 125: 
      var $607=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $608=$607; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $609=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $610=(($608)>>>0) >= (($609)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $611=(($610)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $612=(($611)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $613=(($612)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($613) { __label__ = 126; break; } else { __label__ = 130; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 126: 
      var $615=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $616=(($615+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $617=(($616)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $618=HEAP32[(($617)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $619=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $620=(($618)|0)==(($619)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($620) { __label__ = 127; break; } else { __label__ = 128; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 127: 
      var $622=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $623=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $624=(($623+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $625=(($624)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($625)>>2)]=$622; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 129; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 128: 
      var $627=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $628=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $629=(($628+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $630=(($629+4)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($630)>>2)]=$627; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 129; break;
    case 129: 
      __label__ = 131; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 130: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 131: 
      __label__ = 132; break;
    case 132: 
      var $635=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $636=(($635)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($636) { __label__ = 133; break; } else { __label__ = 147; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 133: 
      var $638=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $639=$638; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $640=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $641=(($639)>>>0) >= (($640)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $642=(($641)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $643=(($642)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $644=(($643)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($644) { __label__ = 134; break; } else { __label__ = 145; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 134: 
      var $646=$XP6; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $647=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $648=(($647+24)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($648)>>2)]=$646; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $649=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $650=(($649+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $651=(($650)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $652=HEAP32[(($651)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $C012=$652; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $653=(($652)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($653) { __label__ = 135; break; } else { __label__ = 139; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 135: 
      var $655=$C012; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $656=$655; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $657=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $658=(($656)>>>0) >= (($657)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $659=(($658)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $660=(($659)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $661=(($660)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($661) { __label__ = 136; break; } else { __label__ = 137; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 136: 
      var $663=$C012; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $664=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $665=(($664+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $666=(($665)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($666)>>2)]=$663; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $667=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $668=$C012; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $669=(($668+24)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($669)>>2)]=$667; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 138; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 137: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 138: 
      __label__ = 139; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 139: 
      var $673=$TP5; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $674=(($673+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $675=(($674+4)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $676=HEAP32[(($675)>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      $C113=$676; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $677=(($676)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($677) { __label__ = 140; break; } else { __label__ = 144; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 140: 
      var $679=$C113; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $680=$679; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $681=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $682=(($680)>>>0) >= (($681)>>>0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $683=(($682)&1); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $684=(($683)==(1)); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $685=(($684)|0)!=0; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      if ($685) { __label__ = 141; break; } else { __label__ = 142; break; } //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 141: 
      var $687=$C113; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $688=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $689=(($688+16)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $690=(($689+4)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($690)>>2)]=$687; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $691=$R7; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $692=$C113; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      var $693=(($692+24)|0); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($693)>>2)]=$691; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 143; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 142: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 143: 
      __label__ = 144; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 144: 
      __label__ = 146; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 145: 
      _abort(); //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 146: 
      __label__ = 147; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 147: 
      __label__ = 148; break; //@line 4807 "/root/emscripten/system/lib/dlmalloc.c"
    case 148: 
      __label__ = 149; break;
    case 149: 
      var $702=$psize; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $703=$702 | 1; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $704=$p; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $705=(($704+4)|0); //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($705)>>2)]=$703; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $706=$psize; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $707=$p; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $708=$707; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $709=$psize; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $710=(($708+$709)|0); //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $711=$710; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $712=(($711)|0); //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($712)>>2)]=$706; //@line 4808 "/root/emscripten/system/lib/dlmalloc.c"
      var $713=$p; //@line 4809 "/root/emscripten/system/lib/dlmalloc.c"
      var $714=HEAP32[((((__gm_+20)|0))>>2)]; //@line 4809 "/root/emscripten/system/lib/dlmalloc.c"
      var $715=(($713)|0)==(($714)|0); //@line 4809 "/root/emscripten/system/lib/dlmalloc.c"
      if ($715) { __label__ = 150; break; } else { __label__ = 151; break; } //@line 4809 "/root/emscripten/system/lib/dlmalloc.c"
    case 150: 
      var $717=$psize; //@line 4810 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+8)|0))>>2)]=$717; //@line 4810 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 196; break; //@line 4811 "/root/emscripten/system/lib/dlmalloc.c"
    case 151: 
      __label__ = 152; break;
    case 152: 
      __label__ = 153; break;
    case 153: 
      __label__ = 155; break; //@line 4814 "/root/emscripten/system/lib/dlmalloc.c"
    case 154: 
      var $722=$next; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $723=(($722+4)|0); //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $724=HEAP32[(($723)>>2)]; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $725=$724 & -2; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($723)>>2)]=$725; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $726=$psize; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $727=$726 | 1; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $728=$p; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $729=(($728+4)|0); //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($729)>>2)]=$727; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $730=$psize; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $731=$p; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $732=$731; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $733=$psize; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $734=(($732+$733)|0); //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $735=$734; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      var $736=(($735)|0); //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($736)>>2)]=$730; //@line 4816 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 155; break;
    case 155: 
      var $738=$psize; //@line 4818 "/root/emscripten/system/lib/dlmalloc.c"
      var $739=$738 >>> 3; //@line 4818 "/root/emscripten/system/lib/dlmalloc.c"
      var $740=(($739)>>>0) < 32; //@line 4818 "/root/emscripten/system/lib/dlmalloc.c"
      if ($740) { __label__ = 156; break; } else { __label__ = 163; break; } //@line 4818 "/root/emscripten/system/lib/dlmalloc.c"
    case 156: 
      var $742=$psize; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $743=$742 >>> 3; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      $I14=$743; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $744=$I14; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $745=$744 << 1; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $746=((((__gm_+40)|0)+($745<<2))|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $747=$746; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $748=$747; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      $B15=$748; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $749=$B15; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      $F16=$749; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $750=HEAP32[((((__gm_)|0))>>2)]; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $751=$I14; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $752=1 << $751; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $753=$750 & $752; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $754=(($753)|0)!=0; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      if ($754) { __label__ = 158; break; } else { __label__ = 157; break; } //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
    case 157: 
      var $756=$I14; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $757=1 << $756; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $758=HEAP32[((((__gm_)|0))>>2)]; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $759=$758 | $757; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_)|0))>>2)]=$759; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 162; break; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
    case 158: 
      var $761=$B15; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $762=(($761+8)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $763=HEAP32[(($762)>>2)]; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $764=$763; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $765=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $766=(($764)>>>0) >= (($765)>>>0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $767=(($766)&1); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $768=(($767)==(1)); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $769=(($768)|0)!=0; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      if ($769) { __label__ = 159; break; } else { __label__ = 160; break; } //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
    case 159: 
      var $771=$B15; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $772=(($771+8)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $773=HEAP32[(($772)>>2)]; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      $F16=$773; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 161; break; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
    case 160: 
      _abort(); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
    case 161: 
      __label__ = 162; break;
    case 162: 
      var $777=$p; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $778=$B15; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $779=(($778+8)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($779)>>2)]=$777; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $780=$p; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $781=$F16; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $782=(($781+12)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($782)>>2)]=$780; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $783=$F16; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $784=$p; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $785=(($784+8)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($785)>>2)]=$783; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $786=$B15; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $787=$p; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      var $788=(($787+12)|0); //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($788)>>2)]=$786; //@line 4819 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 192; break; //@line 4821 "/root/emscripten/system/lib/dlmalloc.c"
    case 163: 
      var $790=$p; //@line 4823 "/root/emscripten/system/lib/dlmalloc.c"
      var $791=$790; //@line 4823 "/root/emscripten/system/lib/dlmalloc.c"
      $tp=$791; //@line 4823 "/root/emscripten/system/lib/dlmalloc.c"
      var $792=$psize; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $793=$792 >>> 8; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $X=$793; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $794=$X; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $795=(($794)|0)==0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($795) { __label__ = 164; break; } else { __label__ = 165; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 164: 
      $I18=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 169; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 165: 
      var $798=$X; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $799=(($798)>>>0) > 65535; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($799) { __label__ = 166; break; } else { __label__ = 167; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 166: 
      $I18=31; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 168; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 167: 
      var $802=$X; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$802; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $803=$Y; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $804=((($803)-(256))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $805=$804 >>> 16; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $806=$805 & 8; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$806; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $807=$N; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $808=$Y; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $809=$808 << $807; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$809; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $810=((($809)-(4096))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $811=$810 >>> 16; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $812=$811 & 4; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$812; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $813=$K; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $814=$N; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $815=((($814)+($813))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$815; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $816=$K; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $817=$Y; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $818=$817 << $816; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$818; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $819=((($818)-(16384))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $820=$819 >>> 16; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $821=$820 & 2; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$821; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $822=$N; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $823=((($822)+($821))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$823; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $824=$N; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $825=(((14)-($824))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $826=$K; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $827=$Y; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $828=$827 << $826; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$828; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $829=$828 >>> 15; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $830=((($825)+($829))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$830; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $831=$K; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $832=$831 << 1; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $833=$psize; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $834=$K; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $835=((($834)+(7))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $836=$833 >>> (($835)>>>0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $837=$836 & 1; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $838=((($832)+($837))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $I18=$838; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 168; break;
    case 168: 
      __label__ = 169; break;
    case 169: 
      var $841=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $842=((((__gm_+304)|0)+($841<<2))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $H17=$842; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $843=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $844=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $845=(($844+28)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($845)>>2)]=$843; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $846=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $847=(($846+16)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $848=(($847+4)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($848)>>2)]=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $849=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $850=(($849+16)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $851=(($850)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($851)>>2)]=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $852=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $853=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $854=1 << $853; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $855=$852 & $854; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $856=(($855)|0)!=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($856) { __label__ = 171; break; } else { __label__ = 170; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 170: 
      var $858=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $859=1 << $858; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $860=HEAP32[((((__gm_+4)|0))>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $861=$860 | $859; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+4)|0))>>2)]=$861; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $862=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $863=$H17; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($863)>>2)]=$862; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $864=$H17; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $865=$864; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $866=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $867=(($866+24)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($867)>>2)]=$865; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $868=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $869=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $870=(($869+12)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($870)>>2)]=$868; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $871=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $872=(($871+8)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($872)>>2)]=$868; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 189; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 171: 
      var $874=$H17; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $875=HEAP32[(($874)>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$875; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $876=$psize; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $877=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $878=(($877)|0)==31; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($878) { __label__ = 172; break; } else { __label__ = 173; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 172: 
      var $887 = 0;__label__ = 174; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 173: 
      var $881=$I18; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $882=$881 >>> 1; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $883=((($882)+(8))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $884=((($883)-(2))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $885=(((31)-($884))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $887 = $885;__label__ = 174; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 174: 
      var $887; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $888=$876 << $887; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $K19=$888; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 175; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 175: 
      var $890=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $891=(($890+4)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $892=HEAP32[(($891)>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $893=$892 & -8; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $894=$psize; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $895=(($893)|0)!=(($894)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($895) { __label__ = 176; break; } else { __label__ = 182; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 176: 
      var $897=$K19; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $898=$897 >>> 31; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $899=$898 & 1; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $900=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $901=(($900+16)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $902=(($901+($899<<2))|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $C=$902; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $903=$K19; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $904=$903 << 1; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $K19=$904; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $905=$C; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $906=HEAP32[(($905)>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $907=(($906)|0)!=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($907) { __label__ = 177; break; } else { __label__ = 178; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 177: 
      var $909=$C; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $910=HEAP32[(($909)>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$910; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 181; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 178: 
      var $912=$C; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $913=$912; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $914=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $915=(($913)>>>0) >= (($914)>>>0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $916=(($915)&1); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $917=(($916)==(1)); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $918=(($917)|0)!=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($918) { __label__ = 179; break; } else { __label__ = 180; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 179: 
      var $920=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $921=$C; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($921)>>2)]=$920; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $922=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $923=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $924=(($923+24)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($924)>>2)]=$922; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $925=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $926=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $927=(($926+12)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($927)>>2)]=$925; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $928=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $929=(($928+8)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($929)>>2)]=$925; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 188; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 180: 
      _abort(); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 181: 
      __label__ = 187; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 182: 
      var $933=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $934=(($933+8)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $935=HEAP32[(($934)>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      $F20=$935; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $936=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $937=$936; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $938=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $939=(($937)>>>0) >= (($938)>>>0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      if ($939) { __label__ = 183; break; } else { var $946 = 0;__label__ = 184; break; } //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 183: 
      var $941=$F20; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $942=$941; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $943=HEAP32[((((__gm_+16)|0))>>2)]; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $944=(($942)>>>0) >= (($943)>>>0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $946 = $944;__label__ = 184; break;
    case 184: 
      var $946;
      var $947=(($946)&1);
      var $948=(($947)==(1));
      var $949=(($948)|0)!=0;
      if ($949) { __label__ = 185; break; } else { __label__ = 186; break; }
    case 185: 
      var $951=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $952=$F20; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $953=(($952+12)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($953)>>2)]=$951; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $954=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $955=(($954+8)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($955)>>2)]=$951; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $956=$F20; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $957=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $958=(($957+8)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($958)>>2)]=$956; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $959=$T; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $960=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $961=(($960+12)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($961)>>2)]=$959; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $962=$tp; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      var $963=(($962+24)|0); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($963)>>2)]=0; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 188; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 186: 
      _abort(); //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 187: 
      __label__ = 175; break; //@line 4824 "/root/emscripten/system/lib/dlmalloc.c"
    case 188: 
      __label__ = 189; break;
    case 189: 
      var $968=HEAP32[((((__gm_+32)|0))>>2)]; //@line 4826 "/root/emscripten/system/lib/dlmalloc.c"
      var $969=((($968)-(1))|0); //@line 4826 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+32)|0))>>2)]=$969; //@line 4826 "/root/emscripten/system/lib/dlmalloc.c"
      var $970=(($969)|0)==0; //@line 4826 "/root/emscripten/system/lib/dlmalloc.c"
      if ($970) { __label__ = 190; break; } else { __label__ = 191; break; } //@line 4826 "/root/emscripten/system/lib/dlmalloc.c"
    case 190: 
      var $972=_release_unused_segments(__gm_); //@line 4827 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 191; break; //@line 4827 "/root/emscripten/system/lib/dlmalloc.c"
    case 191: 
      __label__ = 192; break;
    case 192: 
      __label__ = 196; break; //@line 4829 "/root/emscripten/system/lib/dlmalloc.c"
    case 193: 
      __label__ = 194; break; //@line 4831 "/root/emscripten/system/lib/dlmalloc.c"
    case 194: 
      __label__ = 195; break; //@line 4831 "/root/emscripten/system/lib/dlmalloc.c"
    case 195: 
      _abort(); //@line 4833 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4833 "/root/emscripten/system/lib/dlmalloc.c"
    case 196: 
      __label__ = 197; break; //@line 4837 "/root/emscripten/system/lib/dlmalloc.c"
    case 197: 
      ;
      return; //@line 4841 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
Module["_free"] = _free;_free["X"]=1;

function _sys_trim($m, $pad) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $released;
      var $unit;
      var $extra;
      var $sp;
      var $old_br;
      var $rel_br;
      var $new_br;
      $1=$m;
      $2=$pad;
      $released=0; //@line 4126 "/root/emscripten/system/lib/dlmalloc.c"
      var $3=HEAP32[((((_mparams)|0))>>2)]; //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=(($3)|0)!=0; //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
      if ($4) { var $9 = 1;__label__ = 4; break; } else { __label__ = 3; break; } //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $6=_init_mparams(); //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=(($6)|0)!=0; //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
      var $9 = $7;__label__ = 4; break; //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $9;
      var $10=(($9)&1); //@line 4127 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=$2; //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=(($11)>>>0) < 4294967232; //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      if ($12) { __label__ = 5; break; } else { __label__ = 26; break; } //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $14=$1; //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=(($14+24)|0); //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=HEAP32[(($15)>>2)]; //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=(($16)|0)!=0; //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
      if ($17) { __label__ = 6; break; } else { __label__ = 26; break; } //@line 4128 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $19=$2; //@line 4129 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=((($19)+(40))|0); //@line 4129 "/root/emscripten/system/lib/dlmalloc.c"
      $2=$20; //@line 4129 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=$1; //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=(($21+12)|0); //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=HEAP32[(($22)>>2)]; //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=$2; //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=(($23)>>>0) > (($24)>>>0); //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
      if ($25) { __label__ = 7; break; } else { __label__ = 22; break; } //@line 4131 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $27=HEAP32[((((_mparams+8)|0))>>2)]; //@line 4133 "/root/emscripten/system/lib/dlmalloc.c"
      $unit=$27; //@line 4133 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$1; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=(($28+12)|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=HEAP32[(($29)>>2)]; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=$2; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=((($30)-($31))|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$unit; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=((($33)-(1))|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=((($32)+($34))|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$unit; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=Math.floor(((($35)>>>0))/((($36)>>>0))); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=((($37)-(1))|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=$unit; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=((($38)*($39))|0); //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      $extra=$40; //@line 4135 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$1; //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$1; //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=(($42+24)|0); //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=HEAP32[(($43)>>2)]; //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$44; //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=_segment_holding($41, $45); //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$46; //@line 4136 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=$sp; //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=(($47+12)|0); //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=HEAP32[(($48)>>2)]; //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$49 & 8; //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=(($50)|0)!=0; //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
      if ($51) { __label__ = 19; break; } else { __label__ = 8; break; } //@line 4138 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $53=$sp; //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=(($53+12)|0); //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=HEAP32[(($54)>>2)]; //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$55 & 0; //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56)|0)!=0; //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
      if ($57) { __label__ = 9; break; } else { __label__ = 10; break; } //@line 4139 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      __label__ = 18; break; //@line 4151 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $60=$extra; //@line 4153 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=(($60)>>>0) >= 2147483647; //@line 4153 "/root/emscripten/system/lib/dlmalloc.c"
      if ($61) { __label__ = 11; break; } else { __label__ = 12; break; } //@line 4153 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $63=$unit; //@line 4154 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=(((-2147483648)-($63))|0); //@line 4154 "/root/emscripten/system/lib/dlmalloc.c"
      $extra=$64; //@line 4154 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 12; break; //@line 4154 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $66=_sbrk(0); //@line 4158 "/root/emscripten/system/lib/dlmalloc.c"
      $old_br=$66; //@line 4158 "/root/emscripten/system/lib/dlmalloc.c"
      var $67=$old_br; //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=$sp; //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=(($68)|0); //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=HEAP32[(($69)>>2)]; //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=$sp; //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=(($71+4)|0); //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=HEAP32[(($72)>>2)]; //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=(($70+$73)|0); //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=(($67)|0)==(($74)|0); //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
      if ($75) { __label__ = 13; break; } else { __label__ = 17; break; } //@line 4159 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $77=$extra; //@line 4160 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=(((-$77))|0); //@line 4160 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=_sbrk($78); //@line 4160 "/root/emscripten/system/lib/dlmalloc.c"
      $rel_br=$79; //@line 4160 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=_sbrk(0); //@line 4161 "/root/emscripten/system/lib/dlmalloc.c"
      $new_br=$80; //@line 4161 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=$rel_br; //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=(($81)|0)!=-1; //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
      if ($82) { __label__ = 14; break; } else { __label__ = 16; break; } //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $84=$new_br; //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
      var $85=$old_br; //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=(($84)>>>0) < (($85)>>>0); //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
      if ($86) { __label__ = 15; break; } else { __label__ = 16; break; } //@line 4162 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $88=$old_br; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=$new_br; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=$88; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=$89; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=((($90)-($91))|0); //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      $released=$92; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 16; break; //@line 4163 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      __label__ = 17; break; //@line 4164 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      __label__ = 18; break;
    case 18: 
      __label__ = 19; break; //@line 4168 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $97=$released; //@line 4170 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=(($97)|0)!=0; //@line 4170 "/root/emscripten/system/lib/dlmalloc.c"
      if ($98) { __label__ = 20; break; } else { __label__ = 21; break; } //@line 4170 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      var $100=$released; //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$sp; //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=(($101+4)|0); //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=HEAP32[(($102)>>2)]; //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=((($103)-($100))|0); //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($102)>>2)]=$104; //@line 4171 "/root/emscripten/system/lib/dlmalloc.c"
      var $105=$released; //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=$1; //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=(($106+432)|0); //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=HEAP32[(($107)>>2)]; //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      var $109=((($108)-($105))|0); //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($107)>>2)]=$109; //@line 4172 "/root/emscripten/system/lib/dlmalloc.c"
      var $110=$1; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=$1; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=(($111+24)|0); //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=HEAP32[(($112)>>2)]; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=$1; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=(($114+12)|0); //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=HEAP32[(($115)>>2)]; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=$released; //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=((($116)-($117))|0); //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      _init_top($110, $113, $118); //@line 4173 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 21; break; //@line 4175 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      __label__ = 22; break; //@line 4176 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      var $121=$released; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=(($121)|0)==0; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      if ($122) { __label__ = 23; break; } else { __label__ = 25; break; } //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      var $124=$1; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=(($124+12)|0); //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=HEAP32[(($125)>>2)]; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=$1; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=(($127+28)|0); //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=HEAP32[(($128)>>2)]; //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=(($126)>>>0) > (($129)>>>0); //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
      if ($130) { __label__ = 24; break; } else { __label__ = 25; break; } //@line 4183 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $132=$1; //@line 4184 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=(($132+28)|0); //@line 4184 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($133)>>2)]=-1; //@line 4184 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 25; break; //@line 4184 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      __label__ = 26; break; //@line 4185 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $136=$released; //@line 4187 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=(($136)|0)!=0; //@line 4187 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=$137 ? 1 : 0; //@line 4187 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $138; //@line 4187 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_sys_trim["X"]=1;

function _segment_holding($m, $addr) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $sp;
      $2=$m;
      $3=$addr;
      var $4=$2; //@line 2562 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=(($4+444)|0); //@line 2562 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$5; //@line 2562 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 2563 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $7=$3; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$sp; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(($8)|0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=HEAP32[(($9)>>2)]; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=(($7)>>>0) >= (($10)>>>0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      if ($11) { __label__ = 4; break; } else { __label__ = 6; break; } //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $13=$3; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=$sp; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=(($14)|0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=HEAP32[(($15)>>2)]; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=$sp; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=(($17+4)|0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=HEAP32[(($18)>>2)]; //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=(($16+$19)|0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=(($13)>>>0) < (($20)>>>0); //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
      if ($21) { __label__ = 5; break; } else { __label__ = 6; break; } //@line 2564 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $23=$sp; //@line 2565 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$23; //@line 2565 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 9; break; //@line 2565 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $25=$sp; //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=(($25+8)|0); //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=HEAP32[(($26)>>2)]; //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$27; //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=(($27)|0)==0; //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
      if ($28) { __label__ = 7; break; } else { __label__ = 8; break; } //@line 2566 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      $1=0; //@line 2567 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 9; break; //@line 2567 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      __label__ = 3; break; //@line 2568 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $32=$1; //@line 2569 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $32; //@line 2569 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}


function _release_unused_segments($m) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $released;
      var $nsegs;
      var $pred;
      var $sp;
      var $base;
      var $size;
      var $next;
      var $p;
      var $psize;
      var $tp;
      var $XP;
      var $R;
      var $F;
      var $RP;
      var $CP;
      var $H;
      var $C0;
      var $C1;
      var $H1;
      var $I;
      var $X;
      var $Y;
      var $N;
      var $K;
      var $T;
      var $K2;
      var $C;
      var $F3;
      $1=$m;
      $released=0; //@line 4079 "/root/emscripten/system/lib/dlmalloc.c"
      $nsegs=0; //@line 4080 "/root/emscripten/system/lib/dlmalloc.c"
      var $2=$1; //@line 4081 "/root/emscripten/system/lib/dlmalloc.c"
      var $3=(($2+444)|0); //@line 4081 "/root/emscripten/system/lib/dlmalloc.c"
      $pred=$3; //@line 4081 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=$pred; //@line 4082 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=(($4+8)|0); //@line 4082 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=HEAP32[(($5)>>2)]; //@line 4082 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$6; //@line 4082 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 4083 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $8=$sp; //@line 4083 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(($8)|0)!=0; //@line 4083 "/root/emscripten/system/lib/dlmalloc.c"
      if ($9) { __label__ = 4; break; } else { __label__ = 88; break; } //@line 4083 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $11=$sp; //@line 4084 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=(($11)|0); //@line 4084 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=HEAP32[(($12)>>2)]; //@line 4084 "/root/emscripten/system/lib/dlmalloc.c"
      $base=$13; //@line 4084 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=$sp; //@line 4085 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=(($14+4)|0); //@line 4085 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=HEAP32[(($15)>>2)]; //@line 4085 "/root/emscripten/system/lib/dlmalloc.c"
      $size=$16; //@line 4085 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=$sp; //@line 4086 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=(($17+8)|0); //@line 4086 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=HEAP32[(($18)>>2)]; //@line 4086 "/root/emscripten/system/lib/dlmalloc.c"
      $next=$19; //@line 4086 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$nsegs; //@line 4087 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=((($20)+(1))|0); //@line 4087 "/root/emscripten/system/lib/dlmalloc.c"
      $nsegs=$21; //@line 4087 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=$sp; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=(($22+12)|0); //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=HEAP32[(($23)>>2)]; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$24 & 0; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=(($25)|0)!=0; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      if ($26) { __label__ = 5; break; } else { __label__ = 87; break; } //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $28=$sp; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=(($28+12)|0); //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=HEAP32[(($29)>>2)]; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=$30 & 8; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=(($31)|0)!=0; //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
      if ($32) { __label__ = 87; break; } else { __label__ = 6; break; } //@line 4088 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $34=$base; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=$base; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=(($35+8)|0); //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$36; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=$37 & 7; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=(($38)|0)==0; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      if ($39) { __label__ = 7; break; } else { __label__ = 8; break; } //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $49 = 0;__label__ = 9; break; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $42=$base; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=(($42+8)|0); //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=$43; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$44 & 7; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=(((8)-($45))|0); //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=$46 & 7; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $49 = $47;__label__ = 9; break; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $49; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=(($34+$49)|0); //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=$50; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$51; //@line 4089 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=$p; //@line 4090 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=(($52+4)|0); //@line 4090 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=HEAP32[(($53)>>2)]; //@line 4090 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=$54 & -8; //@line 4090 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$55; //@line 4090 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$p; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56+4)|0); //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=HEAP32[(($57)>>2)]; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=$58 & 3; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=(($59)|0)!=1; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      if ($60) { __label__ = 86; break; } else { __label__ = 10; break; } //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $62=$p; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$62; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=$psize; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=(($63+$64)|0); //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $66=$base; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $67=$size; //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=(($66+$67)|0); //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=((($68)-(40))|0); //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=(($65)>>>0) >= (($69)>>>0); //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
      if ($70) { __label__ = 11; break; } else { __label__ = 86; break; } //@line 4092 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $72=$p; //@line 4093 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=$72; //@line 4093 "/root/emscripten/system/lib/dlmalloc.c"
      $tp=$73; //@line 4093 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=$p; //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=$1; //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=(($75+20)|0); //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=HEAP32[(($76)>>2)]; //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=(($74)|0)==(($77)|0); //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
      if ($78) { __label__ = 12; break; } else { __label__ = 13; break; } //@line 4095 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $80=$1; //@line 4096 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=(($80+20)|0); //@line 4096 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($81)>>2)]=0; //@line 4096 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=$1; //@line 4097 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=(($82+8)|0); //@line 4097 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($83)>>2)]=0; //@line 4097 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 59; break; //@line 4098 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $85=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=(($85+24)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=HEAP32[(($86)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $XP=$87; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=(($88+12)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=HEAP32[(($89)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=(($90)|0)!=(($91)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($92) { __label__ = 14; break; } else { __label__ = 18; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $94=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=(($94+8)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $96=HEAP32[(($95)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$96; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $97=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=(($97+12)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=HEAP32[(($98)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$99; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=$F; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$100; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=(($102+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=HEAP32[(($103)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $105=(($101)>>>0) >= (($104)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=(($105)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=(($106)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=(($107)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($108) { __label__ = 15; break; } else { __label__ = 16; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $110=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $111=$F; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $112=(($111+12)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($112)>>2)]=$110; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=$F; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=(($114+8)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($115)>>2)]=$113; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 17; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      __label__ = 30; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $119=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=(($119+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=(($120+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$121; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=HEAP32[(($121)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$122; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $123=(($122)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($123) { __label__ = 20; break; } else { __label__ = 19; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $125=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=(($125+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=(($126)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$127; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=HEAP32[(($127)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$128; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=(($128)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($129) { __label__ = 20; break; } else { __label__ = 29; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      __label__ = 21; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 21: 
      var $132=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=(($132+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=(($133+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$134; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=HEAP32[(($134)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=(($135)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($136) { var $144 = 1;__label__ = 23; break; } else { __label__ = 22; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      var $138=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=(($138+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $140=(($139)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$140; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=HEAP32[(($140)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=(($141)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $144 = $142;__label__ = 23; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      var $144;
      if ($144) { __label__ = 24; break; } else { __label__ = 25; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $146=$CP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$146; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=HEAP32[(($146)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$147; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 21; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      var $149=$RP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $150=$149; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=(($151+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=HEAP32[(($152)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=(($150)>>>0) >= (($153)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=(($154)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=(($155)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=(($156)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($157) { __label__ = 26; break; } else { __label__ = 27; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $159=$RP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($159)>>2)]=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 28; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      __label__ = 29; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      __label__ = 30; break;
    case 30: 
      var $164=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=(($164)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($165) { __label__ = 31; break; } else { __label__ = 58; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $167=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=(($167+28)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=HEAP32[(($168)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $171=(($170+304)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=(($171+($169<<2))|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$172; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $173=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $174=$H; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $175=HEAP32[(($174)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=(($173)|0)==(($175)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($176) { __label__ = 32; break; } else { __label__ = 35; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $178=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $179=$H; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($179)>>2)]=$178; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $180=(($178)|0)==0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($180) { __label__ = 33; break; } else { __label__ = 34; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      var $182=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=(($182+28)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=HEAP32[(($183)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $185=1 << $184; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=$185 ^ -1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $187=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $188=(($187+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=HEAP32[(($188)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $190=$189 & $186; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($188)>>2)]=$190; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 34; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      __label__ = 42; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $193=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=$193; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=(($195+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $197=HEAP32[(($196)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $198=(($194)>>>0) >= (($197)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=(($198)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $200=(($199)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $201=(($200)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($201) { __label__ = 36; break; } else { __label__ = 40; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $203=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=(($203+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=(($204)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=HEAP32[(($205)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=(($206)|0)==(($207)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($208) { __label__ = 37; break; } else { __label__ = 38; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $210=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=(($211+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $213=(($212)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($213)>>2)]=$210; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 39; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $215=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $216=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $217=(($216+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $218=(($217+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($218)>>2)]=$215; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 39; break;
    case 39: 
      __label__ = 41; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 41: 
      __label__ = 42; break;
    case 42: 
      var $223=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=(($223)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($224) { __label__ = 43; break; } else { __label__ = 57; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 43: 
      var $226=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=$226; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=(($228+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=HEAP32[(($229)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=(($227)>>>0) >= (($230)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $232=(($231)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $233=(($232)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=(($233)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($234) { __label__ = 44; break; } else { __label__ = 55; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      var $236=$XP; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=(($237+24)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($238)>>2)]=$236; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $239=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $240=(($239+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $241=(($240)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $242=HEAP32[(($241)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $C0=$242; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=(($242)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($243) { __label__ = 45; break; } else { __label__ = 49; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      var $245=$C0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=$245; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($247+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $249=HEAP32[(($248)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=(($246)>>>0) >= (($249)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=(($250)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $252=(($251)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $253=(($252)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($253) { __label__ = 46; break; } else { __label__ = 47; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $255=$C0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $256=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $257=(($256+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=(($257)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($258)>>2)]=$255; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=$C0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=(($260+24)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($261)>>2)]=$259; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 48; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      __label__ = 49; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $265=$tp; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $266=(($265+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $267=(($266+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $268=HEAP32[(($267)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      $C1=$268; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $269=(($268)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($269) { __label__ = 50; break; } else { __label__ = 54; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      var $271=$C1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=$271; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=$1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $274=(($273+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $275=HEAP32[(($274)>>2)]; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($272)>>>0) >= (($275)>>>0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $277=(($276)&1); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $278=(($277)==(1)); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=(($278)|0)!=0; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      if ($279) { __label__ = 51; break; } else { __label__ = 52; break; } //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      var $281=$C1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=(($282+16)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=(($283+4)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($284)>>2)]=$281; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=$R; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=$C1; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=(($286+24)|0); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($287)>>2)]=$285; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 53; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 52: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 53: 
      __label__ = 54; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      __label__ = 56; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 55: 
      _abort(); //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      __label__ = 57; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      __label__ = 58; break; //@line 4100 "/root/emscripten/system/lib/dlmalloc.c"
    case 58: 
      __label__ = 59; break;
    case 59: 
      var $296=$psize; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=$296 >>> 8; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $X=$297; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $298=$X; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $299=(($298)|0)==0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($299) { __label__ = 60; break; } else { __label__ = 61; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      $I=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 65; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      var $302=$X; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $303=(($302)>>>0) > 65535; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($303) { __label__ = 62; break; } else { __label__ = 63; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      $I=31; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 64; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 63: 
      var $306=$X; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$306; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=$Y; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $308=((($307)-(256))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $309=$308 >>> 16; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=$309 & 8; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$310; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $311=$N; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=$Y; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=$312 << $311; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$313; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=((($313)-(4096))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=$314 >>> 16; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=$315 & 4; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$316; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=$K; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $318=$N; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $319=((($318)+($317))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$319; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=$K; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=$Y; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=$321 << $320; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$322; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=((($322)-(16384))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=$323 >>> 16; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=$324 & 2; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$325; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=$N; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $327=((($326)+($325))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$327; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $328=$N; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $329=(((14)-($328))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $330=$K; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $331=$Y; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $332=$331 << $330; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$332; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $333=$332 >>> 15; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $334=((($329)+($333))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$334; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=$K; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=$335 << 1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $337=$psize; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $338=$K; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=((($338)+(7))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=$337 >>> (($339)>>>0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=$340 & 1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=((($336)+($341))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$342; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 64; break;
    case 64: 
      __label__ = 65; break;
    case 65: 
      var $345=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=(($346+304)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=(($347+($345<<2))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $H1=$348; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=(($350+28)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($351)>>2)]=$349; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $353=(($352+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $354=(($353+4)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($354)>>2)]=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=(($355+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $357=(($356)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($357)>>2)]=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=(($358+4)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=HEAP32[(($359)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $362=1 << $361; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $363=$360 & $362; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=(($363)|0)!=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($364) { __label__ = 67; break; } else { __label__ = 66; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 66: 
      var $366=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=1 << $366; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=(($368+4)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=HEAP32[(($369)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=$370 | $367; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($369)>>2)]=$371; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $373=$H1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($373)>>2)]=$372; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=$H1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=$374; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $377=(($376+24)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($377)>>2)]=$375; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $378=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $379=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=(($379+12)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($380)>>2)]=$378; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=(($381+8)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($382)>>2)]=$378; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 85; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 67: 
      var $384=$H1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=HEAP32[(($384)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$385; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=$psize; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $388=(($387)|0)==31; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($388) { __label__ = 68; break; } else { __label__ = 69; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 68: 
      var $397 = 0;__label__ = 70; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      var $391=$I; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $392=$391 >>> 1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $393=((($392)+(8))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=((($393)-(2))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=(((31)-($394))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $397 = $395;__label__ = 70; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 70: 
      var $397; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $398=$386 << $397; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$398; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 71; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 71: 
      var $400=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $401=(($400+4)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $402=HEAP32[(($401)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $403=$402 & -8; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $404=$psize; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $405=(($403)|0)!=(($404)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($405) { __label__ = 72; break; } else { __label__ = 78; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 72: 
      var $407=$K2; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $408=$407 >>> 31; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $409=$408 & 1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $410=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $411=(($410+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $412=(($411+($409<<2))|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $C=$412; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $413=$K2; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=$413 << 1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$414; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=$C; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $416=HEAP32[(($415)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $417=(($416)|0)!=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($417) { __label__ = 73; break; } else { __label__ = 74; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 73: 
      var $419=$C; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $420=HEAP32[(($419)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$420; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 77; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 74: 
      var $422=$C; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $423=$422; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=(($424+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $426=HEAP32[(($425)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $427=(($423)>>>0) >= (($426)>>>0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=(($427)&1); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=(($428)==(1)); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $430=(($429)|0)!=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($430) { __label__ = 75; break; } else { __label__ = 76; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 75: 
      var $432=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $433=$C; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($433)>>2)]=$432; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $435=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $436=(($435+24)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($436)>>2)]=$434; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $437=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $439=(($438+12)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($439)>>2)]=$437; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $440=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=(($440+8)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($441)>>2)]=$437; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 84; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 76: 
      _abort(); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 77: 
      __label__ = 83; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 78: 
      var $445=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $446=(($445+8)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $447=HEAP32[(($446)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      $F3=$447; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $448=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $449=$448; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $450=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $451=(($450+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $452=HEAP32[(($451)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $453=(($449)>>>0) >= (($452)>>>0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      if ($453) { __label__ = 79; break; } else { var $462 = 0;__label__ = 80; break; } //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 79: 
      var $455=$F3; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $456=$455; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $457=$1; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $458=(($457+16)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $459=HEAP32[(($458)>>2)]; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $460=(($456)>>>0) >= (($459)>>>0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $462 = $460;__label__ = 80; break;
    case 80: 
      var $462;
      var $463=(($462)&1);
      var $464=(($463)==(1));
      var $465=(($464)|0)!=0;
      if ($465) { __label__ = 81; break; } else { __label__ = 82; break; }
    case 81: 
      var $467=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $468=$F3; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $469=(($468+12)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($469)>>2)]=$467; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $470=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $471=(($470+8)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($471)>>2)]=$467; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $472=$F3; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $473=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $474=(($473+8)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($474)>>2)]=$472; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $475=$T; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $476=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $477=(($476+12)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($477)>>2)]=$475; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $478=$tp; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      var $479=(($478+24)|0); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($479)>>2)]=0; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 84; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 82: 
      _abort(); //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 83: 
      __label__ = 71; break; //@line 4110 "/root/emscripten/system/lib/dlmalloc.c"
    case 84: 
      __label__ = 85; break;
    case 85: 
      __label__ = 86; break; //@line 4112 "/root/emscripten/system/lib/dlmalloc.c"
    case 86: 
      __label__ = 87; break; //@line 4113 "/root/emscripten/system/lib/dlmalloc.c"
    case 87: 
      var $486=$sp; //@line 4116 "/root/emscripten/system/lib/dlmalloc.c"
      $pred=$486; //@line 4116 "/root/emscripten/system/lib/dlmalloc.c"
      var $487=$next; //@line 4117 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$487; //@line 4117 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 4118 "/root/emscripten/system/lib/dlmalloc.c"
    case 88: 
      var $489=$nsegs; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      var $490=(($489)>>>0) > 4294967295; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      if ($490) { __label__ = 89; break; } else { __label__ = 90; break; } //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
    case 89: 
      var $492=$nsegs; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      var $495 = $492;__label__ = 91; break; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
    case 90: 
      var $495 = -1;__label__ = 91; break; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
    case 91: 
      var $495; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      var $496=$1; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      var $497=(($496+32)|0); //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($497)>>2)]=$495; //@line 4120 "/root/emscripten/system/lib/dlmalloc.c"
      var $498=$released; //@line 4122 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $498; //@line 4122 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_release_unused_segments["X"]=1;

function _init_mparams() {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $magic;
      var $psize;
      var $gsize;
      var $1=HEAP32[((((_mparams)|0))>>2)]; //@line 2965 "/root/emscripten/system/lib/dlmalloc.c"
      var $2=(($1)|0)==0; //@line 2965 "/root/emscripten/system/lib/dlmalloc.c"
      if ($2) { __label__ = 3; break; } else { __label__ = 7; break; } //@line 2965 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $4=_sysconf(8); //@line 2971 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$4; //@line 2971 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=$psize; //@line 2972 "/root/emscripten/system/lib/dlmalloc.c"
      $gsize=$5; //@line 2972 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=$gsize; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=$gsize; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=((($7)-(1))|0); //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=$6 & $8; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=(($9)|0)!=0; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      if ($10) { __label__ = 5; break; } else { __label__ = 4; break; } //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $12=$psize; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=$psize; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=((($13)-(1))|0); //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$12 & $14; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=(($15)|0)!=0; //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
      if ($16) { __label__ = 5; break; } else { __label__ = 6; break; } //@line 2989 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      _abort(); //@line 2997 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 2997 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $19=$gsize; //@line 2999 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams+8)|0))>>2)]=$19; //@line 2999 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$psize; //@line 3000 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams+4)|0))>>2)]=$20; //@line 3000 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams+12)|0))>>2)]=-1; //@line 3001 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams+16)|0))>>2)]=2097152; //@line 3002 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams+20)|0))>>2)]=0; //@line 3004 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=HEAP32[((((_mparams+20)|0))>>2)]; //@line 3011 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((__gm_+440)|0))>>2)]=$21; //@line 3011 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=_time(0); //@line 3030 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$22 ^ 1431655765; //@line 3030 "/root/emscripten/system/lib/dlmalloc.c"
      $magic=$23; //@line 3030 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=$magic; //@line 3032 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$24 | 8; //@line 3032 "/root/emscripten/system/lib/dlmalloc.c"
      $magic=$25; //@line 3032 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$magic; //@line 3033 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$26 & -8; //@line 3033 "/root/emscripten/system/lib/dlmalloc.c"
      $magic=$27; //@line 3033 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$magic; //@line 3034 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[((((_mparams)|0))>>2)]=$28; //@line 3034 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 7; break; //@line 3036 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      ;
      return 1; //@line 3039 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}


function _init_top($m, $p, $psize) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $offset;
      $1=$m;
      $2=$p;
      $3=$psize;
      var $4=$2; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=$4; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=(($5+8)|0); //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=$6; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$7 & 7; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(($8)|0)==0; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      if ($9) { __label__ = 3; break; } else { __label__ = 4; break; } //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $20 = 0;__label__ = 5; break; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $12=$2; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=$12; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=(($13+8)|0); //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$14; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$15 & 7; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=(((8)-($16))|0); //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=$17 & 7; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $20 = $18;__label__ = 5; break; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $20; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      $offset=$20; //@line 3736 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=$2; //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=$21; //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$offset; //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=(($22+$23)|0); //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$24; //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      $2=$25; //@line 3737 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$offset; //@line 3738 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$3; //@line 3738 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=((($27)-($26))|0); //@line 3738 "/root/emscripten/system/lib/dlmalloc.c"
      $3=$28; //@line 3738 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=$2; //@line 3740 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$1; //@line 3740 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=(($30+24)|0); //@line 3740 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($31)>>2)]=$29; //@line 3740 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=$3; //@line 3741 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$1; //@line 3741 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=(($33+12)|0); //@line 3741 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($34)>>2)]=$32; //@line 3741 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=$3; //@line 3742 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$35 | 1; //@line 3742 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$2; //@line 3742 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=(($37+4)|0); //@line 3742 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($38)>>2)]=$36; //@line 3742 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=$2; //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$39; //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$3; //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=(($40+$41)|0); //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$42; //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=(($43+4)|0); //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($44)>>2)]=40; //@line 3744 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=HEAP32[((((_mparams+16)|0))>>2)]; //@line 3745 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=$1; //@line 3745 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=(($46+28)|0); //@line 3745 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($47)>>2)]=$45; //@line 3745 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return; //@line 3746 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_init_top["X"]=1;

function _mmap_alloc($m, $nb) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $mmsize;
      var $mm;
      var $offset;
      var $psize;
      var $p;
      $2=$m;
      $3=$nb;
      var $4=$3; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $5=((($4)+(24))|0); //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=((($5)+(7))|0); //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=HEAP32[((((_mparams+4)|0))>>2)]; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=((($7)-(1))|0); //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=((($6)+($8))|0); //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=HEAP32[((((_mparams+4)|0))>>2)]; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=((($10)-(1))|0); //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=$11 ^ -1; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=$9 & $12; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      $mmsize=$13; //@line 3672 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=$mmsize; //@line 3673 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$3; //@line 3673 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=(($14)>>>0) > (($15)>>>0); //@line 3673 "/root/emscripten/system/lib/dlmalloc.c"
      if ($16) { __label__ = 3; break; } else { __label__ = 14; break; } //@line 3673 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      $mm=-1; //@line 3674 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=$mm; //@line 3675 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=(($18)|0)!=-1; //@line 3675 "/root/emscripten/system/lib/dlmalloc.c"
      if ($19) { __label__ = 4; break; } else { __label__ = 13; break; } //@line 3675 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $21=$mm; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=(($21+8)|0); //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$22; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=$23 & 7; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=(($24)|0)==0; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      if ($25) { __label__ = 5; break; } else { __label__ = 6; break; } //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $35 = 0;__label__ = 7; break; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $28=$mm; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=(($28+8)|0); //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $30=$29; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $31=$30 & 7; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=(((8)-($31))|0); //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$32 & 7; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $35 = $33;__label__ = 7; break; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $35; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      $offset=$35; //@line 3676 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$mmsize; //@line 3677 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$offset; //@line 3677 "/root/emscripten/system/lib/dlmalloc.c"
      var $38=((($36)-($37))|0); //@line 3677 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=((($38)-(16))|0); //@line 3677 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$39; //@line 3677 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$mm; //@line 3678 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$offset; //@line 3678 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=(($40+$41)|0); //@line 3678 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$42; //@line 3678 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$43; //@line 3678 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=$offset; //@line 3679 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$p; //@line 3679 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=(($45)|0); //@line 3679 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($46)>>2)]=$44; //@line 3679 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=$psize; //@line 3680 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=$p; //@line 3680 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=(($48+4)|0); //@line 3680 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($49)>>2)]=$47; //@line 3680 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$p; //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=$50; //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=$psize; //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=(($51+$52)|0); //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=$53; //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=(($54+4)|0); //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($55)>>2)]=7; //@line 3682 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$p; //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=$56; //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=$psize; //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=((($58)+(4))|0); //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=(($57+$59)|0); //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=$60; //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=(($61+4)|0); //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($62)>>2)]=0; //@line 3683 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$2; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=(($63+16)|0); //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=HEAP32[(($64)>>2)]; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $66=(($65)|0)==0; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      if ($66) { __label__ = 9; break; } else { __label__ = 8; break; } //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $68=$mm; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=$2; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=(($69+16)|0); //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=HEAP32[(($70)>>2)]; //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=(($68)>>>0) < (($71)>>>0); //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
      if ($72) { __label__ = 9; break; } else { __label__ = 10; break; } //@line 3685 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $74=$mm; //@line 3686 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=$2; //@line 3686 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=(($75+16)|0); //@line 3686 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($76)>>2)]=$74; //@line 3686 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 10; break; //@line 3686 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $78=$mmsize; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=$2; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=(($79+432)|0); //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=HEAP32[(($80)>>2)]; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=((($81)+($78))|0); //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($80)>>2)]=$82; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=$2; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=(($83+436)|0); //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $85=HEAP32[(($84)>>2)]; //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=(($82)>>>0) > (($85)>>>0); //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
      if ($86) { __label__ = 11; break; } else { __label__ = 12; break; } //@line 3687 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $88=$2; //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=(($88+432)|0); //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=HEAP32[(($89)>>2)]; //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=$2; //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=(($91+436)|0); //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($92)>>2)]=$90; //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 12; break; //@line 3688 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $94=$p; //@line 3691 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=$94; //@line 3691 "/root/emscripten/system/lib/dlmalloc.c"
      var $96=(($95+8)|0); //@line 3691 "/root/emscripten/system/lib/dlmalloc.c"
      $1=$96; //@line 3691 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 15; break; //@line 3691 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      __label__ = 14; break; //@line 3693 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      $1=0; //@line 3694 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 15; break; //@line 3694 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $100=$1; //@line 3695 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $100; //@line 3695 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_mmap_alloc["X"]=1;

function _init_bins($m) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $i;
      var $bin;
      $1=$m;
      $i=0; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $3=$i; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      var $4=(($3)>>>0) < 32; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      if ($4) { __label__ = 4; break; } else { __label__ = 6; break; } //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $6=$i; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=$6 << 1; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$1; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=(($8+40)|0); //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=(($9+($7<<2))|0); //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=$10; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=$11; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      $bin=$12; //@line 3753 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=$bin; //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=$bin; //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=(($14+12)|0); //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($15)>>2)]=$13; //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$bin; //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=(($16+8)|0); //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($17)>>2)]=$13; //@line 3754 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 5; break; //@line 3755 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $19=$i; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=((($19)+(1))|0); //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      $i=$20; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 3; break; //@line 3752 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      ;
      return; //@line 3756 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}


function _prepend_alloc($m, $newbase, $oldbase, $nb) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $p;
      var $oldfirst;
      var $psize;
      var $q;
      var $qsize;
      var $tsize;
      var $dsize;
      var $nsize;
      var $F;
      var $B;
      var $I;
      var $TP;
      var $XP;
      var $R;
      var $F1;
      var $RP;
      var $CP;
      var $H;
      var $C0;
      var $C1;
      var $I2;
      var $B3;
      var $F4;
      var $TP5;
      var $H6;
      var $I7;
      var $X;
      var $Y;
      var $N;
      var $K;
      var $T;
      var $K8;
      var $C;
      var $F9;
      $1=$m;
      $2=$newbase;
      $3=$oldbase;
      $4=$nb;
      var $5=$2; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=$2; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=(($6+8)|0); //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$7; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=$8 & 7; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=(($9)|0)==0; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      if ($10) { __label__ = 3; break; } else { __label__ = 4; break; } //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $20 = 0;__label__ = 5; break; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $13=$2; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=(($13+8)|0); //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$14; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=$15 & 7; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=(((8)-($16))|0); //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=$17 & 7; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $20 = $18;__label__ = 5; break; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $20; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=(($5+$20)|0); //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=$21; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$22; //@line 3780 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=$3; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=$3; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=(($24+8)|0); //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=$25; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$26 & 7; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=(($27)|0)==0; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      if ($28) { __label__ = 6; break; } else { __label__ = 7; break; } //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $38 = 0;__label__ = 8; break; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $31=$3; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $32=(($31+8)|0); //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=$32; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=$33 & 7; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=(((8)-($34))|0); //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=$35 & 7; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $38 = $36;__label__ = 8; break; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $38; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $39=(($23+$38)|0); //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$39; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      $oldfirst=$40; //@line 3781 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$oldfirst; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=$41; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$p; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=$43; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=$42; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=$44; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $47=((($45)-($46))|0); //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$47; //@line 3782 "/root/emscripten/system/lib/dlmalloc.c"
      var $48=$p; //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      var $49=$48; //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      var $50=$4; //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      var $51=(($49+$50)|0); //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      var $52=$51; //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      $q=$52; //@line 3783 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=$psize; //@line 3784 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=$4; //@line 3784 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=((($53)-($54))|0); //@line 3784 "/root/emscripten/system/lib/dlmalloc.c"
      $qsize=$55; //@line 3784 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$4; //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=$56 | 1; //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=$57 | 2; //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=$p; //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=(($59+4)|0); //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($60)>>2)]=$58; //@line 3785 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=$oldfirst; //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=$1; //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=(($62+24)|0); //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=HEAP32[(($63)>>2)]; //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=(($61)|0)==(($64)|0); //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
      if ($65) { __label__ = 9; break; } else { __label__ = 10; break; } //@line 3792 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $67=$qsize; //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=$1; //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=(($68+12)|0); //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=HEAP32[(($69)>>2)]; //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=((($70)+($67))|0); //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($69)>>2)]=$71; //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      $tsize=$71; //@line 3793 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=$q; //@line 3794 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=$1; //@line 3794 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=(($73+24)|0); //@line 3794 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($74)>>2)]=$72; //@line 3794 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=$tsize; //@line 3795 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=$75 | 1; //@line 3795 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=$q; //@line 3795 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=(($77+4)|0); //@line 3795 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($78)>>2)]=$76; //@line 3795 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 110; break; //@line 3797 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $80=$oldfirst; //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=$1; //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=(($81+20)|0); //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=HEAP32[(($82)>>2)]; //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=(($80)|0)==(($83)|0); //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
      if ($84) { __label__ = 11; break; } else { __label__ = 12; break; } //@line 3798 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      var $86=$qsize; //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=$1; //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=(($87+8)|0); //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=HEAP32[(($88)>>2)]; //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=((($89)+($86))|0); //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($88)>>2)]=$90; //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      $dsize=$90; //@line 3799 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=$q; //@line 3800 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=$1; //@line 3800 "/root/emscripten/system/lib/dlmalloc.c"
      var $93=(($92+20)|0); //@line 3800 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($93)>>2)]=$91; //@line 3800 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=$dsize; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=$94 | 1; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $96=$q; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $97=(($96+4)|0); //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($97)>>2)]=$95; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=$dsize; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=$q; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=$99; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$dsize; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=(($100+$101)|0); //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=$102; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=(($103)|0); //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($104)>>2)]=$98; //@line 3801 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 109; break; //@line 3802 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      var $106=$oldfirst; //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=(($106+4)|0); //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=HEAP32[(($107)>>2)]; //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
      var $109=$108 & 3; //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
      var $110=(($109)|0)!=1; //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
      if ($110) { __label__ = 73; break; } else { __label__ = 13; break; } //@line 3804 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $112=$oldfirst; //@line 3805 "/root/emscripten/system/lib/dlmalloc.c"
      var $113=(($112+4)|0); //@line 3805 "/root/emscripten/system/lib/dlmalloc.c"
      var $114=HEAP32[(($113)>>2)]; //@line 3805 "/root/emscripten/system/lib/dlmalloc.c"
      var $115=$114 & -8; //@line 3805 "/root/emscripten/system/lib/dlmalloc.c"
      $nsize=$115; //@line 3805 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=$nsize; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=$116 >>> 3; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $118=(($117)>>>0) < 32; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($118) { __label__ = 14; break; } else { __label__ = 26; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $120=$oldfirst; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=(($120+8)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=HEAP32[(($121)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$122; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $123=$oldfirst; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $124=(($123+12)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=HEAP32[(($124)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$125; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=$nsize; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=$126 >>> 3; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$127; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=$F; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=$B; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=(($128)|0)==(($129)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($130) { __label__ = 15; break; } else { __label__ = 16; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $132=$I; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=1 << $132; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=$133 ^ -1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=(($135)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=HEAP32[(($136)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=$137 & $134; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($136)>>2)]=$138; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 25; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      var $140=$F; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=$I; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=$141 << 1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=(($143+40)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=(($144+($142<<2))|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=$145; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=$146; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=(($140)|0)==(($147)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($148) { __label__ = 18; break; } else { __label__ = 17; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $150=$F; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=$150; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=(($152+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=HEAP32[(($153)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=(($151)>>>0) >= (($154)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($155) { __label__ = 18; break; } else { var $176 = 0;__label__ = 21; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $157=$B; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=$I; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=$158 << 1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=(($160+40)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=(($161+($159<<2))|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=$162; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $164=$163; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=(($157)|0)==(($164)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($165) { var $174 = 1;__label__ = 20; break; } else { __label__ = 19; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      var $167=$B; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $168=$167; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=(($169+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $171=HEAP32[(($170)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=(($168)>>>0) >= (($171)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $174 = $172;__label__ = 20; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      var $174;
      var $176 = $174;__label__ = 21; break;
    case 21: 
      var $176;
      var $177=(($176)&1);
      var $178=(($177)==(1));
      var $179=(($178)|0)!=0;
      if ($179) { __label__ = 22; break; } else { __label__ = 23; break; }
    case 22: 
      var $181=$B; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $182=$F; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=(($182+12)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($183)>>2)]=$181; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=$F; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $185=$B; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $186=(($185+8)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($186)>>2)]=$184; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 24; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      __label__ = 25; break;
    case 25: 
      __label__ = 72; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $191=$oldfirst; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $192=$191; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $TP=$192; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $193=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=(($193+24)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=HEAP32[(($194)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $XP=$195; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $197=(($196+12)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $198=HEAP32[(($197)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $200=(($198)|0)!=(($199)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($200) { __label__ = 27; break; } else { __label__ = 31; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 27: 
      var $202=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $203=(($202+8)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=HEAP32[(($203)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $F1=$204; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $205=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $206=(($205+12)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=HEAP32[(($206)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$207; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=$F1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=$208; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=(($210+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $212=HEAP32[(($211)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $213=(($209)>>>0) >= (($212)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $214=(($213)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $215=(($214)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $216=(($215)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($216) { __label__ = 28; break; } else { __label__ = 29; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 28: 
      var $218=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $219=$F1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $220=(($219+12)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($220)>>2)]=$218; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=$F1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=(($222+8)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($223)>>2)]=$221; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 30; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      __label__ = 43; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $227=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=(($227+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=(($228+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$229; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=HEAP32[(($229)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$230; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=(($230)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($231) { __label__ = 33; break; } else { __label__ = 32; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $233=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=(($233+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $235=(($234)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$235; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=HEAP32[(($235)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$236; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=(($236)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($237) { __label__ = 33; break; } else { __label__ = 42; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      __label__ = 34; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $240=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $241=(($240+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $242=(($241+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$242; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=HEAP32[(($242)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=(($243)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($244) { var $252 = 1;__label__ = 36; break; } else { __label__ = 35; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $246=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=(($246+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=(($247)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $CP=$248; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $249=HEAP32[(($248)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=(($249)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $252 = $250;__label__ = 36; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $252;
      if ($252) { __label__ = 37; break; } else { __label__ = 38; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $254=$CP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $RP=$254; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $255=HEAP32[(($254)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $R=$255; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 34; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $257=$RP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=$257; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=(($259+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=HEAP32[(($260)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $262=(($258)>>>0) >= (($261)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=(($262)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=(($263)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=(($264)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($265) { __label__ = 39; break; } else { __label__ = 40; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      var $267=$RP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($267)>>2)]=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 41; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 41: 
      __label__ = 42; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      __label__ = 43; break;
    case 43: 
      var $272=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=(($272)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($273) { __label__ = 44; break; } else { __label__ = 71; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 44: 
      var $275=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($275+28)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $277=HEAP32[(($276)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $278=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=(($278+304)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=(($279+($277<<2))|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$280; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $281=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=$H; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=HEAP32[(($282)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=(($281)|0)==(($283)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($284) { __label__ = 45; break; } else { __label__ = 48; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      var $286=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=$H; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($287)>>2)]=$286; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=(($286)|0)==0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($288) { __label__ = 46; break; } else { __label__ = 47; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      var $290=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $291=(($290+28)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=HEAP32[(($291)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=1 << $292; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=$293 ^ -1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $295=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $296=(($295+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=HEAP32[(($296)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $298=$297 & $294; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($296)>>2)]=$298; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 47; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      __label__ = 55; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 48: 
      var $301=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $302=$301; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $303=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $304=(($303+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $305=HEAP32[(($304)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $306=(($302)>>>0) >= (($305)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=(($306)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $308=(($307)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $309=(($308)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($309) { __label__ = 49; break; } else { __label__ = 53; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 49: 
      var $311=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $312=(($311+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=(($312)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=HEAP32[(($313)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=(($314)|0)==(($315)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($316) { __label__ = 50; break; } else { __label__ = 51; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      var $318=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $319=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=(($319+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=(($320)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($321)>>2)]=$318; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 52; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 51: 
      var $323=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=(($324+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=(($325+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($326)>>2)]=$323; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 52; break;
    case 52: 
      __label__ = 54; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 53: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 54: 
      __label__ = 55; break;
    case 55: 
      var $331=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $332=(($331)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($332) { __label__ = 56; break; } else { __label__ = 70; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 56: 
      var $334=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=$334; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $337=(($336+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $338=HEAP32[(($337)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=(($335)>>>0) >= (($338)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=(($339)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=(($340)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=(($341)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($342) { __label__ = 57; break; } else { __label__ = 68; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 57: 
      var $344=$XP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=(($345+24)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($346)>>2)]=$344; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=(($347+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=(($348)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=HEAP32[(($349)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $C0=$350; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=(($350)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($351) { __label__ = 58; break; } else { __label__ = 62; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 58: 
      var $353=$C0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $354=$353; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $355=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $356=(($355+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $357=HEAP32[(($356)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=(($354)>>>0) >= (($357)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=(($358)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=(($359)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=(($360)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($361) { __label__ = 59; break; } else { __label__ = 60; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 59: 
      var $363=$C0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=(($364+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $366=(($365)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($366)>>2)]=$363; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $367=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$C0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=(($368+24)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($369)>>2)]=$367; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 61; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 60: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 61: 
      __label__ = 62; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 62: 
      var $373=$TP; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $374=(($373+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $375=(($374+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $376=HEAP32[(($375)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      $C1=$376; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $377=(($376)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($377) { __label__ = 63; break; } else { __label__ = 67; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 63: 
      var $379=$C1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=$379; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=$1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=(($381+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $383=HEAP32[(($382)>>2)]; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $384=(($380)>>>0) >= (($383)>>>0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=(($384)&1); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=(($385)==(1)); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=(($386)|0)!=0; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      if ($387) { __label__ = 64; break; } else { __label__ = 65; break; } //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 64: 
      var $389=$C1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $391=(($390+16)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $392=(($391+4)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($392)>>2)]=$389; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $393=$R; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $394=$C1; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      var $395=(($394+24)|0); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($395)>>2)]=$393; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 66; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 65: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 66: 
      __label__ = 67; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 67: 
      __label__ = 69; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 68: 
      _abort(); //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 69: 
      __label__ = 70; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 70: 
      __label__ = 71; break; //@line 3806 "/root/emscripten/system/lib/dlmalloc.c"
    case 71: 
      __label__ = 72; break;
    case 72: 
      var $404=$oldfirst; //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      var $405=$404; //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      var $406=$nsize; //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      var $407=(($405+$406)|0); //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      var $408=$407; //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      $oldfirst=$408; //@line 3807 "/root/emscripten/system/lib/dlmalloc.c"
      var $409=$nsize; //@line 3808 "/root/emscripten/system/lib/dlmalloc.c"
      var $410=$qsize; //@line 3808 "/root/emscripten/system/lib/dlmalloc.c"
      var $411=((($410)+($409))|0); //@line 3808 "/root/emscripten/system/lib/dlmalloc.c"
      $qsize=$411; //@line 3808 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 73; break; //@line 3809 "/root/emscripten/system/lib/dlmalloc.c"
    case 73: 
      var $413=$oldfirst; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $414=(($413+4)|0); //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $415=HEAP32[(($414)>>2)]; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $416=$415 & -2; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($414)>>2)]=$416; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $417=$qsize; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $418=$417 | 1; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $419=$q; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $420=(($419+4)|0); //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($420)>>2)]=$418; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $421=$qsize; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $422=$q; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $423=$422; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $424=$qsize; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $425=(($423+$424)|0); //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $426=$425; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $427=(($426)|0); //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($427)>>2)]=$421; //@line 3810 "/root/emscripten/system/lib/dlmalloc.c"
      var $428=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $429=$428 >>> 3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $430=(($429)>>>0) < 32; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($430) { __label__ = 74; break; } else { __label__ = 81; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 74: 
      var $432=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $433=$432 >>> 3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $I2=$433; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $434=$I2; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $435=$434 << 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $436=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $437=(($436+40)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $438=(($437+($435<<2))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $439=$438; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $440=$439; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $B3=$440; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $441=$B3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $F4=$441; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $442=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $443=(($442)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $444=HEAP32[(($443)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $445=$I2; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $446=1 << $445; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $447=$444 & $446; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $448=(($447)|0)!=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($448) { __label__ = 76; break; } else { __label__ = 75; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 75: 
      var $450=$I2; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $451=1 << $450; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $452=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $453=(($452)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $454=HEAP32[(($453)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $455=$454 | $451; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($453)>>2)]=$455; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 80; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 76: 
      var $457=$B3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $458=(($457+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $459=HEAP32[(($458)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $460=$459; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $461=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $462=(($461+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $463=HEAP32[(($462)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $464=(($460)>>>0) >= (($463)>>>0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $465=(($464)&1); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $466=(($465)==(1)); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $467=(($466)|0)!=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($467) { __label__ = 77; break; } else { __label__ = 78; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 77: 
      var $469=$B3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $470=(($469+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $471=HEAP32[(($470)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $F4=$471; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 79; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 78: 
      _abort(); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 79: 
      __label__ = 80; break;
    case 80: 
      var $475=$q; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $476=$B3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $477=(($476+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($477)>>2)]=$475; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $478=$q; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $479=$F4; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $480=(($479+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($480)>>2)]=$478; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $481=$F4; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $482=$q; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $483=(($482+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($483)>>2)]=$481; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $484=$B3; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $485=$q; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $486=(($485+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($486)>>2)]=$484; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 108; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 81: 
      var $488=$q; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $489=$488; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $TP5=$489; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $490=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $491=$490 >>> 8; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $X=$491; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $492=$X; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $493=(($492)|0)==0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($493) { __label__ = 82; break; } else { __label__ = 83; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 82: 
      $I7=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 87; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 83: 
      var $496=$X; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $497=(($496)>>>0) > 65535; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($497) { __label__ = 84; break; } else { __label__ = 85; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 84: 
      $I7=31; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 86; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 85: 
      var $500=$X; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$500; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $501=$Y; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $502=((($501)-(256))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $503=$502 >>> 16; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $504=$503 & 8; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$504; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $505=$N; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $506=$Y; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $507=$506 << $505; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$507; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $508=((($507)-(4096))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $509=$508 >>> 16; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $510=$509 & 4; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$510; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $511=$K; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $512=$N; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $513=((($512)+($511))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$513; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $514=$K; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $515=$Y; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $516=$515 << $514; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$516; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $517=((($516)-(16384))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $518=$517 >>> 16; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $519=$518 & 2; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$519; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $520=$N; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $521=((($520)+($519))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$521; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $522=$N; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $523=(((14)-($522))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $524=$K; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $525=$Y; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $526=$525 << $524; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$526; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $527=$526 >>> 15; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $528=((($523)+($527))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$528; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $529=$K; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $530=$529 << 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $531=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $532=$K; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $533=((($532)+(7))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $534=$531 >>> (($533)>>>0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $535=$534 & 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $536=((($530)+($535))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $I7=$536; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 86; break;
    case 86: 
      __label__ = 87; break;
    case 87: 
      var $539=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $540=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $541=(($540+304)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $542=(($541+($539<<2))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $H6=$542; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $543=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $544=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $545=(($544+28)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($545)>>2)]=$543; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $546=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $547=(($546+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $548=(($547+4)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($548)>>2)]=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $549=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $550=(($549+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $551=(($550)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($551)>>2)]=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $552=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $553=(($552+4)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $554=HEAP32[(($553)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $555=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $556=1 << $555; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $557=$554 & $556; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $558=(($557)|0)!=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($558) { __label__ = 89; break; } else { __label__ = 88; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 88: 
      var $560=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $561=1 << $560; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $562=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $563=(($562+4)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $564=HEAP32[(($563)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $565=$564 | $561; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($563)>>2)]=$565; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $566=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $567=$H6; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($567)>>2)]=$566; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $568=$H6; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $569=$568; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $570=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $571=(($570+24)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($571)>>2)]=$569; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $572=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $573=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $574=(($573+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($574)>>2)]=$572; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $575=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $576=(($575+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($576)>>2)]=$572; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 107; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 89: 
      var $578=$H6; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $579=HEAP32[(($578)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$579; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $580=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $581=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $582=(($581)|0)==31; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($582) { __label__ = 90; break; } else { __label__ = 91; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 90: 
      var $591 = 0;__label__ = 92; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 91: 
      var $585=$I7; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $586=$585 >>> 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $587=((($586)+(8))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $588=((($587)-(2))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $589=(((31)-($588))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $591 = $589;__label__ = 92; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 92: 
      var $591; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $592=$580 << $591; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $K8=$592; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 93; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 93: 
      var $594=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $595=(($594+4)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $596=HEAP32[(($595)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $597=$596 & -8; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $598=$qsize; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $599=(($597)|0)!=(($598)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($599) { __label__ = 94; break; } else { __label__ = 100; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 94: 
      var $601=$K8; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $602=$601 >>> 31; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $603=$602 & 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $604=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $605=(($604+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $606=(($605+($603<<2))|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $C=$606; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $607=$K8; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $608=$607 << 1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $K8=$608; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $609=$C; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $610=HEAP32[(($609)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $611=(($610)|0)!=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($611) { __label__ = 95; break; } else { __label__ = 96; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 95: 
      var $613=$C; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $614=HEAP32[(($613)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$614; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 99; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 96: 
      var $616=$C; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $617=$616; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $618=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $619=(($618+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $620=HEAP32[(($619)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $621=(($617)>>>0) >= (($620)>>>0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $622=(($621)&1); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $623=(($622)==(1)); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $624=(($623)|0)!=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($624) { __label__ = 97; break; } else { __label__ = 98; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 97: 
      var $626=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $627=$C; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($627)>>2)]=$626; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $628=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $629=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $630=(($629+24)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($630)>>2)]=$628; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $631=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $632=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $633=(($632+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($633)>>2)]=$631; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $634=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $635=(($634+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($635)>>2)]=$631; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 106; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 98: 
      _abort(); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 99: 
      __label__ = 105; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 100: 
      var $639=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $640=(($639+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $641=HEAP32[(($640)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      $F9=$641; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $642=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $643=$642; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $644=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $645=(($644+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $646=HEAP32[(($645)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $647=(($643)>>>0) >= (($646)>>>0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      if ($647) { __label__ = 101; break; } else { var $656 = 0;__label__ = 102; break; } //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 101: 
      var $649=$F9; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $650=$649; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $651=$1; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $652=(($651+16)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $653=HEAP32[(($652)>>2)]; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $654=(($650)>>>0) >= (($653)>>>0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $656 = $654;__label__ = 102; break;
    case 102: 
      var $656;
      var $657=(($656)&1);
      var $658=(($657)==(1));
      var $659=(($658)|0)!=0;
      if ($659) { __label__ = 103; break; } else { __label__ = 104; break; }
    case 103: 
      var $661=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $662=$F9; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $663=(($662+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($663)>>2)]=$661; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $664=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $665=(($664+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($665)>>2)]=$661; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $666=$F9; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $667=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $668=(($667+8)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($668)>>2)]=$666; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $669=$T; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $670=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $671=(($670+12)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($671)>>2)]=$669; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $672=$TP5; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      var $673=(($672+24)|0); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($673)>>2)]=0; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 106; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 104: 
      _abort(); //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 105: 
      __label__ = 93; break; //@line 3811 "/root/emscripten/system/lib/dlmalloc.c"
    case 106: 
      __label__ = 107; break;
    case 107: 
      __label__ = 108; break;
    case 108: 
      __label__ = 109; break;
    case 109: 
      __label__ = 110; break;
    case 110: 
      var $681=$p; //@line 3816 "/root/emscripten/system/lib/dlmalloc.c"
      var $682=$681; //@line 3816 "/root/emscripten/system/lib/dlmalloc.c"
      var $683=(($682+8)|0); //@line 3816 "/root/emscripten/system/lib/dlmalloc.c"
      ;
      return $683; //@line 3816 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_prepend_alloc["X"]=1;

function _add_segment($m, $tbase, $tsize, $mmapped) {
  ;
  var __label__;
  __label__ = 2; 
  while(1) switch(__label__) {
    case 2: 
      var $1;
      var $2;
      var $3;
      var $4;
      var $old_top;
      var $oldsp;
      var $old_end;
      var $ssize;
      var $rawsp;
      var $offset;
      var $asp;
      var $csp;
      var $sp;
      var $ss;
      var $tnext;
      var $p;
      var $nfences;
      var $nextp;
      var $q;
      var $psize;
      var $tn;
      var $I;
      var $B;
      var $F;
      var $TP;
      var $H;
      var $I1;
      var $X;
      var $Y;
      var $N;
      var $K;
      var $T;
      var $K2;
      var $C;
      var $F3;
      $1=$m;
      $2=$tbase;
      $3=$tsize;
      $4=$mmapped;
      var $5=$1; //@line 3822 "/root/emscripten/system/lib/dlmalloc.c"
      var $6=(($5+24)|0); //@line 3822 "/root/emscripten/system/lib/dlmalloc.c"
      var $7=HEAP32[(($6)>>2)]; //@line 3822 "/root/emscripten/system/lib/dlmalloc.c"
      var $8=$7; //@line 3822 "/root/emscripten/system/lib/dlmalloc.c"
      $old_top=$8; //@line 3822 "/root/emscripten/system/lib/dlmalloc.c"
      var $9=$1; //@line 3823 "/root/emscripten/system/lib/dlmalloc.c"
      var $10=$old_top; //@line 3823 "/root/emscripten/system/lib/dlmalloc.c"
      var $11=_segment_holding($9, $10); //@line 3823 "/root/emscripten/system/lib/dlmalloc.c"
      $oldsp=$11; //@line 3823 "/root/emscripten/system/lib/dlmalloc.c"
      var $12=$oldsp; //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $13=(($12)|0); //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $14=HEAP32[(($13)>>2)]; //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $15=$oldsp; //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $16=(($15+4)|0); //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $17=HEAP32[(($16)>>2)]; //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      var $18=(($14+$17)|0); //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      $old_end=$18; //@line 3824 "/root/emscripten/system/lib/dlmalloc.c"
      $ssize=24; //@line 3825 "/root/emscripten/system/lib/dlmalloc.c"
      var $19=$old_end; //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $20=$ssize; //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $21=((($20)+(16))|0); //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $22=((($21)+(7))|0); //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $23=(((-$22))|0); //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $24=(($19+$23)|0); //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      $rawsp=$24; //@line 3826 "/root/emscripten/system/lib/dlmalloc.c"
      var $25=$rawsp; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $26=(($25+8)|0); //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $27=$26; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $28=$27 & 7; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $29=(($28)|0)==0; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      if ($29) { __label__ = 3; break; } else { __label__ = 4; break; } //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
    case 3: 
      var $39 = 0;__label__ = 5; break; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
    case 4: 
      var $32=$rawsp; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $33=(($32+8)|0); //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $34=$33; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $35=$34 & 7; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $36=(((8)-($35))|0); //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $37=$36 & 7; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $39 = $37;__label__ = 5; break; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
    case 5: 
      var $39; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      $offset=$39; //@line 3827 "/root/emscripten/system/lib/dlmalloc.c"
      var $40=$rawsp; //@line 3828 "/root/emscripten/system/lib/dlmalloc.c"
      var $41=$offset; //@line 3828 "/root/emscripten/system/lib/dlmalloc.c"
      var $42=(($40+$41)|0); //@line 3828 "/root/emscripten/system/lib/dlmalloc.c"
      $asp=$42; //@line 3828 "/root/emscripten/system/lib/dlmalloc.c"
      var $43=$asp; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $44=$old_top; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $45=(($44+16)|0); //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $46=(($43)>>>0) < (($45)>>>0); //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      if ($46) { __label__ = 6; break; } else { __label__ = 7; break; } //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
    case 6: 
      var $48=$old_top; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $52 = $48;__label__ = 8; break; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
    case 7: 
      var $50=$asp; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $52 = $50;__label__ = 8; break; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
    case 8: 
      var $52; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      $csp=$52; //@line 3829 "/root/emscripten/system/lib/dlmalloc.c"
      var $53=$csp; //@line 3830 "/root/emscripten/system/lib/dlmalloc.c"
      var $54=$53; //@line 3830 "/root/emscripten/system/lib/dlmalloc.c"
      $sp=$54; //@line 3830 "/root/emscripten/system/lib/dlmalloc.c"
      var $55=$sp; //@line 3831 "/root/emscripten/system/lib/dlmalloc.c"
      var $56=$55; //@line 3831 "/root/emscripten/system/lib/dlmalloc.c"
      var $57=(($56+8)|0); //@line 3831 "/root/emscripten/system/lib/dlmalloc.c"
      var $58=$57; //@line 3831 "/root/emscripten/system/lib/dlmalloc.c"
      $ss=$58; //@line 3831 "/root/emscripten/system/lib/dlmalloc.c"
      var $59=$sp; //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      var $60=$59; //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      var $61=$ssize; //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      var $62=(($60+$61)|0); //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      var $63=$62; //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      $tnext=$63; //@line 3832 "/root/emscripten/system/lib/dlmalloc.c"
      var $64=$tnext; //@line 3833 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$64; //@line 3833 "/root/emscripten/system/lib/dlmalloc.c"
      $nfences=0; //@line 3834 "/root/emscripten/system/lib/dlmalloc.c"
      var $65=$1; //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      var $66=$2; //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      var $67=$66; //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      var $68=$3; //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      var $69=((($68)-(40))|0); //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      _init_top($65, $67, $69); //@line 3837 "/root/emscripten/system/lib/dlmalloc.c"
      var $70=$ssize; //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      var $71=$70 | 1; //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      var $72=$71 | 2; //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      var $73=$sp; //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      var $74=(($73+4)|0); //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($74)>>2)]=$72; //@line 3841 "/root/emscripten/system/lib/dlmalloc.c"
      var $75=$ss; //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      var $76=$1; //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      var $77=(($76+444)|0); //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      var $78=$75; //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      var $79=$77; //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      assert(16 % 1 === 0, 'memcpy given ' + 16 + ' bytes to copy. Problem with quantum=1 corrections perhaps?');HEAP32[(($78)>>2)]=HEAP32[(($79)>>2)];HEAP32[((($78)+(4))>>2)]=HEAP32[((($79)+(4))>>2)];HEAP32[((($78)+(8))>>2)]=HEAP32[((($79)+(8))>>2)];HEAP32[((($78)+(12))>>2)]=HEAP32[((($79)+(12))>>2)]; //@line 3842 "/root/emscripten/system/lib/dlmalloc.c"
      var $80=$2; //@line 3843 "/root/emscripten/system/lib/dlmalloc.c"
      var $81=$1; //@line 3843 "/root/emscripten/system/lib/dlmalloc.c"
      var $82=(($81+444)|0); //@line 3843 "/root/emscripten/system/lib/dlmalloc.c"
      var $83=(($82)|0); //@line 3843 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($83)>>2)]=$80; //@line 3843 "/root/emscripten/system/lib/dlmalloc.c"
      var $84=$3; //@line 3844 "/root/emscripten/system/lib/dlmalloc.c"
      var $85=$1; //@line 3844 "/root/emscripten/system/lib/dlmalloc.c"
      var $86=(($85+444)|0); //@line 3844 "/root/emscripten/system/lib/dlmalloc.c"
      var $87=(($86+4)|0); //@line 3844 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($87)>>2)]=$84; //@line 3844 "/root/emscripten/system/lib/dlmalloc.c"
      var $88=$4; //@line 3845 "/root/emscripten/system/lib/dlmalloc.c"
      var $89=$1; //@line 3845 "/root/emscripten/system/lib/dlmalloc.c"
      var $90=(($89+444)|0); //@line 3845 "/root/emscripten/system/lib/dlmalloc.c"
      var $91=(($90+12)|0); //@line 3845 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($91)>>2)]=$88; //@line 3845 "/root/emscripten/system/lib/dlmalloc.c"
      var $92=$ss; //@line 3846 "/root/emscripten/system/lib/dlmalloc.c"
      var $93=$1; //@line 3846 "/root/emscripten/system/lib/dlmalloc.c"
      var $94=(($93+444)|0); //@line 3846 "/root/emscripten/system/lib/dlmalloc.c"
      var $95=(($94+8)|0); //@line 3846 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($95)>>2)]=$92; //@line 3846 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 9; break; //@line 3849 "/root/emscripten/system/lib/dlmalloc.c"
    case 9: 
      var $97=$p; //@line 3850 "/root/emscripten/system/lib/dlmalloc.c"
      var $98=$97; //@line 3850 "/root/emscripten/system/lib/dlmalloc.c"
      var $99=(($98+4)|0); //@line 3850 "/root/emscripten/system/lib/dlmalloc.c"
      var $100=$99; //@line 3850 "/root/emscripten/system/lib/dlmalloc.c"
      $nextp=$100; //@line 3850 "/root/emscripten/system/lib/dlmalloc.c"
      var $101=$p; //@line 3851 "/root/emscripten/system/lib/dlmalloc.c"
      var $102=(($101+4)|0); //@line 3851 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($102)>>2)]=7; //@line 3851 "/root/emscripten/system/lib/dlmalloc.c"
      var $103=$nfences; //@line 3852 "/root/emscripten/system/lib/dlmalloc.c"
      var $104=((($103)+(1))|0); //@line 3852 "/root/emscripten/system/lib/dlmalloc.c"
      $nfences=$104; //@line 3852 "/root/emscripten/system/lib/dlmalloc.c"
      var $105=$nextp; //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
      var $106=(($105+4)|0); //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
      var $107=$106; //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
      var $108=$old_end; //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
      var $109=(($107)>>>0) < (($108)>>>0); //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
      if ($109) { __label__ = 10; break; } else { __label__ = 11; break; } //@line 3853 "/root/emscripten/system/lib/dlmalloc.c"
    case 10: 
      var $111=$nextp; //@line 3854 "/root/emscripten/system/lib/dlmalloc.c"
      $p=$111; //@line 3854 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 12; break; //@line 3854 "/root/emscripten/system/lib/dlmalloc.c"
    case 11: 
      __label__ = 13; break; //@line 3856 "/root/emscripten/system/lib/dlmalloc.c"
    case 12: 
      __label__ = 9; break; //@line 3857 "/root/emscripten/system/lib/dlmalloc.c"
    case 13: 
      var $115=$csp; //@line 3861 "/root/emscripten/system/lib/dlmalloc.c"
      var $116=$old_top; //@line 3861 "/root/emscripten/system/lib/dlmalloc.c"
      var $117=(($115)|0)!=(($116)|0); //@line 3861 "/root/emscripten/system/lib/dlmalloc.c"
      if ($117) { __label__ = 14; break; } else { __label__ = 50; break; } //@line 3861 "/root/emscripten/system/lib/dlmalloc.c"
    case 14: 
      var $119=$old_top; //@line 3862 "/root/emscripten/system/lib/dlmalloc.c"
      var $120=$119; //@line 3862 "/root/emscripten/system/lib/dlmalloc.c"
      $q=$120; //@line 3862 "/root/emscripten/system/lib/dlmalloc.c"
      var $121=$csp; //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      var $122=$old_top; //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      var $123=$121; //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      var $124=$122; //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      var $125=((($123)-($124))|0); //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      $psize=$125; //@line 3863 "/root/emscripten/system/lib/dlmalloc.c"
      var $126=$q; //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      var $127=$126; //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      var $128=$psize; //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      var $129=(($127+$128)|0); //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      var $130=$129; //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      $tn=$130; //@line 3864 "/root/emscripten/system/lib/dlmalloc.c"
      var $131=$tn; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $132=(($131+4)|0); //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $133=HEAP32[(($132)>>2)]; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $134=$133 & -2; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($132)>>2)]=$134; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $135=$psize; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $136=$135 | 1; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $137=$q; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $138=(($137+4)|0); //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($138)>>2)]=$136; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $139=$psize; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $140=$q; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $141=$140; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $142=$psize; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $143=(($141+$142)|0); //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $144=$143; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $145=(($144)|0); //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($145)>>2)]=$139; //@line 3865 "/root/emscripten/system/lib/dlmalloc.c"
      var $146=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $147=$146 >>> 3; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $148=(($147)>>>0) < 32; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($148) { __label__ = 15; break; } else { __label__ = 22; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 15: 
      var $150=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $151=$150 >>> 3; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $I=$151; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $152=$I; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $153=$152 << 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $154=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $155=(($154+40)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $156=(($155+($153<<2))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $157=$156; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $158=$157; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $B=$158; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $159=$B; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$159; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $160=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $161=(($160)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $162=HEAP32[(($161)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $163=$I; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $164=1 << $163; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $165=$162 & $164; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $166=(($165)|0)!=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($166) { __label__ = 17; break; } else { __label__ = 16; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 16: 
      var $168=$I; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $169=1 << $168; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $170=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $171=(($170)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $172=HEAP32[(($171)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $173=$172 | $169; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($171)>>2)]=$173; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 21; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 17: 
      var $175=$B; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $176=(($175+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $177=HEAP32[(($176)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $178=$177; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $179=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $180=(($179+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $181=HEAP32[(($180)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $182=(($178)>>>0) >= (($181)>>>0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $183=(($182)&1); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $184=(($183)==(1)); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $185=(($184)|0)!=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($185) { __label__ = 18; break; } else { __label__ = 19; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 18: 
      var $187=$B; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $188=(($187+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $189=HEAP32[(($188)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $F=$189; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 20; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 19: 
      _abort(); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 20: 
      __label__ = 21; break;
    case 21: 
      var $193=$q; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $194=$B; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $195=(($194+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($195)>>2)]=$193; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $196=$q; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $197=$F; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $198=(($197+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($198)>>2)]=$196; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $199=$F; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $200=$q; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $201=(($200+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($201)>>2)]=$199; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $202=$B; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $203=$q; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $204=(($203+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($204)>>2)]=$202; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 49; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 22: 
      var $206=$q; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $207=$206; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $TP=$207; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $208=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $209=$208 >>> 8; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $X=$209; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $210=$X; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $211=(($210)|0)==0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($211) { __label__ = 23; break; } else { __label__ = 24; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 23: 
      $I1=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 28; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 24: 
      var $214=$X; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $215=(($214)>>>0) > 65535; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($215) { __label__ = 25; break; } else { __label__ = 26; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 25: 
      $I1=31; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 27; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 26: 
      var $218=$X; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$218; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $219=$Y; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $220=((($219)-(256))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $221=$220 >>> 16; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $222=$221 & 8; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$222; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $223=$N; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $224=$Y; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $225=$224 << $223; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$225; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $226=((($225)-(4096))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $227=$226 >>> 16; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $228=$227 & 4; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$228; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $229=$K; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $230=$N; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $231=((($230)+($229))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$231; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $232=$K; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $233=$Y; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $234=$233 << $232; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$234; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $235=((($234)-(16384))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $236=$235 >>> 16; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $237=$236 & 2; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$237; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $238=$N; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $239=((($238)+($237))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $N=$239; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $240=$N; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $241=(((14)-($240))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $242=$K; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $243=$Y; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $244=$243 << $242; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $Y=$244; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $245=$244 >>> 15; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $246=((($241)+($245))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $K=$246; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $247=$K; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $248=$247 << 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $249=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $250=$K; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $251=((($250)+(7))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $252=$249 >>> (($251)>>>0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $253=$252 & 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $254=((($248)+($253))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $I1=$254; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 27; break;
    case 27: 
      __label__ = 28; break;
    case 28: 
      var $257=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $258=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $259=(($258+304)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $260=(($259+($257<<2))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $H=$260; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $261=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $262=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $263=(($262+28)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($263)>>2)]=$261; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $264=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $265=(($264+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $266=(($265+4)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($266)>>2)]=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $267=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $268=(($267+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $269=(($268)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($269)>>2)]=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $270=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $271=(($270+4)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $272=HEAP32[(($271)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $273=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $274=1 << $273; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $275=$272 & $274; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $276=(($275)|0)!=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($276) { __label__ = 30; break; } else { __label__ = 29; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 29: 
      var $278=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $279=1 << $278; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $280=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $281=(($280+4)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $282=HEAP32[(($281)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $283=$282 | $279; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($281)>>2)]=$283; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $284=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $285=$H; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($285)>>2)]=$284; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $286=$H; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $287=$286; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $288=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $289=(($288+24)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($289)>>2)]=$287; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $290=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $291=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $292=(($291+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($292)>>2)]=$290; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $293=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $294=(($293+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($294)>>2)]=$290; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 48; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 30: 
      var $296=$H; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $297=HEAP32[(($296)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$297; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $298=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $299=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $300=(($299)|0)==31; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($300) { __label__ = 31; break; } else { __label__ = 32; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 31: 
      var $309 = 0;__label__ = 33; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 32: 
      var $303=$I1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $304=$303 >>> 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $305=((($304)+(8))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $306=((($305)-(2))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $307=(((31)-($306))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $309 = $307;__label__ = 33; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 33: 
      var $309; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $310=$298 << $309; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$310; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 34; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 34: 
      var $312=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $313=(($312+4)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $314=HEAP32[(($313)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $315=$314 & -8; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $316=$psize; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $317=(($315)|0)!=(($316)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($317) { __label__ = 35; break; } else { __label__ = 41; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 35: 
      var $319=$K2; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $320=$319 >>> 31; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $321=$320 & 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $322=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $323=(($322+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $324=(($323+($321<<2))|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $C=$324; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $325=$K2; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $326=$325 << 1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $K2=$326; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $327=$C; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $328=HEAP32[(($327)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $329=(($328)|0)!=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($329) { __label__ = 36; break; } else { __label__ = 37; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 36: 
      var $331=$C; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $332=HEAP32[(($331)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $T=$332; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 40; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 37: 
      var $334=$C; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $335=$334; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $336=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $337=(($336+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $338=HEAP32[(($337)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $339=(($335)>>>0) >= (($338)>>>0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $340=(($339)&1); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $341=(($340)==(1)); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $342=(($341)|0)!=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($342) { __label__ = 38; break; } else { __label__ = 39; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 38: 
      var $344=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $345=$C; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($345)>>2)]=$344; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $346=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $347=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $348=(($347+24)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($348)>>2)]=$346; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $349=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $350=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $351=(($350+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($351)>>2)]=$349; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $352=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $353=(($352+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($353)>>2)]=$349; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 47; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 39: 
      _abort(); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 40: 
      __label__ = 46; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 41: 
      var $357=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $358=(($357+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $359=HEAP32[(($358)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      $F3=$359; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $360=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $361=$360; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $362=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $363=(($362+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $364=HEAP32[(($363)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $365=(($361)>>>0) >= (($364)>>>0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      if ($365) { __label__ = 42; break; } else { var $374 = 0;__label__ = 43; break; } //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 42: 
      var $367=$F3; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $368=$367; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $369=$1; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $370=(($369+16)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $371=HEAP32[(($370)>>2)]; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $372=(($368)>>>0) >= (($371)>>>0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $374 = $372;__label__ = 43; break;
    case 43: 
      var $374;
      var $375=(($374)&1);
      var $376=(($375)==(1));
      var $377=(($376)|0)!=0;
      if ($377) { __label__ = 44; break; } else { __label__ = 45; break; }
    case 44: 
      var $379=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $380=$F3; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $381=(($380+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($381)>>2)]=$379; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $382=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $383=(($382+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($383)>>2)]=$379; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $384=$F3; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $385=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $386=(($385+8)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($386)>>2)]=$384; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $387=$T; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $388=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $389=(($388+12)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($389)>>2)]=$387; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $390=$TP; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      var $391=(($390+24)|0); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      HEAP32[(($391)>>2)]=0; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      __label__ = 47; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 45: 
      _abort(); //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
      throw "Reached an unreachable!" //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 46: 
      __label__ = 34; break; //@line 3866 "/root/emscripten/system/lib/dlmalloc.c"
    case 47: 
      __label__ = 48; break;
    case 48: 
      __label__ = 49; break;
    case 49: 
      __label__ = 50; break; //@line 3867 "/root/emscripten/system/lib/dlmalloc.c"
    case 50: 
      ;
      return; //@line 3870 "/root/emscripten/system/lib/dlmalloc.c"
    default: assert(0, "bad label: " + __label__);
  }
}
_add_segment["X"]=1;

// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.
// TODO: strip out parts of this we do not need

//======= begin closure i64 code =======

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

var i64Math = (function() { // Emscripten wrapper
  var goog = { math: {} };


  /**
   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * Javascript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within Javascript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   *
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   * @constructor
   */
  goog.math.Long = function(low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0;  // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */
    this.high_ = high | 0;  // force into 32 signed bits.
  };


  // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
  // from* methods on which they depend.


  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */
  goog.math.Long.IntCache_ = {};


  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @param {number} value The 32-bit integer in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = goog.math.Long.IntCache_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      goog.math.Long.IntCache_[value] = obj;
    }
    return obj;
  };


  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @param {number} value The number in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return goog.math.Long.ZERO;
    } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MIN_VALUE;
    } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MAX_VALUE;
    } else if (value < 0) {
      return goog.math.Long.fromNumber(-value).negate();
    } else {
      return new goog.math.Long(
          (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
          (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
  };


  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromBits = function(lowBits, highBits) {
    return new goog.math.Long(lowBits, highBits);
  };


  /**
   * Returns a Long representation of the given string, written using the given
   * radix.
   * @param {string} str The textual representation of the Long.
   * @param {number=} opt_radix The radix in which the text is written.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromString = function(str, opt_radix) {
    if (str.length == 0) {
      throw Error('number format error: empty string');
    }

    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (str.charAt(0) == '-') {
      return goog.math.Long.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf('-') >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

    var result = goog.math.Long.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = goog.math.Long.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(goog.math.Long.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(goog.math.Long.fromNumber(value));
      }
    }
    return result;
  };


  // NOTE: the compiler should inline these constant values below and then remove
  // these variables, so there should be no runtime penalty for these.


  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_32_DBL_ =
      goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_31_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ / 2;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_48_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_64_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_63_DBL_ =
      goog.math.Long.TWO_PWR_64_DBL_ / 2;


  /** @type {!goog.math.Long} */
  goog.math.Long.ZERO = goog.math.Long.fromInt(0);


  /** @type {!goog.math.Long} */
  goog.math.Long.ONE = goog.math.Long.fromInt(1);


  /** @type {!goog.math.Long} */
  goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


  /** @type {!goog.math.Long} */
  goog.math.Long.MAX_VALUE =
      goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


  /** @type {!goog.math.Long} */
  goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


  /**
   * @type {!goog.math.Long}
   * @private
   */
  goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


  /** @return {number} The value, assuming it is a 32-bit integer. */
  goog.math.Long.prototype.toInt = function() {
    return this.low_;
  };


  /** @return {number} The closest floating-point representation to this value. */
  goog.math.Long.prototype.toNumber = function() {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
           this.getLowBitsUnsigned();
  };


  /**
   * @param {number=} opt_radix The radix in which the text should be written.
   * @return {string} The textual representation of this value.
   */
  goog.math.Long.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (this.isZero()) {
      return '0';
    }

    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return '-' + this.negate().toString(radix);
      }
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

    var rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);

      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = '0' + digits;
        }
        result = '' + digits + result;
      }
    }
  };


  /** @return {number} The high 32-bits as a signed value. */
  goog.math.Long.prototype.getHighBits = function() {
    return this.high_;
  };


  /** @return {number} The low 32-bits as a signed value. */
  goog.math.Long.prototype.getLowBits = function() {
    return this.low_;
  };


  /** @return {number} The low 32-bits as an unsigned value. */
  goog.math.Long.prototype.getLowBitsUnsigned = function() {
    return (this.low_ >= 0) ?
        this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };


  /**
   * @return {number} Returns the number of bits needed to represent the absolute
   *     value of this Long.
   */
  goog.math.Long.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ != 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & (1 << bit)) != 0) {
          break;
        }
      }
      return this.high_ != 0 ? bit + 33 : bit + 1;
    }
  };


  /** @return {boolean} Whether this value is zero. */
  goog.math.Long.prototype.isZero = function() {
    return this.high_ == 0 && this.low_ == 0;
  };


  /** @return {boolean} Whether this value is negative. */
  goog.math.Long.prototype.isNegative = function() {
    return this.high_ < 0;
  };


  /** @return {boolean} Whether this value is odd. */
  goog.math.Long.prototype.isOdd = function() {
    return (this.low_ & 1) == 1;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */
  goog.math.Long.prototype.equals = function(other) {
    return (this.high_ == other.high_) && (this.low_ == other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long does not equal the other.
   */
  goog.math.Long.prototype.notEquals = function(other) {
    return (this.high_ != other.high_) || (this.low_ != other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */
  goog.math.Long.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than or equal to the other.
   */
  goog.math.Long.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than the other.
   */
  goog.math.Long.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */
  goog.math.Long.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };


  /**
   * Compares this Long with the given one.
   * @param {goog.math.Long} other Long to compare against.
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */
  goog.math.Long.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }

    // at this point, the signs are the same, so subtraction will not overflow
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };


  /** @return {!goog.math.Long} The negation of this value. */
  goog.math.Long.prototype.negate = function() {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.MIN_VALUE;
    } else {
      return this.not().add(goog.math.Long.ONE);
    }
  };


  /**
   * Returns the sum of this and the given Long.
   * @param {goog.math.Long} other Long to add to this one.
   * @return {!goog.math.Long} The sum of this and the given Long.
   */
  goog.math.Long.prototype.add = function(other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns the difference of this and the given Long.
   * @param {goog.math.Long} other Long to subtract from this.
   * @return {!goog.math.Long} The difference of this and the given Long.
   */
  goog.math.Long.prototype.subtract = function(other) {
    return this.add(other.negate());
  };


  /**
   * Returns the product of this and the given long.
   * @param {goog.math.Long} other Long to multiply with this.
   * @return {!goog.math.Long} The product of this and the other.
   */
  goog.math.Long.prototype.multiply = function(other) {
    if (this.isZero()) {
      return goog.math.Long.ZERO;
    } else if (other.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }

    // If both longs are small, use float multiplication
    if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
        other.lessThan(goog.math.Long.TWO_PWR_24_)) {
      return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
    }

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns this Long divided by the given one.
   * @param {goog.math.Long} other Long by which to divide.
   * @return {!goog.math.Long} This Long divided by the given one.
   */
  goog.math.Long.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error('division by zero');
    } else if (this.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      if (other.equals(goog.math.Long.ONE) ||
          other.equals(goog.math.Long.NEG_ONE)) {
        return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      } else if (other.equals(goog.math.Long.MIN_VALUE)) {
        return goog.math.Long.ONE;
      } else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(goog.math.Long.ZERO)) {
          return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.greaterThanOrEqual(other)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      var approxRes = goog.math.Long.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = goog.math.Long.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) {
        approxRes = goog.math.Long.ONE;
      }

      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };


  /**
   * Returns this Long modulo the given one.
   * @param {goog.math.Long} other Long by which to mod.
   * @return {!goog.math.Long} This Long modulo the given one.
   */
  goog.math.Long.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };


  /** @return {!goog.math.Long} The bitwise-NOT of this value. */
  goog.math.Long.prototype.not = function() {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };


  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to AND.
   * @return {!goog.math.Long} The bitwise-AND of this and the other.
   */
  goog.math.Long.prototype.and = function(other) {
    return goog.math.Long.fromBits(this.low_ & other.low_,
                                   this.high_ & other.high_);
  };


  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to OR.
   * @return {!goog.math.Long} The bitwise-OR of this and the other.
   */
  goog.math.Long.prototype.or = function(other) {
    return goog.math.Long.fromBits(this.low_ | other.low_,
                                   this.high_ | other.high_);
  };


  /**
   * Returns the bitwise-XOR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to XOR.
   * @return {!goog.math.Long} The bitwise-XOR of this and the other.
   */
  goog.math.Long.prototype.xor = function(other) {
    return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                   this.high_ ^ other.high_);
  };


  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the left by the given amount.
   */
  goog.math.Long.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return goog.math.Long.fromBits(
            low << numBits,
            (high << numBits) | (low >>> (32 - numBits)));
      } else {
        return goog.math.Long.fromBits(0, low << (numBits - 32));
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount.
   */
  goog.math.Long.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >> numBits);
      } else {
        return goog.math.Long.fromBits(
            high >> (numBits - 32),
            high >= 0 ? 0 : -1);
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */
  goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits);
      } else if (numBits == 32) {
        return goog.math.Long.fromBits(high, 0);
      } else {
        return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
      }
    }
  };

  //======= begin jsbn =======

  var navigator = { appName: 'Modern Browser' }; // polyfill a little

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // http://www-cs-students.stanford.edu/~tjw/jsbn/

  /*
   * Copyright (c) 2003-2005  Tom Wu
   * All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   */

  // Basic JavaScript BN library - subset useful for RSA encryption.

  // Bits per digit
  var dbits;

  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary&0xffffff)==0xefcafe);

  // (public) Constructor
  function BigInteger(a,b,c) {
    if(a != null)
      if("number" == typeof a) this.fromNumber(a,b,c);
      else if(b == null && "string" != typeof a) this.fromString(a,256);
      else this.fromString(a,b);
  }

  // return new, unset BigInteger
  function nbi() { return new BigInteger(null); }

  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.

  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i,x,w,j,c,n) {
    while(--n >= 0) {
      var v = x*this[i++]+w[j]+c;
      c = Math.floor(v/0x4000000);
      w[j++] = v&0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i,x,w,j,c,n) {
    var xl = x&0x7fff, xh = x>>15;
    while(--n >= 0) {
      var l = this[i]&0x7fff;
      var h = this[i++]>>15;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
      c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
      w[j++] = l&0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i,x,w,j,c,n) {
    var xl = x&0x3fff, xh = x>>14;
    while(--n >= 0) {
      var l = this[i]&0x3fff;
      var h = this[i++]>>14;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x3fff)<<14)+w[j]+c;
      c = (l>>28)+(m>>14)+xh*h;
      w[j++] = l&0xfffffff;
    }
    return c;
  }
  if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if(j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }

  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1<<dbits)-1);
  BigInteger.prototype.DV = (1<<dbits);

  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2,BI_FP);
  BigInteger.prototype.F1 = BI_FP-dbits;
  BigInteger.prototype.F2 = 2*dbits-BI_FP;

  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr,vv;
  rr = "0".charCodeAt(0);
  for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n) { return BI_RM.charAt(n); }
  function intAt(s,i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c==null)?-1:c;
  }

  // (protected) copy this to r
  function bnpCopyTo(r) {
    for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }

  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x) {
    this.t = 1;
    this.s = (x<0)?-1:0;
    if(x > 0) this[0] = x;
    else if(x < -1) this[0] = x+DV;
    else this.t = 0;
  }

  // return bigint initialized to value
  function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

  // (protected) set from string and radix
  function bnpFromString(s,b) {
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 256) k = 8; // byte array
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else { this.fromRadix(s,b); return; }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while(--i >= 0) {
      var x = (k==8)?s[i]&0xff:intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if(sh == 0)
        this[this.t++] = x;
      else if(sh+k > this.DB) {
        this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
        this[this.t++] = (x>>(this.DB-sh));
      }
      else
        this[this.t-1] |= x<<sh;
      sh += k;
      if(sh >= this.DB) sh -= this.DB;
    }
    if(k == 8 && (s[0]&0x80) != 0) {
      this.s = -1;
      if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
    }
    this.clamp();
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) clamp off excess high words
  function bnpClamp() {
    var c = this.s&this.DM;
    while(this.t > 0 && this[this.t-1] == c) --this.t;
  }

  // (public) return string representation in given radix
  function bnToString(b) {
    if(this.s < 0) return "-"+this.negate().toString(b);
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1<<k)-1, d, m = false, r = "", i = this.t;
    var p = this.DB-(i*this.DB)%k;
    if(i-- > 0) {
      if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
      while(i >= 0) {
        if(p < k) {
          d = (this[i]&((1<<p)-1))<<(k-p);
          d |= this[--i]>>(p+=this.DB-k);
        }
        else {
          d = (this[i]>>(p-=k))&km;
          if(p <= 0) { p += this.DB; --i; }
        }
        if(d > 0) m = true;
        if(m) r += int2char(d);
      }
    }
    return m?r:"0";
  }

  // (public) -this
  function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

  // (public) |this|
  function bnAbs() { return (this.s<0)?this.negate():this; }

  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a) {
    var r = this.s-a.s;
    if(r != 0) return r;
    var i = this.t;
    r = i-a.t;
    if(r != 0) return r;
    while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
    return 0;
  }

  // returns bit length of the integer x
  function nbits(x) {
    var r = 1, t;
    if((t=x>>>16) != 0) { x = t; r += 16; }
    if((t=x>>8) != 0) { x = t; r += 8; }
    if((t=x>>4) != 0) { x = t; r += 4; }
    if((t=x>>2) != 0) { x = t; r += 2; }
    if((t=x>>1) != 0) { x = t; r += 1; }
    return r;
  }

  // (public) return the number of bits in "this"
  function bnBitLength() {
    if(this.t <= 0) return 0;
    return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
  }

  // (protected) r = this << n*DB
  function bnpDLShiftTo(n,r) {
    var i;
    for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
    for(i = n-1; i >= 0; --i) r[i] = 0;
    r.t = this.t+n;
    r.s = this.s;
  }

  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n,r) {
    for(var i = n; i < this.t; ++i) r[i-n] = this[i];
    r.t = Math.max(this.t-n,0);
    r.s = this.s;
  }

  // (protected) r = this << n
  function bnpLShiftTo(n,r) {
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<cbs)-1;
    var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
    for(i = this.t-1; i >= 0; --i) {
      r[i+ds+1] = (this[i]>>cbs)|c;
      c = (this[i]&bm)<<bs;
    }
    for(i = ds-1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t+ds+1;
    r.s = this.s;
    r.clamp();
  }

  // (protected) r = this >> n
  function bnpRShiftTo(n,r) {
    r.s = this.s;
    var ds = Math.floor(n/this.DB);
    if(ds >= this.t) { r.t = 0; return; }
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<bs)-1;
    r[0] = this[ds]>>bs;
    for(var i = ds+1; i < this.t; ++i) {
      r[i-ds-1] |= (this[i]&bm)<<cbs;
      r[i-ds] = this[i]>>bs;
    }
    if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
    r.t = this.t-ds;
    r.clamp();
  }

  // (protected) r = this - a
  function bnpSubTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]-a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c -= a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c -= a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c<0)?-1:0;
    if(c < -1) r[i++] = this.DV+c;
    else if(c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }

  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a,r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i+y.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
    r.s = 0;
    r.clamp();
    if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
  }

  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2*x.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < x.t-1; ++i) {
      var c = x.am(i,x[i],r,2*i,0,1);
      if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
        r[i+x.t] -= x.DV;
        r[i+x.t+1] = 1;
      }
    }
    if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
    r.s = 0;
    r.clamp();
  }

  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m,q,r) {
    var pm = m.abs();
    if(pm.t <= 0) return;
    var pt = this.abs();
    if(pt.t < pm.t) {
      if(q != null) q.fromInt(0);
      if(r != null) this.copyTo(r);
      return;
    }
    if(r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
    if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
    else { pm.copyTo(y); pt.copyTo(r); }
    var ys = y.t;
    var y0 = y[ys-1];
    if(y0 == 0) return;
    var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
    var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
    var i = r.t, j = i-ys, t = (q==null)?nbi():q;
    y.dlShiftTo(j,t);
    if(r.compareTo(t) >= 0) {
      r[r.t++] = 1;
      r.subTo(t,r);
    }
    BigInteger.ONE.dlShiftTo(ys,t);
    t.subTo(y,y);	// "negative" y so we can replace sub with am later
    while(y.t < ys) y[y.t++] = 0;
    while(--j >= 0) {
      // Estimate quotient digit
      var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
      if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
        y.dlShiftTo(j,t);
        r.subTo(t,r);
        while(r[i] < --qd) r.subTo(t,r);
      }
    }
    if(q != null) {
      r.drShiftTo(ys,q);
      if(ts != ms) BigInteger.ZERO.subTo(q,q);
    }
    r.t = ys;
    r.clamp();
    if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
    if(ts < 0) BigInteger.ZERO.subTo(r,r);
  }

  // (public) this mod a
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a,null,r);
    if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
    return r;
  }

  // Modular reduction using "classic" algorithm
  function Classic(m) { this.m = m; }
  function cConvert(x) {
    if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }
  function cRevert(x) { return x; }
  function cReduce(x) { x.divRemTo(this.m,null,x); }
  function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
  function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;

  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit() {
    if(this.t < 1) return 0;
    var x = this[0];
    if((x&1) == 0) return 0;
    var y = x&3;		// y == 1/x mod 2^2
    y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
    y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
    y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y>0)?this.DV-y:-y;
  }

  // Montgomery reduction
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp&0x7fff;
    this.mph = this.mp>>15;
    this.um = (1<<(m.DB-15))-1;
    this.mt2 = 2*m.t;
  }

  // xR mod m
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t,r);
    r.divRemTo(this.m,null,r);
    if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
    return r;
  }

  // x/R mod m
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }

  // x = x/R mod m (HAC 14.32)
  function montReduce(x) {
    while(x.t <= this.mt2)	// pad x so am has enough room later
      x[x.t++] = 0;
    for(var i = 0; i < this.m.t; ++i) {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i]&0x7fff;
      var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i+this.m.t;
      x[j] += this.m.am(0,u0,x,i,0,this.m.t);
      // propagate carry
      while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
    }
    x.clamp();
    x.drShiftTo(this.m.t,x);
    if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
  }

  // r = "x^2/R mod m"; x != r
  function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  // r = "xy/R mod m"; x,y != r
  function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;

  // (protected) true iff this is even
  function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e,z) {
    if(e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
    g.copyTo(r);
    while(--i >= 0) {
      z.sqrTo(r,r2);
      if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
      else { var t = r; r = r2; r2 = t; }
    }
    return z.revert(r);
  }

  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e,m) {
    var z;
    if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e,z);
  }

  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;

  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;

  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);

  // jsbn2 stuff

  // (protected) convert from radix string
  function bnpFromRadix(s,b) {
    this.fromInt(0);
    if(b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
    for(var i = 0; i < s.length; ++i) {
      var x = intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b*w+x;
      if(++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w,0);
        j = 0;
        w = 0;
      }
    }
    if(j > 0) {
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum() {
    if(this.s < 0) return -1;
    else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }

  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n) {
    this[this.t] = this.am(0,n-1,this,0,0,this.t);
    ++this.t;
    this.clamp();
  }

  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n,w) {
    if(n == 0) return;
    while(this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while(this[w] >= this.DV) {
      this[w] -= this.DV;
      if(++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }

  // (protected) convert to radix string
  function bnpToRadix(b) {
    if(b == null) b = 10;
    if(this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b,cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d,y,z);
    while(y.signum() > 0) {
      r = (a+z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d,y,z);
    }
    return z.intValue().toString(b) + r;
  }

  // (public) return value as integer
  function bnIntValue() {
    if(this.s < 0) {
      if(this.t == 1) return this[0]-this.DV;
      else if(this.t == 0) return -1;
    }
    else if(this.t == 1) return this[0];
    else if(this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
  }

  // (protected) r = this + a
  function bnpAddTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]+a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c += a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c += a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c<0)?-1:0;
    if(c > 0) r[i++] = c;
    else if(c < -1) r[i++] = this.DV+c;
    r.t = i;
    r.clamp();
  }

  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.addTo = bnpAddTo;

  //======= end jsbn =======

  // Emscripten wrapper
  var Wrapper = {
    result: [0, 0], // return result stored here
    add: function(xl, xh, yl, yh) {
      var x = new goog.math.Long(xl, xh);
      var y = new goog.math.Long(yl, yh);
      var ret = x.add(y);
      Wrapper.result[0] = ret.low_;
      Wrapper.result[1] = ret.high_;
    },
    subtract: function(xl, xh, yl, yh) {
      var x = new goog.math.Long(xl, xh);
      var y = new goog.math.Long(yl, yh);
      var ret = x.subtract(y);
      Wrapper.result[0] = ret.low_;
      Wrapper.result[1] = ret.high_;
    },
    multiply: function(xl, xh, yl, yh) {
      var x = new goog.math.Long(xl, xh);
      var y = new goog.math.Long(yl, yh);
      var ret = x.multiply(y);
      Wrapper.result[0] = ret.low_;
      Wrapper.result[1] = ret.high_;
    },
    makeTwo32: function() {
      Wrapper.two32 = new BigInteger();
      Wrapper.two32.fromString('4294967296', 10);
    },
    lh2bignum: function(l, h) {
      var a = new BigInteger();
      a.fromString(h.toString(), 10);
      var b = new BigInteger();
      a.multiplyTo(Wrapper.two32, b);
      var c = new BigInteger();
      c.fromString(l.toString(), 10);
      var d = new BigInteger();
      c.addTo(b, d);
      return d;
    },
    divide: function(xl, xh, yl, yh, unsigned) {
      if (!Wrapper.two32) Wrapper.makeTwo32();
      if (!unsigned) {
        var x = new goog.math.Long(xl, xh);
        var y = new goog.math.Long(yl, yh);
        var ret = x.div(y);
        Wrapper.result[0] = ret.low_;
        Wrapper.result[1] = ret.high_;
      } else {
        // slow precise bignum division
        var x = Wrapper.lh2bignum(xl >>> 0, xh >>> 0);
        var y = Wrapper.lh2bignum(yl >>> 0, yh >>> 0);
        var z = new BigInteger();
        x.divRemTo(y, z, null);
        var l = new BigInteger();
        var h = new BigInteger();
        z.divRemTo(Wrapper.two32, h, l);
        Wrapper.result[0] = parseInt(l.toString()) | 0;
        Wrapper.result[1] = parseInt(h.toString()) | 0;
      }
    },
    modulo: function(xl, xh, yl, yh, unsigned) {
      if (!Wrapper.two32) Wrapper.makeTwo32();
      if (!unsigned) {
        var x = new goog.math.Long(xl, xh);
        var y = new goog.math.Long(yl, yh);
        var ret = x.modulo(y);
        Wrapper.result[0] = ret.low_;
        Wrapper.result[1] = ret.high_;
      } else {
        // slow precise bignum division
        var x = Wrapper.lh2bignum(xl >>> 0, xh >>> 0);
        var y = Wrapper.lh2bignum(yl >>> 0, yh >>> 0);
        var z = new BigInteger();
        x.divRemTo(y, null, z);
        var l = new BigInteger();
        var h = new BigInteger();
        z.divRemTo(Wrapper.two32, h, l);
        Wrapper.result[0] = parseInt(l.toString()) | 0;
        Wrapper.result[1] = parseInt(h.toString()) | 0;
      }
    },
    stringify: function(l, h, unsigned) {
      var ret = new goog.math.Long(l, h).toString();
      if (unsigned && ret[0] == '-') {
        // unsign slowly using jsbn bignums
        if (!Wrapper.two64) {
          Wrapper.two64 = new BigInteger();
          Wrapper.two64.fromString('18446744073709551616', 10);
        }
        var bignum = new BigInteger();
        bignum.fromString(ret, 10);
        ret = new BigInteger();
        Wrapper.two64.addTo(bignum, ret);
        ret = ret.toString(10);
      }
      return ret;
    }
  };
  return Wrapper;
})();

//======= end closure i64 code =======



  
  function _memcpy(dest, src, num, align) {
      assert(num % 1 === 0, 'memcpy given ' + num + ' bytes to copy. Problem with quantum=1 corrections perhaps?');
      if (num >= 20 && src % 2 == dest % 2) {
        // This is unaligned, but quite large, and potentially alignable, so work hard to get to aligned settings
        if (src % 4 == dest % 4) {
          var stop = src + num;
          while (src % 4) { // no need to check for stop, since we have large num
            HEAP8[dest++] = HEAP8[src++];
          }
          var src4 = src >> 2, dest4 = dest >> 2, stop4 = stop >> 2;
          while (src4 < stop4) {
            HEAP32[dest4++] = HEAP32[src4++];
          }
          src = src4 << 2;
          dest = dest4 << 2;
          while (src < stop) {
            HEAP8[dest++] = HEAP8[src++];
          }
        } else {
          var stop = src + num;
          if (src % 2) { // no need to check for stop, since we have large num
            HEAP8[dest++] = HEAP8[src++];
          }
          var src2 = src >> 1, dest2 = dest >> 1, stop2 = stop >> 1;
          while (src2 < stop2) {
            HEAP16[dest2++] = HEAP16[src2++];
          }
          src = src2 << 1;
          dest = dest2 << 1;
          if (src < stop) {
            HEAP8[dest++] = HEAP8[src++];
          }
        }
      } else {
        while (num--) {
          HEAP8[dest++] = HEAP8[src++];
        }
      }
    }var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;

  
  function _memset(ptr, value, num, align) {
      // TODO: make these settings, and in memcpy, {{'s
      if (num >= 20) {
        // This is unaligned, but quite large, so work hard to get to aligned settings
        var stop = ptr + num;
        while (ptr % 4) { // no need to check for stop, since we have large num
          HEAP8[ptr++] = value;
        }
        if (value < 0) value += 256; // make it unsigned
        var ptr4 = ptr >> 2, stop4 = stop >> 2, value4 = value | (value << 8) | (value << 16) | (value << 24);
        while (ptr4 < stop4) {
          HEAP32[ptr4++] = value4;
        }
        ptr = ptr4 << 2;
        while (ptr < stop) {
          HEAP8[ptr++] = value;
        }
      } else {
        while (num--) {
          HEAP8[ptr++] = value;
        }
      }
    }var _llvm_memset_p0i8_i32=_memset;

  function _strlen(ptr) {
      return String_len(ptr);
    }
var _llvm_va_start; // stub for _llvm_va_start

  function _llvm_va_end() {}

  function _strcpy(pdest, psrc) {
      var i = 0;
      do {
        HEAP8[(pdest+i)]=HEAP8[(psrc+i)];
        i ++;
      } while (HEAP8[((psrc)+(i-1))] != 0);
      return pdest;
    }

  
  
  
  var ERRNO_CODES={E2BIG:7,EACCES:13,EADDRINUSE:98,EADDRNOTAVAIL:99,EAFNOSUPPORT:97,EAGAIN:11,EALREADY:114,EBADF:9,EBADMSG:74,EBUSY:16,ECANCELED:125,ECHILD:10,ECONNABORTED:103,ECONNREFUSED:111,ECONNRESET:104,EDEADLK:35,EDESTADDRREQ:89,EDOM:33,EDQUOT:122,EEXIST:17,EFAULT:14,EFBIG:27,EHOSTUNREACH:113,EIDRM:43,EILSEQ:84,EINPROGRESS:115,EINTR:4,EINVAL:22,EIO:5,EISCONN:106,EISDIR:21,ELOOP:40,EMFILE:24,EMLINK:31,EMSGSIZE:90,EMULTIHOP:72,ENAMETOOLONG:36,ENETDOWN:100,ENETRESET:102,ENETUNREACH:101,ENFILE:23,ENOBUFS:105,ENODATA:61,ENODEV:19,ENOENT:2,ENOEXEC:8,ENOLCK:37,ENOLINK:67,ENOMEM:12,ENOMSG:42,ENOPROTOOPT:92,ENOSPC:28,ENOSR:63,ENOSTR:60,ENOSYS:38,ENOTCONN:107,ENOTDIR:20,ENOTEMPTY:39,ENOTRECOVERABLE:131,ENOTSOCK:88,ENOTSUP:95,ENOTTY:25,ENXIO:6,EOVERFLOW:75,EOWNERDEAD:130,EPERM:1,EPIPE:32,EPROTO:71,EPROTONOSUPPORT:93,EPROTOTYPE:91,ERANGE:34,EROFS:30,ESPIPE:29,ESRCH:3,ESTALE:116,ETIME:62,ETIMEDOUT:110,ETXTBSY:26,EWOULDBLOCK:11,EXDEV:18};
  
  function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      if (!___setErrNo.ret) ___setErrNo.ret = allocate([0], 'i32', ALLOC_STATIC);
      HEAP32[((___setErrNo.ret)>>2)]=value
      return value;
    }
  
  var _stdin=0;
  
  var _stdout=0;
  
  var _stderr=0;
  
  var __impure_ptr=0;var FS={currentPath:"/",nextInode:2,streams:[null],checkStreams:function () {
        for (var i in FS.streams) assert(i >= 0 && i < FS.streams.length); // no keys not in dense span
        for (var i = 0; i < FS.streams.length; i++) assert(typeof FS.streams[i] == 'object'); // no non-null holes in dense span
      },ignorePermissions:true,joinPath:function (parts, forceRelative) {
        var ret = parts[0];
        for (var i = 1; i < parts.length; i++) {
          if (ret[ret.length-1] != '/') ret += '/';
          ret += parts[i];
        }
        if (forceRelative && ret[0] == '/') ret = ret.substr(1);
        return ret;
      },absolutePath:function (relative, base) {
        if (typeof relative !== 'string') return null;
        if (base === undefined) base = FS.currentPath;
        if (relative && relative[0] == '/') base = '';
        var full = base + '/' + relative;
        var parts = full.split('/').reverse();
        var absolute = [''];
        while (parts.length) {
          var part = parts.pop();
          if (part == '' || part == '.') {
            // Nothing.
          } else if (part == '..') {
            if (absolute.length > 1) absolute.pop();
          } else {
            absolute.push(part);
          }
        }
        return absolute.length == 1 ? '/' : absolute.join('/');
      },analyzePath:function (path, dontResolveLastLink, linksVisited) {
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        path = FS.absolutePath(path);
        if (path == '/') {
          ret.isRoot = true;
          ret.exists = ret.parentExists = true;
          ret.name = '/';
          ret.path = ret.parentPath = '/';
          ret.object = ret.parentObject = FS.root;
        } else if (path !== null) {
          linksVisited = linksVisited || 0;
          path = path.slice(1).split('/');
          var current = FS.root;
          var traversed = [''];
          while (path.length) {
            if (path.length == 1 && current.isFolder) {
              ret.parentExists = true;
              ret.parentPath = traversed.length == 1 ? '/' : traversed.join('/');
              ret.parentObject = current;
              ret.name = path[0];
            }
            var target = path.shift();
            if (!current.isFolder) {
              ret.error = ERRNO_CODES.ENOTDIR;
              break;
            } else if (!current.read) {
              ret.error = ERRNO_CODES.EACCES;
              break;
            } else if (!current.contents.hasOwnProperty(target)) {
              ret.error = ERRNO_CODES.ENOENT;
              break;
            }
            current = current.contents[target];
            if (current.link && !(dontResolveLastLink && path.length == 0)) {
              if (linksVisited > 40) { // Usual Linux SYMLOOP_MAX.
                ret.error = ERRNO_CODES.ELOOP;
                break;
              }
              var link = FS.absolutePath(current.link, traversed.join('/'));
              ret = FS.analyzePath([link].concat(path).join('/'),
                                   dontResolveLastLink, linksVisited + 1);
              return ret;
            }
            traversed.push(target);
            if (path.length == 0) {
              ret.exists = true;
              ret.path = traversed.join('/');
              ret.object = current;
            }
          }
        }
        return ret;
      },findObject:function (path, dontResolveLastLink) {
        FS.ensureRoot();
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },createObject:function (parent, name, properties, canRead, canWrite) {
        if (!parent) parent = '/';
        if (typeof parent === 'string') parent = FS.findObject(parent);
  
        if (!parent) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent path must exist.');
        }
        if (!parent.isFolder) {
          ___setErrNo(ERRNO_CODES.ENOTDIR);
          throw new Error('Parent must be a folder.');
        }
        if (!parent.write && !FS.ignorePermissions) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent folder must be writeable.');
        }
        if (!name || name == '.' || name == '..') {
          ___setErrNo(ERRNO_CODES.ENOENT);
          throw new Error('Name must not be empty.');
        }
        if (parent.contents.hasOwnProperty(name)) {
          ___setErrNo(ERRNO_CODES.EEXIST);
          throw new Error("Can't overwrite object.");
        }
  
        parent.contents[name] = {
          read: canRead === undefined ? true : canRead,
          write: canWrite === undefined ? false : canWrite,
          timestamp: Date.now(),
          inodeNumber: FS.nextInode++
        };
        for (var key in properties) {
          if (properties.hasOwnProperty(key)) {
            parent.contents[name][key] = properties[key];
          }
        }
  
        return parent.contents[name];
      },createFolder:function (parent, name, canRead, canWrite) {
        var properties = {isFolder: true, isDevice: false, contents: {}};
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createPath:function (parent, path, canRead, canWrite) {
        var current = FS.findObject(parent);
        if (current === null) throw new Error('Invalid parent.');
        path = path.split('/').reverse();
        while (path.length) {
          var part = path.pop();
          if (!part) continue;
          if (!current.contents.hasOwnProperty(part)) {
            FS.createFolder(current, part, canRead, canWrite);
          }
          current = current.contents[part];
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        properties.isFolder = false;
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createDataFile:function (parent, name, data, canRead, canWrite) {
        if (typeof data === 'string') {
          var dataArray = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i) dataArray[i] = data.charCodeAt(i);
          data = dataArray;
        }
        var properties = {
          isDevice: false,
          contents: data.subarray ? data.subarray(0) : data // as an optimization, create a new array wrapper (not buffer) here, to help JS engines understand this object
        };
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
  
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          var LazyUint8Array = function(chunkSize, length) {
            this.length = length;
            this.chunkSize = chunkSize;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % chunkSize;
            var chunkNum = Math.floor(idx / chunkSize);
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function(getter) {
            this.getter = getter;
          }
    
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
          if (!hasByteServing) chunkSize = datalength;
    
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
    
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
    
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
    
          var lazyArray = new LazyUint8Array(chunkSize, datalength);
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * lazyArray.chunkSize;
            var end = (chunkNum+1) * lazyArray.chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile) {
        Browser.ensureObjects();
        var fullname = FS.joinPath([parent, name], true);
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },createLink:function (parent, name, target, canRead, canWrite) {
        var properties = {isDevice: false, link: target};
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createDevice:function (parent, name, input, output) {
        if (!(input || output)) {
          throw new Error('A device must have at least one callback defined.');
        }
        var ops = {isDevice: true, input: input, output: output};
        return FS.createFile(parent, name, ops, Boolean(input), Boolean(output));
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },ensureRoot:function () {
        if (FS.root) return;
        // The main file system tree. All the contents are inside this.
        FS.root = {
          read: true,
          write: true,
          isFolder: true,
          isDevice: false,
          timestamp: Date.now(),
          inodeNumber: 1,
          contents: {}
        };
      },init:function (input, output, error) {
        // Make sure we initialize only once.
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureRoot();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input = input || Module['stdin'];
        output = output || Module['stdout'];
        error = error || Module['stderr'];
  
        // Default handlers.
        var stdinOverridden = true, stdoutOverridden = true, stderrOverridden = true;
        if (!input) {
          stdinOverridden = false;
          input = function() {
            if (!input.cache || !input.cache.length) {
              var result;
              if (typeof window != 'undefined' &&
                  typeof window.prompt == 'function') {
                // Browser.
                result = window.prompt('Input: ');
                if (result === null) result = String.fromCharCode(0); // cancel ==> EOF
              } else if (typeof readline == 'function') {
                // Command line.
                result = readline();
              }
              if (!result) result = '';
              input.cache = intArrayFromString(result + '\n', true);
            }
            return input.cache.shift();
          };
        }
        var utf8 = new Runtime.UTF8Processor();
        function simpleOutput(val) {
          if (val === null || val === '\n'.charCodeAt(0)) {
            output.printer(output.buffer.join(''));
            output.buffer = [];
          } else {
            output.buffer.push(utf8.processCChar(val));
          }
        }
        if (!output) {
          stdoutOverridden = false;
          output = simpleOutput;
        }
        if (!output.printer) output.printer = Module['print'];
        if (!output.buffer) output.buffer = [];
        if (!error) {
          stderrOverridden = false;
          error = simpleOutput;
        }
        if (!error.printer) error.printer = Module['print'];
        if (!error.buffer) error.buffer = [];
  
        // Create the temporary folder, if not already created
        try {
          FS.createFolder('/', 'tmp', true, true);
        } catch(e) {}
  
        // Create the I/O devices.
        var devFolder = FS.createFolder('/', 'dev', true, true);
        var stdin = FS.createDevice(devFolder, 'stdin', input);
        var stdout = FS.createDevice(devFolder, 'stdout', null, output);
        var stderr = FS.createDevice(devFolder, 'stderr', null, error);
        FS.createDevice(devFolder, 'tty', input, output);
  
        // Create default streams.
        FS.streams[1] = {
          path: '/dev/stdin',
          object: stdin,
          position: 0,
          isRead: true,
          isWrite: false,
          isAppend: false,
          isTerminal: !stdinOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[2] = {
          path: '/dev/stdout',
          object: stdout,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stdoutOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[3] = {
          path: '/dev/stderr',
          object: stderr,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stderrOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        // Allocate these on the stack (and never free, we are called from ATINIT or earlier), to keep their locations low
        _stdin = allocate([1], 'void*', ALLOC_STACK);
        _stdout = allocate([2], 'void*', ALLOC_STACK);
        _stderr = allocate([3], 'void*', ALLOC_STACK);
  
        // Other system paths
        FS.createPath('/', 'dev/shm/tmp', true, true); // temp files
  
        // Newlib initialization
        for (var i = FS.streams.length; i < Math.max(_stdin, _stdout, _stderr) + 4; i++) {
          FS.streams[i] = null; // Make sure to keep FS.streams dense
        }
        FS.streams[_stdin] = FS.streams[1];
        FS.streams[_stdout] = FS.streams[2];
        FS.streams[_stderr] = FS.streams[3];
        FS.checkStreams();
        assert(FS.streams.length < 1024); // at this early stage, we should not have a large set of file descriptors - just a few
        __impure_ptr = allocate([ allocate(
          [0, 0, 0, 0, _stdin, 0, 0, 0, _stdout, 0, 0, 0, _stderr, 0, 0, 0],
          'void*', ALLOC_STATIC) ], 'void*', ALLOC_STATIC);
      },quit:function () {
        if (!FS.init.initialized) return;
        // Flush any partially-printed lines in stdout and stderr. Careful, they may have been closed
        if (FS.streams[2] && FS.streams[2].object.output.buffer.length > 0) FS.streams[2].object.output('\n'.charCodeAt(0));
        if (FS.streams[3] && FS.streams[3].object.output.buffer.length > 0) FS.streams[3].object.output('\n'.charCodeAt(0));
      },standardizePath:function (path) {
        if (path.substr(0, 2) == './') path = path.substr(2);
        return path;
      },deleteFile:function (path) {
        var path = FS.analyzePath(path);
        if (!path.parentExists || !path.exists) {
          throw 'Invalid path ' + path;
        }
        delete path.parentObject.contents[path.name];
      }};
  
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream || stream.object.isDevice) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (stream.object.isFolder) {
        ___setErrNo(ERRNO_CODES.EISDIR);
        return -1;
      } else if (nbyte < 0 || offset < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var contents = stream.object.contents;
        while (contents.length < offset) contents.push(0);
        for (var i = 0; i < nbyte; i++) {
          contents[offset + i] = HEAPU8[((buf)+(i))];
        }
        stream.object.timestamp = Date.now();
        return i;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (nbyte < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        if (stream.object.isDevice) {
          if (stream.object.output) {
            for (var i = 0; i < nbyte; i++) {
              try {
                stream.object.output(HEAP8[((buf)+(i))]);
              } catch (e) {
                ___setErrNo(ERRNO_CODES.EIO);
                return -1;
              }
            }
            stream.object.timestamp = Date.now();
            return i;
          } else {
            ___setErrNo(ERRNO_CODES.ENXIO);
            return -1;
          }
        } else {
          var bytesWritten = _pwrite(fildes, buf, nbyte, stream.position);
          if (bytesWritten != -1) stream.position += bytesWritten;
          return bytesWritten;
        }
      }
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var bytesWritten = _write(stream, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        if (FS.streams[stream]) FS.streams[stream].error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }
  
  function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = (tempDoubleI32[0]=HEAP32[(((varargs)+(argIndex))>>2)],tempDoubleI32[1]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],tempDoubleF64[0]);
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[(textIndex+1)];
        if (curr == '%'.charCodeAt(0)) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          flagsLoop: while (1) {
            switch (next) {
              case '+'.charCodeAt(0):
                flagAlwaysSigned = true;
                break;
              case '-'.charCodeAt(0):
                flagLeftAlign = true;
                break;
              case '#'.charCodeAt(0):
                flagAlternative = true;
                break;
              case '0'.charCodeAt(0):
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[(textIndex+1)];
          }
  
          // Handle width.
          var width = 0;
          if (next == '*'.charCodeAt(0)) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[(textIndex+1)];
          } else {
            while (next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0)) {
              width = width * 10 + (next - '0'.charCodeAt(0));
              textIndex++;
              next = HEAP8[(textIndex+1)];
            }
          }
  
          // Handle precision.
          var precisionSet = false;
          if (next == '.'.charCodeAt(0)) {
            var precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[(textIndex+1)];
            if (next == '*'.charCodeAt(0)) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[(textIndex+1)];
                if (precisionChr < '0'.charCodeAt(0) ||
                    precisionChr > '9'.charCodeAt(0)) break;
                precision = precision * 10 + (precisionChr - '0'.charCodeAt(0));
                textIndex++;
              }
            }
            next = HEAP8[(textIndex+1)];
          } else {
            var precision = 6; // Standard default.
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[(textIndex+2)];
              if (nextNext == 'h'.charCodeAt(0)) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[(textIndex+2)];
              if (nextNext == 'l'.charCodeAt(0)) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[(textIndex+1)];
  
          // Handle type specifier.
          if (['d', 'i', 'u', 'o', 'x', 'X', 'p'].indexOf(String.fromCharCode(next)) != -1) {
            // Integer.
            var signed = next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0);
            argSize = argSize || 4;
            var currArg = getNextArg('i' + (argSize * 8));
            var origArg = currArg;
            var argText;
            // Flatten i64-1 [low, high] into a (slightly rounded) double
            if (argSize == 8) {
              currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 'u'.charCodeAt(0));
            }
            // Truncate to requested size.
            if (argSize <= 4) {
              var limit = Math.pow(256, argSize) - 1;
              currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
            }
            // Format the number.
            var currAbsArg = Math.abs(currArg);
            var prefix = '';
            if (next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1]); else
              argText = reSign(currArg, 8 * argSize, 1).toString(10);
            } else if (next == 'u'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
              argText = unSign(currArg, 8 * argSize, 1).toString(10);
              currArg = Math.abs(currArg);
            } else if (next == 'o'.charCodeAt(0)) {
              argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
            } else if (next == 'x'.charCodeAt(0) || next == 'X'.charCodeAt(0)) {
              prefix = flagAlternative ? '0x' : '';
              if (currArg < 0) {
                // Represent negative numbers in hex as 2's complement.
                currArg = -currArg;
                argText = (currAbsArg - 1).toString(16);
                var buffer = [];
                for (var i = 0; i < argText.length; i++) {
                  buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                }
                argText = buffer.join('');
                while (argText.length < argSize * 2) argText = 'f' + argText;
              } else {
                argText = currAbsArg.toString(16);
              }
              if (next == 'X'.charCodeAt(0)) {
                prefix = prefix.toUpperCase();
                argText = argText.toUpperCase();
              }
            } else if (next == 'p'.charCodeAt(0)) {
              if (currAbsArg === 0) {
                argText = '(nil)';
              } else {
                prefix = '0x';
                argText = currAbsArg.toString(16);
              }
            }
            if (precisionSet) {
              while (argText.length < precision) {
                argText = '0' + argText;
              }
            }
  
            // Add sign if needed
            if (flagAlwaysSigned) {
              if (currArg < 0) {
                prefix = '-' + prefix;
              } else {
                prefix = '+' + prefix;
              }
            }
  
            // Add padding.
            while (prefix.length + argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad) {
                  argText = '0' + argText;
                } else {
                  prefix = ' ' + prefix;
                }
              }
            }
  
            // Insert the result into the buffer.
            argText = prefix + argText;
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (['f', 'F', 'e', 'E', 'g', 'G'].indexOf(String.fromCharCode(next)) != -1) {
            // Float.
            var currArg = getNextArg('double');
            var argText;
  
            if (isNaN(currArg)) {
              argText = 'nan';
              flagZeroPad = false;
            } else if (!isFinite(currArg)) {
              argText = (currArg < 0 ? '-' : '') + 'inf';
              flagZeroPad = false;
            } else {
              var isGeneral = false;
              var effectivePrecision = Math.min(precision, 20);
  
              // Convert g/G to f/F or e/E, as per:
              // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
              if (next == 'g'.charCodeAt(0) || next == 'G'.charCodeAt(0)) {
                isGeneral = true;
                precision = precision || 1;
                var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                if (precision > exponent && exponent >= -4) {
                  next = ((next == 'g'.charCodeAt(0)) ? 'f' : 'F').charCodeAt(0);
                  precision -= exponent + 1;
                } else {
                  next = ((next == 'g'.charCodeAt(0)) ? 'e' : 'E').charCodeAt(0);
                  precision--;
                }
                effectivePrecision = Math.min(precision, 20);
              }
  
              if (next == 'e'.charCodeAt(0) || next == 'E'.charCodeAt(0)) {
                argText = currArg.toExponential(effectivePrecision);
                // Make sure the exponent has at least 2 digits.
                if (/[eE][-+]\d$/.test(argText)) {
                  argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                }
              } else if (next == 'f'.charCodeAt(0) || next == 'F'.charCodeAt(0)) {
                argText = currArg.toFixed(effectivePrecision);
              }
  
              var parts = argText.split('e');
              if (isGeneral && !flagAlternative) {
                // Discard trailing zeros and periods.
                while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                       (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                  parts[0] = parts[0].slice(0, -1);
                }
              } else {
                // Make sure we have a period in alternative mode.
                if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                // Zero pad until required precision.
                while (precision > effectivePrecision++) parts[0] += '0';
              }
              argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
              // Capitalize 'E' if needed.
              if (next == 'E'.charCodeAt(0)) argText = argText.toUpperCase();
  
              // Add sign.
              if (flagAlwaysSigned && currArg >= 0) {
                argText = '+' + argText;
              }
            }
  
            // Add padding.
            while (argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                  argText = argText[0] + '0' + argText.slice(1);
                } else {
                  argText = (flagZeroPad ? '0' : ' ') + argText;
                }
              }
            }
  
            // Adjust case.
            if (next < 'a'.charCodeAt(0)) argText = argText.toUpperCase();
  
            // Insert the result into the buffer.
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (next == 's'.charCodeAt(0)) {
            // String.
            var arg = getNextArg('i8*') || nullString;
            var argLength = String_len(arg);
            if (precisionSet) argLength = Math.min(argLength, precision);
            if (!flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
            for (var i = 0; i < argLength; i++) {
              ret.push(HEAPU8[(arg++)]);
            }
            if (flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
          } else if (next == 'c'.charCodeAt(0)) {
            // Character.
            if (flagLeftAlign) ret.push(getNextArg('i8'));
            while (--width > 0) {
              ret.push(' '.charCodeAt(0));
            }
            if (!flagLeftAlign) ret.push(getNextArg('i8'));
          } else if (next == 'n'.charCodeAt(0)) {
            // Write the length written so far to the next parameter.
            var ptr = getNextArg('i32*');
            HEAP32[((ptr)>>2)]=ret.length
          } else if (next == '%'.charCodeAt(0)) {
            // Literal percent sign.
            ret.push(curr);
          } else {
            // Unknown specifiers remain untouched.
            for (var i = startTextIndex; i < textIndex + 2; i++) {
              ret.push(HEAP8[(i)]);
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }

  function _abort() {
      ABORT = true;
      throw 'abort() at ' + (new Error().stack);
    }

  
  function _strncmp(px, py, n) {
      var i = 0;
      while (i < n) {
        var x = HEAPU8[((px)+(i))];
        var y = HEAPU8[((py)+(i))];
        if (x == y && x == 0) return 0;
        if (x == 0) return -1;
        if (y == 0) return 1;
        if (x == y) {
          i ++;
          continue;
        } else {
          return x > y ? 1 : -1;
        }
      }
      return 0;
    }function _strcmp(px, py) {
      return _strncmp(px, py, TOTAL_MEMORY);
    }


  
  function _close(fildes) {
      // int close(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/close.html
      if (FS.streams[fildes]) {
        if (FS.streams[fildes].currentEntry) {
          _free(FS.streams[fildes].currentEntry);
        }
        FS.streams[fildes] = null;
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }
  
  function _fsync(fildes) {
      // int fsync(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fsync.html
      if (FS.streams[fildes]) {
        // We write directly to the file system, so there's nothing to do here.
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }function _fclose(stream) {
      // int fclose(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fclose.html
      _fsync(stream);
      return _close(stream);
    }

  var _vfprintf=_fprintf;

  function _printf(format, varargs) {
      // int printf(const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var stdout = HEAP32[((_stdout)>>2)];
      return _fprintf(stdout, format, varargs);
    }

  function _strncat(pdest, psrc, num) {
      var len = _strlen(pdest);
      var i = 0;
      while(1) {
        HEAP8[(pdest+len+i)]=HEAP8[(psrc+i)];
        if (HEAP8[((pdest)+(len+i))] == 0) break;
        i ++;
        if (i == num) {
          HEAP8[((pdest)+(len+i))]=0
          break;
        }
      }
      return pdest;
    }

  function _isspace(chr) {
      return chr in { 32: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0 };
    }

  function _isdigit(chr) {
      return chr >= '0'.charCodeAt(0) && chr <= '9'.charCodeAt(0);
    }

  
  
  function __isFloat(text) {
      return !!(/^[+-]?[0-9]*\.?[0-9]+([eE][+-]?[0-9]+)?$/.exec(text));
    }function __scanString(format, get, unget, varargs) {
      if (!__scanString.whiteSpace) {
        __scanString.whiteSpace = {};
        __scanString.whiteSpace[' '.charCodeAt(0)] = 1;
        __scanString.whiteSpace['\t'.charCodeAt(0)] = 1;
        __scanString.whiteSpace['\n'.charCodeAt(0)] = 1;
        __scanString.whiteSpace[' '] = 1;
        __scanString.whiteSpace['\t'] = 1;
        __scanString.whiteSpace['\n'] = 1;
      }
      // Supports %x, %4x, %d.%d, %lld, %s, %f, %lf.
      // TODO: Support all format specifiers.
      format = Pointer_stringify(format);
      var soFar = 0;
      if (format.indexOf('%n') >= 0) {
        // need to track soFar
        var _get = get;
        get = function() {
          soFar++;
          return _get();
        }
        var _unget = unget;
        unget = function() {
          soFar--;
          return _unget();
        }
      }
      var formatIndex = 0;
      var argsi = 0;
      var fields = 0;
      var argIndex = 0;
      var next;
  
      next = 1;
      mainLoop:
      for (var formatIndex = 0; formatIndex < format.length; formatIndex++) {
        // remove whitespace
        while (1) {
          next = get();
          if (next == 0) return fields;
          if (!(next in __scanString.whiteSpace)) break;
        } 
        unget(next);
        
        if (next <= 0) return fields;
        var next = get();
        if (next <= 0) return fields;  // End of input.
  
        if (format[formatIndex] === '%') {
          formatIndex++;
          var maxSpecifierStart = formatIndex;
          while (format[formatIndex].charCodeAt(0) >= '0'.charCodeAt(0) &&
                 format[formatIndex].charCodeAt(0) <= '9'.charCodeAt(0)) {
            formatIndex++;
          }
          var max_;
          if (formatIndex != maxSpecifierStart) {
            max_ = parseInt(format.slice(maxSpecifierStart, formatIndex), 10);
          }
          var long_ = false;
          var half = false;
          var longLong = false;
          if (format[formatIndex] == 'l') {
            long_ = true;
            formatIndex++;
            if(format[formatIndex] == 'l') {
              longLong = true;
              formatIndex++;
            }
          } else if (format[formatIndex] == 'h') {
            half = true;
            formatIndex++;
          }
          var type = format[formatIndex];
          formatIndex++;
          var curr = 0;
          var buffer = [];
          // Read characters according to the format. floats are trickier, they may be in an unfloat state in the middle, then be a valid float later
          if (type == 'f') {
            var last = 0;
            while (next > 0) {
              buffer.push(String.fromCharCode(next));
              if (__isFloat(buffer.join(''))) {
                last = buffer.length;
              }
              next = get();
            }
            unget(next);
            while (buffer.length > last) {
              unget(buffer.pop().charCodeAt(0));
            }
            next = get();
          } else if (type != 'n') {
            var first = true;
            while ((curr < max_ || isNaN(max_)) && next > 0) {
              if (!(next in __scanString.whiteSpace) && // stop on whitespace
                  (type == 's' ||
                   ((type === 'd' || type == 'u' || type == 'i') && ((next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0)) ||
                                                                     (first && next == '-'.charCodeAt(0)))) ||
                   (type === 'x' && (next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0) ||
                                     next >= 'a'.charCodeAt(0) && next <= 'f'.charCodeAt(0) ||
                                     next >= 'A'.charCodeAt(0) && next <= 'F'.charCodeAt(0)))) &&
                  (formatIndex >= format.length || next !== format[formatIndex].charCodeAt(0))) { // Stop when we read something that is coming up
                buffer.push(String.fromCharCode(next));
                next = get();
                curr++;
              } else {
                break;
              }
              first = false;
            }
          }
          if (buffer.length === 0 && type != 'n') return 0;  // Failure.
          var text = buffer.join('');
          var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += Runtime.getNativeFieldSize('void*');
          switch (type) {
            case 'd': case 'u': case 'i':
              if (half) {
                HEAP16[((argPtr)>>1)]=parseInt(text, 10);
              } else if(longLong) {
                (tempI64 = [parseInt(text, 10)>>>0,Math.min(Math.floor((parseInt(text, 10))/4294967296), 4294967295)],HEAP32[((argPtr)>>2)]=tempI64[0],HEAP32[(((argPtr)+(4))>>2)]=tempI64[1]);
              } else {
                HEAP32[((argPtr)>>2)]=parseInt(text, 10);
              }
              break;
            case 'x':
              HEAP32[((argPtr)>>2)]=parseInt(text, 16)
              break;
            case 'f':
              if (long_) {
                (tempDoubleF64[0]=parseFloat(text),HEAP32[((argPtr)>>2)]=tempDoubleI32[0],HEAP32[(((argPtr)+(4))>>2)]=tempDoubleI32[1])
              } else {
                HEAPF32[((argPtr)>>2)]=parseFloat(text)
              }
              break;
            case 's':
              var array = intArrayFromString(text);
              for (var j = 0; j < array.length; j++) {
                HEAP8[((argPtr)+(j))]=array[j]
              }
              break;
            case 'n':
              HEAP32[((argPtr)>>2)]=soFar-1
              break;
          }
          if (type != 'n') fields++;
          if (next <= 0) break mainLoop;  // End of input.
        } else if (format[formatIndex] in __scanString.whiteSpace) {
          while (next in __scanString.whiteSpace) {
            next = get();
            if (next <= 0) break mainLoop;  // End of input.
          }
          unget(next);
        } else {
          // Not a specifier.
          if (format[formatIndex].charCodeAt(0) !== next) {
            unget(next);
            break mainLoop;
          }
        }
      }
      // 'n' is special in that it needs no input. so it can be at the end, even with nothing left to read
      if (format[formatIndex-1] == '%' && format[formatIndex] == 'n') {
        var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
        HEAP32[((argPtr)>>2)]=soFar-1
      }
      return fields;
    }function _sscanf(s, format, varargs) {
      // int sscanf(const char *restrict s, const char *restrict format, ... );
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/scanf.html
      var index = 0;
      var get = function() { return HEAP8[((s)+(index++))]; };
      var unget = function() { index--; };
      return __scanString(format, get, unget, varargs);
    }

  function _strtod(str, endptr) {
      var origin = str;
  
      // Skip space.
      while (_isspace(HEAP8[(str)])) str++;
  
      // Check for a plus/minus sign.
      var multiplier = 1;
      if (HEAP8[(str)] == '-'.charCodeAt(0)) {
        multiplier = -1;
        str++;
      } else if (HEAP8[(str)] == '+'.charCodeAt(0)) {
        str++;
      }
  
      var chr;
      var ret = 0;
  
      // Get whole part.
      var whole = false;
      while(1) {
        chr = HEAP8[(str)];
        if (!_isdigit(chr)) break;
        whole = true;
        ret = ret*10 + chr - '0'.charCodeAt(0);
        str++;
      }
  
      // Get fractional part.
      var fraction = false;
      if (HEAP8[(str)] == '.'.charCodeAt(0)) {
        str++;
        var mul = 1/10;
        while(1) {
          chr = HEAP8[(str)];
          if (!_isdigit(chr)) break;
          fraction = true;
          ret += mul*(chr - '0'.charCodeAt(0));
          mul /= 10;
          str++;
        }
      }
  
      if (!whole && !fraction) {
        if (endptr) {
          HEAP32[((endptr)>>2)]=origin
        }
        return 0;
      }
  
      // Get exponent part.
      chr = HEAP8[(str)];
      if (chr == 'e'.charCodeAt(0) || chr == 'E'.charCodeAt(0)) {
        str++;
        var exponent = 0;
        var expNegative = false;
        chr = HEAP8[(str)];
        if (chr == '-'.charCodeAt(0)) {
          expNegative = true;
          str++;
        } else if (chr == '+'.charCodeAt(0)) {
          str++;
        }
        chr = HEAP8[(str)];
        while(1) {
          if (!_isdigit(chr)) break;
          exponent = exponent*10 + chr - '0'.charCodeAt(0);
          str++;
          chr = HEAP8[(str)];
        }
        if (expNegative) exponent = -exponent;
        ret *= Math.pow(10, exponent);
      }
  
      // Set end pointer.
      if (endptr) {
        HEAP32[((endptr)>>2)]=str
      }
  
      return ret * multiplier;
    }

  
  function __parseInt(str, endptr, base, min, max, bits, unsign) {
      // Skip space.
      while (_isspace(HEAP8[(str)])) str++;
  
      // Check for a plus/minus sign.
      var multiplier = 1;
      if (HEAP8[(str)] == '-'.charCodeAt(0)) {
        multiplier = -1;
        str++;
      } else if (HEAP8[(str)] == '+'.charCodeAt(0)) {
        str++;
      }
  
      // Find base.
      var finalBase = base;
      if (!finalBase) {
        if (HEAP8[(str)] == '0'.charCodeAt(0)) {
          if (HEAP8[(str+1)] == 'x'.charCodeAt(0) ||
              HEAP8[(str+1)] == 'X'.charCodeAt(0)) {
            finalBase = 16;
            str += 2;
          } else {
            finalBase = 8;
            str++;
          }
        }
      }
      if (!finalBase) finalBase = 10;
  
      // Get digits.
      var chr;
      var ret = 0;
      while ((chr = HEAP8[(str)]) != 0) {
        var digit = parseInt(String.fromCharCode(chr), finalBase);
        if (isNaN(digit)) {
          break;
        } else {
          ret = ret * finalBase + digit;
          str++;
        }
      }
  
      // Apply sign.
      ret *= multiplier;
  
      // Set end pointer.
      if (endptr) {
        HEAP32[((endptr)>>2)]=str
      }
  
      // Unsign if needed.
      if (unsign) {
        if (Math.abs(ret) > max) {
          ret = max;
          ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          ret = unSign(ret, bits);
        }
      }
  
      // Validate range.
      if (ret > max || ret < min) {
        ret = ret > max ? max : min;
        ___setErrNo(ERRNO_CODES.ERANGE);
      }
  
      if (bits == 64) {
        ret = [ret>>>0,Math.min(Math.floor((ret)/4294967296), 4294967295)];
      }
  
      return ret;
    }function _strtol(str, endptr, base) {
      return __parseInt(str, endptr, base, -2147483648, 2147483647, 32);  // LONG_MIN, LONG_MAX.
    }

  function _isalpha(chr) {
      return (chr >= 'a'.charCodeAt(0) && chr <= 'z'.charCodeAt(0)) ||
             (chr >= 'A'.charCodeAt(0) && chr <= 'Z'.charCodeAt(0));
    }

  
  
  function _pread(fildes, buf, nbyte, offset) {
      // ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.streams[fildes];
      if (!stream || stream.object.isDevice) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isRead) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (stream.object.isFolder) {
        ___setErrNo(ERRNO_CODES.EISDIR);
        return -1;
      } else if (nbyte < 0 || offset < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var bytesRead = 0;
        while (stream.ungotten.length && nbyte > 0) {
          HEAP8[(buf++)]=stream.ungotten.pop()
          nbyte--;
          bytesRead++;
        }
        var contents = stream.object.contents;
        var size = Math.min(contents.length - offset, nbyte);
        if (contents.subarray || contents.slice) { // typed array or normal array
          for (var i = 0; i < size; i++) {
            HEAP8[((buf)+(i))]=contents[offset + i]
          }
        } else {
          for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
            HEAP8[((buf)+(i))]=contents.get(offset + i)
          }
        }
        bytesRead += size;
        return bytesRead;
      }
    }function _read(fildes, buf, nbyte) {
      // ssize_t read(int fildes, void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.streams[fildes];
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isRead) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (nbyte < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var bytesRead;
        if (stream.object.isDevice) {
          if (stream.object.input) {
            bytesRead = 0;
            while (stream.ungotten.length && nbyte > 0) {
              HEAP8[(buf++)]=stream.ungotten.pop()
              nbyte--;
              bytesRead++;
            }
            for (var i = 0; i < nbyte; i++) {
              try {
                var result = stream.object.input();
              } catch (e) {
                ___setErrNo(ERRNO_CODES.EIO);
                return -1;
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              HEAP8[((buf)+(i))]=result
            }
            return bytesRead;
          } else {
            ___setErrNo(ERRNO_CODES.ENXIO);
            return -1;
          }
        } else {
          var ungotSize = stream.ungotten.length;
          bytesRead = _pread(fildes, buf, nbyte, stream.position);
          if (bytesRead != -1) {
            stream.position += (stream.ungotten.length - ungotSize) + bytesRead;
          }
          return bytesRead;
        }
      }
    }function _fgetc(stream) {
      // int fgetc(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fgetc.html
      if (!FS.streams[stream]) return -1;
      var streamObj = FS.streams[stream];
      if (streamObj.eof || streamObj.error) return -1;
      var ret = _read(stream, _fgetc.ret, 1);
      if (ret == 0) {
        streamObj.eof = true;
        return -1;
      } else if (ret == -1) {
        streamObj.error = true;
        return -1;
      } else {
        return HEAPU8[(_fgetc.ret)];
      }
    }

  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
  
  
      exitRuntime();
      ABORT = true;
  
      throw 'exit(' + status + ') called, at ' + new Error().stack;
    }function _exit(status) {
      __exit(status);
    }


  function _atoi(ptr) {
      return _strtol(ptr, null, 10);
    }

  function _memcmp(p1, p2, num) {
      for (var i = 0; i < num; i++) {
        var v1 = HEAPU8[((p1)+(i))];
        var v2 = HEAPU8[((p2)+(i))];
        if (v1 != v2) return v1 > v2 ? 1 : -1;
      }
      return 0;
    }

  function _isupper(chr) {
      return chr >= 'A'.charCodeAt(0) && chr <= 'Z'.charCodeAt(0);
    }

  function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[(_fputc.ret)]=chr
      var ret = _write(stream, _fputc.ret, 1);
      if (ret == -1) {
        if (FS.streams[stream]) FS.streams[stream].error = true;
        return -1;
      } else {
        return chr;
      }
    }

  function _fputs(s, stream) {
      // int fputs(const char *restrict s, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputs.html
      return _write(stream, s, _strlen(s));
    }

  var _getc=_fgetc;

  function _ferror(stream) {
      // int ferror(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ferror.html
      return Number(FS.streams[stream] && FS.streams[stream].error);
    }

  
  
  var ___dirent_struct_layout=null;function _open(path, oflag, varargs) {
      // int open(const char *path, int oflag, ...);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html
      // NOTE: This implementation tries to mimic glibc rather that strictly
      // following the POSIX standard.
  
      var mode = HEAP32[((varargs)>>2)];
  
      // Simplify flags.
      var accessMode = oflag & 3;
      var isWrite = accessMode != 0;
      var isRead = accessMode != 1;
      var isCreate = Boolean(oflag & 512);
      var isExistCheck = Boolean(oflag & 2048);
      var isTruncate = Boolean(oflag & 1024);
      var isAppend = Boolean(oflag & 8);
  
      // Verify path.
      var origPath = path;
      path = FS.analyzePath(Pointer_stringify(path));
      if (!path.parentExists) {
        ___setErrNo(path.error);
        return -1;
      }
      var target = path.object || null;
      var finalPath;
  
      // Verify the file exists, create if needed and allowed.
      if (target) {
        if (isCreate && isExistCheck) {
          ___setErrNo(ERRNO_CODES.EEXIST);
          return -1;
        }
        if ((isWrite || isCreate || isTruncate) && target.isFolder) {
          ___setErrNo(ERRNO_CODES.EISDIR);
          return -1;
        }
        if (isRead && !target.read || isWrite && !target.write) {
          ___setErrNo(ERRNO_CODES.EACCES);
          return -1;
        }
        if (isTruncate && !target.isDevice) {
          target.contents = [];
        } else {
          if (!FS.forceLoadFile(target)) {
            ___setErrNo(ERRNO_CODES.EIO);
            return -1;
          }
        }
        finalPath = path.path;
      } else {
        if (!isCreate) {
          ___setErrNo(ERRNO_CODES.ENOENT);
          return -1;
        }
        if (!path.parentObject.write) {
          ___setErrNo(ERRNO_CODES.EACCES);
          return -1;
        }
        target = FS.createDataFile(path.parentObject, path.name, [],
                                   mode & 0x100, mode & 0x80);  // S_IRUSR, S_IWUSR.
        finalPath = path.parentPath + '/' + path.name;
      }
      // Actually create an open stream.
      var id = FS.streams.length; // Keep dense
      if (target.isFolder) {
        var entryBuffer = 0;
        if (___dirent_struct_layout) {
          entryBuffer = _malloc(___dirent_struct_layout.__size__);
        }
        var contents = [];
        for (var key in target.contents) contents.push(key);
        FS.streams[id] = {
          path: finalPath,
          object: target,
          // An index into contents. Special values: -2 is ".", -1 is "..".
          position: -2,
          isRead: true,
          isWrite: false,
          isAppend: false,
          error: false,
          eof: false,
          ungotten: [],
          // Folder-specific properties:
          // Remember the contents at the time of opening in an array, so we can
          // seek between them relying on a single order.
          contents: contents,
          // Each stream has its own area for readdir() returns.
          currentEntry: entryBuffer
        };
      } else {
        FS.streams[id] = {
          path: finalPath,
          object: target,
          position: 0,
          isRead: isRead,
          isWrite: isWrite,
          isAppend: isAppend,
          error: false,
          eof: false,
          ungotten: []
        };
      }
      FS.checkStreams();
      return id;
    }function _fopen(filename, mode) {
      // FILE *fopen(const char *restrict filename, const char *restrict mode);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fopen.html
      var flags;
      mode = Pointer_stringify(mode);
      if (mode[0] == 'r') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 0;
        }
      } else if (mode[0] == 'w') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 1024;
      } else if (mode[0] == 'a') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 8;
      } else {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return 0;
      }
      var ret = _open(filename, flags, allocate([0x1FF, 0, 0, 0], 'i32', ALLOC_STACK));  // All creation permissions.
      return (ret == -1) ? 0 : ret;
    }
var _llvm_dbg_declare; // stub for _llvm_dbg_declare
var _llvm_expect_i32; // stub for _llvm_expect_i32

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 8: return PAGE_SIZE;
        case 54:
        case 56:
        case 21:
        case 61:
        case 63:
        case 22:
        case 67:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 69:
        case 28:
        case 101:
        case 70:
        case 71:
        case 29:
        case 30:
        case 199:
        case 75:
        case 76:
        case 32:
        case 43:
        case 44:
        case 80:
        case 46:
        case 47:
        case 45:
        case 48:
        case 49:
        case 42:
        case 82:
        case 33:
        case 7:
        case 108:
        case 109:
        case 107:
        case 112:
        case 119:
        case 121:
          return 200809;
        case 13:
        case 104:
        case 94:
        case 95:
        case 34:
        case 35:
        case 77:
        case 81:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 94:
        case 95:
        case 110:
        case 111:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 120:
        case 40:
        case 16:
        case 79:
        case 19:
          return -1;
        case 92:
        case 93:
        case 5:
        case 72:
        case 6:
        case 74:
        case 92:
        case 93:
        case 96:
        case 97:
        case 98:
        case 99:
        case 102:
        case 103:
        case 105:
          return 1;
        case 38:
        case 66:
        case 50:
        case 51:
        case 4:
          return 1024;
        case 15:
        case 64:
        case 41:
          return 32;
        case 55:
        case 37:
        case 17:
          return 2147483647;
        case 18:
        case 1:
          return 47839;
        case 59:
        case 57:
          return 99;
        case 68:
        case 58:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 14: return 32768;
        case 73: return 32767;
        case 39: return 16384;
        case 60: return 1000;
        case 106: return 700;
        case 52: return 256;
        case 62: return 255;
        case 2: return 100;
        case 65: return 64;
        case 36: return 20;
        case 100: return 16;
        case 20: return 6;
        case 53: return 4;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret
      }
      return ret;
    }

  
  function ___errno_location() {
      return ___setErrNo.ret;
    }var ___errno=___errno_location;

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
  
      // We need to make sure no one else allocates unfreeable memory!
      // We must control this entirely. So we don't even need to do
      // unfreeable allocations - the HEAP is ours, from STATICTOP up.
      // TODO: We could in theory slice off the top of the HEAP when
      //       sbrk gets a negative increment in |bytes|...
      var self = _sbrk;
      if (!self.called) {
        STATICTOP = alignMemoryPage(STATICTOP); // make sure we start out aligned
        self.called = true;
        _sbrk.DYNAMIC_START = STATICTOP;
      }
      var ret = STATICTOP;
      if (bytes != 0) Runtime.staticAlloc(bytes);
      return ret;  // Previous break location.
    }





  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],ensureObjects:function () {
        if (Browser.ensured) return;
        Browser.ensured = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : console.log("warning: cannot create object URLs");
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        function getMimetype(name) {
          return {
            'jpg': 'image/jpeg',
            'png': 'image/png',
            'bmp': 'image/bmp',
            'ogg': 'audio/ogg',
            'wav': 'audio/wav',
            'mp3': 'audio/mpeg'
          }[name.substr(-3)];
          return ret;
        }
  
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = [];
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function(name) {
          return name.substr(-4) in { '.jpg': 1, '.png': 1, '.bmp': 1 };
        };
        imagePlugin['handle'] = function(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function(name) {
          return name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            setTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
      },createContext:function (canvas, useWebGL, setInModule) {
        try {
          var ctx = canvas.getContext(useWebGL ? 'experimental-webgl' : '2d');
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas - ' + e);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
  
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
        }
        return ctx;
      },requestFullScreen:function () {
        var canvas = Module['canvas'];
        function fullScreenChange() {
          var isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                        canvas['mozRequestPointerLock'] ||
                                        canvas['webkitRequestPointerLock'];
            canvas.requestPointerLock();
            isFullScreen = true;
          }
          if (Module['onFullScreen']) Module['onFullScreen'](isFullScreen);
        }
  
        document.addEventListener('fullscreenchange', fullScreenChange, false);
        document.addEventListener('mozfullscreenchange', fullScreenChange, false);
        document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
  
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
  
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen(); 
      },requestAnimationFrame:function (func) {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                         window['mozRequestAnimationFrame'] ||
                                         window['webkitRequestAnimationFrame'] ||
                                         window['msRequestAnimationFrame'] ||
                                         window['oRequestAnimationFrame'] ||
                                         window['setTimeout'];
        }
        window.requestAnimationFrame(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status == 200) {
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      }};
__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___setErrNo(0);
_fgetc.ret = allocate([0], "i8", ALLOC_STATIC);
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
Module["requestFullScreen"] = function() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function(func) { Browser.requestAnimationFrame(func) };
  Module["pauseMainLoop"] = function() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function() { Browser.mainLoop.resume() };
  

// === Auto-generated postamble setup entry stuff ===

Module.callMain = function callMain(args) {
  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_STATIC) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_STATIC));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_STATIC);

  return _main(argc, argv, 0);
}




var _asm_instr;









































































































var _stderr;

var _code_statements_data;
var _code_statements_elements;
var _code_statements_allocated;

var _code_defs_data;
var _code_defs_elements;
var _code_defs_allocated;
var _code_fields_data;
var _code_fields_elements;
var _code_fields_allocated;
var _code_functions_data;
var _code_functions_elements;
var _code_functions_allocated;
var _code_globals_data;
var _code_globals_elements;
var _code_globals_allocated;
var _code_chars_data;
var _code_chars_elements;
var _code_chars_allocated;
var _code_entfields;
var _code_crc;


















var _asm_instr138;




































































var _levelcolor;











var _type_name;
var _type_sizeof;
var _type_store_instr;
var _field_store_instr;
var _type_storep_instr;
var _type_eq_instr;
var _type_ne_instr;









var _asm_instr231;







































































































































var _lex_filenames_data;
var _lex_filenames_elements;
var _lex_filenames_allocated;



















































var _opts_O;

var _opts_output;
var _opts_standard;
var _opts_debug;
var _opts_memchk;
var _opts_dump;
var _opts_werror;
var _opts_forcecrc;
var _opts_pp_only;
var _operators;
var _operator_count;
var _items_data;
var _items_elements;
var _items_allocated;

var _app_name;
var _opts_warn;
var _c_operators;
var _qcc_operators;

var _opts_flag_list;
var _opts_flags;

var _opts_warn_list;














var _opts_output_wasset;


var _opts_forced_crc;





































































































var _parser;










































































































































































var _mem_ab;
var _mem_db;
var _mem_at;
var _mem_dt;
var _mem_start;






var _stdout;



var _util_crc16_table;
var __gm_;
var _mparams;
STRING_TABLE.__str=allocate([97,115,116,46,99,0] /* ast.c\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str1=allocate([99,97,110,110,111,116,32,100,101,116,101,114,109,105,110,101,32,116,121,112,101,32,111,102,32,117,110,97,114,121,32,111,112,101,114,97,116,105,111,110,32,37,115,0] /* cannot determine typ */, "i8", ALLOC_STATIC);
_asm_instr=allocate([0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str2=allocate([109,101,109,98,101,114,45,97,99,99,101,115,115,32,111,110,32,97,110,32,105,110,118,97,108,105,100,32,111,119,110,101,114,32,111,102,32,116,121,112,101,32,37,115,0] /* member-access on an  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str3=allocate([105,110,118,97,108,105,100,32,116,121,112,101,32,102,111,114,32,112,97,114,97,109,101,116,101,114,32,37,117,32,105,110,32,102,117,110,99,116,105,111,110,32,99,97,108,108,0] /* invalid type for par */, "i8", ALLOC_STATIC);
STRING_TABLE.__str4=allocate([97,115,116,95,118,97,108,117,101,32,117,115,101,100,32,98,101,102,111,114,101,32,103,101,110,101,114,97,116,101,100,32,40,37,115,41,0] /* ast_value used befor */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5=allocate([84,79,68,79,58,32,99,111,110,115,116,97,110,116,32,102,105,101,108,100,32,112,111,105,110,116,101,114,115,32,119,105,116,104,32,118,97,108,117,101,0] /* TODO: constant field */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6=allocate([105,114,95,98,117,105,108,100,101,114,95,99,114,101,97,116,101,95,103,108,111,98,97,108,32,102,97,105,108,101,100,0] /* ir_builder_create_gl */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7=allocate([103,108,111,98,97,108,32,111,102,32,116,121,112,101,32,102,117,110,99,116,105,111,110,32,110,111,116,32,112,114,111,112,101,114,108,121,32,103,101,110,101,114,97,116,101,100,0] /* global of type funct */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8=allocate([84,79,68,79,58,32,103,108,111,98,97,108,32,99,111,110,115,116,97,110,116,32,116,121,112,101,32,37,105,0] /* TODO: global constan */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9=allocate([97,115,116,95,102,117,110,99,116,105,111,110,39,115,32,114,101,108,97,116,101,100,32,97,115,116,95,118,97,108,117,101,32,119,97,115,32,110,111,116,32,103,101,110,101,114,97,116,101,100,32,121,101,116,0] /* ast_function's relat */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10=allocate([102,117,110,99,116,105,111,110,32,96,37,115,96,32,104,97,115,32,110,111,32,98,111,100,121,0] /* function `%s` has no */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11=allocate([101,110,116,114,121,0] /* entry\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12=allocate([102,97,105,108,101,100,32,116,111,32,97,108,108,111,99,97,116,101,32,101,110,116,114,121,32,98,108,111,99,107,32,102,111,114,32,96,37,115,96,0] /* failed to allocate e */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13=allocate([110,111,116,32,97,110,32,108,45,118,97,108,117,101,32,40,99,111,100,101,45,98,108,111,99,107,41,0] /* not an l-value (code */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,108,111,99,97,108,32,96,37,115,96,0] /* failed to generate l */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15=allocate([110,111,116,32,97,110,32,108,45,118,97,108,117,101,32,40,98,105,110,111,112,41,0] /* not an l-value (bino */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16=allocate([98,105,110,0] /* bin\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17=allocate([98,105,110,115,116,0] /* binst\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str18=allocate([117,110,97,114,121,0] /* unary\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str19=allocate([114,101,116,117,114,110,45,101,120,112,114,101,115,115,105,111,110,32,105,115,32,110,111,116,32,97,110,32,108,45,118,97,108,117,101,0] /* return-expression is */, "i8", ALLOC_STATIC);
STRING_TABLE.__str20=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,97,115,116,95,114,101,116,117,114,110,32,99,97,110,110,111,116,32,98,101,32,114,101,117,115,101,100,44,32,105,116,32,98,101,97,114,115,32,110,111,32,114,101,115,117,108,116,33,0] /* internal error: ast_ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21=allocate([101,102,97,0] /* efa\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22=allocate([101,102,118,0] /* efv\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23=allocate([102,97,105,108,101,100,32,116,111,32,99,114,101,97,116,101,32,37,115,32,105,110,115,116,114,117,99,116,105,111,110,32,40,111,117,116,112,117,116,32,116,121,112,101,32,37,115,41,0] /* failed to create %s  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24=allocate([65,68,68,82,69,83,83,0] /* ADDRESS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25=allocate([70,73,69,76,68,0] /* FIELD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str26=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,97,115,116,95,105,102,116,104,101,110,32,99,97,110,110,111,116,32,98,101,32,114,101,117,115,101,100,44,32,105,116,32,98,101,97,114,115,32,110,111,32,114,101,115,117,108,116,33,0] /* internal error: ast_ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27=allocate([111,110,116,114,117,101,0] /* ontrue\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28=allocate([111,110,102,97,108,115,101,0] /* onfalse\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29=allocate([101,110,100,105,102,0] /* endif\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,97,115,116,95,108,111,111,112,32,99,97,110,110,111,116,32,98,101,32,114,101,117,115,101,100,44,32,105,116,32,98,101,97,114,115,32,110,111,32,114,101,115,117,108,116,33,0] /* internal error: ast_ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35=allocate([112,114,101,95,108,111,111,112,95,99,111,110,100,0] /* pre_loop_cond\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36=allocate([108,111,111,112,95,105,110,99,114,101,109,101,110,116,0] /* loop_increment\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37=allocate([112,111,115,116,95,108,111,111,112,95,99,111,110,100,0] /* post_loop_cond\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38=allocate([97,102,116,101,114,95,108,111,111,112,0] /* after_loop\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39=allocate([108,111,111,112,95,98,111,100,121,0] /* loop_body\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40=allocate([110,111,116,32,97,110,32,108,45,118,97,108,117,101,32,40,102,117,110,99,116,105,111,110,32,99,97,108,108,41,0] /* not an l-value (func */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41=allocate([99,97,108,108,0] /* call\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42=allocate([68,79,78,69,0] /* DONE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43=allocate([77,85,76,95,70,0] /* MUL_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44=allocate([77,85,76,95,86,0] /* MUL_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45=allocate([77,85,76,95,70,86,0] /* MUL_FV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46=allocate([77,85,76,95,86,70,0] /* MUL_VF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47=allocate([68,73,86,0] /* DIV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48=allocate([65,68,68,95,70,0] /* ADD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49=allocate([65,68,68,95,86,0] /* ADD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50=allocate([83,85,66,95,70,0] /* SUB_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51=allocate([83,85,66,95,86,0] /* SUB_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str52=allocate([69,81,95,70,0] /* EQ_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str53=allocate([69,81,95,86,0] /* EQ_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str54=allocate([69,81,95,83,0] /* EQ_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str55=allocate([69,81,95,69,0] /* EQ_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str56=allocate([69,81,95,70,78,67,0] /* EQ_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str57=allocate([78,69,95,70,0] /* NE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str58=allocate([78,69,95,86,0] /* NE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str59=allocate([78,69,95,83,0] /* NE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str60=allocate([78,69,95,69,0] /* NE_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str61=allocate([78,69,95,70,78,67,0] /* NE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str62=allocate([76,69,0] /* LE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str63=allocate([71,69,0] /* GE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str64=allocate([76,84,0] /* LT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str65=allocate([71,84,0] /* GT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str66=allocate([70,73,69,76,68,95,70,0] /* FIELD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str67=allocate([70,73,69,76,68,95,86,0] /* FIELD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str68=allocate([70,73,69,76,68,95,83,0] /* FIELD_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str69=allocate([70,73,69,76,68,95,69,78,84,0] /* FIELD_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str70=allocate([70,73,69,76,68,95,70,76,68,0] /* FIELD_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str71=allocate([70,73,69,76,68,95,70,78,67,0] /* FIELD_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str72=allocate([83,84,79,82,69,95,70,0] /* STORE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str73=allocate([83,84,79,82,69,95,86,0] /* STORE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str74=allocate([83,84,79,82,69,95,83,0] /* STORE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str75=allocate([83,84,79,82,69,95,69,78,84,0] /* STORE_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str76=allocate([83,84,79,82,69,95,70,76,68,0] /* STORE_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str77=allocate([83,84,79,82,69,95,70,78,67,0] /* STORE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str78=allocate([83,84,79,82,69,80,95,70,0] /* STOREP_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str79=allocate([83,84,79,82,69,80,95,86,0] /* STOREP_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str80=allocate([83,84,79,82,69,80,95,83,0] /* STOREP_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str81=allocate([83,84,79,82,69,80,95,69,78,84,0] /* STOREP_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str82=allocate([83,84,79,82,69,80,95,70,76,68,0] /* STOREP_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str83=allocate([83,84,79,82,69,80,95,70,78,67,0] /* STOREP_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str84=allocate([82,69,84,85,82,78,0] /* RETURN\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str85=allocate([78,79,84,95,70,0] /* NOT_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str86=allocate([78,79,84,95,86,0] /* NOT_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str87=allocate([78,79,84,95,83,0] /* NOT_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str88=allocate([78,79,84,95,69,78,84,0] /* NOT_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str89=allocate([78,79,84,95,70,78,67,0] /* NOT_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str90=allocate([73,70,0] /* IF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str91=allocate([73,70,78,79,84,0] /* IFNOT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str92=allocate([67,65,76,76,48,0] /* CALL0\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str93=allocate([67,65,76,76,49,0] /* CALL1\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str94=allocate([67,65,76,76,50,0] /* CALL2\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str95=allocate([67,65,76,76,51,0] /* CALL3\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str96=allocate([67,65,76,76,52,0] /* CALL4\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str97=allocate([67,65,76,76,53,0] /* CALL5\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str98=allocate([67,65,76,76,54,0] /* CALL6\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str99=allocate([67,65,76,76,55,0] /* CALL7\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str100=allocate([67,65,76,76,56,0] /* CALL8\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str101=allocate([83,84,65,84,69,0] /* STATE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str102=allocate([71,79,84,79,0] /* GOTO\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str103=allocate([65,78,68,0] /* AND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str104=allocate([79,82,0] /* OR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str105=allocate([66,73,84,65,78,68,0] /* BITAND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str106=allocate([66,73,84,79,82,0] /* BITOR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str107=allocate([69,78,68,0] /* END\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str108=allocate([101,114,114,111,114,0] /* error\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str109=allocate([40,110,117,108,108,41,0] /* (null)\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str110=allocate([40,118,97,114,105,97,110,116,41,0] /* (variant)\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str111=allocate([97,115,116,32,110,111,100,101,32,109,105,115,115,105,110,103,32,100,101,115,116,114,111,121,40,41,10,0] /* ast node missing des */, "i8", ALLOC_STATIC);
_code_statements_data=allocate(4, "i8", ALLOC_STATIC);
_code_statements_elements=allocate(4, "i8", ALLOC_STATIC);
_code_statements_allocated=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str112=allocate([99,111,100,101,46,99,0] /* code.c\00 */, "i8", ALLOC_STATIC);
_code_defs_data=allocate(4, "i8", ALLOC_STATIC);
_code_defs_elements=allocate(4, "i8", ALLOC_STATIC);
_code_defs_allocated=allocate(4, "i8", ALLOC_STATIC);
_code_fields_data=allocate(4, "i8", ALLOC_STATIC);
_code_fields_elements=allocate(4, "i8", ALLOC_STATIC);
_code_fields_allocated=allocate(4, "i8", ALLOC_STATIC);
_code_functions_data=allocate(4, "i8", ALLOC_STATIC);
_code_functions_elements=allocate(4, "i8", ALLOC_STATIC);
_code_functions_allocated=allocate(4, "i8", ALLOC_STATIC);
_code_globals_data=allocate(4, "i8", ALLOC_STATIC);
_code_globals_elements=allocate(4, "i8", ALLOC_STATIC);
_code_globals_allocated=allocate(4, "i8", ALLOC_STATIC);
_code_chars_data=allocate(4, "i8", ALLOC_STATIC);
_code_chars_elements=allocate(4, "i8", ALLOC_STATIC);
_code_chars_allocated=allocate(4, "i8", ALLOC_STATIC);
_code_entfields=allocate(4, "i8", ALLOC_STATIC);
_code_crc=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str8120=allocate([71,69,78,0] /* GEN\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9121=allocate([80,97,116,99,104,105,110,103,32,115,116,114,105,110,103,116,97,98,108,101,32,102,111,114,32,45,102,100,97,114,107,112,108,97,99,101,115,45,115,116,114,105,110,103,116,97,98,108,101,98,117,103,10,0] /* Patching stringtable */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10122=allocate([119,98,0] /* wb\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11123=allocate([72,69,65,68,69,82,58,10,0] /* HEADER:\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12124=allocate([32,32,32,32,118,101,114,115,105,111,110,58,32,32,32,32,61,32,37,100,10,0] /*     version:    = %d */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13125=allocate([32,32,32,32,99,114,99,49,54,58,32,32,32,32,32,32,61,32,37,100,10,0] /*     crc16:      = %d */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14126=allocate([32,32,32,32,101,110,116,102,105,101,108,100,58,32,32,32,61,32,37,100,10,0] /*     entfield:   = %d */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15127=allocate([32,32,32,32,115,116,97,116,101,109,101,110,116,115,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     statements  = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16128=allocate([32,32,32,32,100,101,102,115,32,32,32,32,32,32,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     defs        = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17129=allocate([32,32,32,32,102,105,101,108,100,115,32,32,32,32,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     fields      = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str18130=allocate([32,32,32,32,102,117,110,99,116,105,111,110,115,32,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     functions   = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str19131=allocate([32,32,32,32,103,108,111,98,97,108,115,32,32,32,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     globals     = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str20132=allocate([32,32,32,32,115,116,114,105,110,103,115,32,32,32,32,32,61,32,123,46,111,102,102,115,101,116,32,61,32,37,32,56,100,44,32,46,108,101,110,103,116,104,32,61,32,37,32,56,100,125,10,0] /*     strings     = {. */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21133=allocate([70,85,78,67,84,73,79,78,83,58,10,0] /* FUNCTIONS:\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22134=allocate([32,32,32,32,123,46,101,110,116,114,121,32,61,37,32,53,100,44,32,46,102,105,114,115,116,108,111,99,97,108,32,61,37,32,53,100,44,32,46,108,111,99,97,108,115,32,61,37,32,53,100,44,32,46,112,114,111,102,105,108,101,32,61,37,32,53,100,44,32,46,110,97,109,101,32,61,37,32,53,100,44,32,46,102,105,108,101,32,61,37,32,53,100,44,32,46,110,97,114,103,115,32,61,37,32,53,100,44,32,46,97,114,103,115,105,122,101,32,61,123,37,100,44,37,100,44,37,100,44,37,100,44,37,100,44,37,100,44,37,100,44,37,100,125,32,125,10,0] /*     {.entry =% 5d, . */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23135=allocate([32,32,32,32,78,65,77,69,58,32,37,115,10,0] /*     NAME: %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24136=allocate([32,32,32,32,67,79,68,69,58,10,0] /*     CODE:\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25137=allocate([32,32,32,32,32,32,32,32,37,45,49,50,115,32,123,37,32,53,105,44,37,32,53,105,44,37,32,53,105,125,10,0] /*         %-12s {% 5i, */, "i8", ALLOC_STATIC);
_asm_instr138=allocate([0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str26139=allocate([32,32,32,32,32,32,32,32,68,79,78,69,32,32,123,48,120,48,48,48,48,48,44,48,120,48,48,48,48,48,44,48,120,48,48,48,48,48,125,10,0] /*         DONE  {0x000 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27140=allocate([68,79,78,69,0] /* DONE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28141=allocate([77,85,76,95,70,0] /* MUL_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29142=allocate([77,85,76,95,86,0] /* MUL_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str30143=allocate([77,85,76,95,70,86,0] /* MUL_FV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str31144=allocate([77,85,76,95,86,70,0] /* MUL_VF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str32145=allocate([68,73,86,0] /* DIV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str33146=allocate([65,68,68,95,70,0] /* ADD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34147=allocate([65,68,68,95,86,0] /* ADD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35148=allocate([83,85,66,95,70,0] /* SUB_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36149=allocate([83,85,66,95,86,0] /* SUB_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37150=allocate([69,81,95,70,0] /* EQ_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38151=allocate([69,81,95,86,0] /* EQ_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39152=allocate([69,81,95,83,0] /* EQ_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40153=allocate([69,81,95,69,0] /* EQ_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41154=allocate([69,81,95,70,78,67,0] /* EQ_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42155=allocate([78,69,95,70,0] /* NE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43156=allocate([78,69,95,86,0] /* NE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44157=allocate([78,69,95,83,0] /* NE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45158=allocate([78,69,95,69,0] /* NE_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46159=allocate([78,69,95,70,78,67,0] /* NE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47160=allocate([76,69,0] /* LE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48161=allocate([71,69,0] /* GE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49162=allocate([76,84,0] /* LT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50163=allocate([71,84,0] /* GT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51164=allocate([70,73,69,76,68,95,70,0] /* FIELD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str52165=allocate([70,73,69,76,68,95,86,0] /* FIELD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str53166=allocate([70,73,69,76,68,95,83,0] /* FIELD_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str54167=allocate([70,73,69,76,68,95,69,78,84,0] /* FIELD_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str55168=allocate([70,73,69,76,68,95,70,76,68,0] /* FIELD_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str56169=allocate([70,73,69,76,68,95,70,78,67,0] /* FIELD_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str57170=allocate([65,68,68,82,69,83,83,0] /* ADDRESS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str58171=allocate([83,84,79,82,69,95,70,0] /* STORE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str59172=allocate([83,84,79,82,69,95,86,0] /* STORE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str60173=allocate([83,84,79,82,69,95,83,0] /* STORE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str61174=allocate([83,84,79,82,69,95,69,78,84,0] /* STORE_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str62175=allocate([83,84,79,82,69,95,70,76,68,0] /* STORE_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str63176=allocate([83,84,79,82,69,95,70,78,67,0] /* STORE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str64177=allocate([83,84,79,82,69,80,95,70,0] /* STOREP_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str65178=allocate([83,84,79,82,69,80,95,86,0] /* STOREP_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str66179=allocate([83,84,79,82,69,80,95,83,0] /* STOREP_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str67180=allocate([83,84,79,82,69,80,95,69,78,84,0] /* STOREP_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str68181=allocate([83,84,79,82,69,80,95,70,76,68,0] /* STOREP_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str69182=allocate([83,84,79,82,69,80,95,70,78,67,0] /* STOREP_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str70183=allocate([82,69,84,85,82,78,0] /* RETURN\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str71184=allocate([78,79,84,95,70,0] /* NOT_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str72185=allocate([78,79,84,95,86,0] /* NOT_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str73186=allocate([78,79,84,95,83,0] /* NOT_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str74187=allocate([78,79,84,95,69,78,84,0] /* NOT_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str75188=allocate([78,79,84,95,70,78,67,0] /* NOT_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str76189=allocate([73,70,0] /* IF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str77190=allocate([73,70,78,79,84,0] /* IFNOT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str78191=allocate([67,65,76,76,48,0] /* CALL0\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str79192=allocate([67,65,76,76,49,0] /* CALL1\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str80193=allocate([67,65,76,76,50,0] /* CALL2\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str81194=allocate([67,65,76,76,51,0] /* CALL3\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str82195=allocate([67,65,76,76,52,0] /* CALL4\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str83196=allocate([67,65,76,76,53,0] /* CALL5\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str84197=allocate([67,65,76,76,54,0] /* CALL6\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str85198=allocate([67,65,76,76,55,0] /* CALL7\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str86199=allocate([67,65,76,76,56,0] /* CALL8\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str87200=allocate([83,84,65,84,69,0] /* STATE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str88201=allocate([71,79,84,79,0] /* GOTO\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str89202=allocate([65,78,68,0] /* AND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str90203=allocate([79,82,0] /* OR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str91204=allocate([66,73,84,65,78,68,0] /* BITAND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str92205=allocate([66,73,84,79,82,0] /* BITOR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str93206=allocate([69,78,68,0] /* END\00 */, "i8", ALLOC_STATIC);
_levelcolor=allocate([37, 0, 0, 0, 36, 0, 0, 0, 31, 0, 0, 0], ["i32",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str207=allocate([27,91,48,59,37,100,109,37,115,58,37,100,58,32,27,91,48,59,37,100,109,37,115,58,32,27,91,48,109,0] /* \1B[0;%dm%s:%d: \1B[ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str1208=allocate([10,0] /* \0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str211=allocate([118,111,105,100,0] /* void\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str1212=allocate([115,116,114,105,110,103,0] /* string\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str2213=allocate([102,108,111,97,116,0] /* float\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str3214=allocate([118,101,99,116,111,114,0] /* vector\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str4215=allocate([101,110,116,105,116,121,0] /* entity\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5216=allocate([102,105,101,108,100,0] /* field\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6217=allocate([102,117,110,99,116,105,111,110,0] /* function\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7218=allocate([112,111,105,110,116,101,114,0] /* pointer\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8219=allocate([118,97,114,105,97,110,116,0] /* variant\00 */, "i8", ALLOC_STATIC);
_type_name=allocate(40, "i8", ALLOC_STATIC);
_type_sizeof=allocate([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], ["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
_type_store_instr=allocate([31, 0, 33, 0, 31, 0, 32, 0, 34, 0, 35, 0, 36, 0, 34, 0, 32, 0, 0, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
_field_store_instr=allocate([35, 0, 35, 0, 35, 0, 32, 0, 35, 0, 35, 0, 35, 0, 35, 0, 32, 0, 0, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
_type_storep_instr=allocate([37, 0, 39, 0, 37, 0, 38, 0, 40, 0, 41, 0, 42, 0, 40, 0, 38, 0, 0, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
_type_eq_instr=allocate([10, 0, 12, 0, 10, 0, 11, 0, 13, 0, 13, 0, 14, 0, 13, 0, 11, 0, 0, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
_type_ne_instr=allocate([15, 0, 17, 0, 15, 0, 16, 0, 18, 0, 18, 0, 19, 0, 18, 0, 16, 0, 0, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
STRING_TABLE.__str9222=allocate([105,114,46,99,0] /* ir.c\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10223=allocate([60,64,117,110,110,97,109,101,100,62,0] /* _@unnamed_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11224=allocate([60,64,110,111,32,99,111,110,116,101,120,116,62,0] /* _@no context_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12225=allocate([99,97,110,110,111,116,32,97,100,100,32,112,97,114,97,109,101,116,101,114,115,32,97,102,116,101,114,32,97,100,100,105,110,103,32,108,111,99,97,108,115,0] /* cannot add parameter */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13226=allocate([111,117,116,32,111,102,32,109,101,109,111,114,121,0] /* out of memory\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14227=allocate([105,110,118,97,108,105,100,32,109,101,109,98,101,114,32,97,99,99,101,115,115,32,111,110,32,37,115,0] /* invalid member acces */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15228=allocate([99,97,110,110,111,116,32,115,116,111,114,101,32,116,111,32,97,110,32,83,83,65,32,118,97,108,117,101,0] /* cannot store to an S */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16229=allocate([116,114,121,105,110,103,32,116,111,32,115,116,111,114,101,58,32,37,115,32,60,45,32,37,115,0] /* trying to store: %s  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17230=allocate([105,110,115,116,114,117,99,116,105,111,110,58,32,37,115,0] /* instruction: %s\00 */, "i8", ALLOC_STATIC);
_asm_instr231=allocate([0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str18232=allocate([98,108,111,99,107,32,97,108,114,101,97,100,121,32,101,110,100,101,100,32,40,37,115,41,0] /* block already ended  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str20234=allocate([118,97,114,105,97,98,108,101,32,96,37,115,96,32,109,97,121,32,98,101,32,117,115,101,100,32,117,110,105,110,105,116,105,97,108,105,122,101,100,32,105,110,32,116,104,105,115,32,102,117,110,99,116,105,111,110,0] /* variable `%s` may be */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21235=allocate([119,114,105,116,105,110,103,32,39,37,115,39,46,46,46,10,0] /* writing '%s'...\0A\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22236=allocate([60,73,78,86,65,76,73,68,62,0] /* _INVALID_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23237=allocate([80,72,73,0] /* PHI\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24238=allocate([74,85,77,80,0] /* JUMP\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25239=allocate([67,79,78,68,0] /* COND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str26240=allocate([60,85,78,75,62,0] /* _UNK_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27241=allocate([109,111,100,117,108,101,32,37,115,10,0] /* module %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28242=allocate([103,108,111,98,97,108,32,0] /* global \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29243=allocate([37,115,32,61,32,0] /* %s = \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str30244=allocate([10,0] /* \0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str31245=allocate([101,110,100,109,111,100,117,108,101,32,37,115,10,0] /* endmodule %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str32246=allocate([37,115,102,117,110,99,116,105,111,110,32,37,115,32,61,32,98,117,105,108,116,105,110,32,37,105,10,0] /* %sfunction %s = buil */, "i8", ALLOC_STATIC);
STRING_TABLE.__str33247=allocate([37,115,102,117,110,99,116,105,111,110,32,37,115,10,0] /* %sfunction %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34248=allocate([9,0] /* \09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35249=allocate([37,115,37,105,32,108,111,99,97,108,115,58,10,0] /* %s%i locals:\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36250=allocate([37,115,9,0] /* %s\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37251=allocate([37,115,108,105,102,101,114,97,110,103,101,115,58,10,0] /* %sliferanges:\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38252=allocate([37,115,9,37,115,58,32,117,110,105,113,117,101,32,0] /* %s\09%s: unique \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39253=allocate([91,37,105,44,37,105,93,32,0] /* [%i,%i] \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40254=allocate([37,115,9,37,115,58,32,64,37,105,32,0] /* %s\09%s: @%i \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41255=allocate([37,115,108,105,102,101,32,112,97,115,115,101,115,32,40,99,104,101,99,107,41,58,32,37,105,10,0] /* %slife passes (check */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42256=allocate([37,115,108,105,102,101,32,112,97,115,115,32,99,104,101,99,107,32,102,97,105,108,33,32,37,105,32,33,61,32,37,105,10,0] /* %slife pass check fa */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43257=allocate([37,115,101,110,100,102,117,110,99,116,105,111,110,32,37,115,10,0] /* %sendfunction %s\0A\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44258=allocate([37,115,58,37,115,10,0] /* %s:%s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45259=allocate([37,115,32,60,45,32,112,104,105,32,0] /* %s _- phi \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46260=allocate([40,91,37,115,93,32,58,32,37,115,41,32,0] /* ([%s] : %s) \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47261=allocate([37,115,32,40,37,105,41,32,0] /* %s (%i) \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48262=allocate([32,60,45,32,0] /*  _- \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49263=allocate([67,65,76,76,37,105,9,0] /* CALL%i\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50264=allocate([44,9,0] /* ,\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51265=allocate([91,37,115,93,0] /* [%s]\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str52266=allocate([37,115,91,37,115,93,0] /* %s[%s]\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str53267=allocate([9,112,97,114,97,109,115,58,32,0] /* \09params: \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str54268=allocate([37,115,44,32,0] /* %s, \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str55269=allocate([40,118,111,105,100,41,0] /* (void)\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str56270=allocate([102,110,58,37,115,0] /* fn:%s\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str57271=allocate([37,103,0] /* %g\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str58272=allocate([39,37,103,32,37,103,32,37,103,39,0] /* '%g %g %g'\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str59273=allocate([40,101,110,116,105,116,121,41,0] /* (entity)\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str60274=allocate([34,37,115,34,0] /* \22%s\22\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str61275=allocate([38,37,115,0] /* &%s\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str62276=allocate([37,115,0] /* %s\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str65279=allocate([102,117,110,99,116,105,111,110,32,96,37,115,96,32,104,97,115,32,110,111,32,98,111,100,121,32,97,110,100,32,105,110,32,81,67,32,105,109,112,108,105,99,105,116,108,121,32,98,101,99,111,109,101,115,32,97,32,102,117,110,99,116,105,111,110,45,112,111,105,110,116,101,114,0] /* function `%s` has no */, "i8", ALLOC_STATIC);
STRING_TABLE.__str66280=allocate([96,37,115,96,58,32,73,82,32,103,108,111,98,97,108,32,119,97,115,110,39,116,32,103,101,110,101,114,97,116,101,100,44,32,102,97,105,108,101,100,32,116,111,32,97,99,99,101,115,115,32,102,117,110,99,116,105,111,110,45,100,101,102,0] /* `%s`: IR global wasn */, "i8", ALLOC_STATIC);
STRING_TABLE.__str67281=allocate([70,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,99,111,100,101,32,102,111,114,32,102,117,110,99,116,105,111,110,32,37,115,0] /* Failed to generate c */, "i8", ALLOC_STATIC);
STRING_TABLE.__str68282=allocate([70,117,110,99,116,105,111,110,32,39,37,115,39,32,100,101,99,108,97,114,101,100,32,119,105,116,104,111,117,116,32,98,111,100,121,46,0] /* Function '%s' declar */, "i8", ALLOC_STATIC);
STRING_TABLE.__str69283=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,98,108,111,99,107,115,32,102,111,114,32,39,37,115,39,0] /* failed to generate b */, "i8", ALLOC_STATIC);
STRING_TABLE.__str70284=allocate([99,97,110,110,111,116,32,103,101,110,101,114,97,116,101,32,118,105,114,116,117,97,108,32,105,110,115,116,114,117,99,116,105,111,110,32,40,112,104,105,41,0] /* cannot generate virt */, "i8", ALLOC_STATIC);
STRING_TABLE.__str71285=allocate([84,79,68,79,58,32,115,116,97,116,101,32,105,110,115,116,114,117,99,116,105,111,110,0] /* TODO: state instruct */, "i8", ALLOC_STATIC);
STRING_TABLE.__str72286=allocate([105,110,118,97,108,105,100,32,102,105,101,108,100,32,110,97,109,101,32,115,105,122,101,58,32,37,117,0] /* invalid field name s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str73287=allocate([102,105,101,108,100,32,105,115,32,109,105,115,115,105,110,103,32,97,32,116,121,112,101,58,32,37,115,32,45,32,100,111,110,39,116,32,107,110,111,119,32,105,116,115,32,115,105,122,101,0] /* field is missing a t */, "i8", ALLOC_STATIC);
STRING_TABLE.__str74288=allocate([73,77,77,69,68,73,65,84,69,0] /* IMMEDIATE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str75289=allocate([101,110,100,95,115,121,115,95,103,108,111,98,97,108,115,0] /* end_sys_globals\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str76290=allocate([101,110,100,95,115,121,115,95,102,105,101,108,100,115,0] /* end_sys_fields\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str77291=allocate([117,110,114,101,99,111,103,110,105,122,101,100,32,118,97,114,105,97,98,108,101,32,111,102,32,116,121,112,101,32,118,111,105,100,32,96,37,115,96,0] /* unrecognized variabl */, "i8", ALLOC_STATIC);
STRING_TABLE.__str78292=allocate([73,110,118,97,108,105,100,32,116,121,112,101,32,102,111,114,32,103,108,111,98,97,108,32,118,97,114,105,97,98,108,101,32,96,37,115,96,58,32,37,115,0] /* Invalid type for glo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str79293=allocate([73,110,118,97,108,105,100,32,115,116,97,116,101,32,111,102,32,102,117,110,99,116,105,111,110,45,103,108,111,98,97,108,58,32,110,111,116,32,99,111,110,115,116,97,110,116,58,32,37,115,0] /* Invalid state of fun */, "i8", ALLOC_STATIC);
STRING_TABLE.__str80294=allocate([70,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,108,111,99,97,108,32,37,115,0] /* Failed to generate l */, "i8", ALLOC_STATIC);
STRING_TABLE.__str81295=allocate([73,110,118,97,108,105,100,32,102,105,101,108,100,32,99,111,110,115,116,97,110,116,32,119,105,116,104,32,110,111,32,102,105,101,108,100,58,32,37,115,0] /* Invalid field consta */, "i8", ALLOC_STATIC);
STRING_TABLE.__str82296=allocate([70,73,88,77,69,58,32,82,101,108,111,99,97,116,105,111,110,32,115,117,112,112,111,114,116,0] /* FIXME: Relocation su */, "i8", ALLOC_STATIC);
STRING_TABLE.__str83297=allocate([73,110,118,97,108,105,100,32,112,111,105,110,116,101,114,32,99,111,110,115,116,97,110,116,58,32,37,115,0] /* Invalid pointer cons */, "i8", ALLOC_STATIC);
STRING_TABLE._ir_block_life_propagate_dbg_ind=allocate([35,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0] /* #0\00\00\00\00\00\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str84298=allocate([114,101,103,0] /* reg\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str85299=allocate([119,97,114,110,105,110,103,0] /* warning\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str86300=allocate([68,79,78,69,0] /* DONE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str87301=allocate([77,85,76,95,70,0] /* MUL_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str88302=allocate([77,85,76,95,86,0] /* MUL_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str89303=allocate([77,85,76,95,70,86,0] /* MUL_FV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str90304=allocate([77,85,76,95,86,70,0] /* MUL_VF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str91305=allocate([68,73,86,0] /* DIV\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str92306=allocate([65,68,68,95,70,0] /* ADD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str93307=allocate([65,68,68,95,86,0] /* ADD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str94308=allocate([83,85,66,95,70,0] /* SUB_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str95309=allocate([83,85,66,95,86,0] /* SUB_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str96310=allocate([69,81,95,70,0] /* EQ_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str97311=allocate([69,81,95,86,0] /* EQ_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str98312=allocate([69,81,95,83,0] /* EQ_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str99313=allocate([69,81,95,69,0] /* EQ_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str100314=allocate([69,81,95,70,78,67,0] /* EQ_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str101315=allocate([78,69,95,70,0] /* NE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str102316=allocate([78,69,95,86,0] /* NE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str103317=allocate([78,69,95,83,0] /* NE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str104318=allocate([78,69,95,69,0] /* NE_E\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str105319=allocate([78,69,95,70,78,67,0] /* NE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str106320=allocate([76,69,0] /* LE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str107321=allocate([71,69,0] /* GE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str108322=allocate([76,84,0] /* LT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str109323=allocate([71,84,0] /* GT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str110324=allocate([70,73,69,76,68,95,70,0] /* FIELD_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str111325=allocate([70,73,69,76,68,95,86,0] /* FIELD_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str112326=allocate([70,73,69,76,68,95,83,0] /* FIELD_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str113=allocate([70,73,69,76,68,95,69,78,84,0] /* FIELD_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str114=allocate([70,73,69,76,68,95,70,76,68,0] /* FIELD_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str115=allocate([70,73,69,76,68,95,70,78,67,0] /* FIELD_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str116=allocate([65,68,68,82,69,83,83,0] /* ADDRESS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str117=allocate([83,84,79,82,69,95,70,0] /* STORE_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str118=allocate([83,84,79,82,69,95,86,0] /* STORE_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str119=allocate([83,84,79,82,69,95,83,0] /* STORE_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str120=allocate([83,84,79,82,69,95,69,78,84,0] /* STORE_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str121=allocate([83,84,79,82,69,95,70,76,68,0] /* STORE_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str122=allocate([83,84,79,82,69,95,70,78,67,0] /* STORE_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str123=allocate([83,84,79,82,69,80,95,70,0] /* STOREP_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str124=allocate([83,84,79,82,69,80,95,86,0] /* STOREP_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str125=allocate([83,84,79,82,69,80,95,83,0] /* STOREP_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str126=allocate([83,84,79,82,69,80,95,69,78,84,0] /* STOREP_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str127=allocate([83,84,79,82,69,80,95,70,76,68,0] /* STOREP_FLD\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str128=allocate([83,84,79,82,69,80,95,70,78,67,0] /* STOREP_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str129=allocate([82,69,84,85,82,78,0] /* RETURN\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str130=allocate([78,79,84,95,70,0] /* NOT_F\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str131=allocate([78,79,84,95,86,0] /* NOT_V\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str132=allocate([78,79,84,95,83,0] /* NOT_S\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str133=allocate([78,79,84,95,69,78,84,0] /* NOT_ENT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str134=allocate([78,79,84,95,70,78,67,0] /* NOT_FNC\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str135=allocate([73,70,0] /* IF\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str136=allocate([73,70,78,79,84,0] /* IFNOT\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str137=allocate([67,65,76,76,48,0] /* CALL0\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str138=allocate([67,65,76,76,49,0] /* CALL1\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str139=allocate([67,65,76,76,50,0] /* CALL2\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str140=allocate([67,65,76,76,51,0] /* CALL3\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str141=allocate([67,65,76,76,52,0] /* CALL4\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str142=allocate([67,65,76,76,53,0] /* CALL5\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str143=allocate([67,65,76,76,54,0] /* CALL6\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str144=allocate([67,65,76,76,55,0] /* CALL7\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str145=allocate([67,65,76,76,56,0] /* CALL8\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str146=allocate([83,84,65,84,69,0] /* STATE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str147=allocate([71,79,84,79,0] /* GOTO\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str148=allocate([65,78,68,0] /* AND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str149=allocate([79,82,0] /* OR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str150=allocate([66,73,84,65,78,68,0] /* BITAND\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str151=allocate([66,73,84,79,82,0] /* BITOR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str152=allocate([69,78,68,0] /* END\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str153=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,0] /* internal error\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str385=allocate([108,101,120,101,114,46,99,0] /* lexer.c\00 */, "i8", ALLOC_STATIC);
_lex_filenames_data=allocate(4, "i8", ALLOC_STATIC);
_lex_filenames_elements=allocate(4, "i8", ALLOC_STATIC);
_lex_filenames_allocated=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str1386=allocate([112,97,114,115,101,32,101,114,114,111,114,0] /* parse error\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str2387=allocate([119,97,114,110,105,110,103,0] /* warning\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str3388=allocate([114,98,0] /* rb\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str4389=allocate([111,112,101,110,32,102,97,105,108,101,100,58,32,39,37,115,39,10,0] /* open failed: '%s'\0A */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5390=allocate([111,117,116,32,111,102,32,109,101,109,111,114,121,10,0] /* out of memory\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6391=allocate([60,115,116,114,105,110,103,45,115,111,117,114,99,101,62,0] /* _string-source_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7392=allocate([104,97,110,103,105,110,103,32,39,36,39,32,109,111,100,101,108,103,101,110,47,115,112,114,105,116,101,103,101,110,32,99,111,109,109,97,110,100,32,108,105,110,101,0] /* hanging '$' modelgen */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8393=allocate([102,114,97,109,101,0] /* frame\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9394=allocate([102,114,97,109,101,115,97,118,101,0] /* framesave\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10395=allocate([102,114,97,109,101,118,97,108,117,101,0] /* framevalue\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11396=allocate([36,102,114,97,109,101,118,97,108,117,101,32,114,101,113,117,105,114,101,115,32,97,110,32,105,110,116,101,103,101,114,32,112,97,114,97,109,101,116,101,114,0] /* $framevalue requires */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12397=allocate([102,114,97,109,101,114,101,115,116,111,114,101,0] /* framerestore\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13398=allocate([36,102,114,97,109,101,114,101,115,116,111,114,101,32,114,101,113,117,105,114,101,115,32,97,32,102,114,97,109,101,110,97,109,101,32,112,97,114,97,109,101,116,101,114,0] /* $framerestore requir */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14399=allocate([117,110,107,110,111,119,110,32,102,114,97,109,101,110,97,109,101,32,96,37,115,96,0] /* unknown framename `% */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15400=allocate([109,111,100,101,108,110,97,109,101,0] /* modelname\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16401=allocate([111,117,116,32,111,102,32,109,101,109,111,114,121,0] /* out of memory\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17402=allocate([102,108,117,115,104,0] /* flush\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str18403=allocate([99,100,0] /* cd\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str19404=allocate([111,114,105,103,105,110,0] /* origin\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str20405=allocate([98,97,115,101,0] /* base\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21406=allocate([102,108,97,103,115,0] /* flags\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22407=allocate([115,99,97,108,101,0] /* scale\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23408=allocate([115,107,105,110,0] /* skin\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24409=allocate([105,110,118,97,108,105,100,32,102,114,97,109,101,32,109,97,99,114,111,0] /* invalid frame macro\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25410=allocate([118,111,105,100,0] /* void\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str26411=allocate([105,110,116,0] /* int\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27412=allocate([102,108,111,97,116,0] /* float\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28413=allocate([115,116,114,105,110,103,0] /* string\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29414=allocate([101,110,116,105,116,121,0] /* entity\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str30415=allocate([118,101,99,116,111,114,0] /* vector\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str31416=allocate([102,111,114,0] /* for\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str32417=allocate([119,104,105,108,101,0] /* while\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str33418=allocate([100,111,0] /* do\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34419=allocate([105,102,0] /* if\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35420=allocate([101,108,115,101,0] /* else\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36421=allocate([108,111,99,97,108,0] /* local\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37422=allocate([114,101,116,117,114,110,0] /* return\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38423=allocate([99,111,110,115,116,0] /* const\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39424=allocate([115,119,105,116,99,104,0] /* switch\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40425=allocate([115,116,114,117,99,116,0] /* struct\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41426=allocate([117,110,105,111,110,0] /* union\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42427=allocate([98,114,101,97,107,0] /* break\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43428=allocate([99,111,110,116,105,110,117,101,0] /* continue\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44429=allocate([32,37,102,32,37,102,32,37,102,32,0] /*  %f %f %f \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45430=allocate([117,110,107,110,111,119,110,32,116,111,107,101,110,0] /* unknown token\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46431=allocate([117,110,101,120,112,101,99,116,101,100,32,101,110,100,32,111,102,32,102,105,108,101,0] /* unexpected end of fi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47432=allocate([117,110,114,101,99,111,103,110,105,122,101,100,32,99,111,110,116,114,111,108,32,115,101,113,117,101,110,99,101,58,32,92,37,99,0] /* unrecognized control */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48433=allocate([117,110,101,120,112,101,99,116,101,100,32,101,110,100,32,111,102,32,102,105,108,101,32,119,105,116,104,105,110,32,115,116,114,105,110,103,32,99,111,110,115,116,97,110,116,0] /* unexpected end of fi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49434=allocate([105,110,118,97,108,105,100,32,102,114,97,109,101,110,97,109,101,44,32,109,117,115,116,32,115,116,97,114,116,32,119,105,116,104,32,111,110,101,32,111,102,32,97,45,122,32,111,114,32,95,44,32,103,111,116,32,37,99,0] /* invalid framename, m */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50435=allocate([117,110,101,120,112,101,99,116,101,100,32,116,114,97,105,108,105,110,103,32,99,104,97,114,97,99,116,101,114,115,32,97,102,116,101,114,32,110,117,109,98,101,114,0] /* unexpected trailing  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51436=allocate([100,117,112,108,105,99,97,116,101,32,102,114,97,109,101,32,109,97,99,114,111,32,100,101,102,105,110,101,100,58,32,96,37,115,96,0] /* duplicate frame macr */, "i8", ALLOC_STATIC);
_opts_O=allocate([1], ["i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str437=allocate([112,114,111,103,115,46,100,97,116,0] /* progs.dat\00 */, "i8", ALLOC_STATIC);
_opts_output=allocate(4, "i8", ALLOC_STATIC);
_opts_standard=allocate([3], ["i32",0,0,0], ALLOC_STATIC);
_opts_debug=allocate(4, "i8", ALLOC_STATIC);
_opts_memchk=allocate(4, "i8", ALLOC_STATIC);
_opts_dump=allocate(4, "i8", ALLOC_STATIC);
_opts_werror=allocate(4, "i8", ALLOC_STATIC);
_opts_forcecrc=allocate(4, "i8", ALLOC_STATIC);
_opts_pp_only=allocate(4, "i8", ALLOC_STATIC);
_operators=allocate(4, "i8", ALLOC_STATIC);
_operator_count=allocate(4, "i8", ALLOC_STATIC);
_items_data=allocate(4, "i8", ALLOC_STATIC);
_items_elements=allocate(4, "i8", ALLOC_STATIC);
_items_allocated=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str1448=allocate([109,97,105,110,46,99,0] /* main.c\00 */, "i8", ALLOC_STATIC);
_app_name=allocate(4, "i8", ALLOC_STATIC);
_opts_warn=allocate(4, "i8", ALLOC_STATIC);
_c_operators=allocate([0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5450539, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5451053, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8528, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 32336, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11088, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11600, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2829136, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2960720, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 45, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15420, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15934, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15421, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15933, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15677, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 8509, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 94, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9766, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 31868, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 16186, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 61, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11069, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11581, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 10813, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 12093, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9533, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 4079165, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3947581, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9789, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 24125, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 31805, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
_qcc_operators=allocate([0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8528, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11088, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11600, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 45, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 60, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15421, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15933, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 15677, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 8509, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 61, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11069, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11581, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 10813, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 12093, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9533, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9789, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 31805, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 9766, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 31868, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str2451=allocate([70,108,97,103,32,37,115,32,61,32,37,105,10,0] /* Flag %s = %i\0A\00 */, "i8", ALLOC_STATIC);
_opts_flag_list=allocate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0], ALLOC_STATIC);
_opts_flags=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str3454=allocate([87,97,114,110,105,110,103,32,37,115,32,61,32,37,105,10,0] /* Warning %s = %i\0A\0 */, "i8", ALLOC_STATIC);
_opts_warn_list=allocate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0], ALLOC_STATIC);
STRING_TABLE.__str4455=allocate([111,117,116,112,117,116,32,61,32,37,115,10,0] /* output = %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5456=allocate([111,112,116,105,109,105,122,97,116,105,111,110,32,108,101,118,101,108,32,61,32,37,105,10,0] /* optimization level = */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6457=allocate([115,116,97,110,100,97,114,100,32,61,32,37,105,10,0] /* standard = %i\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7458=allocate([102,97,105,108,101,100,32,116,111,32,105,110,105,116,105,97,108,105,122,101,32,112,97,114,115,101,114,10,0] /* failed to initialize */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8459=allocate([67,79,77,0] /* COM\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9460=allocate([115,116,97,114,116,105,110,103,32,46,46,46,10,0] /* starting ...\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10461=allocate([77,111,100,101,58,32,109,97,110,117,97,108,10,0] /* Mode: manual\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11462=allocate([84,104,101,114,101,32,97,114,101,32,37,108,117,32,105,116,101,109,115,32,116,111,32,99,111,109,112,105,108,101,58,10,0] /* There are %lu items  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12463=allocate([106,115,46,113,99,0] /* js.qc\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13464=allocate([77,111,100,101,58,32,112,114,111,103,115,46,115,114,99,10,0] /* Mode: progs.src\0A\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14465=allocate([112,114,111,103,115,46,115,114,99,0] /* progs.src\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15466=allocate([114,98,0] /* rb\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16467=allocate([102,97,105,108,101,100,32,116,111,32,111,112,101,110,32,96,112,114,111,103,115,46,115,114,99,96,32,102,111,114,32,114,101,97,100,105,110,103,10,0] /* failed to open `prog */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17468=allocate([105,108,108,102,111,114,109,97,116,116,101,100,32,112,114,111,103,115,46,115,114,99,32,102,105,108,101,58,32,101,120,112,101,99,116,101,100,32,111,117,116,112,117,116,32,102,105,108,101,110,97,109,101,32,105,110,32,102,105,114,115,116,32,108,105,110,101,10,0] /* illformatted progs.s */, "i8", ALLOC_STATIC);
_opts_output_wasset=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str18469=allocate([32,32,115,114,99,58,32,37,115,10,0] /*   src: %s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str19470=allocate([99,108,101,97,110,105,110,103,32,46,46,46,10,0] /* cleaning ...\0A\00 */, "i8", ALLOC_STATIC);
_opts_forced_crc=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str20473=allocate([68,69,66,85,71,0] /* DEBUG\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21474=allocate([85,78,85,83,69,68,95,86,65,82,73,65,66,76,69,0] /* UNUSED_VARIABLE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22475=allocate([85,83,69,68,95,85,78,73,78,73,84,73,65,76,73,90,69,68,0] /* USED_UNINITIALIZED\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23476=allocate([85,78,75,78,79,87,78,95,67,79,78,84,82,79,76,95,83,69,81,85,69,78,67,69,0] /* UNKNOWN_CONTROL_SEQU */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24477=allocate([69,88,84,69,78,83,73,79,78,83,0] /* EXTENSIONS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25478=allocate([70,73,69,76,68,95,82,69,68,69,67,76,65,82,69,68,0] /* FIELD_REDECLARED\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str26479=allocate([77,73,83,83,73,78,71,95,82,69,84,85,82,78,95,86,65,76,85,69,83,0] /* MISSING_RETURN_VALUE */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27480=allocate([84,79,79,95,70,69,87,95,80,65,82,65,77,69,84,69,82,83,0] /* TOO_FEW_PARAMETERS\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28481=allocate([76,79,67,65,76,95,83,72,65,68,79,87,83,0] /* LOCAL_SHADOWS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29482=allocate([76,79,67,65,76,95,67,79,78,83,84,65,78,84,83,0] /* LOCAL_CONSTANTS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str30483=allocate([86,79,73,68,95,86,65,82,73,65,66,76,69,83,0] /* VOID_VARIABLES\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str31484=allocate([73,77,80,76,73,67,73,84,95,70,85,78,67,84,73,79,78,95,80,79,73,78,84,69,82,0] /* IMPLICIT_FUNCTION_PO */, "i8", ALLOC_STATIC);
STRING_TABLE.__str32485=allocate([86,65,82,73,65,68,73,67,95,70,85,78,67,84,73,79,78,0] /* VARIADIC_FUNCTION\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str33486=allocate([70,82,65,77,69,95,77,65,67,82,79,83,0] /* FRAME_MACROS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34487=allocate([69,70,70,69,67,84,76,69,83,83,95,83,84,65,84,69,77,69,78,84,0] /* EFFECTLESS_STATEMENT */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35488=allocate([69,78,68,95,83,89,83,95,70,73,69,76,68,83,0] /* END_SYS_FIELDS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36489=allocate([65,83,83,73,71,78,95,70,85,78,67,84,73,79,78,95,84,89,80,69,83,0] /* ASSIGN_FUNCTION_TYPE */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37490=allocate([79,86,69,82,76,65,80,95,76,79,67,65,76,83,0] /* OVERLAP_LOCALS\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38491=allocate([68,65,82,75,80,76,65,67,69,83,95,83,84,82,73,78,71,95,84,65,66,76,69,95,66,85,71,0] /* DARKPLACES_STRING_TA */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39492=allocate([79,77,73,84,95,78,85,76,76,95,66,89,84,69,83,0] /* OMIT_NULL_BYTES\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40493=allocate([65,68,74,85,83,84,95,86,69,67,84,79,82,95,70,73,69,76,68,83,0] /* ADJUST_VECTOR_FIELDS */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41494=allocate([40,0] /* (\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42495=allocate([46,0] /* .\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43496=allocate([33,0] /* !\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44497=allocate([43,0] /* +\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45498=allocate([45,0] /* -\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46499=allocate([42,0] /* _\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47500=allocate([47,0] /* /\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48501=allocate([38,0] /* &\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49502=allocate([124,0] /* |\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50503=allocate([60,0] /* _\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51504=allocate([62,0] /* _\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str52505=allocate([60,61,0] /* _=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str53506=allocate([62,61,0] /* _=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str54507=allocate([61,61,0] /* ==\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str55508=allocate([33,61,0] /* !=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str56509=allocate([61,0] /* =\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str57510=allocate([43,61,0] /* +=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str58511=allocate([45,61,0] /* -=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str59512=allocate([42,61,0] /* _=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str60513=allocate([47,61,0] /* /=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str61514=allocate([37,61,0] /* %=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str62515=allocate([38,61,0] /* &=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str63516=allocate([124,61,0] /* |=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str64517=allocate([38,38,0] /* &&\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str65518=allocate([124,124,0] /* ||\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str66519=allocate([44,0] /* ,\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str67520=allocate([43,43,0] /* ++\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str68521=allocate([45,45,0] /* --\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str69522=allocate([126,0] /* ~\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str70523=allocate([37,0] /* %\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str71524=allocate([60,60,0] /* __\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str72525=allocate([62,62,0] /* __\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str73526=allocate([94,0] /* ^\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str74527=allocate([63,0] /* ?\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str75528=allocate([62,62,61,0] /* __=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str76529=allocate([60,60,61,0] /* __=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str77530=allocate([94,61,0] /* ^=\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str78531=allocate([117,115,97,103,101,58,32,37,115,32,91,111,112,116,105,111,110,115,93,32,91,102,105,108,101,115,46,46,46,93,0] /* usage: %s [options]  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str79532=allocate([111,112,116,105,111,110,115,58,10,32,32,45,104,44,32,45,45,104,101,108,112,32,32,32,32,32,32,32,32,32,32,32,32,32,115,104,111,119,32,116,104,105,115,32,104,101,108,112,32,109,101,115,115,97,103,101,10,32,32,45,100,101,98,117,103,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,116,117,114,110,115,32,111,110,32,99,111,109,112,105,108,101,114,32,100,101,98,117,103,32,109,101,115,115,97,103,101,115,10,32,32,45,109,101,109,99,104,107,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,116,117,114,110,115,32,111,110,32,99,111,109,112,105,108,101,114,32,109,101,109,111,114,121,32,108,101,97,107,32,99,104,101,99,107,10,0] /* options:\0A  -h, --h */, "i8", ALLOC_STATIC);
STRING_TABLE.__str80533=allocate([32,32,45,111,44,32,45,45,111,117,116,112,117,116,61,102,105,108,101,32,32,32,32,32,32,111,117,116,112,117,116,32,102,105,108,101,44,32,100,101,102,97,117,108,116,115,32,116,111,32,112,114,111,103,115,46,100,97,116,10,32,32,45,97,32,102,105,108,101,110,97,109,101,32,32,32,32,32,32,32,32,32,32,32,32,97,100,100,32,97,110,32,97,115,109,32,102,105,108,101,32,116,111,32,98,101,32,97,115,115,101,109,98,108,101,100,10,32,32,45,115,32,102,105,108,101,110,97,109,101,32,32,32,32,32,32,32,32,32,32,32,32,97,100,100,32,97,32,112,114,111,103,115,46,115,114,99,32,102,105,108,101,32,116,111,32,98,101,32,117,115,101,100,10,0] /*   -o, --output=file  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str81534=allocate([32,32,45,69,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,115,116,111,112,32,97,102,116,101,114,32,112,114,101,112,114,111,99,101,115,115,105,110,103,10,0] /*   -E                 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str82535=allocate([32,32,45,102,60,102,108,97,103,62,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,110,97,98,108,101,32,97,32,102,108,97,103,10,32,32,45,102,110,111,45,60,102,108,97,103,62,32,32,32,32,32,32,32,32,32,32,32,32,100,105,115,97,98,108,101,32,97,32,102,108,97,103,10,32,32,45,115,116,100,32,115,116,97,110,100,97,114,100,32,32,32,32,32,32,32,32,32,32,115,101,108,101,99,116,32,111,110,101,32,111,102,32,116,104,101,32,102,111,108,108,111,119,105,110,103,32,115,116,97,110,100,97,114,100,115,10,32,32,32,32,32,32,32,45,115,116,100,61,113,99,99,32,32,32,32,32,32,32,32,32,32,111,114,105,103,105,110,97,108,32,81,117,97,107,101,67,10,32,32,32,32,32,32,32,45,115,116,100,61,102,116,101,113,99,99,32,32,32,32,32,32,32,102,116,101,113,99,99,32,81,117,97,107,101,67,10,32,32,32,32,32,32,32,45,115,116,100,61,103,109,113,99,99,32,32,32,32,32,32,32,32,116,104,105,115,32,99,111,109,112,105,108,101,114,32,40,100,101,102,97,117,108,116,41,10,0] /*   -f_flag_           */, "i8", ALLOC_STATIC);
STRING_TABLE.__str83536=allocate([32,32,45,87,60,119,97,114,110,105,110,103,62,32,32,32,32,32,32,32,32,32,32,32,32,101,110,97,98,108,101,32,97,32,119,97,114,110,105,110,103,10,32,32,45,87,110,111,45,60,119,97,114,110,105,110,103,62,32,32,32,32,32,32,32,32,32,100,105,115,97,98,108,101,32,97,32,119,97,114,110,105,110,103,10,32,32,45,87,97,108,108,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,110,97,98,108,101,32,97,108,108,32,119,97,114,110,105,110,103,115,10,32,32,45,87,101,114,114,111,114,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,116,114,101,97,116,32,119,97,114,110,105,110,103,115,32,97,115,32,101,114,114,111,114,115,10,0] /*   -W_warning_        */, "i8", ALLOC_STATIC);
STRING_TABLE.__str84537=allocate([32,32,45,102,111,114,99,101,45,99,114,99,61,110,117,109,32,32,32,32,32,32,32,32,32,102,111,114,99,101,32,97,32,115,112,101,99,105,102,105,99,32,99,104,101,99,107,115,117,109,32,105,110,116,111,32,116,104,101,32,104,101,97,100,101,114,10,0] /*   -force-crc=num     */, "i8", ALLOC_STATIC);
STRING_TABLE.__str85538=allocate([10,0] /* \0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str86539=allocate([102,108,97,103,115,58,10,32,32,45,102,97,100,106,117,115,116,45,118,101,99,116,111,114,45,102,105,101,108,100,115,10,32,32,32,32,32,32,32,32,32,32,32,32,119,104,101,110,32,97,115,115,105,103,110,105,110,103,32,97,32,118,101,99,116,111,114,32,102,105,101,108,100,44,32,105,116,115,32,95,121,32,97,110,100,32,95,122,32,102,105,101,108,100,115,32,97,108,115,111,32,103,101,116,32,97,115,115,105,103,110,101,100,10,0] /* flags:\0A  -fadjust- */, "i8", ALLOC_STATIC);
STRING_TABLE.__str87540=allocate([115,116,100,0] /* std\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str88541=allocate([103,109,113,99,99,0] /* gmqcc\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str89542=allocate([100,101,102,97,117,108,116,0] /* default\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str90543=allocate([113,99,99,0] /* qcc\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str91544=allocate([102,116,101,0] /* fte\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str92545=allocate([102,116,101,113,99,99,0] /* fteqcc\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str93546=allocate([113,99,99,120,0] /* qccx\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str94547=allocate([85,110,107,110,111,119,110,32,115,116,97,110,100,97,114,100,58,32,37,115,10,0] /* Unknown standard: %s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str95548=allocate([102,111,114,99,101,45,99,114,99,0] /* force-crc\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str96549=allocate([100,101,98,117,103,0] /* debug\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str97550=allocate([100,117,109,112,0] /* dump\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str98551=allocate([109,101,109,99,104,107,0] /* memchk\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str99552=allocate([72,69,76,80,0] /* HELP\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str100553=allocate([80,111,115,115,105,98,108,101,32,102,108,97,103,115,58,10,0] /* Possible flags:\0A\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str101554=allocate([32,45,102,37,115,10,0] /*  -f%s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str102555=allocate([78,79,95,0] /* NO_\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str103556=allocate([117,110,107,110,111,119,110,32,102,108,97,103,58,32,37,115,10,0] /* unknown flag: %s\0A\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str104557=allocate([80,111,115,115,105,98,108,101,32,119,97,114,110,105,110,103,115,58,10,0] /* Possible warnings:\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str105558=allocate([32,45,87,37,115,10,0] /*  -W%s\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str106559=allocate([78,79,95,69,82,82,79,82,0] /* NO_ERROR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str107560=allocate([69,82,82,79,82,0] /* ERROR\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str108561=allocate([78,79,78,69,0] /* NONE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str109562=allocate([65,76,76,0] /* ALL\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str110563=allocate([117,110,107,110,111,119,110,32,119,97,114,110,105,110,103,58,32,37,115,10,0] /* unknown warning: %s\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str111564=allocate([111,112,116,105,111,110,32,45,79,32,114,101,113,117,105,114,101,115,32,97,32,110,117,109,101,114,105,99,97,108,32,97,114,103,117,109,101,110,116,10,0] /* option -O requires a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str112565=allocate([111,112,116,105,111,110,32,45,111,32,114,101,113,117,105,114,101,115,32,97,110,32,97,114,103,117,109,101,110,116,58,32,116,104,101,32,111,117,116,112,117,116,32,102,105,108,101,32,110,97,109,101,10,0] /* option -o requires a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str113566=allocate([111,112,116,105,111,110,32,45,97,32,114,101,113,117,105,114,101,115,32,97,32,102,105,108,101,110,97,109,101,32,37,115,10,0] /* option -a requires a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str114567=allocate([99,111,110,116,97,105,110,105,110,103,32,81,67,45,97,115,109,0] /* containing QC-asm\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str115568=allocate([99,111,110,116,97,105,110,105,110,103,32,97,32,112,114,111,103,115,46,115,114,99,32,102,111,114,109,97,116,116,101,100,32,108,105,115,116,0] /* containing a progs.s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str116569=allocate([104,101,108,112,0] /* help\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str117570=allocate([111,117,116,112,117,116,0] /* output\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str118571=allocate([85,110,107,110,111,119,110,32,112,97,114,97,109,101,116,101,114,58,32,37,115,10,0] /* Unknown parameter: % */, "i8", ALLOC_STATIC);
STRING_TABLE.__str572=allocate([112,97,114,115,101,114,46,99,0] /* parser.c\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str1573=allocate([108,101,120,32,101,114,114,111,114,0] /* lex error\00 */, "i8", ALLOC_STATIC);
_parser=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str2574=allocate([117,110,101,120,112,101,99,116,101,100,32,101,111,102,0] /* unexpected eof\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str3575=allocate([116,104,101,114,101,32,104,97,118,101,32,98,101,101,110,32,101,114,114,111,114,115,44,32,98,97,105,108,105,110,103,32,111,117,116,0] /* there have been erro */, "i8", ALLOC_STATIC);
STRING_TABLE.__str4576=allocate([112,97,114,115,101,32,101,114,114,111,114,0] /* parse error\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5577=allocate([102,97,105,108,101,100,32,116,111,32,111,112,101,110,32,102,105,108,101,32,34,37,115,34,10,0] /* failed to open file  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6578=allocate([102,97,105,108,101,100,32,116,111,32,99,114,101,97,116,101,32,108,101,120,101,114,32,102,111,114,32,115,116,114,105,110,103,32,34,37,115,34,10,0] /* failed to create lex */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7579=allocate([103,109,113,99,99,95,111,117,116,0] /* gmqcc_out\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8580=allocate([102,97,105,108,101,100,32,116,111,32,97,108,108,111,99,97,116,101,32,98,117,105,108,100,101,114,10,0] /* failed to allocate b */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9581=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,102,105,101,108,100,32,37,115,10,0] /* failed to generate f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str10582=allocate([101,110,100,95,115,121,115,95,103,108,111,98,97,108,115,0] /* end_sys_globals\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str11583=allocate([101,110,100,95,115,121,115,95,102,105,101,108,100,115,0] /* end_sys_fields\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str12584=allocate([117,110,117,115,101,100,32,103,108,111,98,97,108,58,32,96,37,115,96,0] /* unused global: `%s`\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str13585=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,103,108,111,98,97,108,32,37,115,10,0] /* failed to generate g */, "i8", ALLOC_STATIC);
STRING_TABLE.__str14586=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,102,117,110,99,116,105,111,110,32,37,115,10,0] /* failed to generate f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str15587=allocate([102,97,105,108,101,100,32,116,111,32,102,105,110,97,108,105,122,101,32,102,117,110,99,116,105,111,110,32,37,115,10,0] /* failed to finalize f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str16588=allocate([42,42,42,32,102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,111,117,116,112,117,116,32,102,105,108,101,10,0] /* ___ failed to genera */, "i8", ALLOC_STATIC);
STRING_TABLE.__str17589=allocate([42,42,42,32,116,104,101,114,101,32,119,101,114,101,32,99,111,109,112,105,108,101,32,101,114,114,111,114,115,10,0] /* ___ there were compi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str18590=allocate([10,47,42,32,102,105,108,101,32,103,101,110,101,114,97,116,101,100,32,98,121,32,113,99,99,44,32,100,111,32,110,111,116,32,109,111,100,105,102,121,32,42,47,10,10,116,121,112,101,100,101,102,32,115,116,114,117,99,116,10,123,0] /* \0A/_ file generated */, "i8", ALLOC_STATIC);
STRING_TABLE.__str19591=allocate([9,105,110,116,9,112,97,100,91,50,56,93,59,10,0] /* \09int\09pad[28];\0A */, "i8", ALLOC_STATIC);
STRING_TABLE.__str20592=allocate([9,102,108,111,97,116,9,0] /* \09float\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str21593=allocate([9,118,101,99,51,95,116,9,0] /* \09vec3_t\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str22594=allocate([9,115,116,114,105,110,103,95,116,9,0] /* \09string_t\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str23595=allocate([9,102,117,110,99,95,116,9,0] /* \09func_t\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str24596=allocate([9,105,110,116,9,0] /* \09int\09\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str25597=allocate([59,10,0] /* ;\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str26598=allocate([125,32,103,108,111,98,97,108,118,97,114,115,95,116,59,10,10,116,121,112,101,100,101,102,32,115,116,114,117,99,116,10,123,10,0] /* } globalvars_t;\0A\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str27599=allocate([125,32,101,110,116,118,97,114,115,95,116,59,10,10,0] /* } entvars_t;\0A\0A\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str28600=allocate([119,97,114,110,105,110,103,0] /* warning\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str29601=allocate([117,110,101,120,112,101,99,116,101,100,32,116,111,107,101,110,58,32,37,115,0] /* unexpected token: %s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str30602=allocate([101,120,112,101,99,116,101,100,32,116,121,112,101,110,97,109,101,32,102,111,114,32,102,105,101,108,100,32,100,101,102,105,110,105,116,105,111,110,0] /* expected typename fo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str31603=allocate([101,120,112,101,99,116,101,100,32,118,97,114,105,97,98,108,101,32,100,101,102,105,110,105,116,105,111,110,0] /* expected variable de */, "i8", ALLOC_STATIC);
STRING_TABLE.__str32604=allocate([102,97,105,108,101,100,32,116,111,32,99,114,101,97,116,101,32,118,97,114,105,97,98,108,101,0] /* failed to create var */, "i8", ALLOC_STATIC);
STRING_TABLE.__str33605=allocate([101,120,112,101,99,116,101,100,32,118,97,114,105,97,98,108,101,32,110,97,109,101,0] /* expected variable na */, "i8", ALLOC_STATIC);
STRING_TABLE.__str34606=allocate([103,108,111,98,97,108,32,39,37,115,39,32,104,105,110,116,32,115,104,111,117,108,100,32,110,111,116,32,98,101,32,97,32,102,105,101,108,100,0] /* global '%s' hint sho */, "i8", ALLOC_STATIC);
STRING_TABLE.__str35607=allocate([102,97,105,108,101,100,32,116,111,32,115,101,116,32,118,97,114,105,97,98,108,101,32,110,97,109,101,10,0] /* failed to set variab */, "i8", ALLOC_STATIC);
STRING_TABLE.__str36608=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,97,32,102,117,110,99,116,105,111,110,32,119,105,116,104,32,116,104,101,32,115,97,109,101,32,110,97,109,101,32,97,115,32,97,32,118,101,99,116,111,114,39,115,32,109,101,109,98,101,114,58,32,37,115,0] /* cannot declare a fun */, "i8", ALLOC_STATIC);
STRING_TABLE.__str37609=allocate([99,111,110,102,108,105,99,116,105,110,103,32,116,121,112,101,115,32,102,111,114,32,96,37,115,96,44,32,112,114,101,118,105,111,117,115,32,100,101,99,108,97,114,97,116,105,111,110,32,119,97,115,32,104,101,114,101,58,32,37,115,58,37,105,0] /* conflicting types fo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str38610=allocate([103,108,111,98,97,108,32,96,37,115,96,32,97,108,114,101,97,100,121,32,100,101,99,108,97,114,101,100,32,104,101,114,101,58,32,37,115,58,37,105,0] /* global `%s` already  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str39611=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,97,32,102,105,101,108,100,32,97,110,100,32,97,32,103,108,111,98,97,108,32,111,102,32,116,104,101,32,115,97,109,101,32,110,97,109,101,32,119,105,116,104,32,45,115,116,100,61,113,99,99,0] /* cannot declare a fie */, "i8", ALLOC_STATIC);
STRING_TABLE.__str40612=allocate([102,105,101,108,100,32,96,37,115,96,32,97,108,114,101,97,100,121,32,100,101,99,108,97,114,101,100,32,104,101,114,101,58,32,37,115,58,37,105,0] /* field `%s` already d */, "i8", ALLOC_STATIC);
STRING_TABLE.__str41613=allocate([102,105,101,108,100,32,37,115,32,104,97,115,32,112,114,101,118,105,111,117,115,108,121,32,98,101,101,110,32,100,101,99,108,97,114,101,100,32,119,105,116,104,32,97,32,100,105,102,102,101,114,101,110,116,32,116,121,112,101,32,104,101,114,101,58,32,37,115,58,37,105,0] /* field %s has previou */, "i8", ALLOC_STATIC);
STRING_TABLE.__str42614=allocate([108,111,99,97,108,32,96,37,115,96,32,97,108,114,101,97,100,121,32,100,101,99,108,97,114,101,100,32,104,101,114,101,58,32,37,115,58,37,105,0] /* local `%s` already d */, "i8", ALLOC_STATIC);
STRING_TABLE.__str43615=allocate([108,111,99,97,108,32,96,37,115,96,32,105,115,32,115,104,97,100,111,119,105,110,103,32,97,32,112,97,114,97,109,101,116,101,114,0] /* local `%s` is shadow */, "i8", ALLOC_STATIC);
STRING_TABLE.__str44616=allocate([97,32,112,97,114,97,109,101,116,101,114,32,105,115,32,115,104,97,100,111,119,105,110,103,32,108,111,99,97,108,32,96,37,115,96,0] /* a parameter is shado */, "i8", ALLOC_STATIC);
STRING_TABLE.__str45617=allocate([109,105,115,115,105,110,103,32,115,101,109,105,99,111,108,111,110,0] /* missing semicolon\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str46618=allocate([105,110,105,116,105,97,108,105,122,105,110,103,32,101,120,112,114,101,115,115,105,111,110,32,116,117,114,110,115,32,118,97,114,105,97,98,108,101,32,96,37,115,96,32,105,110,116,111,32,97,32,99,111,110,115,116,97,110,116,32,105,110,32,116,104,105,115,32,115,116,97,110,100,97,114,100,0] /* initializing express */, "i8", ALLOC_STATIC);
STRING_TABLE.__str47619=allocate([109,105,115,115,105,110,103,32,115,101,109,105,99,111,108,111,110,32,111,114,32,105,110,105,116,105,97,108,105,122,101,114,0] /* missing semicolon or */, "i8", ALLOC_STATIC);
STRING_TABLE.__str48620=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,98,117,105,108,116,105,110,115,32,119,105,116,104,105,110,32,102,117,110,99,116,105,111,110,115,0] /* cannot declare built */, "i8", ALLOC_STATIC);
STRING_TABLE.__str49621=allocate([117,110,101,120,112,101,99,116,101,100,32,98,117,105,108,116,105,110,32,110,117,109,98,101,114,44,32,39,37,115,39,32,105,115,32,110,111,116,32,97,32,102,117,110,99,116,105,111,110,0] /* unexpected builtin n */, "i8", ALLOC_STATIC);
STRING_TABLE.__str50622=allocate([101,120,112,101,99,116,101,100,32,98,117,105,108,116,105,110,32,110,117,109,98,101,114,0] /* expected builtin num */, "i8", ALLOC_STATIC);
STRING_TABLE.__str51623=allocate([98,117,105,108,116,105,110,32,110,117,109,98,101,114,32,109,117,115,116,32,98,101,32,97,110,32,105,110,116,101,103,101,114,32,99,111,110,115,116,97,110,116,0] /* builtin number must  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str52624=allocate([98,117,105,108,116,105,110,32,110,117,109,98,101,114,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101,32,105,110,116,101,103,101,114,32,103,114,101,97,116,101,114,32,116,104,97,110,32,122,101,114,111,0] /* builtin number must  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str53625=allocate([102,97,105,108,101,100,32,116,111,32,97,108,108,111,99,97,116,101,32,102,117,110,99,116,105,111,110,32,102,111,114,32,96,37,115,96,0] /* failed to allocate f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str54626=allocate([102,97,105,108,101,100,32,116,111,32,97,108,108,111,99,97,116,101,32,115,108,111,116,32,102,111,114,32,102,117,110,99,116,105,111,110,32,96,37,115,96,0] /* failed to allocate s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str55627=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,102,117,110,99,116,105,111,110,115,32,119,105,116,104,105,110,32,102,117,110,99,116,105,111,110,115,0] /* cannot declare funct */, "i8", ALLOC_STATIC);
STRING_TABLE.__str56628=allocate([99,97,110,110,111,116,32,105,110,105,116,105,97,108,105,122,101,32,97,32,103,108,111,98,97,108,32,99,111,110,115,116,97,110,116,32,118,97,114,105,97,98,108,101,32,119,105,116,104,32,97,32,110,111,110,45,99,111,110,115,116,97,110,116,32,101,120,112,114,101,115,115,105,111,110,0] /* cannot initialize a  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str57629=allocate([101,120,112,101,99,116,101,100,32,111,112,101,114,97,116,111,114,32,111,114,32,101,110,100,32,111,102,32,115,116,97,116,101,109,101,110,116,0] /* expected operator or */, "i8", ALLOC_STATIC);
STRING_TABLE.__str58630=allocate([84,79,68,79,58,32,105,109,112,108,101,109,101,110,116,32,101,102,102,101,99,116,105,118,101,32,118,101,99,116,111,114,32,109,101,109,98,101,114,32,97,99,99,101,115,115,0] /* TODO: implement effe */, "i8", ALLOC_STATIC);
STRING_TABLE.__str59631=allocate([110,97,109,101,115,112,97,99,101,32,102,111,114,32,109,101,109,98,101,114,32,110,111,116,32,102,111,117,110,100,0] /* namespace for member */, "i8", ALLOC_STATIC);
STRING_TABLE.__str60632=allocate([117,110,101,120,112,101,99,116,101,100,32,105,100,101,110,116,58,32,37,115,0] /* unexpected ident: %s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str61633=allocate([111,117,116,32,111,102,32,109,101,109,111,114,121,0] /* out of memory\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str62634=allocate([101,120,112,101,99,116,101,100,32,111,112,101,114,97,116,111,114,32,111,114,32,101,110,100,32,111,102,32,115,116,97,116,101,109,101,110,116,44,32,103,111,116,32,99,111,110,115,116,97,110,116,0] /* expected operator or */, "i8", ALLOC_STATIC);
STRING_TABLE.__str63635=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,39,40,39,32,115,104,111,117,108,100,32,98,101,32,99,108,97,115,115,105,102,105,101,100,32,97,115,32,111,112,101,114,97,116,111,114,0] /* internal error: '('  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str64636=allocate([117,110,101,120,112,101,99,116,101,100,32,109,101,109,98,101,114,32,111,112,101,114,97,116,111,114,0] /* unexpected member op */, "i8", ALLOC_STATIC);
STRING_TABLE.__str65637=allocate([116,121,112,101,32,101,114,114,111,114,58,32,116,121,112,101,32,104,97,115,32,110,111,32,109,101,109,98,101,114,115,0] /* type error: type has */, "i8", ALLOC_STATIC);
STRING_TABLE.__str66638=allocate([101,109,112,116,121,32,101,120,112,114,101,115,115,105,111,110,0] /* empty expression\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str67639=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,109,105,115,115,105,110,103,32,111,112,101,114,97,116,111,114,0] /* internal error: miss */, "i8", ALLOC_STATIC);
STRING_TABLE.__str68640=allocate([117,110,109,97,116,99,104,101,100,32,112,97,114,101,110,116,104,101,115,105,115,0] /* unmatched parenthesi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str69641=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,110,111,116,32,101,110,111,117,103,104,32,111,112,101,114,97,110,100,115,58,32,37,105,32,40,111,112,101,114,97,116,111,114,32,37,115,32,40,37,105,41,41,0] /* internal error: not  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str70642=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,111,112,101,114,97,116,111,114,32,99,97,110,110,111,116,32,98,101,32,97,112,112,108,105,101,100,32,111,110,32,101,109,112,116,121,32,98,108,111,99,107,115,0] /* internal error: oper */, "i8", ALLOC_STATIC);
STRING_TABLE.__str71643=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,117,110,104,97,110,100,108,101,100,32,111,112,101,114,97,116,111,114,58,32,37,115,32,40,37,105,41,0] /* internal error: unha */, "i8", ALLOC_STATIC);
STRING_TABLE.__str72644=allocate([116,121,112,101,32,101,114,114,111,114,58,32,114,105,103,104,116,32,104,97,110,100,32,111,102,32,109,101,109,98,101,114,45,111,112,101,114,97,110,100,32,115,104,111,117,108,100,32,98,101,32,97,110,32,101,110,116,105,116,121,45,102,105,101,108,100,0] /* type error: right ha */, "i8", ALLOC_STATIC);
STRING_TABLE.__str73645=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,118,101,99,116,111,114,32,97,99,99,101,115,115,32,105,115,32,110,111,116,32,115,117,112,112,111,115,101,100,32,116,111,32,98,101,32,104,97,110,100,108,101,100,32,97,116,32,116,104,105,115,32,112,111,105,110,116,0] /* internal error: vect */, "i8", ALLOC_STATIC);
STRING_TABLE.__str74646=allocate([116,121,112,101,32,101,114,114,111,114,58,32,109,101,109,98,101,114,45,111,102,32,111,112,101,114,97,116,111,114,32,111,110,32,115,111,109,101,116,104,105,110,103,32,116,104,97,116,32,105,115,32,110,111,116,32,97,110,32,101,110,116,105,116,121,32,111,114,32,118,101,99,116,111,114,0] /* type error: member-o */, "i8", ALLOC_STATIC);
STRING_TABLE.__str75647=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,110,101,103,97,116,101,32,116,121,112,101,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str76648=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,108,111,103,105,99,97,108,108,121,32,110,101,103,97,116,101,32,116,121,112,101,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str77649=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,97,100,100,32,116,121,112,101,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str78650=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,115,117,98,116,114,97,99,116,32,116,121,112,101,32,37,115,32,102,114,111,109,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str79651=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,109,117,108,116,105,112,108,121,32,116,121,112,101,115,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str80652=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,100,105,118,105,100,101,32,116,121,112,101,115,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str81653=allocate([113,99,32,100,111,101,115,32,110,111,116,32,104,97,118,101,32,97,32,109,111,100,117,108,111,32,111,112,101,114,97,116,111,114,0] /* qc does not have a m */, "i8", ALLOC_STATIC);
STRING_TABLE.__str82654=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,112,101,114,102,111,114,109,32,98,105,116,32,111,112,101,114,97,116,105,111,110,115,32,98,101,116,119,101,101,110,32,116,121,112,101,115,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str83655=allocate([84,79,68,79,58,32,98,105,116,120,111,114,0] /* TODO: bitxor\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str84656=allocate([84,79,68,79,58,32,115,104,105,102,116,115,0] /* TODO: shifts\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str85657=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,112,101,114,102,111,114,109,32,108,111,103,105,99,97,108,32,111,112,101,114,97,116,105,111,110,115,32,98,101,116,119,101,101,110,32,116,121,112,101,115,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str86658=allocate([84,79,68,79,58,32,108,111,103,105,99,97,108,32,111,112,115,32,102,111,114,32,97,114,98,105,116,114,97,114,121,32,116,121,112,101,115,32,117,115,105,110,103,32,73,78,83,84,82,95,78,79,84,0] /* TODO: logical ops fo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str87659=allocate([84,79,68,79,58,32,111,112,116,105,111,110,97,108,32,101,97,114,108,121,32,111,117,116,0] /* TODO: optional early */, "i8", ALLOC_STATIC);
STRING_TABLE.__str88660=allocate([84,79,68,79,58,32,101,97,114,108,121,32,111,117,116,32,108,111,103,105,99,10,0] /* TODO: early out logi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str89661=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,112,101,114,102,111,114,109,32,99,111,109,112,97,114,105,115,111,110,32,98,101,116,119,101,101,110,32,116,121,112,101,115,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str90662=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,105,110,32,97,115,115,105,103,110,109,101,110,116,58,32,99,97,110,110,111,116,32,97,115,115,105,103,110,32,37,115,32,116,111,32,37,115,0] /* invalid types in ass */, "i8", ALLOC_STATIC);
STRING_TABLE.__str91663=allocate([105,110,118,97,108,105,100,32,116,121,112,101,115,32,117,115,101,100,32,105,110,32,101,120,112,114,101,115,115,105,111,110,58,32,99,97,110,110,111,116,32,97,100,100,32,111,114,32,115,117,98,116,114,97,99,116,32,116,121,112,101,32,37,115,32,97,110,100,32,37,115,0] /* invalid types used i */, "i8", ALLOC_STATIC);
STRING_TABLE.__str92664=allocate([102,97,105,108,101,100,32,116,111,32,97,112,112,108,121,32,111,112,101,114,97,110,100,32,37,115,0] /* failed to apply oper */, "i8", ALLOC_STATIC);
STRING_TABLE.__str93665=allocate([117,110,109,97,116,99,104,101,100,32,99,108,111,115,105,110,103,32,112,97,114,101,110,0] /* unmatched closing pa */, "i8", ALLOC_STATIC);
STRING_TABLE.__str94666=allocate([105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,102,117,110,99,116,105,111,110,32,99,97,108,108,32,110,101,101,100,115,32,102,117,110,99,116,105,111,110,32,97,110,100,32,112,97,114,97,109,101,116,101,114,32,108,105,115,116,46,46,46,0] /* internal error: func */, "i8", ALLOC_STATIC);
STRING_TABLE.__str95667=allocate([105,110,118,97,108,105,100,32,102,117,110,99,116,105,111,110,32,99,97,108,108,0] /* invalid function cal */, "i8", ALLOC_STATIC);
STRING_TABLE.__str96668=allocate([110,111,116,32,97,32,102,117,110,99,116,105,111,110,32,40,37,115,41,0] /* not a function (%s)\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str97669=allocate([99,111,117,108,100,32,110,111,116,32,100,101,116,101,114,109,105,110,101,32,102,117,110,99,116,105,111,110,32,114,101,116,117,114,110,32,116,121,112,101,0] /* could not determine  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str98670=allocate([102,101,119,0] /* few\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str99671=allocate([109,97,110,121,0] /* many\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str100672=allocate([116,111,111,32,37,115,32,112,97,114,97,109,101,116,101,114,115,32,102,111,114,32,99,97,108,108,32,116,111,32,37,115,58,32,101,120,112,101,99,116,101,100,32,37,105,44,32,103,111,116,32,37,105,10,32,45,62,32,96,37,115,96,32,104,97,115,32,98,101,101,110,32,100,101,99,108,97,114,101,100,32,104,101,114,101,58,32,37,115,58,37,105,0] /* too %s parameters fo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str101673=allocate([116,111,111,32,37,115,32,112,97,114,97,109,101,116,101,114,115,32,102,111,114,32,102,117,110,99,116,105,111,110,32,99,97,108,108,58,32,101,120,112,101,99,116,101,100,32,37,105,44,32,103,111,116,32,37,105,10,32,45,62,32,96,37,115,96,32,104,97,115,32,98,101,101,110,32,100,101,99,108,97,114,101,100,32,104,101,114,101,58,32,37,115,58,37,105,0] /* too %s parameters fo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str102674=allocate([35,73,77,77,69,68,73,65,84,69,0] /* #IMMEDIATE\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str103675=allocate([118,97,114,105,97,100,105,99,32,102,117,110,99,116,105,111,110,32,119,105,116,104,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,32,119,105,108,108,32,110,111,116,32,98,101,32,97,98,108,101,32,116,111,32,97,99,99,101,115,115,32,97,100,100,105,116,105,111,110,97,108,32,112,97,114,97,109,101,116,101,114,115,0] /* variadic function wi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str104676=allocate([116,104,105,110,107,0] /* think\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str105677=allocate([110,101,120,116,116,104,105,110,107,0] /* nextthink\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str106678=allocate([102,114,97,109,101,0] /* frame\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str107679=allocate([99,97,110,110,111,116,32,117,115,101,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,32,119,105,116,104,111,117,116,32,116,104,101,32,114,101,113,117,105,114,101,100,32,102,105,101,108,100,115,0] /* cannot use [frame,th */, "i8", ALLOC_STATIC);
STRING_TABLE.__str108680=allocate([112,108,101,97,115,101,32,100,101,99,108,97,114,101,32,116,104,101,32,102,111,108,108,111,119,105,110,103,32,101,110,116,105,116,121,102,105,101,108,100,115,58,32,96,102,114,97,109,101,96,44,32,96,116,104,105,110,107,96,44,32,96,110,101,120,116,116,104,105,110,107,96,0] /* please declare the f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str109681=allocate([116,105,109,101,0] /* time\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str110682=allocate([115,101,108,102,0] /* self\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str111683=allocate([99,97,110,110,111,116,32,117,115,101,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,32,119,105,116,104,111,117,116,32,116,104,101,32,114,101,113,117,105,114,101,100,32,103,108,111,98,97,108,115,0] /* cannot use [frame,th */, "i8", ALLOC_STATIC);
STRING_TABLE.__str112684=allocate([112,108,101,97,115,101,32,100,101,99,108,97,114,101,32,116,104,101,32,102,111,108,108,111,119,105,110,103,32,103,108,111,98,97,108,115,58,32,96,116,105,109,101,96,44,32,96,115,101,108,102,96,0] /* please declare the f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str113685=allocate([101,120,112,101,99,116,101,100,32,97,32,102,114,97,109,101,110,117,109,98,101,114,32,99,111,110,115,116,97,110,116,32,105,110,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,0] /* expected a framenumb */, "i8", ALLOC_STATIC);
STRING_TABLE.__str114686=allocate([102,114,97,109,101,110,117,109,98,101,114,32,105,110,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,32,109,117,115,116,32,98,101,32,97,32,99,111,110,115,116,97,110,116,0] /* framenumber in [fram */, "i8", ALLOC_STATIC);
STRING_TABLE.__str115687=allocate([101,120,112,101,99,116,101,100,32,99,111,109,109,97,32,97,102,116,101,114,32,102,114,97,109,101,32,110,117,109,98,101,114,32,105,110,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,0] /* expected comma after */, "i8", ALLOC_STATIC);
STRING_TABLE.__str116688=allocate([71,111,116,32,97,32,37,105,10,0] /* Got a %i\0A\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str117689=allocate([102,97,105,108,101,100,32,116,111,32,99,114,101,97,116,101,32,105,109,112,108,105,99,105,116,32,112,114,111,116,111,116,121,112,101,32,102,111,114,32,96,37,115,96,0] /* failed to create imp */, "i8", ALLOC_STATIC);
STRING_TABLE.__str118690=allocate([101,120,112,101,99,116,101,100,32,97,32,116,104,105,110,107,45,102,117,110,99,116,105,111,110,32,105,110,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,0] /* expected a think-fun */, "i8", ALLOC_STATIC);
STRING_TABLE.__str119691=allocate([116,104,105,110,107,45,102,117,110,99,116,105,111,110,32,105,110,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,32,109,117,115,116,32,98,101,32,97,32,99,111,110,115,116,97,110,116,0] /* think-function in [f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str120692=allocate([101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,96,93,96,32,102,111,114,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,110,111,116,97,116,105,111,110,0] /* expected closing `]` */, "i8", ALLOC_STATIC);
STRING_TABLE.__str121693=allocate([97,32,102,117,110,99,116,105,111,110,32,98,111,100,121,32,104,97,115,32,116,111,32,98,101,32,100,101,99,108,97,114,101,100,32,97,102,116,101,114,32,97,32,91,102,114,97,109,101,44,116,104,105,110,107,93,32,100,101,99,108,97,114,97,116,105,111,110,0] /* a function body has  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str122694=allocate([102,97,105,108,101,100,32,116,111,32,97,108,108,111,99,97,116,101,32,98,108,111,99,107,0] /* failed to allocate b */, "i8", ALLOC_STATIC);
STRING_TABLE.__str123695=allocate([102,97,105,108,101,100,32,116,111,32,103,101,110,101,114,97,116,101,32,99,111,100,101,32,102,111,114,32,91,102,114,97,109,101,44,116,104,105,110,107,93,0] /* failed to generate c */, "i8", ALLOC_STATIC);
STRING_TABLE.__str124696=allocate([109,105,115,115,105,110,103,32,115,101,109,105,99,111,108,111,110,32,97,102,116,101,114,32,102,117,110,99,116,105,111,110,32,98,111,100,121,32,40,109,97,110,100,97,116,111,114,121,32,119,105,116,104,32,45,115,116,100,61,113,99,99,41,0] /* missing semicolon af */, "i8", ALLOC_STATIC);
STRING_TABLE.__str125697=allocate([117,110,117,115,101,100,32,118,97,114,105,97,98,108,101,58,32,96,37,115,96,0] /* unused variable: `%s */, "i8", ALLOC_STATIC);
STRING_TABLE.__str126698=allocate([101,120,112,101,99,116,101,100,32,102,117,110,99,116,105,111,110,32,98,111,100,121,0] /* expected function bo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str127699=allocate([99,111,110,116,114,111,108,32,114,101,97,99,104,101,115,32,101,110,100,32,111,102,32,110,111,110,45,118,111,105,100,32,102,117,110,99,116,105,111,110,0] /* control reaches end  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str128700=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,97,32,118,97,114,105,97,98,108,101,32,102,114,111,109,32,104,101,114,101,0] /* cannot declare a var */, "i8", ALLOC_STATIC);
STRING_TABLE.__str129701=allocate([109,105,115,115,105,110,103,32,39,108,111,99,97,108,39,32,107,101,121,119,111,114,100,32,119,104,101,110,32,100,101,99,108,97,114,105,110,103,32,97,32,108,111,99,97,108,32,118,97,114,105,97,98,108,101,0] /* missing 'local' keyw */, "i8", ALLOC_STATIC);
STRING_TABLE.__str130702=allocate([108,111,99,97,108,0] /* local\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str131703=allocate([99,97,110,110,111,116,32,100,101,99,108,97,114,101,32,97,32,108,111,99,97,108,32,118,97,114,105,97,98,108,101,32,104,101,114,101,0] /* cannot declare a loc */, "i8", ALLOC_STATIC);
STRING_TABLE.__str132704=allocate([101,120,112,101,99,116,101,100,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,0] /* expected variable de */, "i8", ALLOC_STATIC);
STRING_TABLE.__str133705=allocate([114,101,116,117,114,110,0] /* return\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str134706=allocate([101,120,112,101,99,116,101,100,32,114,101,116,117,114,110,32,101,120,112,114,101,115,115,105,111,110,0] /* expected return expr */, "i8", ALLOC_STATIC);
STRING_TABLE.__str135707=allocate([114,101,116,117,114,110,32,119,105,116,104,32,105,110,118,97,108,105,100,32,101,120,112,114,101,115,115,105,111,110,0] /* return with invalid  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str136708=allocate([114,101,116,117,114,110,32,119,105,116,104,111,117,116,32,118,97,108,117,101,0] /* return without value */, "i8", ALLOC_STATIC);
STRING_TABLE.__str137709=allocate([105,102,0] /* if\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str138710=allocate([119,104,105,108,101,0] /* while\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str139711=allocate([100,111,0] /* do\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str140712=allocate([102,111,114,0] /* for\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str141713=allocate([102,111,114,32,108,111,111,112,115,32,97,114,101,32,110,111,116,32,114,101,99,111,103,110,105,122,101,100,32,105,110,32,116,104,101,32,111,114,105,103,105,110,97,108,32,81,117,97,107,101,32,67,32,115,116,97,110,100,97,114,100,44,32,116,111,32,101,110,97,98,108,101,32,116,114,121,32,97,110,32,97,108,116,101,114,110,97,116,101,32,115,116,97,110,100,97,114,100,32,45,45,115,116,100,61,63,0] /* for loops are not re */, "i8", ALLOC_STATIC);
STRING_TABLE.__str142714=allocate([85,110,101,120,112,101,99,116,101,100,32,107,101,121,119,111,114,100,0] /* Unexpected keyword\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str143715=allocate([115,116,97,116,101,109,101,110,116,32,104,97,115,32,110,111,32,101,102,102,101,99,116,0] /* statement has no eff */, "i8", ALLOC_STATIC);
STRING_TABLE.__str144716=allocate([101,120,112,101,99,116,101,100,32,39,102,111,114,39,32,101,120,112,114,101,115,115,105,111,110,115,32,105,110,32,112,97,114,101,110,116,104,101,115,105,115,0] /* expected 'for' expre */, "i8", ALLOC_STATIC);
STRING_TABLE.__str145717=allocate([101,120,112,101,99,116,101,100,32,39,102,111,114,39,32,105,110,105,116,105,97,108,105,122,101,114,32,97,102,116,101,114,32,111,112,101,110,105,110,103,32,112,97,114,101,110,0] /* expected 'for' initi */, "i8", ALLOC_STATIC);
STRING_TABLE.__str146718=allocate([99,117,114,114,101,110,116,32,115,116,97,110,100,97,114,100,32,100,111,101,115,32,110,111,116,32,97,108,108,111,119,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,32,105,110,32,102,111,114,45,108,111,111,112,32,105,110,105,116,105,97,108,105,122,101,114,115,0] /* current standard doe */, "i8", ALLOC_STATIC);
STRING_TABLE.__str147719=allocate([84,79,68,79,58,32,97,115,115,105,103,110,109,101,110,116,32,111,102,32,110,101,119,32,118,97,114,105,97,98,108,101,115,32,116,111,32,98,101,32,110,111,110,45,99,111,110,115,116,0] /* TODO: assignment of  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str148720=allocate([101,120,112,101,99,116,101,100,32,115,101,109,105,99,111,108,111,110,32,97,102,116,101,114,32,102,111,114,45,108,111,111,112,32,105,110,105,116,105,97,108,105,122,101,114,0] /* expected semicolon a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str149721=allocate([101,120,112,101,99,116,101,100,32,102,111,114,45,108,111,111,112,32,99,111,110,100,105,116,105,111,110,0] /* expected for-loop co */, "i8", ALLOC_STATIC);
STRING_TABLE.__str150722=allocate([101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,112,97,114,101,110,32,97,102,116,101,114,32,39,102,111,114,45,108,111,111,112,39,32,105,110,99,114,101,109,101,110,116,111,114,0] /* expected closing par */, "i8", ALLOC_STATIC);
STRING_TABLE.__str151723=allocate([101,120,112,101,99,116,101,100,32,102,111,114,45,108,111,111,112,32,98,111,100,121,0] /* expected for-loop bo */, "i8", ALLOC_STATIC);
STRING_TABLE.__str152724=allocate([101,120,112,101,99,116,101,100,32,108,111,111,112,32,98,111,100,121,0] /* expected loop body\0 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str153725=allocate([101,120,112,101,99,116,101,100,32,39,119,104,105,108,101,39,32,97,110,100,32,99,111,110,100,105,116,105,111,110,0] /* expected 'while' and */, "i8", ALLOC_STATIC);
STRING_TABLE.__str154=allocate([101,120,112,101,99,116,101,100,32,39,119,104,105,108,101,39,32,99,111,110,100,105,116,105,111,110,32,105,110,32,112,97,114,101,110,116,104,101,115,105,115,0] /* expected 'while' con */, "i8", ALLOC_STATIC);
STRING_TABLE.__str155=allocate([101,120,112,101,99,116,101,100,32,39,119,104,105,108,101,39,32,99,111,110,100,105,116,105,111,110,32,97,102,116,101,114,32,111,112,101,110,105,110,103,32,112,97,114,101,110,0] /* expected 'while' con */, "i8", ALLOC_STATIC);
STRING_TABLE.__str156=allocate([101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,112,97,114,101,110,32,97,102,116,101,114,32,39,119,104,105,108,101,39,32,99,111,110,100,105,116,105,111,110,0] /* expected closing par */, "i8", ALLOC_STATIC);
STRING_TABLE.__str157=allocate([101,120,112,101,99,116,101,100,32,115,101,109,105,99,111,108,111,110,32,97,102,116,101,114,32,99,111,110,100,105,116,105,111,110,0] /* expected semicolon a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str158=allocate([101,120,112,101,99,116,101,100,32,119,104,105,108,101,45,108,111,111,112,32,98,111,100,121,0] /* expected while-loop  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str159=allocate([101,120,112,101,99,116,101,100,32,39,105,102,39,32,99,111,110,100,105,116,105,111,110,32,105,110,32,112,97,114,101,110,116,104,101,115,105,115,0] /* expected 'if' condit */, "i8", ALLOC_STATIC);
STRING_TABLE.__str160=allocate([101,120,112,101,99,116,101,100,32,39,105,102,39,32,99,111,110,100,105,116,105,111,110,32,97,102,116,101,114,32,111,112,101,110,105,110,103,32,112,97,114,101,110,0] /* expected 'if' condit */, "i8", ALLOC_STATIC);
STRING_TABLE.__str161=allocate([101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,112,97,114,101,110,32,97,102,116,101,114,32,39,105,102,39,32,99,111,110,100,105,116,105,111,110,0] /* expected closing par */, "i8", ALLOC_STATIC);
STRING_TABLE.__str162=allocate([101,120,112,101,99,116,101,100,32,115,116,97,116,101,109,101,110,116,32,102,111,114,32,111,110,45,116,114,117,101,32,98,114,97,110,99,104,32,111,102,32,39,105,102,39,0] /* expected statement f */, "i8", ALLOC_STATIC);
STRING_TABLE.__str163=allocate([101,108,115,101,0] /* else\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str164=allocate([101,120,112,101,99,116,101,100,32,111,110,45,102,97,108,115,101,32,98,114,97,110,99,104,32,97,102,116,101,114,32,39,101,108,115,101,39,0] /* expected on-false br */, "i8", ALLOC_STATIC);
STRING_TABLE.__str165=allocate([101,120,112,101,99,116,101,100,32,102,105,101,108,100,32,112,97,114,97,109,101,116,101,114,32,116,121,112,101,0] /* expected field param */, "i8", ALLOC_STATIC);
STRING_TABLE.__str166=allocate([96,46,46,46,96,32,109,117,115,116,32,98,101,32,116,104,101,32,108,97,115,116,32,112,97,114,97,109,101,116,101,114,32,111,102,32,97,32,118,97,114,105,97,100,105,99,32,102,117,110,99,116,105,111,110,32,100,101,99,108,97,114,97,116,105,111,110,0] /* `...` must be the la */, "i8", ALLOC_STATIC);
STRING_TABLE.__str167=allocate([118,97,114,105,97,100,105,99,32,102,117,110,99,116,105,111,110,115,32,97,114,101,32,110,111,116,32,97,118,97,105,108,97,98,108,101,32,105,110,32,116,104,105,115,32,115,116,97,110,100,97,114,100,0] /* variadic functions a */, "i8", ALLOC_STATIC);
STRING_TABLE.__str168=allocate([79,117,116,32,111,102,32,109,101,109,111,114,121,32,119,104,105,108,101,32,112,97,114,115,105,110,103,32,116,121,112,101,110,97,109,101,0] /* Out of memory while  */, "i8", ALLOC_STATIC);
STRING_TABLE.__str169=allocate([85,110,101,120,112,101,99,116,101,100,32,116,111,107,101,110,0] /* Unexpected token\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str170=allocate([109,111,114,101,32,116,104,97,110,32,56,32,112,97,114,97,109,101,116,101,114,115,32,97,114,101,32,99,117,114,114,101,110,116,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0] /* more than 8 paramete */, "i8", ALLOC_STATIC);
STRING_TABLE.__str171=allocate([60,117,110,110,97,109,101,100,62,0] /* _unnamed_\00 */, "i8", ALLOC_STATIC);
_mem_ab=allocate(8, "i8", ALLOC_STATIC);
_mem_db=allocate(8, "i8", ALLOC_STATIC);
_mem_at=allocate(8, "i8", ALLOC_STATIC);
_mem_dt=allocate(8, "i8", ALLOC_STATIC);
_mem_start=allocate(4, "i8", ALLOC_STATIC);
STRING_TABLE.__str736=allocate([77,69,77,0] /* MEM\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str1737=allocate([97,108,108,111,99,97,116,105,111,110,58,32,32,32,37,32,56,117,32,40,98,121,116,101,115,41,32,97,100,100,114,101,115,115,32,48,120,37,48,56,88,32,64,32,37,115,58,37,117,10,0] /* allocation:   % 8u ( */, "i8", ALLOC_STATIC);
STRING_TABLE.__str2738=allocate([114,101,108,101,97,115,101,100,58,32,32,32,32,32,37,32,56,117,32,40,98,121,116,101,115,41,32,97,100,100,114,101,115,115,32,48,120,37,48,56,88,32,64,32,37,115,58,37,117,10,0] /* released:     % 8u ( */, "i8", ALLOC_STATIC);
STRING_TABLE.__str4740=allocate([108,111,115,116,58,32,32,32,32,32,32,32,37,32,56,117,32,40,98,121,116,101,115,41,32,97,116,32,37,115,58,37,117,10,0] /* lost:       % 8u (by */, "i8", ALLOC_STATIC);
STRING_TABLE.__str5741=allocate([77,101,109,111,114,121,32,105,110,102,111,114,109,97,116,105,111,110,58,10,32,32,32,32,32,32,32,32,84,111,116,97,108,32,97,108,108,111,99,97,116,105,111,110,115,58,32,32,32,37,108,108,117,10,32,32,32,32,32,32,32,32,84,111,116,97,108,32,100,101,97,108,108,111,99,97,116,105,111,110,115,58,32,37,108,108,117,10,32,32,32,32,32,32,32,32,84,111,116,97,108,32,97,108,108,111,99,97,116,101,100,58,32,32,32,32,32,37,108,108,117,32,40,98,121,116,101,115,41,10,32,32,32,32,32,32,32,32,84,111,116,97,108,32,100,101,97,108,108,111,99,97,116,101,100,58,32,32,32,37,108,108,117,32,40,98,121,116,101,115,41,10,32,32,32,32,32,32,32,32,76,101,97,107,115,32,102,111,117,110,100,58,32,32,32,32,32,32,32,32,32,108,111,115,116,32,37,108,108,117,32,40,98,121,116,101,115,41,32,105,110,32,37,100,32,97,108,108,111,99,97,116,105,111,110,115,10,0] /* Memory information:\ */, "i8", ALLOC_STATIC);
STRING_TABLE.__str6742=allocate([117,116,105,108,46,99,0] /* util.c\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str7743=allocate([68,69,66,85,71,58,32,0] /* DEBUG: \00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str8744=allocate([37,115,0] /* %s\00 */, "i8", ALLOC_STATIC);
STRING_TABLE.__str9745=allocate([93,32,0] /* ] \00 */, "i8", ALLOC_STATIC);
_util_crc16_table=allocate([0, 0, 4129, 0, 8258, 0, 12387, 0, 16516, 0, 20645, 0, 24774, 0, 28903, 0, -32504, 0, -28375, 0, -24246, 0, -20117, 0, -15988, 0, -11859, 0, -7730, 0, -3601, 0, 4657, 0, 528, 0, 12915, 0, 8786, 0, 21173, 0, 17044, 0, 29431, 0, 25302, 0, -27847, 0, -31976, 0, -19589, 0, -23718, 0, -11331, 0, -15460, 0, -3073, 0, -7202, 0, 9314, 0, 13379, 0, 1056, 0, 5121, 0, 25830, 0, 29895, 0, 17572, 0, 21637, 0, -23190, 0, -19125, 0, -31448, 0, -27383, 0, -6674, 0, -2609, 0, -14932, 0, -10867, 0, 13907, 0, 9842, 0, 5649, 0, 1584, 0, 30423, 0, 26358, 0, 22165, 0, 18100, 0, -18597, 0, -22662, 0, -26855, 0, -30920, 0, -2081, 0, -6146, 0, -10339, 0, -14404, 0, 18628, 0, 22757, 0, 26758, 0, 30887, 0, 2112, 0, 6241, 0, 10242, 0, 14371, 0, -13876, 0, -9747, 0, -5746, 0, -1617, 0, -30392, 0, -26263, 0, -22262, 0, -18133, 0, 23285, 0, 19156, 0, 31415, 0, 27286, 0, 6769, 0, 2640, 0, 14899, 0, 10770, 0, -9219, 0, -13348, 0, -1089, 0, -5218, 0, -25735, 0, -29864, 0, -17605, 0, -21734, 0, 27814, 0, 31879, 0, 19684, 0, 23749, 0, 11298, 0, 15363, 0, 3168, 0, 7233, 0, -4690, 0, -625, 0, -12820, 0, -8755, 0, -21206, 0, -17141, 0, -29336, 0, -25271, 0, 32407, 0, 28342, 0, 24277, 0, 20212, 0, 15891, 0, 11826, 0, 7761, 0, 3696, 0, -97, 0, -4162, 0, -8227, 0, -12292, 0, -16613, 0, -20678, 0, -24743, 0, -28808, 0, -28280, 0, -32343, 0, -20022, 0, -24085, 0, -12020, 0, -16083, 0, -3762, 0, -7825, 0, 4224, 0, 161, 0, 12482, 0, 8419, 0, 20484, 0, 16421, 0, 28742, 0, 24679, 0, -31815, 0, -27752, 0, -23557, 0, -19494, 0, -15555, 0, -11492, 0, -7297, 0, -3234, 0, 689, 0, 4752, 0, 8947, 0, 13010, 0, 16949, 0, 21012, 0, 25207, 0, 29270, 0, -18966, 0, -23093, 0, -27224, 0, -31351, 0, -2706, 0, -6833, 0, -10964, 0, -15091, 0, 13538, 0, 9411, 0, 5280, 0, 1153, 0, 29798, 0, 25671, 0, 21540, 0, 17413, 0, -22565, 0, -18438, 0, -30823, 0, -26696, 0, -6305, 0, -2178, 0, -14563, 0, -10436, 0, 9939, 0, 14066, 0, 1681, 0, 5808, 0, 26199, 0, 30326, 0, 17941, 0, 22068, 0, -9908, 0, -13971, 0, -1778, 0, -5841, 0, -26168, 0, -30231, 0, -18038, 0, -22101, 0, 22596, 0, 18533, 0, 30726, 0, 26663, 0, 6336, 0, 2273, 0, 14466, 0, 10403, 0, -13443, 0, -9380, 0, -5313, 0, -1250, 0, -29703, 0, -25640, 0, -21573, 0, -17510, 0, 19061, 0, 23124, 0, 27191, 0, 31254, 0, 2801, 0, 6864, 0, 10931, 0, 14994, 0, -722, 0, -4849, 0, -8852, 0, -12979, 0, -16982, 0, -21109, 0, -25112, 0, -29239, 0, 31782, 0, 27655, 0, 23652, 0, 19525, 0, 15522, 0, 11395, 0, 7392, 0, 3265, 0, -4321, 0, -194, 0, -12451, 0, -8324, 0, -20581, 0, -16454, 0, -28711, 0, -24584, 0, 28183, 0, 32310, 0, 20053, 0, 24180, 0, 11923, 0, 16050, 0, 3793, 0, 7920, 0], ["i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0], ALLOC_STATIC);
__gm_=allocate(468, "i8", ALLOC_STATIC);
_mparams=allocate(24, "i8", ALLOC_STATIC);
HEAP32[((_asm_instr)>>2)]=((STRING_TABLE.__str42)|0);
HEAP32[(((_asm_instr)+(12))>>2)]=((STRING_TABLE.__str43)|0);
HEAP32[(((_asm_instr)+(24))>>2)]=((STRING_TABLE.__str44)|0);
HEAP32[(((_asm_instr)+(36))>>2)]=((STRING_TABLE.__str45)|0);
HEAP32[(((_asm_instr)+(48))>>2)]=((STRING_TABLE.__str46)|0);
HEAP32[(((_asm_instr)+(60))>>2)]=((STRING_TABLE.__str47)|0);
HEAP32[(((_asm_instr)+(72))>>2)]=((STRING_TABLE.__str48)|0);
HEAP32[(((_asm_instr)+(84))>>2)]=((STRING_TABLE.__str49)|0);
HEAP32[(((_asm_instr)+(96))>>2)]=((STRING_TABLE.__str50)|0);
HEAP32[(((_asm_instr)+(108))>>2)]=((STRING_TABLE.__str51)|0);
HEAP32[(((_asm_instr)+(120))>>2)]=((STRING_TABLE.__str52)|0);
HEAP32[(((_asm_instr)+(132))>>2)]=((STRING_TABLE.__str53)|0);
HEAP32[(((_asm_instr)+(144))>>2)]=((STRING_TABLE.__str54)|0);
HEAP32[(((_asm_instr)+(156))>>2)]=((STRING_TABLE.__str55)|0);
HEAP32[(((_asm_instr)+(168))>>2)]=((STRING_TABLE.__str56)|0);
HEAP32[(((_asm_instr)+(180))>>2)]=((STRING_TABLE.__str57)|0);
HEAP32[(((_asm_instr)+(192))>>2)]=((STRING_TABLE.__str58)|0);
HEAP32[(((_asm_instr)+(204))>>2)]=((STRING_TABLE.__str59)|0);
HEAP32[(((_asm_instr)+(216))>>2)]=((STRING_TABLE.__str60)|0);
HEAP32[(((_asm_instr)+(228))>>2)]=((STRING_TABLE.__str61)|0);
HEAP32[(((_asm_instr)+(240))>>2)]=((STRING_TABLE.__str62)|0);
HEAP32[(((_asm_instr)+(252))>>2)]=((STRING_TABLE.__str63)|0);
HEAP32[(((_asm_instr)+(264))>>2)]=((STRING_TABLE.__str64)|0);
HEAP32[(((_asm_instr)+(276))>>2)]=((STRING_TABLE.__str65)|0);
HEAP32[(((_asm_instr)+(288))>>2)]=((STRING_TABLE.__str66)|0);
HEAP32[(((_asm_instr)+(300))>>2)]=((STRING_TABLE.__str67)|0);
HEAP32[(((_asm_instr)+(312))>>2)]=((STRING_TABLE.__str68)|0);
HEAP32[(((_asm_instr)+(324))>>2)]=((STRING_TABLE.__str69)|0);
HEAP32[(((_asm_instr)+(336))>>2)]=((STRING_TABLE.__str70)|0);
HEAP32[(((_asm_instr)+(348))>>2)]=((STRING_TABLE.__str71)|0);
HEAP32[(((_asm_instr)+(360))>>2)]=((STRING_TABLE.__str24)|0);
HEAP32[(((_asm_instr)+(372))>>2)]=((STRING_TABLE.__str72)|0);
HEAP32[(((_asm_instr)+(384))>>2)]=((STRING_TABLE.__str73)|0);
HEAP32[(((_asm_instr)+(396))>>2)]=((STRING_TABLE.__str74)|0);
HEAP32[(((_asm_instr)+(408))>>2)]=((STRING_TABLE.__str75)|0);
HEAP32[(((_asm_instr)+(420))>>2)]=((STRING_TABLE.__str76)|0);
HEAP32[(((_asm_instr)+(432))>>2)]=((STRING_TABLE.__str77)|0);
HEAP32[(((_asm_instr)+(444))>>2)]=((STRING_TABLE.__str78)|0);
HEAP32[(((_asm_instr)+(456))>>2)]=((STRING_TABLE.__str79)|0);
HEAP32[(((_asm_instr)+(468))>>2)]=((STRING_TABLE.__str80)|0);
HEAP32[(((_asm_instr)+(480))>>2)]=((STRING_TABLE.__str81)|0);
HEAP32[(((_asm_instr)+(492))>>2)]=((STRING_TABLE.__str82)|0);
HEAP32[(((_asm_instr)+(504))>>2)]=((STRING_TABLE.__str83)|0);
HEAP32[(((_asm_instr)+(516))>>2)]=((STRING_TABLE.__str84)|0);
HEAP32[(((_asm_instr)+(528))>>2)]=((STRING_TABLE.__str85)|0);
HEAP32[(((_asm_instr)+(540))>>2)]=((STRING_TABLE.__str86)|0);
HEAP32[(((_asm_instr)+(552))>>2)]=((STRING_TABLE.__str87)|0);
HEAP32[(((_asm_instr)+(564))>>2)]=((STRING_TABLE.__str88)|0);
HEAP32[(((_asm_instr)+(576))>>2)]=((STRING_TABLE.__str89)|0);
HEAP32[(((_asm_instr)+(588))>>2)]=((STRING_TABLE.__str90)|0);
HEAP32[(((_asm_instr)+(600))>>2)]=((STRING_TABLE.__str91)|0);
HEAP32[(((_asm_instr)+(612))>>2)]=((STRING_TABLE.__str92)|0);
HEAP32[(((_asm_instr)+(624))>>2)]=((STRING_TABLE.__str93)|0);
HEAP32[(((_asm_instr)+(636))>>2)]=((STRING_TABLE.__str94)|0);
HEAP32[(((_asm_instr)+(648))>>2)]=((STRING_TABLE.__str95)|0);
HEAP32[(((_asm_instr)+(660))>>2)]=((STRING_TABLE.__str96)|0);
HEAP32[(((_asm_instr)+(672))>>2)]=((STRING_TABLE.__str97)|0);
HEAP32[(((_asm_instr)+(684))>>2)]=((STRING_TABLE.__str98)|0);
HEAP32[(((_asm_instr)+(696))>>2)]=((STRING_TABLE.__str99)|0);
HEAP32[(((_asm_instr)+(708))>>2)]=((STRING_TABLE.__str100)|0);
HEAP32[(((_asm_instr)+(720))>>2)]=((STRING_TABLE.__str101)|0);
HEAP32[(((_asm_instr)+(732))>>2)]=((STRING_TABLE.__str102)|0);
HEAP32[(((_asm_instr)+(744))>>2)]=((STRING_TABLE.__str103)|0);
HEAP32[(((_asm_instr)+(756))>>2)]=((STRING_TABLE.__str104)|0);
HEAP32[(((_asm_instr)+(768))>>2)]=((STRING_TABLE.__str105)|0);
HEAP32[(((_asm_instr)+(780))>>2)]=((STRING_TABLE.__str106)|0);
HEAP32[(((_asm_instr)+(792))>>2)]=((STRING_TABLE.__str107)|0);
HEAP32[((_asm_instr138)>>2)]=((STRING_TABLE.__str27140)|0);
HEAP32[(((_asm_instr138)+(12))>>2)]=((STRING_TABLE.__str28141)|0);
HEAP32[(((_asm_instr138)+(24))>>2)]=((STRING_TABLE.__str29142)|0);
HEAP32[(((_asm_instr138)+(36))>>2)]=((STRING_TABLE.__str30143)|0);
HEAP32[(((_asm_instr138)+(48))>>2)]=((STRING_TABLE.__str31144)|0);
HEAP32[(((_asm_instr138)+(60))>>2)]=((STRING_TABLE.__str32145)|0);
HEAP32[(((_asm_instr138)+(72))>>2)]=((STRING_TABLE.__str33146)|0);
HEAP32[(((_asm_instr138)+(84))>>2)]=((STRING_TABLE.__str34147)|0);
HEAP32[(((_asm_instr138)+(96))>>2)]=((STRING_TABLE.__str35148)|0);
HEAP32[(((_asm_instr138)+(108))>>2)]=((STRING_TABLE.__str36149)|0);
HEAP32[(((_asm_instr138)+(120))>>2)]=((STRING_TABLE.__str37150)|0);
HEAP32[(((_asm_instr138)+(132))>>2)]=((STRING_TABLE.__str38151)|0);
HEAP32[(((_asm_instr138)+(144))>>2)]=((STRING_TABLE.__str39152)|0);
HEAP32[(((_asm_instr138)+(156))>>2)]=((STRING_TABLE.__str40153)|0);
HEAP32[(((_asm_instr138)+(168))>>2)]=((STRING_TABLE.__str41154)|0);
HEAP32[(((_asm_instr138)+(180))>>2)]=((STRING_TABLE.__str42155)|0);
HEAP32[(((_asm_instr138)+(192))>>2)]=((STRING_TABLE.__str43156)|0);
HEAP32[(((_asm_instr138)+(204))>>2)]=((STRING_TABLE.__str44157)|0);
HEAP32[(((_asm_instr138)+(216))>>2)]=((STRING_TABLE.__str45158)|0);
HEAP32[(((_asm_instr138)+(228))>>2)]=((STRING_TABLE.__str46159)|0);
HEAP32[(((_asm_instr138)+(240))>>2)]=((STRING_TABLE.__str47160)|0);
HEAP32[(((_asm_instr138)+(252))>>2)]=((STRING_TABLE.__str48161)|0);
HEAP32[(((_asm_instr138)+(264))>>2)]=((STRING_TABLE.__str49162)|0);
HEAP32[(((_asm_instr138)+(276))>>2)]=((STRING_TABLE.__str50163)|0);
HEAP32[(((_asm_instr138)+(288))>>2)]=((STRING_TABLE.__str51164)|0);
HEAP32[(((_asm_instr138)+(300))>>2)]=((STRING_TABLE.__str52165)|0);
HEAP32[(((_asm_instr138)+(312))>>2)]=((STRING_TABLE.__str53166)|0);
HEAP32[(((_asm_instr138)+(324))>>2)]=((STRING_TABLE.__str54167)|0);
HEAP32[(((_asm_instr138)+(336))>>2)]=((STRING_TABLE.__str55168)|0);
HEAP32[(((_asm_instr138)+(348))>>2)]=((STRING_TABLE.__str56169)|0);
HEAP32[(((_asm_instr138)+(360))>>2)]=((STRING_TABLE.__str57170)|0);
HEAP32[(((_asm_instr138)+(372))>>2)]=((STRING_TABLE.__str58171)|0);
HEAP32[(((_asm_instr138)+(384))>>2)]=((STRING_TABLE.__str59172)|0);
HEAP32[(((_asm_instr138)+(396))>>2)]=((STRING_TABLE.__str60173)|0);
HEAP32[(((_asm_instr138)+(408))>>2)]=((STRING_TABLE.__str61174)|0);
HEAP32[(((_asm_instr138)+(420))>>2)]=((STRING_TABLE.__str62175)|0);
HEAP32[(((_asm_instr138)+(432))>>2)]=((STRING_TABLE.__str63176)|0);
HEAP32[(((_asm_instr138)+(444))>>2)]=((STRING_TABLE.__str64177)|0);
HEAP32[(((_asm_instr138)+(456))>>2)]=((STRING_TABLE.__str65178)|0);
HEAP32[(((_asm_instr138)+(468))>>2)]=((STRING_TABLE.__str66179)|0);
HEAP32[(((_asm_instr138)+(480))>>2)]=((STRING_TABLE.__str67180)|0);
HEAP32[(((_asm_instr138)+(492))>>2)]=((STRING_TABLE.__str68181)|0);
HEAP32[(((_asm_instr138)+(504))>>2)]=((STRING_TABLE.__str69182)|0);
HEAP32[(((_asm_instr138)+(516))>>2)]=((STRING_TABLE.__str70183)|0);
HEAP32[(((_asm_instr138)+(528))>>2)]=((STRING_TABLE.__str71184)|0);
HEAP32[(((_asm_instr138)+(540))>>2)]=((STRING_TABLE.__str72185)|0);
HEAP32[(((_asm_instr138)+(552))>>2)]=((STRING_TABLE.__str73186)|0);
HEAP32[(((_asm_instr138)+(564))>>2)]=((STRING_TABLE.__str74187)|0);
HEAP32[(((_asm_instr138)+(576))>>2)]=((STRING_TABLE.__str75188)|0);
HEAP32[(((_asm_instr138)+(588))>>2)]=((STRING_TABLE.__str76189)|0);
HEAP32[(((_asm_instr138)+(600))>>2)]=((STRING_TABLE.__str77190)|0);
HEAP32[(((_asm_instr138)+(612))>>2)]=((STRING_TABLE.__str78191)|0);
HEAP32[(((_asm_instr138)+(624))>>2)]=((STRING_TABLE.__str79192)|0);
HEAP32[(((_asm_instr138)+(636))>>2)]=((STRING_TABLE.__str80193)|0);
HEAP32[(((_asm_instr138)+(648))>>2)]=((STRING_TABLE.__str81194)|0);
HEAP32[(((_asm_instr138)+(660))>>2)]=((STRING_TABLE.__str82195)|0);
HEAP32[(((_asm_instr138)+(672))>>2)]=((STRING_TABLE.__str83196)|0);
HEAP32[(((_asm_instr138)+(684))>>2)]=((STRING_TABLE.__str84197)|0);
HEAP32[(((_asm_instr138)+(696))>>2)]=((STRING_TABLE.__str85198)|0);
HEAP32[(((_asm_instr138)+(708))>>2)]=((STRING_TABLE.__str86199)|0);
HEAP32[(((_asm_instr138)+(720))>>2)]=((STRING_TABLE.__str87200)|0);
HEAP32[(((_asm_instr138)+(732))>>2)]=((STRING_TABLE.__str88201)|0);
HEAP32[(((_asm_instr138)+(744))>>2)]=((STRING_TABLE.__str89202)|0);
HEAP32[(((_asm_instr138)+(756))>>2)]=((STRING_TABLE.__str90203)|0);
HEAP32[(((_asm_instr138)+(768))>>2)]=((STRING_TABLE.__str91204)|0);
HEAP32[(((_asm_instr138)+(780))>>2)]=((STRING_TABLE.__str92205)|0);
HEAP32[(((_asm_instr138)+(792))>>2)]=((STRING_TABLE.__str93206)|0);
HEAP32[((_type_name)>>2)]=((STRING_TABLE.__str211)|0);
HEAP32[(((_type_name)+(4))>>2)]=((STRING_TABLE.__str1212)|0);
HEAP32[(((_type_name)+(8))>>2)]=((STRING_TABLE.__str2213)|0);
HEAP32[(((_type_name)+(12))>>2)]=((STRING_TABLE.__str3214)|0);
HEAP32[(((_type_name)+(16))>>2)]=((STRING_TABLE.__str4215)|0);
HEAP32[(((_type_name)+(20))>>2)]=((STRING_TABLE.__str5216)|0);
HEAP32[(((_type_name)+(24))>>2)]=((STRING_TABLE.__str6217)|0);
HEAP32[(((_type_name)+(28))>>2)]=((STRING_TABLE.__str7218)|0);
HEAP32[(((_type_name)+(32))>>2)]=((STRING_TABLE.__str8219)|0);
HEAP32[((_asm_instr231)>>2)]=((STRING_TABLE.__str86300)|0);
HEAP32[(((_asm_instr231)+(12))>>2)]=((STRING_TABLE.__str87301)|0);
HEAP32[(((_asm_instr231)+(24))>>2)]=((STRING_TABLE.__str88302)|0);
HEAP32[(((_asm_instr231)+(36))>>2)]=((STRING_TABLE.__str89303)|0);
HEAP32[(((_asm_instr231)+(48))>>2)]=((STRING_TABLE.__str90304)|0);
HEAP32[(((_asm_instr231)+(60))>>2)]=((STRING_TABLE.__str91305)|0);
HEAP32[(((_asm_instr231)+(72))>>2)]=((STRING_TABLE.__str92306)|0);
HEAP32[(((_asm_instr231)+(84))>>2)]=((STRING_TABLE.__str93307)|0);
HEAP32[(((_asm_instr231)+(96))>>2)]=((STRING_TABLE.__str94308)|0);
HEAP32[(((_asm_instr231)+(108))>>2)]=((STRING_TABLE.__str95309)|0);
HEAP32[(((_asm_instr231)+(120))>>2)]=((STRING_TABLE.__str96310)|0);
HEAP32[(((_asm_instr231)+(132))>>2)]=((STRING_TABLE.__str97311)|0);
HEAP32[(((_asm_instr231)+(144))>>2)]=((STRING_TABLE.__str98312)|0);
HEAP32[(((_asm_instr231)+(156))>>2)]=((STRING_TABLE.__str99313)|0);
HEAP32[(((_asm_instr231)+(168))>>2)]=((STRING_TABLE.__str100314)|0);
HEAP32[(((_asm_instr231)+(180))>>2)]=((STRING_TABLE.__str101315)|0);
HEAP32[(((_asm_instr231)+(192))>>2)]=((STRING_TABLE.__str102316)|0);
HEAP32[(((_asm_instr231)+(204))>>2)]=((STRING_TABLE.__str103317)|0);
HEAP32[(((_asm_instr231)+(216))>>2)]=((STRING_TABLE.__str104318)|0);
HEAP32[(((_asm_instr231)+(228))>>2)]=((STRING_TABLE.__str105319)|0);
HEAP32[(((_asm_instr231)+(240))>>2)]=((STRING_TABLE.__str106320)|0);
HEAP32[(((_asm_instr231)+(252))>>2)]=((STRING_TABLE.__str107321)|0);
HEAP32[(((_asm_instr231)+(264))>>2)]=((STRING_TABLE.__str108322)|0);
HEAP32[(((_asm_instr231)+(276))>>2)]=((STRING_TABLE.__str109323)|0);
HEAP32[(((_asm_instr231)+(288))>>2)]=((STRING_TABLE.__str110324)|0);
HEAP32[(((_asm_instr231)+(300))>>2)]=((STRING_TABLE.__str111325)|0);
HEAP32[(((_asm_instr231)+(312))>>2)]=((STRING_TABLE.__str112326)|0);
HEAP32[(((_asm_instr231)+(324))>>2)]=((STRING_TABLE.__str113)|0);
HEAP32[(((_asm_instr231)+(336))>>2)]=((STRING_TABLE.__str114)|0);
HEAP32[(((_asm_instr231)+(348))>>2)]=((STRING_TABLE.__str115)|0);
HEAP32[(((_asm_instr231)+(360))>>2)]=((STRING_TABLE.__str116)|0);
HEAP32[(((_asm_instr231)+(372))>>2)]=((STRING_TABLE.__str117)|0);
HEAP32[(((_asm_instr231)+(384))>>2)]=((STRING_TABLE.__str118)|0);
HEAP32[(((_asm_instr231)+(396))>>2)]=((STRING_TABLE.__str119)|0);
HEAP32[(((_asm_instr231)+(408))>>2)]=((STRING_TABLE.__str120)|0);
HEAP32[(((_asm_instr231)+(420))>>2)]=((STRING_TABLE.__str121)|0);
HEAP32[(((_asm_instr231)+(432))>>2)]=((STRING_TABLE.__str122)|0);
HEAP32[(((_asm_instr231)+(444))>>2)]=((STRING_TABLE.__str123)|0);
HEAP32[(((_asm_instr231)+(456))>>2)]=((STRING_TABLE.__str124)|0);
HEAP32[(((_asm_instr231)+(468))>>2)]=((STRING_TABLE.__str125)|0);
HEAP32[(((_asm_instr231)+(480))>>2)]=((STRING_TABLE.__str126)|0);
HEAP32[(((_asm_instr231)+(492))>>2)]=((STRING_TABLE.__str127)|0);
HEAP32[(((_asm_instr231)+(504))>>2)]=((STRING_TABLE.__str128)|0);
HEAP32[(((_asm_instr231)+(516))>>2)]=((STRING_TABLE.__str129)|0);
HEAP32[(((_asm_instr231)+(528))>>2)]=((STRING_TABLE.__str130)|0);
HEAP32[(((_asm_instr231)+(540))>>2)]=((STRING_TABLE.__str131)|0);
HEAP32[(((_asm_instr231)+(552))>>2)]=((STRING_TABLE.__str132)|0);
HEAP32[(((_asm_instr231)+(564))>>2)]=((STRING_TABLE.__str133)|0);
HEAP32[(((_asm_instr231)+(576))>>2)]=((STRING_TABLE.__str134)|0);
HEAP32[(((_asm_instr231)+(588))>>2)]=((STRING_TABLE.__str135)|0);
HEAP32[(((_asm_instr231)+(600))>>2)]=((STRING_TABLE.__str136)|0);
HEAP32[(((_asm_instr231)+(612))>>2)]=((STRING_TABLE.__str137)|0);
HEAP32[(((_asm_instr231)+(624))>>2)]=((STRING_TABLE.__str138)|0);
HEAP32[(((_asm_instr231)+(636))>>2)]=((STRING_TABLE.__str139)|0);
HEAP32[(((_asm_instr231)+(648))>>2)]=((STRING_TABLE.__str140)|0);
HEAP32[(((_asm_instr231)+(660))>>2)]=((STRING_TABLE.__str141)|0);
HEAP32[(((_asm_instr231)+(672))>>2)]=((STRING_TABLE.__str142)|0);
HEAP32[(((_asm_instr231)+(684))>>2)]=((STRING_TABLE.__str143)|0);
HEAP32[(((_asm_instr231)+(696))>>2)]=((STRING_TABLE.__str144)|0);
HEAP32[(((_asm_instr231)+(708))>>2)]=((STRING_TABLE.__str145)|0);
HEAP32[(((_asm_instr231)+(720))>>2)]=((STRING_TABLE.__str146)|0);
HEAP32[(((_asm_instr231)+(732))>>2)]=((STRING_TABLE.__str147)|0);
HEAP32[(((_asm_instr231)+(744))>>2)]=((STRING_TABLE.__str148)|0);
HEAP32[(((_asm_instr231)+(756))>>2)]=((STRING_TABLE.__str149)|0);
HEAP32[(((_asm_instr231)+(768))>>2)]=((STRING_TABLE.__str150)|0);
HEAP32[(((_asm_instr231)+(780))>>2)]=((STRING_TABLE.__str151)|0);
HEAP32[(((_asm_instr231)+(792))>>2)]=((STRING_TABLE.__str152)|0);
HEAP32[((_opts_output)>>2)]=((STRING_TABLE.__str437)|0);
HEAP32[((_c_operators)>>2)]=((STRING_TABLE.__str41494)|0);
HEAP32[(((_c_operators)+(24))>>2)]=((STRING_TABLE.__str67520)|0);
HEAP32[(((_c_operators)+(48))>>2)]=((STRING_TABLE.__str68521)|0);
HEAP32[(((_c_operators)+(72))>>2)]=((STRING_TABLE.__str42495)|0);
HEAP32[(((_c_operators)+(96))>>2)]=((STRING_TABLE.__str41494)|0);
HEAP32[(((_c_operators)+(120))>>2)]=((STRING_TABLE.__str43496)|0);
HEAP32[(((_c_operators)+(144))>>2)]=((STRING_TABLE.__str69522)|0);
HEAP32[(((_c_operators)+(168))>>2)]=((STRING_TABLE.__str44497)|0);
HEAP32[(((_c_operators)+(192))>>2)]=((STRING_TABLE.__str45498)|0);
HEAP32[(((_c_operators)+(216))>>2)]=((STRING_TABLE.__str67520)|0);
HEAP32[(((_c_operators)+(240))>>2)]=((STRING_TABLE.__str68521)|0);
HEAP32[(((_c_operators)+(264))>>2)]=((STRING_TABLE.__str46499)|0);
HEAP32[(((_c_operators)+(288))>>2)]=((STRING_TABLE.__str47500)|0);
HEAP32[(((_c_operators)+(312))>>2)]=((STRING_TABLE.__str70523)|0);
HEAP32[(((_c_operators)+(336))>>2)]=((STRING_TABLE.__str44497)|0);
HEAP32[(((_c_operators)+(360))>>2)]=((STRING_TABLE.__str45498)|0);
HEAP32[(((_c_operators)+(384))>>2)]=((STRING_TABLE.__str71524)|0);
HEAP32[(((_c_operators)+(408))>>2)]=((STRING_TABLE.__str72525)|0);
HEAP32[(((_c_operators)+(432))>>2)]=((STRING_TABLE.__str50503)|0);
HEAP32[(((_c_operators)+(456))>>2)]=((STRING_TABLE.__str51504)|0);
HEAP32[(((_c_operators)+(480))>>2)]=((STRING_TABLE.__str52505)|0);
HEAP32[(((_c_operators)+(504))>>2)]=((STRING_TABLE.__str53506)|0);
HEAP32[(((_c_operators)+(528))>>2)]=((STRING_TABLE.__str54507)|0);
HEAP32[(((_c_operators)+(552))>>2)]=((STRING_TABLE.__str55508)|0);
HEAP32[(((_c_operators)+(576))>>2)]=((STRING_TABLE.__str48501)|0);
HEAP32[(((_c_operators)+(600))>>2)]=((STRING_TABLE.__str73526)|0);
HEAP32[(((_c_operators)+(624))>>2)]=((STRING_TABLE.__str49502)|0);
HEAP32[(((_c_operators)+(648))>>2)]=((STRING_TABLE.__str64517)|0);
HEAP32[(((_c_operators)+(672))>>2)]=((STRING_TABLE.__str65518)|0);
HEAP32[(((_c_operators)+(696))>>2)]=((STRING_TABLE.__str74527)|0);
HEAP32[(((_c_operators)+(720))>>2)]=((STRING_TABLE.__str56509)|0);
HEAP32[(((_c_operators)+(744))>>2)]=((STRING_TABLE.__str57510)|0);
HEAP32[(((_c_operators)+(768))>>2)]=((STRING_TABLE.__str58511)|0);
HEAP32[(((_c_operators)+(792))>>2)]=((STRING_TABLE.__str59512)|0);
HEAP32[(((_c_operators)+(816))>>2)]=((STRING_TABLE.__str60513)|0);
HEAP32[(((_c_operators)+(840))>>2)]=((STRING_TABLE.__str61514)|0);
HEAP32[(((_c_operators)+(864))>>2)]=((STRING_TABLE.__str75528)|0);
HEAP32[(((_c_operators)+(888))>>2)]=((STRING_TABLE.__str76529)|0);
HEAP32[(((_c_operators)+(912))>>2)]=((STRING_TABLE.__str62515)|0);
HEAP32[(((_c_operators)+(936))>>2)]=((STRING_TABLE.__str77530)|0);
HEAP32[(((_c_operators)+(960))>>2)]=((STRING_TABLE.__str63516)|0);
HEAP32[(((_c_operators)+(984))>>2)]=((STRING_TABLE.__str66519)|0);
HEAP32[((_qcc_operators)>>2)]=((STRING_TABLE.__str41494)|0);
HEAP32[(((_qcc_operators)+(24))>>2)]=((STRING_TABLE.__str42495)|0);
HEAP32[(((_qcc_operators)+(48))>>2)]=((STRING_TABLE.__str41494)|0);
HEAP32[(((_qcc_operators)+(72))>>2)]=((STRING_TABLE.__str43496)|0);
HEAP32[(((_qcc_operators)+(96))>>2)]=((STRING_TABLE.__str44497)|0);
HEAP32[(((_qcc_operators)+(120))>>2)]=((STRING_TABLE.__str45498)|0);
HEAP32[(((_qcc_operators)+(144))>>2)]=((STRING_TABLE.__str46499)|0);
HEAP32[(((_qcc_operators)+(168))>>2)]=((STRING_TABLE.__str47500)|0);
HEAP32[(((_qcc_operators)+(192))>>2)]=((STRING_TABLE.__str48501)|0);
HEAP32[(((_qcc_operators)+(216))>>2)]=((STRING_TABLE.__str49502)|0);
HEAP32[(((_qcc_operators)+(240))>>2)]=((STRING_TABLE.__str44497)|0);
HEAP32[(((_qcc_operators)+(264))>>2)]=((STRING_TABLE.__str45498)|0);
HEAP32[(((_qcc_operators)+(288))>>2)]=((STRING_TABLE.__str50503)|0);
HEAP32[(((_qcc_operators)+(312))>>2)]=((STRING_TABLE.__str51504)|0);
HEAP32[(((_qcc_operators)+(336))>>2)]=((STRING_TABLE.__str52505)|0);
HEAP32[(((_qcc_operators)+(360))>>2)]=((STRING_TABLE.__str53506)|0);
HEAP32[(((_qcc_operators)+(384))>>2)]=((STRING_TABLE.__str54507)|0);
HEAP32[(((_qcc_operators)+(408))>>2)]=((STRING_TABLE.__str55508)|0);
HEAP32[(((_qcc_operators)+(432))>>2)]=((STRING_TABLE.__str56509)|0);
HEAP32[(((_qcc_operators)+(456))>>2)]=((STRING_TABLE.__str57510)|0);
HEAP32[(((_qcc_operators)+(480))>>2)]=((STRING_TABLE.__str58511)|0);
HEAP32[(((_qcc_operators)+(504))>>2)]=((STRING_TABLE.__str59512)|0);
HEAP32[(((_qcc_operators)+(528))>>2)]=((STRING_TABLE.__str60513)|0);
HEAP32[(((_qcc_operators)+(552))>>2)]=((STRING_TABLE.__str61514)|0);
HEAP32[(((_qcc_operators)+(576))>>2)]=((STRING_TABLE.__str62515)|0);
HEAP32[(((_qcc_operators)+(600))>>2)]=((STRING_TABLE.__str63516)|0);
HEAP32[(((_qcc_operators)+(624))>>2)]=((STRING_TABLE.__str64517)|0);
HEAP32[(((_qcc_operators)+(648))>>2)]=((STRING_TABLE.__str65518)|0);
HEAP32[(((_qcc_operators)+(672))>>2)]=((STRING_TABLE.__str66519)|0);
HEAP32[((_opts_flag_list)>>2)]=((STRING_TABLE.__str37490)|0);
HEAP32[(((_opts_flag_list)+(8))>>2)]=((STRING_TABLE.__str38491)|0);
HEAP32[(((_opts_flag_list)+(16))>>2)]=((STRING_TABLE.__str39492)|0);
HEAP32[(((_opts_flag_list)+(24))>>2)]=((STRING_TABLE.__str40493)|0);
HEAP32[((_opts_warn_list)>>2)]=((STRING_TABLE.__str20473)|0);
HEAP32[(((_opts_warn_list)+(8))>>2)]=((STRING_TABLE.__str21474)|0);
HEAP32[(((_opts_warn_list)+(16))>>2)]=((STRING_TABLE.__str22475)|0);
HEAP32[(((_opts_warn_list)+(24))>>2)]=((STRING_TABLE.__str23476)|0);
HEAP32[(((_opts_warn_list)+(32))>>2)]=((STRING_TABLE.__str24477)|0);
HEAP32[(((_opts_warn_list)+(40))>>2)]=((STRING_TABLE.__str25478)|0);
HEAP32[(((_opts_warn_list)+(48))>>2)]=((STRING_TABLE.__str26479)|0);
HEAP32[(((_opts_warn_list)+(56))>>2)]=((STRING_TABLE.__str27480)|0);
HEAP32[(((_opts_warn_list)+(64))>>2)]=((STRING_TABLE.__str28481)|0);
HEAP32[(((_opts_warn_list)+(72))>>2)]=((STRING_TABLE.__str29482)|0);
HEAP32[(((_opts_warn_list)+(80))>>2)]=((STRING_TABLE.__str30483)|0);
HEAP32[(((_opts_warn_list)+(88))>>2)]=((STRING_TABLE.__str31484)|0);
HEAP32[(((_opts_warn_list)+(96))>>2)]=((STRING_TABLE.__str32485)|0);
HEAP32[(((_opts_warn_list)+(104))>>2)]=((STRING_TABLE.__str33486)|0);
HEAP32[(((_opts_warn_list)+(112))>>2)]=((STRING_TABLE.__str34487)|0);
HEAP32[(((_opts_warn_list)+(120))>>2)]=((STRING_TABLE.__str35488)|0);
HEAP32[(((_opts_warn_list)+(128))>>2)]=((STRING_TABLE.__str36489)|0);
FUNCTION_TABLE = [0,0,_ast_return_codegen,0,_ast_ifthen_codegen,0,_ast_value_codegen,0,__ast_node_destroy,0,_ast_return_delete,0,_ast_unary_delete,0,_ast_member_codegen,0,_ast_binstore_codegen,0,_ast_ifthen_delete,0,_ast_entfield_codegen,0,_ast_expression_delete_full,0,_ast_unary_codegen,0,_ast_store_delete,0,_ast_loop_delete,0,_ast_value_delete,0,_ast_function_delete,0,_printf,0,_ast_binary_codegen,0,_ast_member_delete,0,_ast_binstore_delete,0,_ast_call_delete,0,_ast_binary_delete,0,_ast_entfield_delete,0,_ast_store_codegen,0,_ast_loop_codegen,0,_ast_call_codegen,0,_ast_block_delete,0,_ast_block_codegen,0]; Module["FUNCTION_TABLE"] = FUNCTION_TABLE;


function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return 0;
  }

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    var toRun = Module['preRun'];
    Module['preRun'] = [];
    for (var i = toRun.length-1; i >= 0; i--) {
      toRun[i]();
    }
    if (runDependencies > 0) {
      // a preRun added a dependency, run will be called later
      return 0;
    }
  }

  function doRun() {
    var ret = 0;
    calledRun = true;
    if (Module['_main']) {
      preMain();
      ret = Module.callMain(args);
      if (!Module['noExitRuntime']) {
        exitRuntime();
      }
    }
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
      while (Module['postRun'].length > 0) {
        Module['postRun'].pop()();
      }
    }
    return ret;
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
    return 0;
  } else {
    return doRun();
  }
}
Module['run'] = run;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

initRuntime();

var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

if (shouldRunNow) {
  var ret = run();
}

// {{POST_RUN_ADDITIONS}}

var std = "gmqcc";
function update() {
}

function compile() {
    
    run(["-std=gmqcc", "-debug", "-memchk", document.getElementById("input").value.replace("\\r?\\n", "\\\n")]);
}





  // {{MODULE_ADDITIONS}}


// EMSCRIPTEN_GENERATED_FUNCTIONS: ["_parse_if","_parser_t_imm_float_add","_options_set","_parse_expression_leave","_ir_instr_params_remove","_ir_builder_create_global","_ast_expression_init","_paramlist_t_p_add","_parser_global_statement","_ast_node_init","_parser_const_vector","_ir_value_out","_lex_finish_ident","_code_write","_ir_value_life_merge","_ast_return_new","_ir_block_create_binop","_lex_filenames_add","_util_strdup","_ir_value_life_add","_ast_ifthen_delete","_ir_function_collect_value","_ir_function_set_name","_ir_value_delete","_ir_value_var","_ir_block_living_add_instr","_parser_t_locals_add","_code_init","_parser_compile","_options_long_witharg","_ir_function_locals_add","_ir_value_set_vector","_parser_find_param","_ast_block_codegen","_ir_block_living_add","_shunt_out_add","_ir_block_create_store","_code_chars_add","_ast_function_new","_parser_close_paren","_ir_value_life_remove","_ir_value_writes_find","_ir_function_finalize","_parser_close_call","_code_functions_add","_lex_try_digraph","_ir_block_create_if","_ir_instr_dump","_isxdigit_only","_lex_finish_digit","_lex_tokench","_lex_try_trigraph","_ir_value_life_merge_into","_free","_shunt_ops_add","_ir_value_reads_remove","_parse_variable","_lex_token_new","_ir_block_create_return","_lexwarn","_code_genstring","_ast_loop_codegen","_ast_expression_common_params_add","_ir_builder_new","_ast_store_codegen","_code_alloc_field","_ir_builder_set_name","_ir_function_values_add","_options_setflag","_options_parse","_options_setwarn","_util_memory_d","_ir_block_create_general_instr","_ast_member_new","_release_unused_segments","_ast_block_set_type","_irerror","_ast_block_collect_add","_ir_builder_filestring","_ir_instr_new","_main","_parser_find_local","_ast_return_codegen","_ir_naive_phi_emit_store","_parser_const_vector_0","_options_long_witharg_all","_vec3_mulvv","_ast_block_exprs_add","_ast_value_codegen","_segment_holding","_lex_finish_frames","_lex_open_string","_options_long_gcc","_ast_return_delete","_parser_init","_token_value_add","_progdefs_crc_sum","_ast_value_set_name","_ast_unary_delete","_util_strtocmd","_malloc","_ir_function_create_block","_parsewarning","_util_memory_a","_ir_value_set_field","_ir_values_overlap","_ir_function_calculate_liferanges","_gen_global_field","_parse_function_body","_ast_value_new","_ir_value_writes_remove","_ast_type_adopt_impl","_lexerror","_lex_skipwhite","_parser_const_string","_code_fields_add","_ir_instr_delete","_parse_while","_ir_function_delete_quick","_ir_block_naive_phi","_parser_compile_string","_parse_for","_ir_builder_delete","_ast_compare_type","_lex_fgetc","_parser_const_float","_mmap_alloc","_vec3_mulvf","_progdefs_crc_file","_util_getline","_ast_block_collect","_ir_value_set_name","_ir_function_blocks_add","_ast_function_delete","_parser_t_imm_vector_add","_ir_value_code_setaddr","_ast_binstore_delete","_ir_block_set_label","_lex_finish_string","_ir_call_param","_ir_block_life_prop_previous","_ast_call_delete","_function_allocator_sizes_add","_ast_binary_delete","_parser_reclassify_token","_vec3_add","_ast_binstore_new","_code_statements_add","_lex_cleanup","_parser_sy_pop","_parse_block","_ir_block_life_propagate","_ir_builder_fields_add","_vec3_sub","_parser_const_float_0","_parser_find_field","_ast_ifthen_new","_ast_local_codegen","_ast_shallow_type","_ir_value_vector_v_add","_util_crc16","_util_debug","_ir_function_new","_ast_type_to_string","_parser_next","_sys_trim","_ast_function_blocks_add","_ir_block_delete","_ir_value_life_insert","_ir_block_instr_remove","_function_allocator_locals_add","_cvprintmsg","_ast_loop_new","_ir_builder_gen_field","_parser_find_var","_parser_t_imm_string_add","_parseerror","_ir_block_new","_options_setflag_all","_usage","_gen_global_function_code","_gen_global_pointer","_ast_block_locals_add","_ir_block_enumerate","_parse_block_into","_ast_block_new","_ir_value_writes_add","_prepend_alloc","_ir_instr_params_add","_ast_member_codegen","_ir_builder_get_global","_ir_function_blocks_remove","_ir_builder_filenames_add","_ir_function_allocate_locals","_parse_expression","_ir_block_exits_add","_progdefs_crc_both","_parser_cleanup","_genwarning","_ir_builder_create_function","_ir_block_entries_add","_ir_block_delete_quick","_tmalloc_small","_ast_type_copy","_parser_const_vector_f","_syblock","_ast_binary_new","_ast_loop_delete","_ir_block_create_load_from_ent","_ir_block_create_fieldaddress","_ir_instr_op","_parser_strdup","_syexp","_lex_getch","_parse_statement","_ir_value_dump","_ast_function_label","_ast_member_delete","_ir_block_dump","_ir_value_vector_member","_code_defs_add","_parser_t_fields_add","_ir_block_living_remove","_lex_open","_lex_parse_frame","_ir_function_dump","_ir_call_value","_ir_block_create_jump","_dump_phi","_lex_close","_ast_call_check_types","_init_bins","_parse_statement_or_block","_asterror","_irwarning","_ast_call_new","_code_globals_add","_ast_entfield_codegen","_isident","_function_allocator_alloc","_ir_value_set_string","_sys_alloc","_ir_builder_get_function","_ir_builder_gen_global","_ir_function_naive_phi","_generate_checksum","_options_witharg","_ast_ifthen_codegen","_syop","_gen_global_function","_gen_blocks_recursive","_ir_function_params_add","_ir_strdup","__ast_node_destroy","_ir_value_code_addr","_util_fopen","_gen_function_code","_lex_endtoken","_ir_value_set_float","_ast_unary_new","_ir_block_instr_add","_parser_pop_local","_ast_binstore_codegen","_ast_value_copy","_ast_entfield_new","_qc_opname","_progs_nextline","_init_top","_lex_do","_ast_expression_delete","_ir_builder_dump","_parser_finish","_ir_block_create_call","_function_allocator_positions_add","_ir_builder_create_field","_parse_dowhile","_ir_op_read_write","_vprintmsg","_init_mparams","_ast_expression_delete_full","_ast_unary_codegen","_ast_store_delete","_ir_block_living_find","_ir_block_create_store_op","_ir_function_create_local","_ast_store_new","_ast_value_delete","_ast_call_codegen","_create_vector_members","_ir_block_create_unary","_ast_entfield_delete","_ast_binary_codegen","_ir_builder_globals_add","_ir_builder_functions_add","_ir_function_enumerate","_ir_value_reads_add","_ir_function_delete","_ir_instr_delete_quick","_util_meminfo","_add_segment","_util_strtononcmd","_parser_find_global","_ir_builder_filestrings_add","_util_endianswap","_ir_builder_get_field","_lex_file_frames_add","_ast_type_to_string_impl","_parser_compile_file","_parse_type","_isident_start","_lex_ungetch","_ast_global_codegen","_parser_t_globals_add","_tmalloc_large","_items_add","_parser_t_functions_add","_ir_builder_generate","_ast_block_delete","_ast_function_codegen","_ir_value_reads_find","_ast_call_params_add","_syparen"]

